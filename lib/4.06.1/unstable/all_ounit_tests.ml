module OUnitTypes
= struct
#1 "oUnitTypes.ml"

(**
  * Commont types for OUnit
  *
  * @author Sylvain Le Gall
  *
  *)

(** See OUnit.mli. *) 
type node = ListItem of int | Label of string

(** See OUnit.mli. *) 
type path = node list 

(** See OUnit.mli. *) 
type log_severity = 
  | LError
  | LWarning
  | LInfo

(** See OUnit.mli. *) 
type test_result =
  | RSuccess of path
  | RFailure of path * string
  | RError of path * string
  | RSkip of path * string
  | RTodo of path * string

(** See OUnit.mli. *) 
type test_event =
  | EStart of path
  | EEnd of path
  | EResult of test_result
  | ELog of log_severity * string
  | ELogRaw of string

(** Events which occur at the global level. *)
type global_event =
  | GStart  (** Start running the tests. *)
  | GEnd    (** Finish running the tests. *)
  | GResults of (float * test_result list * int)

(* The type of test function *)
type test_fun = unit -> unit 

(* The type of tests *)
type test = 
  | TestCase of test_fun
  | TestList of test list
  | TestLabel of string * test

type state = 
    {
      tests_planned : (path * (unit -> unit)) list;
      results : test_result list;
    }


end
module OUnitChooser
= struct
#1 "oUnitChooser.ml"


(**
    Heuristic to pick a test to run.
   
    @author Sylvain Le Gall
  *)

open OUnitTypes

(** Most simple heuristic, just pick the first test. *)
let simple state =
  List.hd state.tests_planned

end
module OUnitUtils
= struct
#1 "oUnitUtils.ml"

(**
  * Utilities for OUnit
  *
  * @author Sylvain Le Gall
  *)

open OUnitTypes

let is_success = 
  function
    | RSuccess _  -> true 
    | RFailure _ | RError _  | RSkip _ | RTodo _ -> false 

let is_failure = 
  function
    | RFailure _ -> true
    | RSuccess _ | RError _  | RSkip _ | RTodo _ -> false

let is_error = 
  function 
    | RError _ -> true
    | RSuccess _ | RFailure _ | RSkip _ | RTodo _ -> false

let is_skip = 
  function
    | RSkip _ -> true
    | RSuccess _ | RFailure _ | RError _  | RTodo _ -> false

let is_todo = 
  function
    | RTodo _ -> true
    | RSuccess _ | RFailure _ | RError _  | RSkip _ -> false

let result_flavour = 
  function
    | RError _ -> "Error"
    | RFailure _ -> "Failure"
    | RSuccess _ -> "Success"
    | RSkip _ -> "Skip"
    | RTodo _ -> "Todo"

let result_path = 
  function
    | RSuccess path 
    | RError (path, _)
    | RFailure (path, _)
    | RSkip (path, _)
    | RTodo (path, _) -> path

let result_msg = 
  function
    | RSuccess _ -> "Success"
    | RError (_, msg)
    | RFailure (_, msg)
    | RSkip (_, msg)
    | RTodo (_, msg) -> msg

(* Returns true if the result list contains successes only. *)
let rec was_successful = 
  function
    | [] -> true
    | RSuccess _::t 
    | RSkip _::t -> 
        was_successful t

    | RFailure _::_
    | RError _::_ 
    | RTodo _::_ -> 
        false

let string_of_node = 
  function
    | ListItem n -> 
        string_of_int n
    | Label s -> 
        s

(* Return the number of available tests *)
let rec test_case_count = 
  function
    | TestCase _ -> 1 
    | TestLabel (_, t) -> test_case_count t
    | TestList l -> 
        List.fold_left 
          (fun c t -> c + test_case_count t) 
          0 l

let string_of_path path =
  String.concat ":" (List.rev_map string_of_node path)

let buff_format_printf f = 
  let buff = Buffer.create 13 in
  let fmt = Format.formatter_of_buffer buff in
    f fmt;
    Format.pp_print_flush fmt ();
    Buffer.contents buff

(* Applies function f in turn to each element in list. Function f takes
   one element, and integer indicating its location in the list *)
let mapi f l = 
  let rec rmapi cnt l = 
    match l with 
      | [] -> 
          [] 

      | h :: t -> 
          (f h cnt) :: (rmapi (cnt + 1) t) 
  in
    rmapi 0 l

let fold_lefti f accu l =
  let rec rfold_lefti cnt accup l = 
    match l with
      | [] -> 
          accup

      | h::t -> 
          rfold_lefti (cnt + 1) (f accup h cnt) t
  in
    rfold_lefti 0 accu l

end
module OUnitLogger
= struct
#1 "oUnitLogger.ml"
(*
 * Logger for information and various OUnit events.
 *)

open OUnitTypes
open OUnitUtils

type event_type = GlobalEvent of global_event | TestEvent of test_event

let format_event verbose event_type =
  match event_type with
    | GlobalEvent e ->
        begin
          match e with 
            | GStart ->
                ""
            | GEnd ->
                ""
            | GResults (running_time, results, test_case_count) -> 
                let separator1 = String.make (Format.get_margin ()) '=' in
                let separator2 = String.make (Format.get_margin ()) '-' in
                let buf = Buffer.create 1024 in
                let bprintf fmt = Printf.bprintf buf fmt in
                let print_results = 
                  List.iter 
                    (fun result -> 
                       bprintf "%s\n%s: %s\n\n%s\n%s\n" 
                         separator1 
                         (result_flavour result) 
                         (string_of_path (result_path result)) 
                         (result_msg result) 
                         separator2)
                in
                let errors   = List.filter is_error results in
                let failures = List.filter is_failure results in
                let skips    = List.filter is_skip results in
                let todos    = List.filter is_todo results in

                  if not verbose then
                    bprintf "\n";

                  print_results errors;
                  print_results failures;
                  bprintf "Ran: %d tests in: %.2f seconds.\n" 
                    (List.length results) running_time;

                  (* Print final verdict *)
                  if was_successful results then 
                    begin
                      if skips = [] then
                        bprintf "OK"
                      else 
                        bprintf "OK: Cases: %d Skip: %d"
                          test_case_count (List.length skips)
                    end
                  else
                    begin
                      bprintf
                        "FAILED: Cases: %d Tried: %d Errors: %d \
                              Failures: %d Skip:%d Todo:%d" 
                        test_case_count (List.length results) 
                        (List.length errors) (List.length failures)
                        (List.length skips) (List.length todos);
                    end;
                  bprintf "\n";
                  Buffer.contents buf
        end

    | TestEvent e ->
        begin
          let string_of_result = 
            if verbose then
              function
                | RSuccess _      -> "ok\n"
                | RFailure (_, _) -> "FAIL\n"
                | RError (_, _)   -> "ERROR\n"
                | RSkip (_, _)    -> "SKIP\n"
                | RTodo (_, _)    -> "TODO\n"
            else
              function
                | RSuccess _      -> "."
                | RFailure (_, _) -> "F"
                | RError (_, _)   -> "E"
                | RSkip (_, _)    -> "S"
                | RTodo (_, _)    -> "T"
          in
            if verbose then
              match e with 
                | EStart p -> 
                    Printf.sprintf "%s start\n" (string_of_path p)
                | EEnd p -> 
                    Printf.sprintf "%s end\n" (string_of_path p)
                | EResult result -> 
                    string_of_result result
                | ELog (lvl, str) ->
                    let prefix = 
                      match lvl with 
                        | LError -> "E"
                        | LWarning -> "W"
                        | LInfo -> "I"
                    in
                      prefix^": "^str
                | ELogRaw str ->
                    str
            else 
              match e with 
                | EStart _ | EEnd _ | ELog _ | ELogRaw _ -> ""
                | EResult result -> string_of_result result
        end

let file_logger fn =
  let chn = open_out fn in
    (fun ev ->
       output_string chn (format_event true ev);
       flush chn),
    (fun () -> close_out chn)

let std_logger verbose =
  (fun ev -> 
     print_string (format_event verbose ev);
     flush stdout),
  (fun () -> ())

let null_logger =
  ignore, ignore

let create output_file_opt verbose (log,close) =
  let std_log, std_close = std_logger verbose in
  let file_log, file_close = 
    match output_file_opt with 
      | Some fn ->
          file_logger fn
      | None ->
          null_logger
  in
    (fun ev ->
       std_log ev; file_log ev; log ev),
    (fun () ->
       std_close (); file_close (); close ())

let printf log fmt =
  Printf.ksprintf
    (fun s ->
       log (TestEvent (ELogRaw s)))
    fmt

end
module OUnit : sig 
#1 "oUnit.mli"
(***********************************************************************)
(* The OUnit library                                                   *)
(*                                                                     *)
(* Copyright (C) 2002-2008 Maas-Maarten Zeeman.                        *)
(* Copyright (C) 2010 OCamlCore SARL                                   *)
(*                                                                     *)
(* See LICENSE for details.                                            *)
(***********************************************************************)

(** Unit test building blocks
 
    @author Maas-Maarten Zeeman
    @author Sylvain Le Gall
  *)

(** {2 Assertions} 

    Assertions are the basic building blocks of unittests. *)

(** Signals a failure. This will raise an exception with the specified
    string. 

    @raise Failure signal a failure *)
val assert_failure : string -> 'a

(** Signals a failure when bool is false. The string identifies the 
    failure.
    
    @raise Failure signal a failure *)
val assert_bool : string -> bool -> unit

(** Shorthand for assert_bool 

    @raise Failure to signal a failure *)
val ( @? ) : string -> bool -> unit

(** Signals a failure when the string is non-empty. The string identifies the
    failure. 
    
    @raise Failure signal a failure *) 
val assert_string : string -> unit

(** [assert_command prg args] Run the command provided.

    @param exit_code expected exit code
    @param sinput provide this [char Stream.t] as input of the process
    @param foutput run this function on output, it can contains an
                   [assert_equal] to check it
    @param use_stderr redirect [stderr] to [stdout]
    @param env Unix environment
    @param verbose if a failure arise, dump stdout/stderr of the process to stderr

    @since 1.1.0
  *)
val assert_command : 
    ?exit_code:Unix.process_status ->
    ?sinput:char Stream.t ->
    ?foutput:(char Stream.t -> unit) ->
    ?use_stderr:bool ->
    ?env:string array ->
    ?verbose:bool ->
    string -> string list -> unit

(** [assert_equal expected real] Compares two values, when they are not equal a
    failure is signaled.

    @param cmp customize function to compare, default is [=]
    @param printer value printer, don't print value otherwise
    @param pp_diff if not equal, ask a custom display of the difference
                using [diff fmt exp real] where [fmt] is the formatter to use
    @param msg custom message to identify the failure

    @raise Failure signal a failure 
    
    @version 1.1.0
  *)
val assert_equal : 
  ?cmp:('a -> 'a -> bool) ->
  ?printer:('a -> string) -> 
  ?pp_diff:(Format.formatter -> ('a * 'a) -> unit) ->
  ?msg:string -> 'a -> 'a -> unit

(** Asserts if the expected exception was raised. 
   
    @param msg identify the failure

    @raise Failure description *)
val assert_raises : ?msg:string -> exn -> (unit -> 'a) -> unit

val assert_raise_any : ?msg:string ->  (unit -> 'a) -> unit

(** {2 Skipping tests } 
  
   In certain condition test can be written but there is no point running it, because they
   are not significant (missing OS features for example). In this case this is not a failure
   nor a success. Following functions allow you to escape test, just as assertion but without
   the same error status.
  
   A test skipped is counted as success. A test todo is counted as failure.
  *)

(** [skip cond msg] If [cond] is true, skip the test for the reason explain in [msg].
    For example [skip_if (Sys.os_type = "Win32") "Test a doesn't run on windows"].
    
    @since 1.0.3
  *)
val skip_if : bool -> string -> unit

(** The associated test is still to be done, for the reason given.
    
    @since 1.0.3
  *)
val todo : string -> unit

(** {2 Compare Functions} *)

(** Compare floats up to a given relative error. 
    
    @param epsilon if the difference is smaller [epsilon] values are equal
  *)
val cmp_float : ?epsilon:float -> float -> float -> bool

(** {2 Bracket}

    A bracket is a functional implementation of the commonly used
    setUp and tearDown feature in unittests. It can be used like this:

    ["MyTestCase" >:: (bracket test_set_up test_fun test_tear_down)] 
    
  *)

(** [bracket set_up test tear_down] The [set_up] function runs first, then
    the [test] function runs and at the end [tear_down] runs. The 
    [tear_down] function runs even if the [test] failed and help to clean
    the environment.
  *)
val bracket: (unit -> 'a) -> ('a -> unit) -> ('a -> unit) -> unit -> unit

(** [bracket_tmpfile test] The [test] function takes a temporary filename
    and matching output channel as arguments. The temporary file is created
    before the test and removed after the test.

    @param prefix see [Filename.open_temp_file]
    @param suffix see [Filename.open_temp_file]
    @param mode see [Filename.open_temp_file]
    
    @since 1.1.0
  *)
val bracket_tmpfile: 
  ?prefix:string -> 
  ?suffix:string -> 
  ?mode:open_flag list ->
  ((string * out_channel) -> unit) -> unit -> unit 

(** {2 Constructing Tests} *)

(** The type of test function *)
type test_fun = unit -> unit

(** The type of tests *)
type test =
    TestCase of test_fun
  | TestList of test list
  | TestLabel of string * test

(** Create a TestLabel for a test *)
val (>:) : string -> test -> test

(** Create a TestLabel for a TestCase *)
val (>::) : string -> test_fun -> test

(** Create a TestLabel for a TestList *)
val (>:::) : string -> test list -> test

(** Some shorthands which allows easy test construction.

   Examples:

   - ["test1" >: TestCase((fun _ -> ()))] =>  
   [TestLabel("test2", TestCase((fun _ -> ())))]
   - ["test2" >:: (fun _ -> ())] => 
   [TestLabel("test2", TestCase((fun _ -> ())))]
   - ["test-suite" >::: ["test2" >:: (fun _ -> ());]] =>
   [TestLabel("test-suite", TestSuite([TestLabel("test2", TestCase((fun _ -> ())))]))]
*)

(** [test_decorate g tst] Apply [g] to test function contains in [tst] tree.
    
    @since 1.0.3
  *)
val test_decorate : (test_fun -> test_fun) -> test -> test

(** [test_filter paths tst] Filter test based on their path string representation. 
    
    @param skip] if set, just use [skip_if] for the matching tests.
    @since 1.0.3
  *)
val test_filter : ?skip:bool -> string list -> test -> test option

(** {2 Retrieve Information from Tests} *)

(** Returns the number of available test cases *)
val test_case_count : test -> int

(** Types which represent the path of a test *)
type node = ListItem of int | Label of string
type path = node list (** The path to the test (in reverse order). *)

(** Make a string from a node *)
val string_of_node : node -> string

(** Make a string from a path. The path will be reversed before it is 
    tranlated into a string *)
val string_of_path : path -> string

(** Returns a list with paths of the test *)
val test_case_paths : test -> path list

(** {2 Performing Tests} *)

(** Severity level for log. *) 
type log_severity = 
  | LError
  | LWarning
  | LInfo

(** The possible results of a test *)
type test_result =
    RSuccess of path
  | RFailure of path * string
  | RError of path * string
  | RSkip of path * string
  | RTodo of path * string

(** Events which occur during a test run. *)
type test_event =
    EStart of path                (** A test start. *)
  | EEnd of path                  (** A test end. *)
  | EResult of test_result        (** Result of a test. *)
  | ELog of log_severity * string (** An event is logged in a test. *)
  | ELogRaw of string             (** Print raw data in the log. *)

(** Perform the test, allows you to build your own test runner *)
val perform_test : (test_event -> 'a) -> test -> test_result list

(** A simple text based test runner. It prints out information
    during the test. 

    @param verbose print verbose message
  *)
val run_test_tt : ?verbose:bool -> test -> test_result list

(** Main version of the text based test runner. It reads the supplied command 
    line arguments to set the verbose level and limit the number of test to 
    run.
    
    @param arg_specs add extra command line arguments
    @param set_verbose call a function to set verbosity

    @version 1.1.0
  *)
val run_test_tt_main : 
    ?arg_specs:(Arg.key * Arg.spec * Arg.doc) list -> 
    ?set_verbose:(bool -> unit) -> 
    test -> test_result list

end = struct
#1 "oUnit.ml"
(***********************************************************************)
(* The OUnit library                                                   *)
(*                                                                     *)
(* Copyright (C) 2002-2008 Maas-Maarten Zeeman.                        *)
(* Copyright (C) 2010 OCamlCore SARL                                   *)
(*                                                                     *)
(* See LICENSE for details.                                            *)
(***********************************************************************)
[@@@warning "a"]
open OUnitUtils
include OUnitTypes

(*
 * Types and global states.
 *)

let global_verbose = ref false

let global_output_file = 
  let pwd = Sys.getcwd () in
  let ocamlbuild_dir = Filename.concat pwd "_build" in
  let dir = 
    if Sys.file_exists ocamlbuild_dir && Sys.is_directory ocamlbuild_dir then
      ocamlbuild_dir
    else 
      pwd
  in
    ref (Some (Filename.concat dir "oUnit.log"))

let global_logger = ref (fst OUnitLogger.null_logger)

let global_chooser = ref OUnitChooser.simple

let bracket set_up f tear_down () =
  let fixture = 
    set_up () 
  in
  let () = 
    try
      let () = f fixture in
        tear_down fixture
    with e -> 
      let () = 
        tear_down fixture
      in
        raise e
  in
    ()

let bracket_tmpfile ?(prefix="ounit-") ?(suffix=".txt") ?mode f =
  bracket
    (fun () ->
       Filename.open_temp_file ?mode prefix suffix)
    f 
    (fun (fn, chn) ->
       begin
         try 
           close_out chn
         with _ ->
           ()
       end;
       begin
         try
           Sys.remove fn
         with _ ->
           ()
       end)

exception Skip of string
let skip_if b msg =
  if b then
    raise (Skip msg)

exception Todo of string
let todo msg =
  raise (Todo msg)

let assert_failure msg = 
  failwith ("OUnit: " ^ msg)

let assert_bool msg b =
  if not b then assert_failure msg

let assert_string str =
  if not (str = "") then assert_failure str

let assert_equal ?(cmp = ( = )) ?printer ?pp_diff ?msg expected actual =
  let get_error_string () =
    let res =
      buff_format_printf
        (fun fmt ->
           Format.pp_open_vbox fmt 0;
           begin
             match msg with 
               | Some s ->
                   Format.pp_open_box fmt 0;
                   Format.pp_print_string fmt s;
                   Format.pp_close_box fmt ();
                   Format.pp_print_cut fmt ()
               | None -> 
                   ()
           end;

           begin
             match printer with
               | Some p ->
                   Format.fprintf fmt
                     "@[expected: @[%s@]@ but got: @[%s@]@]@,"
                     (p expected)
                     (p actual)

               | None ->
                   Format.fprintf fmt "@[not equal@]@,"
           end;

           begin
             match pp_diff with 
               | Some d ->
                   Format.fprintf fmt 
                     "@[differences: %a@]@,"
                      d (expected, actual)

               | None ->
                   ()
           end;
           Format.pp_close_box fmt ())
    in
    let len = 
      String.length res
    in
      if len > 0 && res.[len - 1] = '\n' then
        String.sub res 0 (len - 1)
      else
        res
  in
    if not (cmp expected actual) then 
      assert_failure (get_error_string ())

let assert_command 
    ?(exit_code=Unix.WEXITED 0)
    ?(sinput=Stream.of_list [])
    ?(foutput=ignore)
    ?(use_stderr=true)
    ?env
    ?verbose
    prg args =

    bracket_tmpfile 
      (fun (fn_out, chn_out) ->
         let cmd_print fmt =
           let () = 
             match env with
               | Some e ->
                   begin
                     Format.pp_print_string fmt "env";
                     Array.iter (Format.fprintf fmt "@ %s") e;
                     Format.pp_print_space fmt ()
                   end
               
               | None ->
                   ()
           in
             Format.pp_print_string fmt prg;
             List.iter (Format.fprintf fmt "@ %s") args
         in

         (* Start the process *)
         let in_write = 
           Unix.dup (Unix.descr_of_out_channel chn_out)
         in
         let (out_read, out_write) = 
           Unix.pipe () 
         in
         let err = 
           if use_stderr then
             in_write
           else
             Unix.stderr
         in
         let args = 
           Array.of_list (prg :: args)
         in
         let pid =
           OUnitLogger.printf !global_logger "%s"
             (buff_format_printf
                (fun fmt ->
                   Format.fprintf fmt "@[Starting command '%t'@]\n" cmd_print));
           Unix.set_close_on_exec out_write;
           match env with 
             | Some e -> 
                 Unix.create_process_env prg args e out_read in_write err
             | None -> 
                 Unix.create_process prg args out_read in_write err
         in
         let () =
           Unix.close out_read; 
           Unix.close in_write
         in
         let () =
           (* Dump sinput into the process stdin *)
           let buff = Bytes.of_string " " in
             Stream.iter 
               (fun c ->
                  let _i : int =
                    Bytes.set buff 0  c;
                    Unix.write out_write buff 0 1
                  in
                    ())
               sinput;
             Unix.close out_write
         in
         let _, real_exit_code =
           let rec wait_intr () = 
             try 
               Unix.waitpid [] pid
             with Unix.Unix_error (Unix.EINTR, _, _) ->
               wait_intr ()
           in
             wait_intr ()
         in
         let exit_code_printer =
           function
             | Unix.WEXITED n ->
                 Printf.sprintf "exit code %d" n
             | Unix.WSTOPPED n ->
                 Printf.sprintf "stopped by signal %d" n
             | Unix.WSIGNALED n ->
                 Printf.sprintf "killed by signal %d" n
         in

           (* Dump process output to stderr *)
           begin
             let chn = open_in fn_out in
             let buff = Bytes.make 4096 'X' in
             let len = ref (-1) in
               while !len <> 0 do 
                 len := input chn buff 0 (Bytes.length buff);
                 OUnitLogger.printf !global_logger "%s" (Bytes.to_string @@ Bytes.sub buff 0 !len);
               done;
               close_in chn
           end;

           (* Check process status *)
           assert_equal 
             ~msg:(buff_format_printf 
                     (fun fmt ->
                        Format.fprintf fmt 
                          "@[Exit status of command '%t'@]" cmd_print))
             ~printer:exit_code_printer
             exit_code
             real_exit_code;

           begin
             let chn = open_in fn_out in
               try 
                 foutput (Stream.of_channel chn)
               with e ->
                 close_in chn;
                 raise e
           end)
      ()

let raises f =
  try
    ignore (f ());
    None
  with e -> 
    Some e

let assert_raises ?msg exn (f: unit -> 'a) = 
  let pexn = 
    Printexc.to_string 
  in
  let get_error_string () =
    let str = 
      Format.sprintf 
        "expected exception %s, but no exception was raised." 
        (pexn exn)
    in
      match msg with
        | None -> 
            assert_failure str
              
        | Some s -> 
            assert_failure (s^"\n"^str)
  in    
    match raises f with
      | None -> 
          assert_failure (get_error_string ())

      | Some e -> 
          assert_equal ?msg ~printer:pexn exn e


let assert_raise_any ?msg (f: unit -> 'a) = 
  let pexn = 
    Printexc.to_string 
  in
  let get_error_string () =
    let str = 
      Format.sprintf 
        "expected exception , but no exception was raised." 
        
    in
      match msg with
        | None -> 
            assert_failure str
              
        | Some s -> 
            assert_failure (s^"\n"^str)
  in    
    match raises f with
      | None -> 
          assert_failure (get_error_string ())

      | Some exn -> 
          assert_bool (pexn exn) true
(* Compare floats up to a given relative error *)
let cmp_float ?(epsilon = 0.00001) a b =
  abs_float (a -. b) <= epsilon *. (abs_float a) ||
    abs_float (a -. b) <= epsilon *. (abs_float b) 
      
(* Now some handy shorthands *)
let (@?) = assert_bool

(* Some shorthands which allows easy test construction *)
let (>:) s t = TestLabel(s, t)             (* infix *)
let (>::) s f = TestLabel(s, TestCase(f))  (* infix *)
let (>:::) s l = TestLabel(s, TestList(l)) (* infix *)

(* Utility function to manipulate test *)
let rec test_decorate g =
  function
    | TestCase f -> 
        TestCase (g f)
    | TestList tst_lst ->
        TestList (List.map (test_decorate g) tst_lst)
    | TestLabel (str, tst) ->
        TestLabel (str, test_decorate g tst)

let test_case_count = OUnitUtils.test_case_count 
let string_of_node = OUnitUtils.string_of_node
let string_of_path = OUnitUtils.string_of_path
    
(* Returns all possible paths in the test. The order is from test case
   to root 
 *)
let test_case_paths test = 
  let rec tcps path test = 
    match test with 
      | TestCase _ -> 
          [path] 

      | TestList tests -> 
          List.concat 
            (mapi (fun t i -> tcps ((ListItem i)::path) t) tests)

      | TestLabel (l, t) -> 
          tcps ((Label l)::path) t
  in
    tcps [] test

(* Test filtering with their path *)
module SetTestPath = Set.Make(String)

let test_filter ?(skip=false) only test =
  let set_test =
    List.fold_left 
      (fun st str -> SetTestPath.add str st)
      SetTestPath.empty
      only
  in
  let rec filter_test path tst =
    if SetTestPath.mem (string_of_path path) set_test then
      begin
        Some tst
      end

    else
      begin
        match tst with
          | TestCase f ->
              begin
                if skip then
                  Some 
                    (TestCase 
                       (fun () ->
                          skip_if true "Test disabled";
                          f ()))
                else
                  None
              end

          | TestList tst_lst ->
              begin
                let ntst_lst =
                  fold_lefti 
                    (fun ntst_lst tst i ->
                       let nntst_lst =
                         match filter_test ((ListItem i) :: path) tst with
                           | Some tst ->
                               tst :: ntst_lst
                           | None ->
                               ntst_lst
                       in
                         nntst_lst)
                    []
                    tst_lst
                in
                  if not skip && ntst_lst = [] then
                    None
                  else
                    Some (TestList (List.rev ntst_lst))
              end

          | TestLabel (lbl, tst) ->
              begin
                let ntst_opt =
                  filter_test 
                    ((Label lbl) :: path)
                    tst
                in
                  match ntst_opt with 
                    | Some ntst ->
                        Some (TestLabel (lbl, ntst))
                    | None ->
                        if skip then
                          Some (TestLabel (lbl, tst))
                        else
                          None
              end
      end
  in
    filter_test [] test


(* The possible test results *)
let is_success = OUnitUtils.is_success
let is_failure = OUnitUtils.is_failure
let is_error   = OUnitUtils.is_error  
let is_skip    = OUnitUtils.is_skip   
let is_todo    = OUnitUtils.is_todo   

(* TODO: backtrace is not correct *)
let maybe_backtrace = ""
  (* Printexc.get_backtrace () *)
    (* (if Printexc.backtrace_status () then *)
    (*    "\n" ^ Printexc.get_backtrace () *)
    (*  else "") *)
(* Events which can happen during testing *)

(* DEFINE MAYBE_BACKTRACE = *)
(* IFDEF BACKTRACE THEN *)
(*     (if Printexc.backtrace_status () then *)
(*        "\n" ^ Printexc.get_backtrace () *)
(*      else "") *)
(* ELSE *)
(*     "" *)
(* ENDIF *)

(* Run all tests, report starts, errors, failures, and return the results *)
let perform_test report test =
  let run_test_case f path =
    try 
      ignore(f ());
      RSuccess path
    with
      | Failure s -> 
          RFailure (path, s ^ maybe_backtrace)

      | Skip s -> 
          RSkip (path, s)

      | Todo s -> 
          RTodo (path, s)

      | s -> 
          RError (path, (Printexc.to_string s) ^ maybe_backtrace)
  in
  let rec flatten_test path acc = 
    function
      | TestCase(f) -> 
          (path, f) :: acc

      | TestList (tests) ->
          fold_lefti 
            (fun acc t cnt -> 
               flatten_test 
                 ((ListItem cnt)::path) 
                 acc t)
            acc tests
      
      | TestLabel (label, t) -> 
          flatten_test ((Label label)::path) acc t
  in
  let test_cases = List.rev (flatten_test [] [] test) in
  let runner (path, f) = 
    let result = 
      ignore @@ report (EStart path);
      run_test_case f path 
    in
      ignore @@ report (EResult result);
      ignore @@ report (EEnd path);
      result
  in
  let rec iter state = 
    match state.tests_planned with 
      | [] ->
          state.results
      | _ ->
          let (path, f) = !global_chooser state in            
          let result = runner (path, f) in
            iter 
              {
                results = result :: state.results;
                tests_planned = 
                  List.filter 
                    (fun (path', _) -> path <> path') state.tests_planned
              }
  in
    iter {results = []; tests_planned = test_cases}

(* Function which runs the given function and returns the running time
   of the function, and the original result in a tuple *)
let time_fun f x y =
  let begin_time = Unix.gettimeofday () in
  let result = f x y in
  let end_time = Unix.gettimeofday () in
    (end_time -. begin_time, result)

(* A simple (currently too simple) text based test runner *)
let run_test_tt ?verbose test =
  let log, log_close = 
    OUnitLogger.create 
      !global_output_file 
      !global_verbose 
      OUnitLogger.null_logger
  in
  let () = 
    global_logger := log
  in

  (* Now start the test *)
  let running_time, results = 
    time_fun 
      perform_test 
      (fun ev ->
         log (OUnitLogger.TestEvent ev))
      test 
  in
    
    (* Print test report *)
    log (OUnitLogger.GlobalEvent (GResults (running_time, results, test_case_count test)));

    (* Reset logger. *)
    log_close ();
    global_logger := fst OUnitLogger.null_logger;

    (* Return the results possibly for further processing *)
    results
      
(* Call this one from you test suites *)
let run_test_tt_main ?(arg_specs=[]) ?(set_verbose=ignore) suite = 
  let only_test = ref [] in
  let () = 
    Arg.parse
      (Arg.align
         [
           "-verbose", 
           Arg.Set global_verbose, 
           " Run the test in verbose mode.";

           "-only-test", 
           Arg.String (fun str -> only_test := str :: !only_test),
           "path Run only the selected test";

           "-output-file",
           Arg.String (fun s -> global_output_file := Some s),
           "fn Output verbose log in this file.";

           "-no-output-file",
           Arg.Unit (fun () -> global_output_file := None),
           " Prevent to write log in a file.";

           "-list-test",
           Arg.Unit
             (fun () -> 
                List.iter
                  (fun pth ->
                     print_endline (string_of_path pth))
                  (test_case_paths suite);
                exit 0),
           " List tests";
         ] @ arg_specs
      )
      (fun x -> raise (Arg.Bad ("Bad argument : " ^ x)))
      ("usage: " ^ Sys.argv.(0) ^ " [-verbose] [-only-test path]*")
  in
  let nsuite = 
    if !only_test = [] then
      suite
    else
      begin
        match test_filter ~skip:true !only_test suite with 
          | Some test ->
              test
          | None ->
              failwith ("Filtering test "^
                        (String.concat ", " !only_test)^
                        " lead to no test")
      end
  in

  let result = 
    set_verbose !global_verbose;
    run_test_tt ~verbose:!global_verbose nsuite 
  in
    if not (was_successful result) then
      exit 1
    else
      result

end
module Ext_array : sig 
#1 "ext_array.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val reverse_range : 'a array -> int -> int -> unit
(** Some utilities for {!Array} operations *)

val reverse_in_place : 'a array -> unit

val reverse : 'a array -> 'a array

val reverse_of_list : 'a list -> 'a array

val filter : 'a array -> ('a -> bool) -> 'a array

val filter_map : 'a array -> ('a -> 'b option) -> 'b array

val range : int -> int -> int array

val map2i : (int -> 'a -> 'b -> 'c) -> 'a array -> 'b array -> 'c array

val to_list_f : 'a array -> ('a -> 'b) -> 'b list

val to_list_map : 'a array -> ('a -> 'b option) -> 'b list

val to_list_map_acc : 'a array -> 'b list -> ('a -> 'b option) -> 'b list

val of_list_map : 'a list -> ('a -> 'b) -> 'b array

val rfind_with_index : 'a array -> ('a -> 'b -> bool) -> 'b -> int

type 'a split = No_split | Split of 'a array * 'a array

val find_and_split : 'a array -> ('a -> 'b -> bool) -> 'b -> 'a split

val exists : 'a array -> ('a -> bool) -> bool

val is_empty : 'a array -> bool

val for_all2_no_exn : 'a array -> 'b array -> ('a -> 'b -> bool) -> bool

val for_alli : 'a array -> (int -> 'a -> bool) -> bool

val map : 'a array -> ('a -> 'b) -> 'b array

val iter : 'a array -> ('a -> unit) -> unit

val fold_left : 'b array -> 'a -> ('a -> 'b -> 'a) -> 'a

val get_or : 'a array -> int -> (unit -> 'a) -> 'a

end = struct
#1 "ext_array.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

external ( .!() ) : 'a array -> int -> 'a = "%array_unsafe_get"

external ( .!()<- ) : 'a array -> int -> 'a -> unit = "%array_unsafe_set"

let reverse_range a i len =
  if len = 0 then ()
  else
    for k = 0 to (len - 1) / 2 do
      let t = a.!(i + k) in
      a.!(i + k) <- a.!(i + len - 1 - k);
      a.!(i + len - 1 - k) <- t
    done

let reverse_in_place a = reverse_range a 0 (Array.length a)

let reverse a =
  let b_len = Array.length a in
  if b_len = 0 then [||]
  else
    let b = Array.copy a in
    for i = 0 to b_len - 1 do
      Array.unsafe_set b i (Array.unsafe_get a (b_len - 1 - i))
    done;
    b

let reverse_of_list = function
  | [] -> [||]
  | hd :: tl ->
      let len = List.length tl in
      let a = Array.make (len + 1) hd in
      let rec fill i = function
        | [] -> a
        | hd :: tl ->
            Array.unsafe_set a i hd;
            fill (i - 1) tl
      in
      fill (len - 1) tl

let filter a f =
  let arr_len = Array.length a in
  let rec aux acc i =
    if i = arr_len then reverse_of_list acc
    else
      let v = Array.unsafe_get a i in
      if f v then aux (v :: acc) (i + 1) else aux acc (i + 1)
  in
  aux [] 0

let filter_map a (f : _ -> _ option) =
  let arr_len = Array.length a in
  let rec aux acc i =
    if i = arr_len then reverse_of_list acc
    else
      let v = Array.unsafe_get a i in
      match f v with Some v -> aux (v :: acc) (i + 1) | None -> aux acc (i + 1)
  in
  aux [] 0

let range from to_ =
  if from > to_ then invalid_arg "Ext_array.range"
  else Array.init (to_ - from + 1) (fun i -> i + from)

let map2i f a b =
  let len = Array.length a in
  if len <> Array.length b then invalid_arg "Ext_array.map2i"
  else Array.mapi (fun i a -> f i a (Array.unsafe_get b i)) a

let rec tolist_f_aux a f i res =
  if i < 0 then res
  else
    let v = Array.unsafe_get a i in
    tolist_f_aux a f (i - 1) (f v :: res)

let to_list_f a f = tolist_f_aux a f (Array.length a - 1) []

let rec tolist_aux a f i res =
  if i < 0 then res
  else
    tolist_aux a f (i - 1)
      (match f a.!(i) with Some v -> v :: res | None -> res)

let to_list_map a f = tolist_aux a f (Array.length a - 1) []

let to_list_map_acc a acc f = tolist_aux a f (Array.length a - 1) acc

let of_list_map a f =
  match a with
  | [] -> [||]
  | [ a0 ] ->
      let b0 = f a0 in
      [| b0 |]
  | [ a0; a1 ] ->
      let b0 = f a0 in
      let b1 = f a1 in
      [| b0; b1 |]
  | [ a0; a1; a2 ] ->
      let b0 = f a0 in
      let b1 = f a1 in
      let b2 = f a2 in
      [| b0; b1; b2 |]
  | [ a0; a1; a2; a3 ] ->
      let b0 = f a0 in
      let b1 = f a1 in
      let b2 = f a2 in
      let b3 = f a3 in
      [| b0; b1; b2; b3 |]
  | [ a0; a1; a2; a3; a4 ] ->
      let b0 = f a0 in
      let b1 = f a1 in
      let b2 = f a2 in
      let b3 = f a3 in
      let b4 = f a4 in
      [| b0; b1; b2; b3; b4 |]
  | a0 :: a1 :: a2 :: a3 :: a4 :: tl ->
      let b0 = f a0 in
      let b1 = f a1 in
      let b2 = f a2 in
      let b3 = f a3 in
      let b4 = f a4 in
      let len = List.length tl + 5 in
      let arr = Array.make len b0 in
      Array.unsafe_set arr 1 b1;
      Array.unsafe_set arr 2 b2;
      Array.unsafe_set arr 3 b3;
      Array.unsafe_set arr 4 b4;
      let rec fill i = function
        | [] -> arr
        | hd :: tl ->
            Array.unsafe_set arr i (f hd);
            fill (i + 1) tl
      in
      fill 5 tl

(**
   {[
     # rfind_with_index [|1;2;3|] (=) 2;;
     - : int = 1
               # rfind_with_index [|1;2;3|] (=) 1;;
     - : int = 0
               # rfind_with_index [|1;2;3|] (=) 3;;
     - : int = 2
               # rfind_with_index [|1;2;3|] (=) 4;;
     - : int = -1
   ]}
*)
let rfind_with_index arr cmp v =
  let len = Array.length arr in
  let rec aux i =
    if i < 0 then i
    else if cmp (Array.unsafe_get arr i) v then i
    else aux (i - 1)
  in
  aux (len - 1)

type 'a split = No_split | Split of 'a array * 'a array

let find_with_index arr cmp v =
  let len = Array.length arr in
  let rec aux i len =
    if i >= len then -1
    else if cmp (Array.unsafe_get arr i) v then i
    else aux (i + 1) len
  in
  aux 0 len

let find_and_split arr cmp v : _ split =
  let i = find_with_index arr cmp v in
  if i < 0 then No_split
  else
    Split (Array.sub arr 0 i, Array.sub arr (i + 1) (Array.length arr - i - 1))

(** TODO: available since 4.03, use {!Array.exists} *)

let exists a p =
  let n = Array.length a in
  let rec loop i =
    if i = n then false
    else if p (Array.unsafe_get a i) then true
    else loop (succ i)
  in
  loop 0

let is_empty arr = Array.length arr = 0

let rec unsafe_loop index len p xs ys =
  if index >= len then true
  else
    p (Array.unsafe_get xs index) (Array.unsafe_get ys index)
    && unsafe_loop (succ index) len p xs ys

let for_alli a p =
  let n = Array.length a in
  let rec loop i =
    if i = n then true
    else if p i (Array.unsafe_get a i) then loop (succ i)
    else false
  in
  loop 0

let for_all2_no_exn xs ys p =
  let len_xs = Array.length xs in
  let len_ys = Array.length ys in
  len_xs = len_ys && unsafe_loop 0 len_xs p xs ys

let map a f =
  let open Array in
  let l = length a in
  if l = 0 then [||]
  else
    let r = make l (f (unsafe_get a 0)) in
    for i = 1 to l - 1 do
      unsafe_set r i (f (unsafe_get a i))
    done;
    r

let iter a f =
  let open Array in
  for i = 0 to length a - 1 do
    f (unsafe_get a i)
  done

let fold_left a x f =
  let open Array in
  let r = ref x in
  for i = 0 to length a - 1 do
    r := f !r (unsafe_get a i)
  done;
  !r

let get_or arr i cb =
  if i >= 0 && i < Array.length arr then Array.unsafe_get arr i else cb ()

end
module Ext_bytes : sig 
#1 "ext_bytes.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

external unsafe_blit_string : string -> int -> bytes -> int -> int -> unit
  = "caml_blit_string"
  [@@noalloc]

end = struct
#1 "ext_bytes.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

external unsafe_blit_string : string -> int -> bytes -> int -> int -> unit
  = "caml_blit_string"
  [@@noalloc]

end
module Ext_string : sig 
#1 "ext_string.pp.mli"
(* Copyright (C) 2015 - 2016 Bloomberg Finance L.P.
 * Copyright (C) 2017 - Hongbo Zhang, Authors of ReScript
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Extension to the standard library [String] module, fixed some bugs like
    avoiding locale sensitivity *) 

(** default is false *)    
val split_by : ?keep_empty:bool -> (char -> bool) -> string -> string list


(** remove whitespace letters ('\t', '\n', ' ') on both side*)
val trim : string -> string 


(** default is false *)
val split : ?keep_empty:bool -> string -> char -> string list

(** split by space chars for quick scripting *)
val quick_split_by_ws : string -> string list 



val starts_with : string -> string -> bool

(**
   return [-1] when not found, the returned index is useful 
   see [ends_with_then_chop]
*)
val ends_with_index : string -> string -> int

val ends_with : string -> string -> bool

(**
   [ends_with_then_chop name ext]
   @example:
   {[
     ends_with_then_chop "a.cmj" ".cmj"
       "a"
   ]}
   This is useful in controlled or file case sensitve system
*)
val ends_with_then_chop : string -> string -> string option




(**
   [for_all_from  s start p]
   if [start] is negative, it raises,
   if [start] is too large, it returns true
*)
val for_all_from:
  string -> 
  int -> 
  (char -> bool) -> 
  bool 

val for_all : 
  string -> 
  (char -> bool) -> 
  bool

val is_empty : string -> bool

val repeat : int -> string -> string 

val equal : string -> string -> bool

(**
   [extract_until s cursor sep]
   When [sep] not found, the cursor is updated to -1,
   otherwise cursor is increased to 1 + [sep_position]
   User can not determine whether it is found or not by
   telling the return string is empty since 
   "\n\n" would result in an empty string too.
*)
(* val extract_until:
   string -> 
   int ref -> (* cursor to be updated *)
   char -> 
   string *)

val index_count:  
  string -> 
  int ->
  char -> 
  int -> 
  int 

(* val index_next :
   string -> 
   int ->
   char -> 
   int  *)


(**
   [find ~start ~sub s]
   returns [-1] if not found
*)
val find : ?start:int -> sub:string -> string -> int

val contain_substring : string -> string -> bool 

val non_overlap_count : sub:string -> string -> int 

val rfind : sub:string -> string -> int

(** [tail_from s 1]
    return a substring from offset 1 (inclusive)
*)
val tail_from : string -> int -> string


(** returns negative number if not found *)
val rindex_neg : string -> char -> int 

val rindex_opt : string -> char -> int option


val no_char : string -> char -> int -> int -> bool 


val no_slash : string -> bool 

(** return negative means no slash, otherwise [i] means the place for first slash *)
val no_slash_idx : string -> int 

val no_slash_idx_from : string -> int -> int 

(** if no conversion happens, reference equality holds *)
val replace_slash_backward : string -> string 

(** if no conversion happens, reference equality holds *)
val replace_backward_slash : string -> string 

val empty : string 


external compare : string -> string -> int = "caml_string_length_based_compare" [@@noalloc];;  
  
val single_space : string

val concat3 : string -> string -> string -> string 
val concat4 : string -> string -> string -> string -> string 
val concat5 : string -> string -> string -> string -> string -> string  
val inter2 : string -> string -> string
val inter3 : string -> string -> string -> string 
val inter4 : string -> string -> string -> string -> string
val concat_array : string -> string array -> string 

val single_colon : string 

val parent_dir_lit : string
val current_dir_lit : string

val capitalize_ascii : string -> string

val capitalize_sub:
  string -> 
  int -> 
  string

val uncapitalize_ascii : string -> string

val lowercase_ascii : string -> string 

(** Play parity to {!Ext_buffer.add_int_1} *)
(* val get_int_1 : string -> int -> int 
   val get_int_2 : string -> int -> int 
   val get_int_3 : string -> int -> int 
   val get_int_4 : string -> int -> int  *)

val get_1_2_3_4 : 
  string -> 
  off:int ->  
  int -> 
  int 

val unsafe_sub :   
  string -> 
  int -> 
  int -> 
  string

val is_valid_hash_number:
  string -> 
  bool

val hash_number_as_i32_exn:
  string ->
  int32

val first_marshal_char:  
  string -> 
  bool
end = struct
#1 "ext_string.pp.ml"
(* Copyright (C) 2015 - 2016 Bloomberg Finance L.P.
 * Copyright (C) 2017 - Hongbo Zhang, Authors of ReScript
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







(*
   {[ split " test_unsafe_obj_ffi_ppx.cmi" ~keep_empty:false ' ']}
*)
let split_by ?(keep_empty=false) is_delim str =
  let len = String.length str in
  let rec loop acc last_pos pos =
    if pos = -1 then
      if last_pos = 0 && not keep_empty then

        acc
      else 
        String.sub str 0 last_pos :: acc
    else
    if is_delim str.[pos] then
      let new_len = (last_pos - pos - 1) in
      if new_len <> 0 || keep_empty then 
        let v = String.sub str (pos + 1) new_len in
        loop ( v :: acc)
          pos (pos - 1)
      else loop acc pos (pos - 1)
    else loop acc last_pos (pos - 1)
  in
  loop [] len (len - 1)

let trim s = 
  let i = ref 0  in
  let j = String.length s in 
  while !i < j &&  
        let u = String.unsafe_get s !i in 
        u = '\t' || u = '\n' || u = ' ' 
  do 
    incr i;
  done;
  let k = ref (j - 1)  in 
  while !k >= !i && 
        let u = String.unsafe_get s !k in 
        u = '\t' || u = '\n' || u = ' ' do 
    decr k ;
  done;
  String.sub s !i (!k - !i + 1)

let split ?keep_empty  str on = 
  if str = "" then [] else 
    split_by ?keep_empty (fun x -> (x : char) = on) str  ;;

let quick_split_by_ws str : string list = 
  split_by ~keep_empty:false (fun x -> x = '\t' || x = '\n' || x = ' ') str

let starts_with s beg = 
  let beg_len = String.length beg in
  let s_len = String.length s in
  beg_len <=  s_len &&
  (let i = ref 0 in
   while !i <  beg_len 
         && String.unsafe_get s !i =
            String.unsafe_get beg !i do 
     incr i 
   done;
   !i = beg_len
  )

let rec ends_aux s end_ j k = 
  if k < 0 then (j + 1)
  else if String.unsafe_get s j = String.unsafe_get end_ k then 
    ends_aux s end_ (j - 1) (k - 1)
  else  -1   

(** return an index which is minus when [s] does not 
    end with [beg]
*)
let ends_with_index s end_ : int = 
  let s_finish = String.length s - 1 in
  let s_beg = String.length end_ - 1 in
  if s_beg > s_finish then -1
  else
    ends_aux s end_ s_finish s_beg

let ends_with s end_ = ends_with_index s end_ >= 0 

let ends_with_then_chop s beg = 
  let i =  ends_with_index s beg in 
  if i >= 0 then Some (String.sub s 0 i) 
  else None

(* let check_suffix_case = ends_with  *)
(* let check_suffix_case_then_chop = ends_with_then_chop *)

(* let check_any_suffix_case s suffixes = 
   Ext_list.exists suffixes (fun x -> check_suffix_case s x)  *)

(* let check_any_suffix_case_then_chop s suffixes = 
   let rec aux suffixes = 
    match suffixes with 
    | [] -> None 
    | x::xs -> 
      let id = ends_with_index s x in 
      if id >= 0 then Some (String.sub s 0 id)
      else aux xs in 
   aux suffixes     *)




(* it is unsafe to expose such API as unsafe since 
   user can provide bad input range 

*)
let rec unsafe_for_all_range s ~start ~finish p =     
  start > finish ||
  p (String.unsafe_get s start) && 
  unsafe_for_all_range s ~start:(start + 1) ~finish p

let for_all_from s start  p = 
  let len = String.length s in 
  if start < 0  then invalid_arg "Ext_string.for_all_from"
  else unsafe_for_all_range s ~start ~finish:(len - 1) p 


let for_all s (p : char -> bool)  =   
  unsafe_for_all_range s ~start:0  ~finish:(String.length s - 1) p 

let is_empty s = String.length s = 0


let repeat n s  =
  let len = String.length s in
  let res = Bytes.create(n * len) in
  for i = 0 to pred n do
    String.blit s 0 res (i * len) len
  done;
  Bytes.to_string res




let unsafe_is_sub ~sub i s j ~len =
  let rec check k =
    if k = len
    then true
    else 
      String.unsafe_get sub (i+k) = 
      String.unsafe_get s (j+k) && check (k+1)
  in
  j+len <= String.length s && check 0



let find ?(start=0) ~sub s =
  let exception Local_exit in
  let n = String.length sub in
  let s_len = String.length s in 
  let i = ref start in  
  try
    while !i + n <= s_len do
      if unsafe_is_sub ~sub 0 s !i ~len:n then
        raise_notrace Local_exit;
      incr i
    done;
    -1
  with Local_exit ->
    !i

let contain_substring s sub = 
  find s ~sub >= 0 

(** TODO: optimize 
    avoid nonterminating when string is empty 
*)
let non_overlap_count ~sub s = 
  let sub_len = String.length sub in 
  let rec aux  acc off = 
    let i = find ~start:off ~sub s  in 
    if i < 0 then acc 
    else aux (acc + 1) (i + sub_len) in
  if String.length sub = 0 then invalid_arg "Ext_string.non_overlap_count"
  else aux 0 0  


let rfind ~sub s =
  let exception Local_exit in   
  let n = String.length sub in
  let i = ref (String.length s - n) in
  try
    while !i >= 0 do
      if unsafe_is_sub ~sub 0 s !i ~len:n then 
        raise_notrace Local_exit;
      decr i
    done;
    -1
  with Local_exit ->
    !i

let tail_from s x = 
  let len = String.length s  in 
  if  x > len then invalid_arg ("Ext_string.tail_from " ^s ^ " : "^ string_of_int x )
  else String.sub s x (len - x)

let equal (x : string) y  = x = y

(* let rec index_rec s lim i c =
   if i >= lim then -1 else
   if String.unsafe_get s i = c then i 
   else index_rec s lim (i + 1) c *)



let rec index_rec_count s lim i c count =
  if i >= lim then -1 else
  if String.unsafe_get s i = c then 
    if count = 1 then i 
    else index_rec_count s lim (i + 1) c (count - 1)
  else index_rec_count s lim (i + 1) c count

let index_count s i c count =     
  let lim = String.length s in 
  if i < 0 || i >= lim || count < 1 then 
    invalid_arg ("index_count: ( " ^string_of_int i ^ "," ^string_of_int count ^ ")" );
  index_rec_count s lim i c count 

(* let index_next s i c =   
   index_count s i c 1  *)

(* let extract_until s cursor c =       
   let len = String.length s in   
   let start = !cursor in 
   if start < 0 || start >= len then (
    cursor := -1;
    ""
    )
   else 
    let i = index_rec s len start c in   
    let finish = 
      if i < 0 then (      
        cursor := -1 ;
        len 
      )
      else (
        cursor := i + 1;
        i 
      ) in 
    String.sub s start (finish - start) *)

let rec rindex_rec s i c =
  if i < 0 then i else
  if String.unsafe_get s i = c then i else rindex_rec s (i - 1) c;;

let rec rindex_rec_opt s i c =
  if i < 0 then None else
  if String.unsafe_get s i = c then Some i else rindex_rec_opt s (i - 1) c;;

let rindex_neg s c = 
  rindex_rec s (String.length s - 1) c;;

let rindex_opt s c = 
  rindex_rec_opt s (String.length s - 1) c;;


(** TODO: can be improved to return a positive integer instead *)
let rec unsafe_no_char x ch i  last_idx = 
  i > last_idx  || 
  (String.unsafe_get x i <> ch && unsafe_no_char x ch (i + 1)  last_idx)

let rec unsafe_no_char_idx x ch i last_idx = 
  if i > last_idx  then -1 
  else 
  if String.unsafe_get x i <> ch then 
    unsafe_no_char_idx x ch (i + 1)  last_idx
  else i

let no_char x ch i len  : bool =
  let str_len = String.length x in 
  if i < 0 || i >= str_len || len >= str_len then invalid_arg "Ext_string.no_char"   
  else unsafe_no_char x ch i len 


let no_slash x = 
  unsafe_no_char x '/' 0 (String.length x - 1)

let no_slash_idx x = 
  unsafe_no_char_idx x '/' 0 (String.length x - 1)

let no_slash_idx_from x from = 
  let last_idx = String.length x - 1  in 
  assert (from >= 0); 
  unsafe_no_char_idx x '/' from last_idx

let replace_slash_backward (x : string ) = 
  let len = String.length x in 
  if unsafe_no_char x '/' 0  (len - 1) then x 
  else 
    String.map (function 
        | '/' -> '\\'
        | x -> x ) x 

let replace_backward_slash (x : string)=
  let len = String.length x in
  if unsafe_no_char x '\\' 0  (len -1) then x 
  else  
    String.map (function 
        |'\\'-> '/'
        | x -> x) x

let empty = ""


external compare : string -> string -> int = "caml_string_length_based_compare" [@@noalloc];;    

let single_space = " "
let single_colon = ":"

let concat_array sep (s : string array) =   
  let s_len = Array.length s in 
  match s_len with 
  | 0 -> empty 
  | 1 -> Array.unsafe_get s 0
  | _ ->     
    let sep_len = String.length sep in 
    let len = ref 0 in 
    for i = 0 to  s_len - 1 do 
      len := !len + String.length (Array.unsafe_get s i)
    done;
    let target = 
      Bytes.create 
        (!len + (s_len - 1) * sep_len ) in    
    let hd = (Array.unsafe_get s 0) in     
    let hd_len = String.length hd in 
    String.unsafe_blit hd  0  target 0 hd_len;   
    let current_offset = ref hd_len in     
    for i = 1 to s_len - 1 do 
      String.unsafe_blit sep 0 target  !current_offset sep_len;
      let cur = Array.unsafe_get s i in 
      let cur_len = String.length cur in     
      let new_off_set = (!current_offset + sep_len ) in
      String.unsafe_blit cur 0 target new_off_set cur_len; 
      current_offset := 
        new_off_set + cur_len ; 
    done;
    Bytes.unsafe_to_string target   

let concat3 a b c = 
  let a_len = String.length a in 
  let b_len = String.length b in 
  let c_len = String.length c in 
  let len = a_len + b_len + c_len in 
  let target = Bytes.create len in 
  String.unsafe_blit a 0 target 0 a_len ; 
  String.unsafe_blit b 0 target a_len b_len;
  String.unsafe_blit c 0 target (a_len + b_len) c_len;
  Bytes.unsafe_to_string target

let concat4 a b c d =
  let a_len = String.length a in 
  let b_len = String.length b in 
  let c_len = String.length c in 
  let d_len = String.length d in 
  let len = a_len + b_len + c_len + d_len in 

  let target = Bytes.create len in 
  String.unsafe_blit a 0 target 0 a_len ; 
  String.unsafe_blit b 0 target a_len b_len;
  String.unsafe_blit c 0 target (a_len + b_len) c_len;
  String.unsafe_blit d 0 target (a_len + b_len + c_len) d_len;
  Bytes.unsafe_to_string target


let concat5 a b c d e =
  let a_len = String.length a in 
  let b_len = String.length b in 
  let c_len = String.length c in 
  let d_len = String.length d in 
  let e_len = String.length e in 
  let len = a_len + b_len + c_len + d_len + e_len in 

  let target = Bytes.create len in 
  String.unsafe_blit a 0 target 0 a_len ; 
  String.unsafe_blit b 0 target a_len b_len;
  String.unsafe_blit c 0 target (a_len + b_len) c_len;
  String.unsafe_blit d 0 target (a_len + b_len + c_len) d_len;
  String.unsafe_blit e 0 target (a_len + b_len + c_len + d_len) e_len;
  Bytes.unsafe_to_string target



let inter2 a b = 
  concat3 a single_space b 


let inter3 a b c = 
  concat5 a  single_space  b  single_space  c 





let inter4 a b c d =
  concat_array single_space [| a; b ; c; d|]


let parent_dir_lit = ".."    
let current_dir_lit = "."


(* reference {!Bytes.unppercase} *)
let capitalize_ascii (s : string) : string = 
  if String.length s = 0 then s 
  else 
    begin
      let c = String.unsafe_get s 0 in 
      if (c >= 'a' && c <= 'z')
      || (c >= '\224' && c <= '\246')
      || (c >= '\248' && c <= '\254') then 
        let uc = Char.unsafe_chr (Char.code c - 32) in 
        let bytes = Bytes.of_string s in
        Bytes.unsafe_set bytes 0 uc;
        Bytes.unsafe_to_string bytes 
      else s 
    end

let capitalize_sub (s : string) len : string = 
  let slen = String.length s in 
  if  len < 0 || len > slen then invalid_arg "Ext_string.capitalize_sub"
  else 
  if len = 0 then ""
  else 
    let bytes = Bytes.create len in 
    let uc = 
      let c = String.unsafe_get s 0 in 
      if (c >= 'a' && c <= 'z')
      || (c >= '\224' && c <= '\246')
      || (c >= '\248' && c <= '\254') then 
        Char.unsafe_chr (Char.code c - 32) else c in 
    Bytes.unsafe_set bytes 0 uc;
    for i = 1 to len - 1 do 
      Bytes.unsafe_set bytes i (String.unsafe_get s i)
    done ;
    Bytes.unsafe_to_string bytes 



let uncapitalize_ascii =
  String.uncapitalize_ascii

let lowercase_ascii = String.lowercase_ascii

external (.![]) : string -> int -> int = "%string_unsafe_get"

let get_int_1_unsafe (x : string) off : int = 
  x.![off]

let get_int_2_unsafe (x : string) off : int =   
  x.![off] lor   
  x.![off+1] lsl 8

let get_int_3_unsafe (x : string) off : int = 
  x.![off] lor   
  x.![off+1] lsl 8  lor 
  x.![off+2] lsl 16


let get_int_4_unsafe (x : string) off : int =     
  x.![off] lor   
  x.![off+1] lsl 8  lor 
  x.![off+2] lsl 16 lor
  x.![off+3] lsl 24 

let get_1_2_3_4 (x : string) ~off len : int =  
  if len = 1 then get_int_1_unsafe x off 
  else if len = 2 then get_int_2_unsafe x off 
  else if len = 3 then get_int_3_unsafe x off 
  else if len = 4 then get_int_4_unsafe x off 
  else assert false

let unsafe_sub  x offs len =
  let b = Bytes.create len in 
  Ext_bytes.unsafe_blit_string x offs b 0 len;
  (Bytes.unsafe_to_string b)

let is_valid_hash_number (x:string) = 
  let len = String.length x in 
  len > 0 && (
    let a = x.![0] in 
    a <= 57 &&
    (if len > 1 then 
       a > 48 && 
       for_all_from x 1 (function '0' .. '9' -> true | _ -> false)
     else
       a >= 48 )
  ) 


let hash_number_as_i32_exn 
    ( x : string) : int32 = 
  Int32.of_string x    


let first_marshal_char (x : string) = 
    x <> ""   &&
    ( String.unsafe_get x  0 = '\132')
  
end
module Ounit_array_tests
= struct
#1 "ounit_array_tests.ml"
let ((>::),
    (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal

let printer_int_array = fun xs -> 
    String.concat ","
    (List.map string_of_int @@ Array.to_list xs )

let suites = 
    __FILE__
    >:::
    [
     __LOC__ >:: begin fun _ ->
        Ext_array.find_and_split 
            [|"a"; "b";"c"|]
            Ext_string.equal "--" =~ No_split
     end;
    __LOC__ >:: begin fun _ ->
        Ext_array.find_and_split 
            [|"a"; "b";"c";"--"|]
            Ext_string.equal "--" =~ Split( [|"a";"b";"c"|], [||])
     end;
     __LOC__ >:: begin fun _ ->
        Ext_array.find_and_split 
            [|"--"; "a"; "b";"c";"--"|]
            Ext_string.equal "--" =~ Split ([||], [|"a";"b";"c";"--"|])
     end;
    __LOC__ >:: begin fun _ ->
        Ext_array.find_and_split 
            [| "u"; "g"; "--"; "a"; "b";"c";"--"|]
            Ext_string.equal "--" =~ Split ([|"u";"g"|], [|"a";"b";"c";"--"|])
     end;
    __LOC__ >:: begin fun _ ->
        Ext_array.reverse [|1;2|] =~ [|2;1|];
        Ext_array.reverse [||] =~ [||]  
    end     ;
    __LOC__ >:: begin fun _ -> 
        let (=~) = OUnit.assert_equal ~printer:printer_int_array in 
        let k x y = Ext_array.of_list_map y x in 
        k succ [] =~ [||];
        k succ [1]  =~ [|2|];
        k succ [1;2;3]  =~ [|2;3;4|];
        k succ [1;2;3;4]  =~ [|2;3;4;5|];
        k succ [1;2;3;4;5]  =~ [|2;3;4;5;6|];
        k succ [1;2;3;4;5;6]  =~ [|2;3;4;5;6;7|];
        k succ [1;2;3;4;5;6;7]  =~ [|2;3;4;5;6;7;8|];
    end; 
    __LOC__ >:: begin fun _ -> 
        Ext_array.to_list_map_acc
        [|1;2;3;4;5;6|] [1;2;3]
        (fun x -> if x mod 2 = 0 then Some x else None )
        =~ [2;4;6;1;2;3]
    end;
    __LOC__ >:: begin fun _ -> 
        Ext_array.to_list_map_acc
        [|1;2;3;4;5;6|] []
        (fun x -> if x mod 2 = 0 then Some x else None )
        =~ [2;4;6]
    end;

    __LOC__ >:: begin fun _ -> 
    OUnit.assert_bool __LOC__ 
        (Ext_array.for_all2_no_exn        
        [|1;2;3|]
        [|1;2;3|]
        (=)
        )
    end;
    __LOC__ >:: begin fun _ -> 
    OUnit.assert_bool __LOC__
    (Ext_array.for_all2_no_exn
    [||] [||] (=) 
    );
    OUnit.assert_bool __LOC__
    (not @@ Ext_array.for_all2_no_exn
    [||] [|1|] (=) 
    )
    end
    ;
    __LOC__ >:: begin fun _ -> 
    OUnit.assert_bool __LOC__
    (not (Ext_array.for_all2_no_exn        
        [|1;2;3|]
        [|1;2;33|]
        (=)
        ))
    end
    ]
end
module Ounit_tests_util
= struct
#1 "ounit_tests_util.ml"



let time ?nums description  f  =
  match nums with 
  | None -> 
    begin 
      let start = Unix.gettimeofday () in 
      ignore @@ f ();
      let finish = Unix.gettimeofday () in
      Printf.printf "\n%s elapsed %f\n" description (finish -. start) ;
      flush stdout; 
    end

  | Some nums -> 
    begin 
        let start = Unix.gettimeofday () in 
        for _i = 0 to nums - 1 do 
          ignore @@ f ();
        done  ;
      let finish = Unix.gettimeofday () in
      Printf.printf "\n%s elapsed %f\n" description (finish -. start)  ;
      flush stdout;
    end

end
module Set_gen : sig 
#1 "set_gen.mli"
type 'a t = private
  | Empty
  | Leaf of 'a
  | Node of { l : 'a t; v : 'a; r : 'a t; h : int }

val empty : 'a t

val is_empty : 'a t -> bool [@@inline]

val unsafe_two_elements : 'a -> 'a -> 'a t

val cardinal : 'a t -> int

val elements : 'a t -> 'a list

val choose : 'a t -> 'a

val iter : 'a t -> ('a -> unit) -> unit

val fold : 'a t -> 'c -> ('a -> 'c -> 'c) -> 'c

val for_all : 'a t -> ('a -> bool) -> bool

val exists : 'a t -> ('a -> bool) -> bool

val check : 'a t -> unit

val bal : 'a t -> 'a -> 'a t -> 'a t

val remove_min_elt : 'a t -> 'a t

val singleton : 'a -> 'a t

val internal_merge : 'a t -> 'a t -> 'a t

val internal_join : 'a t -> 'a -> 'a t -> 'a t

val internal_concat : 'a t -> 'a t -> 'a t

val partition : 'a t -> ('a -> bool) -> 'a t * 'a t

val of_sorted_array : 'a array -> 'a t

val is_ordered : cmp:('a -> 'a -> int) -> 'a t -> bool

val invariant : cmp:('a -> 'a -> int) -> 'a t -> bool

module type S = sig
  type elt

  type t

  val empty : t

  val is_empty : t -> bool

  val iter : t -> (elt -> unit) -> unit

  val fold : t -> 'a -> (elt -> 'a -> 'a) -> 'a

  val for_all : t -> (elt -> bool) -> bool

  val exists : t -> (elt -> bool) -> bool

  val singleton : elt -> t

  val cardinal : t -> int

  val elements : t -> elt list

  val choose : t -> elt

  val mem : t -> elt -> bool

  val add : t -> elt -> t

  val remove : t -> elt -> t

  val union : t -> t -> t

  val inter : t -> t -> t

  val diff : t -> t -> t

  val of_list : elt list -> t

  val of_sorted_array : elt array -> t

  val invariant : t -> bool

  val print : Format.formatter -> t -> unit
end

end = struct
#1 "set_gen.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the GNU Library General Public License, with    *)
(*  the special exception on linking described in file ../LICENSE.     *)
(*                                                                     *)
(***********************************************************************)
[@@@warnerror "+55"]

(* balanced tree based on stdlib distribution *)

type 'a t0 =
  | Empty
  | Leaf of 'a
  | Node of { l : 'a t0; v : 'a; r : 'a t0; h : int }

type 'a partial_node = { l : 'a t0; v : 'a; r : 'a t0; h : int }

external ( ~! ) : 'a t0 -> 'a partial_node = "%identity"

let empty = Empty

let[@inline] height = function Empty -> 0 | Leaf _ -> 1 | Node { h } -> h

let[@inline] calc_height a b = (if a >= b then a else b) + 1

(*
     Invariants:
     1. {[ l < v < r]}
     2. l and r balanced
     3. [height l] - [height r] <= 2
*)
let[@inline] unsafe_node v l r h = Node { l; v; r; h }

let[@inline] unsafe_node_maybe_leaf v l r h =
  if h = 1 then Leaf v else Node { l; v; r; h }

let[@inline] singleton x = Leaf x

let[@inline] unsafe_two_elements x v = unsafe_node v (singleton x) empty 2

type 'a t = 'a t0 = private
  | Empty
  | Leaf of 'a
  | Node of { l : 'a t0; v : 'a; r : 'a t0; h : int }

(* Smallest and greatest element of a set *)

let rec min_exn = function
  | Empty -> raise Not_found
  | Leaf v -> v
  | Node { l; v } -> ( match l with Empty -> v | Leaf _ | Node _ -> min_exn l)

let[@inline] is_empty = function Empty -> true | _ -> false

let rec cardinal_aux acc = function
  | Empty -> acc
  | Leaf _ -> acc + 1
  | Node { l; r } -> cardinal_aux (cardinal_aux (acc + 1) r) l

let cardinal s = cardinal_aux 0 s

let rec elements_aux accu = function
  | Empty -> accu
  | Leaf v -> v :: accu
  | Node { l; v; r } -> elements_aux (v :: elements_aux accu r) l

let elements s = elements_aux [] s

let choose = min_exn

let rec iter x f =
  match x with
  | Empty -> ()
  | Leaf v -> f v
  | Node { l; v; r } ->
      iter l f;
      f v;
      iter r f

let rec fold s accu f =
  match s with
  | Empty -> accu
  | Leaf v -> f v accu
  | Node { l; v; r } -> fold r (f v (fold l accu f)) f

let rec for_all x p =
  match x with
  | Empty -> true
  | Leaf v -> p v
  | Node { l; v; r } -> p v && for_all l p && for_all r p

let rec exists x p =
  match x with
  | Empty -> false
  | Leaf v -> p v
  | Node { l; v; r } -> p v || exists l p || exists r p

exception Height_invariant_broken

exception Height_diff_borken

let rec check_height_and_diff = function
  | Empty -> 0
  | Leaf _ -> 1
  | Node { l; r; h } ->
      let hl = check_height_and_diff l in
      let hr = check_height_and_diff r in
      if h <> calc_height hl hr then raise Height_invariant_broken
      else
        let diff = abs (hl - hr) in
        if diff > 2 then raise Height_diff_borken else h

let check tree = ignore (check_height_and_diff tree)

(* Same as create, but performs one step of rebalancing if necessary.
    Invariants:
    1. {[ l < v < r ]}
    2. l and r balanced
    3. | height l - height r | <= 3.

    Proof by indunction

    Lemma: the height of  [bal l v r] will bounded by [max l r] + 1
*)
let bal l v r : _ t =
  let hl = height l in
  let hr = height r in
  if hl > hr + 2 then
    let { l = ll; r = lr; v = lv; h = _ } = ~!l in
    let hll = height ll in
    let hlr = height lr in
    if hll >= hlr then
      let hnode = calc_height hlr hr in
      unsafe_node lv ll
        (unsafe_node_maybe_leaf v lr r hnode)
        (calc_height hll hnode)
    else
      let { l = lrl; r = lrr; v = lrv } = ~!lr in
      let hlrl = height lrl in
      let hlrr = height lrr in
      let hlnode = calc_height hll hlrl in
      let hrnode = calc_height hlrr hr in
      unsafe_node lrv
        (unsafe_node_maybe_leaf lv ll lrl hlnode)
        (unsafe_node_maybe_leaf v lrr r hrnode)
        (calc_height hlnode hrnode)
  else if hr > hl + 2 then
    let { l = rl; r = rr; v = rv } = ~!r in
    let hrr = height rr in
    let hrl = height rl in
    if hrr >= hrl then
      let hnode = calc_height hl hrl in
      unsafe_node rv
        (unsafe_node_maybe_leaf v l rl hnode)
        rr (calc_height hnode hrr)
    else
      let { l = rll; r = rlr; v = rlv } = ~!rl in
      let hrll = height rll in
      let hrlr = height rlr in
      let hlnode = calc_height hl hrll in
      let hrnode = calc_height hrlr hrr in
      unsafe_node rlv
        (unsafe_node_maybe_leaf v l rll hlnode)
        (unsafe_node_maybe_leaf rv rlr rr hrnode)
        (calc_height hlnode hrnode)
  else unsafe_node_maybe_leaf v l r (calc_height hl hr)

let rec remove_min_elt = function
  | Empty -> invalid_arg "Set.remove_min_elt"
  | Leaf _ -> empty
  | Node { l = Empty; r } -> r
  | Node { l; v; r } -> bal (remove_min_elt l) v r

(*
    All elements of l must precede the elements of r.
        Assume | height l - height r | <= 2.
    weak form of [concat]
*)

let internal_merge l r =
  match (l, r) with
  | Empty, t -> t
  | t, Empty -> t
  | _, _ -> bal l (min_exn r) (remove_min_elt r)

(* Beware: those two functions assume that the added v is *strictly*
    smaller (or bigger) than all the present elements in the tree; it
    does not test for equality with the current min (or max) element.
    Indeed, they are only used during the "join" operation which
    respects this precondition.
*)

let rec add_min v = function
  | Empty -> singleton v
  | Leaf x -> unsafe_two_elements v x
  | Node n -> bal (add_min v n.l) n.v n.r

let rec add_max v = function
  | Empty -> singleton v
  | Leaf x -> unsafe_two_elements x v
  | Node n -> bal n.l n.v (add_max v n.r)

(** 
    Invariants:
    1. l < v < r 
    2. l and r are balanced 

    Proof by induction
    The height of output will be ~~ (max (height l) (height r) + 2)
    Also use the lemma from [bal]
*)
let rec internal_join l v r =
  match (l, r) with
  | Empty, _ -> add_min v r
  | _, Empty -> add_max v l
  | Leaf lv, Node { h = rh } ->
      if rh > 3 then add_min lv (add_min v r) (* FIXME: could inlined *)
      else unsafe_node v l r (rh + 1)
  | Leaf _, Leaf _ -> unsafe_node v l r 2
  | Node { h = lh }, Leaf rv ->
      if lh > 3 then add_max rv (add_max v l) else unsafe_node v l r (lh + 1)
  | ( Node { l = ll; v = lv; r = lr; h = lh },
      Node { l = rl; v = rv; r = rr; h = rh } ) ->
      if lh > rh + 2 then
        (* proof by induction:
           now [height of ll] is [lh - 1]
        *)
        bal ll lv (internal_join lr v r)
      else if rh > lh + 2 then bal (internal_join l v rl) rv rr
      else unsafe_node v l r (calc_height lh rh)

(*
    Required Invariants: 
    [t1] < [t2]  
*)
let internal_concat t1 t2 =
  match (t1, t2) with
  | Empty, t -> t
  | t, Empty -> t
  | _, _ -> internal_join t1 (min_exn t2) (remove_min_elt t2)

let rec partition x p =
  match x with
  | Empty -> (empty, empty)
  | Leaf v ->
      let pv = p v in
      if pv then (x, empty) else (empty, x)
  | Node { l; v; r } ->
      (* call [p] in the expected left-to-right order *)
      let lt, lf = partition l p in
      let pv = p v in
      let rt, rf = partition r p in
      if pv then (internal_join lt v rt, internal_concat lf rf)
      else (internal_concat lt rt, internal_join lf v rf)

let of_sorted_array l =
  let rec sub start n l =
    if n = 0 then empty
    else if n = 1 then
      let x0 = Array.unsafe_get l start in
      singleton x0
    else if n = 2 then
      let x0 = Array.unsafe_get l start in
      let x1 = Array.unsafe_get l (start + 1) in
      unsafe_node x1 (singleton x0) empty 2
    else if n = 3 then
      let x0 = Array.unsafe_get l start in
      let x1 = Array.unsafe_get l (start + 1) in
      let x2 = Array.unsafe_get l (start + 2) in
      unsafe_node x1 (singleton x0) (singleton x2) 2
    else
      let nl = n / 2 in
      let left = sub start nl l in
      let mid = start + nl in
      let v = Array.unsafe_get l mid in
      let right = sub (mid + 1) (n - nl - 1) l in
      unsafe_node v left right (calc_height (height left) (height right))
  in
  sub 0 (Array.length l) l

let is_ordered ~cmp tree =
  let rec is_ordered_min_max tree =
    match tree with
    | Empty -> `Empty
    | Leaf v -> `V (v, v)
    | Node { l; v; r } -> (
        match is_ordered_min_max l with
        | `No -> `No
        | `Empty -> (
            match is_ordered_min_max r with
            | `No -> `No
            | `Empty -> `V (v, v)
            | `V (l, r) -> if cmp v l < 0 then `V (v, r) else `No)
        | `V (min_v, max_v) -> (
            match is_ordered_min_max r with
            | `No -> `No
            | `Empty -> if cmp max_v v < 0 then `V (min_v, v) else `No
            | `V (min_v_r, max_v_r) ->
                if cmp max_v min_v_r < 0 then `V (min_v, max_v_r) else `No))
  in
  is_ordered_min_max tree <> `No

let invariant ~cmp t =
  check t;
  is_ordered ~cmp t

module type S = sig
  type elt

  type t

  val empty : t

  val is_empty : t -> bool

  val iter : t -> (elt -> unit) -> unit

  val fold : t -> 'a -> (elt -> 'a -> 'a) -> 'a

  val for_all : t -> (elt -> bool) -> bool

  val exists : t -> (elt -> bool) -> bool

  val singleton : elt -> t

  val cardinal : t -> int

  val elements : t -> elt list

  val choose : t -> elt

  val mem : t -> elt -> bool

  val add : t -> elt -> t

  val remove : t -> elt -> t

  val union : t -> t -> t

  val inter : t -> t -> t

  val diff : t -> t -> t

  val of_list : elt list -> t

  val of_sorted_array : elt array -> t

  val invariant : t -> bool

  val print : Format.formatter -> t -> unit
end

end
module Ext_int : sig 
#1 "ext_int.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = int

val compare : t -> t -> int

val equal : t -> t -> bool

val int32_unsigned_to_int : int32 -> int
(** 
   works on 64 bit platform only
   given input as an uint32 and convert it io int64
*)

end = struct
#1 "ext_int.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = int

let compare (x : t) (y : t) = Pervasives.compare x y

let equal (x : t) (y : t) = x = y

let move = 0x1_0000_0000

(* works only on 64 bit platform *)
let int32_unsigned_to_int (n : int32) : int =
  let i = Int32.to_int n in
  if i < 0 then i + move else i

end
module Set_int : sig 
#1 "set_int.mli"
include Set_gen.S with type elt = int

end = struct
#1 "set_int.ml"
# 1 "ext/set.cppo.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


# 43 "ext/set.cppo.ml"
type elt = int 
let compare_elt = Ext_int.compare 
let print_elt = Format.pp_print_int
let [@inline] eq_elt (x : elt) y = x = y


# 52 "ext/set.cppo.ml"
(* let (=) (a:int) b = a = b *)

type ('a ) t0 = 'a Set_gen.t 

type  t = elt t0

let empty = Set_gen.empty 
let is_empty = Set_gen.is_empty
let iter = Set_gen.iter
let fold = Set_gen.fold
let for_all = Set_gen.for_all 
let exists = Set_gen.exists 
let singleton = Set_gen.singleton 
let cardinal = Set_gen.cardinal
let elements = Set_gen.elements
let choose = Set_gen.choose 

let of_sorted_array = Set_gen.of_sorted_array

let rec mem (tree : t) (x : elt) =  match tree with 
  | Empty -> false
  | Leaf v -> eq_elt x  v 
  | Node{l; v; r} ->
    let c = compare_elt x v in
    c = 0 || mem (if c < 0 then l else r) x

type split = 
  | Yes of  {l : t ;  r :  t }
  | No of { l : t; r : t}  

let [@inline] split_l (x : split) = 
  match x with 
  | Yes {l} | No {l} -> l 

let [@inline] split_r (x : split) = 
  match x with 
  | Yes {r} | No {r} -> r       

let [@inline] split_pres (x : split) = match x with | Yes _ -> true | No _ -> false   

let rec split (tree : t) x : split =  match tree with 
  | Empty ->
     No {l = empty;  r = empty}
  | Leaf v ->   
    let c = compare_elt x v in
    if c = 0 then Yes {l = empty; r = empty}
    else if c < 0 then
      No {l = empty;  r = tree}
    else
      No {l = tree;  r = empty}
  | Node {l; v; r} ->
    let c = compare_elt x v in
    if c = 0 then Yes {l; r}
    else if c < 0 then
      match split l x with 
      | Yes result -> 
        Yes { result with r = Set_gen.internal_join result.r v r }
      | No result ->
        No { result with r= Set_gen.internal_join result.r v r }
    else
      match split r x with
      | Yes result -> 
        Yes {result with l = Set_gen.internal_join l v result.l}
      | No result ->   
        No {result with l = Set_gen.internal_join l v result.l}

let rec add (tree : t) x : t =  match tree with 
  | Empty -> singleton x
  | Leaf v -> 
    let c = compare_elt x v in
    if c = 0 then tree else     
    if c < 0 then 
      Set_gen.unsafe_two_elements x v
    else 
      Set_gen.unsafe_two_elements v x 
  | Node {l; v; r} as t ->
    let c = compare_elt x v in
    if c = 0 then t else
    if c < 0 then Set_gen.bal (add l x ) v r else Set_gen.bal l v (add r x )

let rec union (s1 : t) (s2 : t) : t  =
  match (s1, s2) with
  | (Empty, t) 
  | (t, Empty) -> t
  | Node _, Leaf v2 ->
    add s1 v2 
  | Leaf v1, Node _ -> 
    add s2 v1 
  | Leaf x, Leaf v -> 
    let c = compare_elt x v in
    if c = 0 then s1 else     
    if c < 0 then 
      Set_gen.unsafe_two_elements x v
    else 
      Set_gen.unsafe_two_elements v x
  | Node{l=l1; v=v1; r=r1; h=h1}, Node{l=l2; v=v2; r=r2; h=h2} ->
    if h1 >= h2 then    
      let split_result =  split s2 v1 in
      Set_gen.internal_join 
        (union l1 (split_l split_result)) v1 
        (union r1 (split_r split_result))  
    else    
      let split_result =  split s1 v2 in
      Set_gen.internal_join 
        (union (split_l split_result) l2) v2 
        (union (split_r split_result) r2)


let rec inter (s1 : t)  (s2 : t) : t  =
  match (s1, s2) with
  | (Empty, _) 
  | (_, Empty) -> empty  
  | Leaf v, _ -> 
    if mem s2 v then s1 else empty
  | Node ({ v } as s1), _ ->
    let result = split s2 v in 
    if split_pres result then 
      Set_gen.internal_join 
        (inter s1.l (split_l result)) 
        v 
        (inter s1.r (split_r result))
    else
      Set_gen.internal_concat 
        (inter s1.l (split_l result)) 
        (inter s1.r (split_r result))


let rec diff (s1 : t) (s2 : t) : t  =
  match (s1, s2) with
  | (Empty, _) -> empty
  | (t1, Empty) -> t1
  | Leaf v, _-> 
    if mem s2 v then empty else s1 
  | (Node({ v} as s1), _) ->
    let result =  split s2 v in
    if split_pres result then 
      Set_gen.internal_concat 
        (diff s1.l (split_l result)) 
        (diff s1.r (split_r result))    
    else
      Set_gen.internal_join 
        (diff s1.l (split_l result))
        v 
        (diff s1.r (split_r result))







let rec remove (tree : t)  (x : elt) : t = match tree with 
  | Empty -> empty (* This case actually would be never reached *)
  | Leaf v ->     
    if eq_elt x  v then empty else tree    
  | Node{l; v; r} ->
    let c = compare_elt x v in
    if c = 0 then Set_gen.internal_merge l r else
    if c < 0 then Set_gen.bal (remove l x) v r else Set_gen.bal l v (remove r x )

(* let compare s1 s2 = Set_gen.compare ~cmp:compare_elt s1 s2  *)



let of_list l =
  match l with
  | [] -> empty
  | [x0] -> singleton x0
  | [x0; x1] -> add (singleton x0) x1 
  | [x0; x1; x2] -> add (add (singleton x0)  x1) x2 
  | [x0; x1; x2; x3] -> add (add (add (singleton x0) x1 ) x2 ) x3 
  | [x0; x1; x2; x3; x4] -> add (add (add (add (singleton x0) x1) x2 ) x3 ) x4 
  | _ -> 
    let arrs = Array.of_list l in 
    Array.sort compare_elt arrs ; 
    of_sorted_array arrs



(* also check order *)
let invariant t =
  Set_gen.check t ;
  Set_gen.is_ordered ~cmp:compare_elt t          

let print fmt s = 
  Format.fprintf 
   fmt   "@[<v>{%a}@]@."
    (fun fmt s   -> 
       iter s
         (fun e -> Format.fprintf fmt "@[<v>%a@],@ " 
         print_elt e) 
    )
    s     






end
module Ounit_bal_tree_tests
= struct
#1 "ounit_bal_tree_tests.ml"
let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal

module Set_poly =  struct 
  include Set_int
let of_sorted_list xs = Array.of_list xs |> of_sorted_array 
let of_array l = 
  Ext_array.fold_left l empty add
end
let suites = 
  __FILE__ >:::
  [
    __LOC__ >:: begin fun _ ->
      OUnit.assert_bool __LOC__
        (Set_poly.invariant 
           (Set_poly.of_array (Array.init 1000 (fun n -> n))))
    end;
    __LOC__ >:: begin fun _ ->
      OUnit.assert_bool __LOC__
        (Set_poly.invariant 
           (Set_poly.of_array (Array.init 1000 (fun n -> 1000-n))))
    end;
    __LOC__ >:: begin fun _ ->
      OUnit.assert_bool __LOC__
        (Set_poly.invariant 
           (Set_poly.of_array (Array.init 1000 (fun _ -> Random.int 1000))))
    end;
    __LOC__ >:: begin fun _ ->
      OUnit.assert_bool __LOC__
        (Set_poly.invariant 
           (Set_poly.of_sorted_list (Array.to_list (Array.init 1000 (fun n -> n)))))
    end;
    __LOC__ >:: begin fun _ ->
      let arr = Array.init 1000 (fun n -> n) in
      let set = (Set_poly.of_sorted_array arr) in
      OUnit.assert_bool __LOC__
        (Set_poly.invariant set );
      OUnit.assert_equal 1000 (Set_poly.cardinal set)    
    end;
    __LOC__ >:: begin fun _ ->
      for i = 0 to 200 do 
        let arr = Array.init i (fun n -> n) in
        let set = (Set_poly.of_sorted_array arr) in
        OUnit.assert_bool __LOC__
          (Set_poly.invariant set );
        OUnit.assert_equal i (Set_poly.cardinal set)
      done    
    end;
    __LOC__ >:: begin fun _ ->
      let arr_size = 200 in
      let arr_sets = Array.make 200 Set_poly.empty in  
      for i = 0 to arr_size - 1 do
        let size = Random.int 1000 in  
        let arr = Array.init size (fun n -> n) in
        arr_sets.(i)<- (Set_poly.of_sorted_array arr)            
      done;
      let large = Array.fold_left Set_poly.union Set_poly.empty arr_sets in 
      OUnit.assert_bool __LOC__ (Set_poly.invariant large)
    end;

     __LOC__ >:: begin fun _ ->
      let arr_size = 1_00_000 in
      let v = ref Set_int.empty in 
      for _ = 0 to arr_size - 1 do
        let size = Random.int 0x3FFFFFFF in  
         v := Set_int.add !v size                       
      done;       
      OUnit.assert_bool __LOC__ (Set_int.invariant !v)
    end;

  ]


type ident = { stamp : int ; name : string ; mutable flags : int}

module Set_ident = Set.Make(struct type t = ident 
    let compare = Pervasives.compare end)

let compare_ident x y = 
  let a =  compare (x.stamp : int) y.stamp in 
  if a <> 0 then a 
  else 
    let b = compare (x.name : string) y.name in 
    if b <> 0 then b 
    else compare (x.flags : int) y.flags     


let rec add (tree : _ Set_gen.t) x  =  match tree with 
  | Empty -> Set_gen.singleton x
  | Leaf v -> 
    let c = compare_ident x v in
    if c = 0 then tree else     
    if c < 0 then 
      Set_gen.unsafe_two_elements x v
    else 
      Set_gen.unsafe_two_elements v x
  | Node {l; v; r} as t ->
    let c = compare_ident x v in
    if c = 0 then t else
    if c < 0 then Set_gen.bal (add l x ) v r else Set_gen.bal l v (add r x )

let rec mem (tree : _ Set_gen.t) x =  match tree with 
    | Empty -> false
    | Leaf v -> compare_ident x v = 0
    | Node{l; v; r} ->
      let c = compare_ident x v in
      c = 0 || mem (if c < 0 then l else r) x
  
module Ident_set2 = Set.Make(struct type t = ident 
    let compare  = compare_ident            
  end)

let bench () = 
  let times = 1_000_000 in
  Ounit_tests_util.time "functor set" begin fun _ -> 
    let v = ref Set_ident.empty in  
    for i = 0 to  times do
      v := Set_ident.add   {stamp = i ; name = "name"; flags = -1 } !v 
    done;
    for i = 0 to times do
      ignore @@ Set_ident.mem   {stamp = i; name = "name" ; flags = -1} !v 
    done 
  end ;
  Ounit_tests_util.time "functor set (specialized)" begin fun _ -> 
    let v = ref Ident_set2.empty in  
    for i = 0 to  times do
      v := Ident_set2.add   {stamp = i ; name = "name"; flags = -1 } !v 
    done;
    for i = 0 to times do
      ignore @@ Ident_set2.mem   {stamp = i; name = "name" ; flags = -1} !v 
    done 
  end ;

  Ounit_tests_util.time "poly set" begin fun _ -> 
    let module Set_poly = Set_ident in 
    let v = ref Set_poly.empty in  
    for i = 0 to  times do
      v := Set_poly.add   {stamp = i ; name = "name"; flags = -1 } !v 
    done;
    for i = 0 to times do
      ignore @@ Set_poly.mem   {stamp = i; name = "name" ; flags = -1} !v 
    done;
  end;
  Ounit_tests_util.time "poly set (specialized)" begin fun _ -> 
    let v = ref Set_gen.empty in  
    for i = 0 to  times do
      v := add  !v {stamp = i ; name = "name"; flags = -1 }  
    done;
    for i = 0 to times do
      ignore @@ mem  !v  {stamp = i; name = "name" ; flags = -1} 
    done 

  end ; 

end
module Ext_list : sig 
#1 "ext_list.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val map : 'a list -> ('a -> 'b) -> 'b list

val map_combine : 'a list -> 'b list -> ('a -> 'c) -> ('c * 'b) list

val combine_array : 'a array -> 'b list -> ('a -> 'c) -> ('c * 'b) list

val combine_array_append :
  'a array -> 'b list -> ('c * 'b) list -> ('a -> 'c) -> ('c * 'b) list

val has_string : string list -> string -> bool

val map_split_opt :
  'a list -> ('a -> 'b option * 'c option) -> 'b list * 'c list

val mapi : 'a list -> (int -> 'a -> 'b) -> 'b list

val mapi_append : 'a list -> (int -> 'a -> 'b) -> 'b list -> 'b list

val map_snd : ('a * 'b) list -> ('b -> 'c) -> ('a * 'c) list

val map_last : 'a list -> (bool -> 'a -> 'b) -> 'b list
(** [map_last f xs ]
    will pass [true] to [f] for the last element, 
    [false] otherwise. 
    For empty list, it returns empty
*)

val last : 'a list -> 'a
(** [last l]
    return the last element
    raise if the list is empty
*)

val append : 'a list -> 'a list -> 'a list

val append_one : 'a list -> 'a -> 'a list

val map_append : 'b list -> 'a list -> ('b -> 'a) -> 'a list

val fold_right : 'a list -> 'b -> ('a -> 'b -> 'b) -> 'b

val fold_right2 : 'a list -> 'b list -> 'c -> ('a -> 'b -> 'c -> 'c) -> 'c

val fold_right3 :
  'a list -> 'b list -> 'c list -> 'd -> ('a -> 'b -> 'c -> 'd -> 'd) -> 'd

val map2 : 'a list -> 'b list -> ('a -> 'b -> 'c) -> 'c list

val map2i : 'a list -> 'b list -> (int -> 'a -> 'b -> 'c) -> 'c list

val fold_left_with_offset :
  'a list -> 'acc -> int -> ('a -> 'acc -> int -> 'acc) -> 'acc

val filter_map : 'a list -> ('a -> 'b option) -> 'b list
(** @unused *)

val exclude : 'a list -> ('a -> bool) -> 'a list
(** [exclude p l] is the opposite of [filter p l] *)

val exclude_with_val : 'a list -> ('a -> bool) -> 'a list option
(** [excludes p l]
    return a tuple [excluded,newl]
    where [exluded] is true indicates that at least one  
    element is removed,[newl] is the new list where all [p x] for [x] is false

*)

val same_length : 'a list -> 'b list -> bool

val init : int -> (int -> 'a) -> 'a list

val split_at : 'a list -> int -> 'a list * 'a list
(** [split_at n l]
    will split [l] into two lists [a,b], [a] will be of length [n], 
    otherwise, it will raise
*)

val split_at_last : 'a list -> 'a list * 'a
(** [split_at_last l]
    It is equivalent to [split_at (List.length l - 1) l ]
*)

val filter_mapi : 'a list -> ('a -> int -> 'b option) -> 'b list

val filter_map2 : 'a list -> 'b list -> ('a -> 'b -> 'c option) -> 'c list

val length_compare : 'a list -> int -> [ `Gt | `Eq | `Lt ]

val length_ge : 'a list -> int -> bool

(**

   {[length xs = length ys + n ]}
   input n should be positive 
   TODO: input checking
*)

val length_larger_than_n : 'a list -> 'a list -> int -> bool

val rev_map_append : 'a list -> 'b list -> ('a -> 'b) -> 'b list
(**
   [rev_map_append f l1 l2]
   [map f l1] and reverse it to append [l2]
   This weird semantics is due to it is the most efficient operation
   we can do
*)

val flat_map : 'a list -> ('a -> 'b list) -> 'b list

val flat_map_append : 'a list -> 'b list -> ('a -> 'b list) -> 'b list

val stable_group : 'a list -> ('a -> 'a -> bool) -> 'a list list
(**
    [stable_group eq lst]
    Example:
    Input:
   {[
     stable_group (=) [1;2;3;4;3]
   ]}
    Output:
   {[
     [[1];[2];[4];[3;3]]
   ]}
    TODO: this is O(n^2) behavior 
    which could be improved later
*)

val drop : 'a list -> int -> 'a list
(** [drop n list]
    raise when [n] is negative
    raise when list's length is less than [n]
*)

val find_first : 'a list -> ('a -> bool) -> 'a option

val find_first_not : 'a list -> ('a -> bool) -> 'a option
(** [find_first_not p lst ]
    if all elements in [lst] pass, return [None] 
    otherwise return the first element [e] as [Some e] which
    fails the predicate
*)

(** [find_opt f l] returns [None] if all return [None],  
    otherwise returns the first one. 
*)

val find_opt : 'a list -> ('a -> 'b option) -> 'b option

val find_def : 'a list -> ('a -> 'b option) -> 'b -> 'b

val rev_iter : 'a list -> ('a -> unit) -> unit

val iter : 'a list -> ('a -> unit) -> unit

val for_all : 'a list -> ('a -> bool) -> bool

val for_all_snd : ('a * 'b) list -> ('b -> bool) -> bool

val for_all2_no_exn : 'a list -> 'b list -> ('a -> 'b -> bool) -> bool
(** [for_all2_no_exn p xs ys]
    return [true] if all satisfied,
    [false] otherwise or length not equal
*)

val split_map : 'a list -> ('a -> 'b * 'c) -> 'b list * 'c list
(** [f] is applied follow the list order *)

val reduce_from_left : 'a list -> ('a -> 'a -> 'a) -> 'a
(** [fn] is applied from left to right *)

val sort_via_array : 'a list -> ('a -> 'a -> int) -> 'a list

val sort_via_arrayf : 'a list -> ('a -> 'a -> int) -> ('a -> 'b) -> 'b list

val assoc_by_string : (string * 'a) list -> string -> 'a option -> 'a
(** [assoc_by_string default key lst]
    if  [key] is found in the list  return that val,
    other unbox the [default], 
    otherwise [assert false ]
*)

val assoc_by_int : (int * 'a) list -> int -> 'a option -> 'a

val nth_opt : 'a list -> int -> 'a option

val iter_snd : ('a * 'b) list -> ('b -> unit) -> unit

val iter_fst : ('a * 'b) list -> ('a -> unit) -> unit

val exists : 'a list -> ('a -> bool) -> bool

val exists_fst : ('a * 'b) list -> ('a -> bool) -> bool

val exists_snd : ('a * 'b) list -> ('b -> bool) -> bool

val concat_append : 'a list list -> 'a list -> 'a list

val fold_left2 : 'a list -> 'b list -> 'c -> ('a -> 'b -> 'c -> 'c) -> 'c

val fold_left : 'a list -> 'b -> ('b -> 'a -> 'b) -> 'b

val singleton_exn : 'a list -> 'a

val mem_string : string list -> string -> bool

val filter : 'a list -> ('a -> bool) -> 'a list

val array_list_filter_map :
  'a array -> 'b list -> ('a -> 'b -> 'c option) -> 'c list

end = struct
#1 "ext_list.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

external ( .!() ) : 'a array -> int -> 'a = "%array_unsafe_get"

let rec map l f =
  match l with
  | [] -> []
  | [ x1 ] ->
      let y1 = f x1 in
      [ y1 ]
  | [ x1; x2 ] ->
      let y1 = f x1 in
      let y2 = f x2 in
      [ y1; y2 ]
  | [ x1; x2; x3 ] ->
      let y1 = f x1 in
      let y2 = f x2 in
      let y3 = f x3 in
      [ y1; y2; y3 ]
  | [ x1; x2; x3; x4 ] ->
      let y1 = f x1 in
      let y2 = f x2 in
      let y3 = f x3 in
      let y4 = f x4 in
      [ y1; y2; y3; y4 ]
  | x1 :: x2 :: x3 :: x4 :: x5 :: tail ->
      let y1 = f x1 in
      let y2 = f x2 in
      let y3 = f x3 in
      let y4 = f x4 in
      let y5 = f x5 in
      y1 :: y2 :: y3 :: y4 :: y5 :: map tail f

let rec has_string l f =
  match l with
  | [] -> false
  | [ x1 ] -> x1 = f
  | [ x1; x2 ] -> x1 = f || x2 = f
  | [ x1; x2; x3 ] -> x1 = f || x2 = f || x3 = f
  | x1 :: x2 :: x3 :: x4 -> x1 = f || x2 = f || x3 = f || has_string x4 f

let rec map_combine l1 l2 f =
  match (l1, l2) with
  | [], [] -> []
  | a1 :: l1, a2 :: l2 -> (f a1, a2) :: map_combine l1 l2 f
  | _, _ -> invalid_arg "Ext_list.map_combine"

let rec arr_list_combine_unsafe arr l i j acc f =
  if i = j then acc
  else
    match l with
    | [] -> invalid_arg "Ext_list.combine"
    | h :: tl ->
        (f arr.!(i), h) :: arr_list_combine_unsafe arr tl (i + 1) j acc f

let combine_array_append arr l acc f =
  let len = Array.length arr in
  arr_list_combine_unsafe arr l 0 len acc f

let combine_array arr l f =
  let len = Array.length arr in
  arr_list_combine_unsafe arr l 0 len [] f

let rec arr_list_filter_map_unasfe arr l i j acc f =
  if i = j then acc
  else
    match l with
    | [] -> invalid_arg "Ext_list.arr_list_filter_map_unsafe"
    | h :: tl -> (
        match f arr.!(i) h with
        | None -> arr_list_filter_map_unasfe arr tl (i + 1) j acc f
        | Some v -> v :: arr_list_filter_map_unasfe arr tl (i + 1) j acc f)

let array_list_filter_map arr l f =
  let len = Array.length arr in
  arr_list_filter_map_unasfe arr l 0 len [] f

let rec map_split_opt (xs : 'a list) (f : 'a -> 'b option * 'c option) :
    'b list * 'c list =
  match xs with
  | [] -> ([], [])
  | x :: xs -> (
      let c, d = f x in
      let cs, ds = map_split_opt xs f in
      ( (match c with Some c -> c :: cs | None -> cs),
        match d with Some d -> d :: ds | None -> ds ))

let rec map_snd l f =
  match l with
  | [] -> []
  | [ (v1, x1) ] ->
      let y1 = f x1 in
      [ (v1, y1) ]
  | [ (v1, x1); (v2, x2) ] ->
      let y1 = f x1 in
      let y2 = f x2 in
      [ (v1, y1); (v2, y2) ]
  | [ (v1, x1); (v2, x2); (v3, x3) ] ->
      let y1 = f x1 in
      let y2 = f x2 in
      let y3 = f x3 in
      [ (v1, y1); (v2, y2); (v3, y3) ]
  | [ (v1, x1); (v2, x2); (v3, x3); (v4, x4) ] ->
      let y1 = f x1 in
      let y2 = f x2 in
      let y3 = f x3 in
      let y4 = f x4 in
      [ (v1, y1); (v2, y2); (v3, y3); (v4, y4) ]
  | (v1, x1) :: (v2, x2) :: (v3, x3) :: (v4, x4) :: (v5, x5) :: tail ->
      let y1 = f x1 in
      let y2 = f x2 in
      let y3 = f x3 in
      let y4 = f x4 in
      let y5 = f x5 in
      (v1, y1) :: (v2, y2) :: (v3, y3) :: (v4, y4) :: (v5, y5) :: map_snd tail f

let rec map_last l f =
  match l with
  | [] -> []
  | [ x1 ] ->
      let y1 = f true x1 in
      [ y1 ]
  | [ x1; x2 ] ->
      let y1 = f false x1 in
      let y2 = f true x2 in
      [ y1; y2 ]
  | [ x1; x2; x3 ] ->
      let y1 = f false x1 in
      let y2 = f false x2 in
      let y3 = f true x3 in
      [ y1; y2; y3 ]
  | [ x1; x2; x3; x4 ] ->
      let y1 = f false x1 in
      let y2 = f false x2 in
      let y3 = f false x3 in
      let y4 = f true x4 in
      [ y1; y2; y3; y4 ]
  | x1 :: x2 :: x3 :: x4 :: tail ->
      (* make sure that tail is not empty *)
      let y1 = f false x1 in
      let y2 = f false x2 in
      let y3 = f false x3 in
      let y4 = f false x4 in
      y1 :: y2 :: y3 :: y4 :: map_last tail f

let rec mapi_aux lst i f tail =
  match lst with
  | [] -> tail
  | a :: l ->
      let r = f i a in
      r :: mapi_aux l (i + 1) f tail

let mapi lst f = mapi_aux lst 0 f []

let mapi_append lst f tail = mapi_aux lst 0 f tail

let rec last xs =
  match xs with
  | [ x ] -> x
  | _ :: tl -> last tl
  | [] -> invalid_arg "Ext_list.last"

let rec append_aux l1 l2 =
  match l1 with
  | [] -> l2
  | [ a0 ] -> a0 :: l2
  | [ a0; a1 ] -> a0 :: a1 :: l2
  | [ a0; a1; a2 ] -> a0 :: a1 :: a2 :: l2
  | [ a0; a1; a2; a3 ] -> a0 :: a1 :: a2 :: a3 :: l2
  | [ a0; a1; a2; a3; a4 ] -> a0 :: a1 :: a2 :: a3 :: a4 :: l2
  | a0 :: a1 :: a2 :: a3 :: a4 :: rest ->
      a0 :: a1 :: a2 :: a3 :: a4 :: append_aux rest l2

let append l1 l2 = match l2 with [] -> l1 | _ -> append_aux l1 l2

let append_one l1 x = append_aux l1 [ x ]

let rec map_append l1 l2 f =
  match l1 with
  | [] -> l2
  | [ a0 ] -> f a0 :: l2
  | [ a0; a1 ] ->
      let b0 = f a0 in
      let b1 = f a1 in
      b0 :: b1 :: l2
  | [ a0; a1; a2 ] ->
      let b0 = f a0 in
      let b1 = f a1 in
      let b2 = f a2 in
      b0 :: b1 :: b2 :: l2
  | [ a0; a1; a2; a3 ] ->
      let b0 = f a0 in
      let b1 = f a1 in
      let b2 = f a2 in
      let b3 = f a3 in
      b0 :: b1 :: b2 :: b3 :: l2
  | [ a0; a1; a2; a3; a4 ] ->
      let b0 = f a0 in
      let b1 = f a1 in
      let b2 = f a2 in
      let b3 = f a3 in
      let b4 = f a4 in
      b0 :: b1 :: b2 :: b3 :: b4 :: l2
  | a0 :: a1 :: a2 :: a3 :: a4 :: rest ->
      let b0 = f a0 in
      let b1 = f a1 in
      let b2 = f a2 in
      let b3 = f a3 in
      let b4 = f a4 in
      b0 :: b1 :: b2 :: b3 :: b4 :: map_append rest l2 f

let rec fold_right l acc f =
  match l with
  | [] -> acc
  | [ a0 ] -> f a0 acc
  | [ a0; a1 ] -> f a0 (f a1 acc)
  | [ a0; a1; a2 ] -> f a0 (f a1 (f a2 acc))
  | [ a0; a1; a2; a3 ] -> f a0 (f a1 (f a2 (f a3 acc)))
  | [ a0; a1; a2; a3; a4 ] -> f a0 (f a1 (f a2 (f a3 (f a4 acc))))
  | a0 :: a1 :: a2 :: a3 :: a4 :: rest ->
      f a0 (f a1 (f a2 (f a3 (f a4 (fold_right rest acc f)))))

let rec fold_right2 l r acc f =
  match (l, r) with
  | [], [] -> acc
  | [ a0 ], [ b0 ] -> f a0 b0 acc
  | [ a0; a1 ], [ b0; b1 ] -> f a0 b0 (f a1 b1 acc)
  | [ a0; a1; a2 ], [ b0; b1; b2 ] -> f a0 b0 (f a1 b1 (f a2 b2 acc))
  | [ a0; a1; a2; a3 ], [ b0; b1; b2; b3 ] ->
      f a0 b0 (f a1 b1 (f a2 b2 (f a3 b3 acc)))
  | [ a0; a1; a2; a3; a4 ], [ b0; b1; b2; b3; b4 ] ->
      f a0 b0 (f a1 b1 (f a2 b2 (f a3 b3 (f a4 b4 acc))))
  | a0 :: a1 :: a2 :: a3 :: a4 :: arest, b0 :: b1 :: b2 :: b3 :: b4 :: brest ->
      f a0 b0
        (f a1 b1 (f a2 b2 (f a3 b3 (f a4 b4 (fold_right2 arest brest acc f)))))
  | _, _ -> invalid_arg "Ext_list.fold_right2"

let rec fold_right3 l r last acc f =
  match (l, r, last) with
  | [], [], [] -> acc
  | [ a0 ], [ b0 ], [ c0 ] -> f a0 b0 c0 acc
  | [ a0; a1 ], [ b0; b1 ], [ c0; c1 ] -> f a0 b0 c0 (f a1 b1 c1 acc)
  | [ a0; a1; a2 ], [ b0; b1; b2 ], [ c0; c1; c2 ] ->
      f a0 b0 c0 (f a1 b1 c1 (f a2 b2 c2 acc))
  | [ a0; a1; a2; a3 ], [ b0; b1; b2; b3 ], [ c0; c1; c2; c3 ] ->
      f a0 b0 c0 (f a1 b1 c1 (f a2 b2 c2 (f a3 b3 c3 acc)))
  | [ a0; a1; a2; a3; a4 ], [ b0; b1; b2; b3; b4 ], [ c0; c1; c2; c3; c4 ] ->
      f a0 b0 c0 (f a1 b1 c1 (f a2 b2 c2 (f a3 b3 c3 (f a4 b4 c4 acc))))
  | ( a0 :: a1 :: a2 :: a3 :: a4 :: arest,
      b0 :: b1 :: b2 :: b3 :: b4 :: brest,
      c0 :: c1 :: c2 :: c3 :: c4 :: crest ) ->
      f a0 b0 c0
        (f a1 b1 c1
           (f a2 b2 c2
              (f a3 b3 c3 (f a4 b4 c4 (fold_right3 arest brest crest acc f)))))
  | _, _, _ -> invalid_arg "Ext_list.fold_right2"

let rec map2i l r f =
  match (l, r) with
  | [], [] -> []
  | [ a0 ], [ b0 ] -> [ f 0 a0 b0 ]
  | [ a0; a1 ], [ b0; b1 ] ->
      let c0 = f 0 a0 b0 in
      let c1 = f 1 a1 b1 in
      [ c0; c1 ]
  | [ a0; a1; a2 ], [ b0; b1; b2 ] ->
      let c0 = f 0 a0 b0 in
      let c1 = f 1 a1 b1 in
      let c2 = f 2 a2 b2 in
      [ c0; c1; c2 ]
  | [ a0; a1; a2; a3 ], [ b0; b1; b2; b3 ] ->
      let c0 = f 0 a0 b0 in
      let c1 = f 1 a1 b1 in
      let c2 = f 2 a2 b2 in
      let c3 = f 3 a3 b3 in
      [ c0; c1; c2; c3 ]
  | [ a0; a1; a2; a3; a4 ], [ b0; b1; b2; b3; b4 ] ->
      let c0 = f 0 a0 b0 in
      let c1 = f 1 a1 b1 in
      let c2 = f 2 a2 b2 in
      let c3 = f 3 a3 b3 in
      let c4 = f 4 a4 b4 in
      [ c0; c1; c2; c3; c4 ]
  | a0 :: a1 :: a2 :: a3 :: a4 :: arest, b0 :: b1 :: b2 :: b3 :: b4 :: brest ->
      let c0 = f 0 a0 b0 in
      let c1 = f 1 a1 b1 in
      let c2 = f 2 a2 b2 in
      let c3 = f 3 a3 b3 in
      let c4 = f 4 a4 b4 in
      c0 :: c1 :: c2 :: c3 :: c4 :: map2i arest brest f
  | _, _ -> invalid_arg "Ext_list.map2"

let rec map2 l r f =
  match (l, r) with
  | [], [] -> []
  | [ a0 ], [ b0 ] -> [ f a0 b0 ]
  | [ a0; a1 ], [ b0; b1 ] ->
      let c0 = f a0 b0 in
      let c1 = f a1 b1 in
      [ c0; c1 ]
  | [ a0; a1; a2 ], [ b0; b1; b2 ] ->
      let c0 = f a0 b0 in
      let c1 = f a1 b1 in
      let c2 = f a2 b2 in
      [ c0; c1; c2 ]
  | [ a0; a1; a2; a3 ], [ b0; b1; b2; b3 ] ->
      let c0 = f a0 b0 in
      let c1 = f a1 b1 in
      let c2 = f a2 b2 in
      let c3 = f a3 b3 in
      [ c0; c1; c2; c3 ]
  | [ a0; a1; a2; a3; a4 ], [ b0; b1; b2; b3; b4 ] ->
      let c0 = f a0 b0 in
      let c1 = f a1 b1 in
      let c2 = f a2 b2 in
      let c3 = f a3 b3 in
      let c4 = f a4 b4 in
      [ c0; c1; c2; c3; c4 ]
  | a0 :: a1 :: a2 :: a3 :: a4 :: arest, b0 :: b1 :: b2 :: b3 :: b4 :: brest ->
      let c0 = f a0 b0 in
      let c1 = f a1 b1 in
      let c2 = f a2 b2 in
      let c3 = f a3 b3 in
      let c4 = f a4 b4 in
      c0 :: c1 :: c2 :: c3 :: c4 :: map2 arest brest f
  | _, _ -> invalid_arg "Ext_list.map2"

let rec fold_left_with_offset l accu i f =
  match l with
  | [] -> accu
  | a :: l -> fold_left_with_offset l (f a accu i) (i + 1) f

let rec filter_map xs (f : 'a -> 'b option) =
  match xs with
  | [] -> []
  | y :: ys -> (
      match f y with None -> filter_map ys f | Some z -> z :: filter_map ys f)

let rec exclude (xs : 'a list) (p : 'a -> bool) : 'a list =
  match xs with
  | [] -> []
  | x :: xs -> if p x then exclude xs p else x :: exclude xs p

let rec exclude_with_val l p =
  match l with
  | [] -> None
  | a0 :: xs -> (
      if p a0 then Some (exclude xs p)
      else
        match xs with
        | [] -> None
        | a1 :: rest -> (
            if p a1 then Some (a0 :: exclude rest p)
            else
              match exclude_with_val rest p with
              | None -> None
              | Some rest -> Some (a0 :: a1 :: rest)))

let rec same_length xs ys =
  match (xs, ys) with
  | [], [] -> true
  | _ :: xs, _ :: ys -> same_length xs ys
  | _, _ -> false

let init n f =
  match n with
  | 0 -> []
  | 1 ->
      let a0 = f 0 in
      [ a0 ]
  | 2 ->
      let a0 = f 0 in
      let a1 = f 1 in
      [ a0; a1 ]
  | 3 ->
      let a0 = f 0 in
      let a1 = f 1 in
      let a2 = f 2 in
      [ a0; a1; a2 ]
  | 4 ->
      let a0 = f 0 in
      let a1 = f 1 in
      let a2 = f 2 in
      let a3 = f 3 in
      [ a0; a1; a2; a3 ]
  | 5 ->
      let a0 = f 0 in
      let a1 = f 1 in
      let a2 = f 2 in
      let a3 = f 3 in
      let a4 = f 4 in
      [ a0; a1; a2; a3; a4 ]
  | _ -> Array.to_list (Array.init n f)

let rec rev_append l1 l2 =
  match l1 with
  | [] -> l2
  | [ a0 ] -> a0 :: l2 (* single element is common *)
  | [ a0; a1 ] -> a1 :: a0 :: l2
  | a0 :: a1 :: a2 :: rest -> rev_append rest (a2 :: a1 :: a0 :: l2)

let rev l = rev_append l []

let rec small_split_at n acc l =
  if n <= 0 then (rev acc, l)
  else
    match l with
    | x :: xs -> small_split_at (n - 1) (x :: acc) xs
    | _ -> invalid_arg "Ext_list.split_at"

let split_at l n = small_split_at n [] l

let rec split_at_last_aux acc x =
  match x with
  | [] -> invalid_arg "Ext_list.split_at_last"
  | [ x ] -> (rev acc, x)
  | y0 :: ys -> split_at_last_aux (y0 :: acc) ys

let split_at_last (x : 'a list) =
  match x with
  | [] -> invalid_arg "Ext_list.split_at_last"
  | [ a0 ] -> ([], a0)
  | [ a0; a1 ] -> ([ a0 ], a1)
  | [ a0; a1; a2 ] -> ([ a0; a1 ], a2)
  | [ a0; a1; a2; a3 ] -> ([ a0; a1; a2 ], a3)
  | [ a0; a1; a2; a3; a4 ] -> ([ a0; a1; a2; a3 ], a4)
  | a0 :: a1 :: a2 :: a3 :: a4 :: rest ->
      let rev, last = split_at_last_aux [] rest in
      (a0 :: a1 :: a2 :: a3 :: a4 :: rev, last)

(**
   can not do loop unroll due to state combination
*)
let filter_mapi xs f =
  let rec aux i xs =
    match xs with
    | [] -> []
    | y :: ys -> (
        match f y i with
        | None -> aux (i + 1) ys
        | Some z -> z :: aux (i + 1) ys)
  in
  aux 0 xs

let rec filter_map2 xs ys (f : 'a -> 'b -> 'c option) =
  match (xs, ys) with
  | [], [] -> []
  | u :: us, v :: vs -> (
      match f u v with
      | None -> filter_map2 us vs f (* idea: rec f us vs instead? *)
      | Some z -> z :: filter_map2 us vs f)
  | _ -> invalid_arg "Ext_list.filter_map2"

let rec rev_map_append l1 l2 f =
  match l1 with [] -> l2 | a :: l -> rev_map_append l (f a :: l2) f

(** It is not worth loop unrolling, 
    it is already tail-call, and we need to be careful 
    about evaluation order when unroll
*)
let rec flat_map_aux f acc append lx =
  match lx with
  | [] -> rev_append acc append
  | a0 :: rest ->
      let new_acc =
        match f a0 with
        | [] -> acc
        | [ a0 ] -> a0 :: acc
        | [ a0; a1 ] -> a1 :: a0 :: acc
        | a0 :: a1 :: a2 :: rest -> rev_append rest (a2 :: a1 :: a0 :: acc)
      in
      flat_map_aux f new_acc append rest

let flat_map lx f = flat_map_aux f [] [] lx

let flat_map_append lx append f = flat_map_aux f [] append lx

let rec length_compare l n =
  if n < 0 then `Gt
  else
    match l with
    | _ :: xs -> length_compare xs (n - 1)
    | [] -> if n = 0 then `Eq else `Lt

let rec length_ge l n =
  if n > 0 then match l with _ :: tl -> length_ge tl (n - 1) | [] -> false
  else true

(**
   {[length xs = length ys + n ]}
*)
let rec length_larger_than_n xs ys n =
  match (xs, ys) with
  | _, [] -> length_compare xs n = `Eq
  | _ :: xs, _ :: ys -> length_larger_than_n xs ys n
  | [], _ -> false

let rec group (eq : 'a -> 'a -> bool) lst =
  match lst with [] -> [] | x :: xs -> aux eq x (group eq xs)

and aux eq (x : 'a) (xss : 'a list list) : 'a list list =
  match xss with
  | [] -> [ [ x ] ]
  | (y0 :: _ as y) :: ys ->
      (* cannot be empty *)
      if eq x y0 then (x :: y) :: ys else y :: aux eq x ys
  | _ :: _ -> assert false

let stable_group lst eq = group eq lst |> rev

let rec drop h n =
  if n < 0 then invalid_arg "Ext_list.drop"
  else if n = 0 then h
  else
    match h with [] -> invalid_arg "Ext_list.drop" | _ :: tl -> drop tl (n - 1)

let rec find_first x p =
  match x with [] -> None | x :: l -> if p x then Some x else find_first l p

let rec find_first_not xs p =
  match xs with
  | [] -> None
  | a :: l -> if p a then find_first_not l p else Some a

let rec rev_iter l f =
  match l with
  | [] -> ()
  | [ x1 ] -> f x1
  | [ x1; x2 ] ->
      f x2;
      f x1
  | [ x1; x2; x3 ] ->
      f x3;
      f x2;
      f x1
  | [ x1; x2; x3; x4 ] ->
      f x4;
      f x3;
      f x2;
      f x1
  | x1 :: x2 :: x3 :: x4 :: x5 :: tail ->
      rev_iter tail f;
      f x5;
      f x4;
      f x3;
      f x2;
      f x1

let rec iter l f =
  match l with
  | [] -> ()
  | [ x1 ] -> f x1
  | [ x1; x2 ] ->
      f x1;
      f x2
  | [ x1; x2; x3 ] ->
      f x1;
      f x2;
      f x3
  | [ x1; x2; x3; x4 ] ->
      f x1;
      f x2;
      f x3;
      f x4
  | x1 :: x2 :: x3 :: x4 :: x5 :: tail ->
      f x1;
      f x2;
      f x3;
      f x4;
      f x5;
      iter tail f

let rec for_all lst p =
  match lst with [] -> true | a :: l -> p a && for_all l p

let rec for_all_snd lst p =
  match lst with [] -> true | (_, a) :: l -> p a && for_all_snd l p

let rec for_all2_no_exn l1 l2 p =
  match (l1, l2) with
  | [], [] -> true
  | a1 :: l1, a2 :: l2 -> p a1 a2 && for_all2_no_exn l1 l2 p
  | _, _ -> false

let rec find_opt xs p =
  match xs with
  | [] -> None
  | x :: l -> ( match p x with Some _ as v -> v | None -> find_opt l p)

let rec find_def xs p def =
  match xs with
  | [] -> def
  | x :: l -> ( match p x with Some v -> v | None -> find_def l p def)

let rec split_map l f =
  match l with
  | [] -> ([], [])
  | [ x1 ] ->
      let a0, b0 = f x1 in
      ([ a0 ], [ b0 ])
  | [ x1; x2 ] ->
      let a1, b1 = f x1 in
      let a2, b2 = f x2 in
      ([ a1; a2 ], [ b1; b2 ])
  | [ x1; x2; x3 ] ->
      let a1, b1 = f x1 in
      let a2, b2 = f x2 in
      let a3, b3 = f x3 in
      ([ a1; a2; a3 ], [ b1; b2; b3 ])
  | [ x1; x2; x3; x4 ] ->
      let a1, b1 = f x1 in
      let a2, b2 = f x2 in
      let a3, b3 = f x3 in
      let a4, b4 = f x4 in
      ([ a1; a2; a3; a4 ], [ b1; b2; b3; b4 ])
  | x1 :: x2 :: x3 :: x4 :: x5 :: tail ->
      let a1, b1 = f x1 in
      let a2, b2 = f x2 in
      let a3, b3 = f x3 in
      let a4, b4 = f x4 in
      let a5, b5 = f x5 in
      let ass, bss = split_map tail f in
      (a1 :: a2 :: a3 :: a4 :: a5 :: ass, b1 :: b2 :: b3 :: b4 :: b5 :: bss)

let sort_via_array lst cmp =
  let arr = Array.of_list lst in
  Array.sort cmp arr;
  Array.to_list arr

let sort_via_arrayf lst cmp f =
  let arr = Array.of_list lst in
  Array.sort cmp arr;
  Ext_array.to_list_f arr f

let rec assoc_by_string lst (k : string) def =
  match lst with
  | [] -> ( match def with None -> assert false | Some x -> x)
  | (k1, v1) :: rest -> if k1 = k then v1 else assoc_by_string rest k def

let rec assoc_by_int lst (k : int) def =
  match lst with
  | [] -> ( match def with None -> assert false | Some x -> x)
  | (k1, v1) :: rest -> if k1 = k then v1 else assoc_by_int rest k def

let rec nth_aux l n =
  match l with
  | [] -> None
  | a :: l -> if n = 0 then Some a else nth_aux l (n - 1)

let nth_opt l n = if n < 0 then None else nth_aux l n

let rec iter_snd lst f =
  match lst with
  | [] -> ()
  | (_, x) :: xs ->
      f x;
      iter_snd xs f

let rec iter_fst lst f =
  match lst with
  | [] -> ()
  | (x, _) :: xs ->
      f x;
      iter_fst xs f

let rec exists l p = match l with [] -> false | x :: xs -> p x || exists xs p

let rec exists_fst l p =
  match l with [] -> false | (a, _) :: l -> p a || exists_fst l p

let rec exists_snd l p =
  match l with [] -> false | (_, a) :: l -> p a || exists_snd l p

let rec concat_append (xss : 'a list list) (xs : 'a list) : 'a list =
  match xss with [] -> xs | l :: r -> append l (concat_append r xs)

let rec fold_left l accu f =
  match l with [] -> accu | a :: l -> fold_left l (f accu a) f

let reduce_from_left lst fn =
  match lst with
  | first :: rest -> fold_left rest first fn
  | _ -> invalid_arg "Ext_list.reduce_from_left"

let rec fold_left2 l1 l2 accu f =
  match (l1, l2) with
  | [], [] -> accu
  | a1 :: l1, a2 :: l2 -> fold_left2 l1 l2 (f a1 a2 accu) f
  | _, _ -> invalid_arg "Ext_list.fold_left2"

let singleton_exn xs = match xs with [ x ] -> x | _ -> assert false

let rec mem_string (xs : string list) (x : string) =
  match xs with [] -> false | a :: l -> a = x || mem_string l x

let filter lst p =
  let rec find ~p accu lst =
    match lst with
    | [] -> rev accu
    | x :: l -> if p x then find (x :: accu) l ~p else find accu l ~p
  in
  find [] lst ~p

end
module Map_gen : sig 
#1 "map_gen.mli"
type ('key, +'a) t = private
  | Empty
  | Leaf of { k : 'key; v : 'a }
  | Node of { l : ('key, 'a) t; k : 'key; v : 'a; r : ('key, 'a) t; h : int }

val cardinal : ('a, 'b) t -> int

val bindings : ('a, 'b) t -> ('a * 'b) list

val fill_array_with_f : ('a, 'b) t -> int -> 'c array -> ('a -> 'b -> 'c) -> int

val fill_array_aux : ('a, 'b) t -> int -> ('a * 'b) array -> int

val to_sorted_array : ('key, 'a) t -> ('key * 'a) array

val to_sorted_array_with_f : ('a, 'b) t -> ('a -> 'b -> 'c) -> 'c array

val keys : ('a, 'b) t -> 'a list

val height : ('a, 'b) t -> int

val singleton : 'a -> 'b -> ('a, 'b) t

val unsafe_node : 'a -> 'b -> ('a, 'b) t -> ('a, 'b) t -> int -> ('a, 'b) t
  [@@inline]

val unsafe_two_elements : 'a -> 'b -> 'a -> 'b -> ('a, 'b) t
  [@@inline]
(** smaller comes first *)

val bal : ('a, 'b) t -> 'a -> 'b -> ('a, 'b) t -> ('a, 'b) t

val empty : ('a, 'b) t

val is_empty : ('a, 'b) t -> bool

val merge : ('a, 'b) t -> ('a, 'b) t -> ('a, 'b) t

val iter : ('a, 'b) t -> ('a -> 'b -> unit) -> unit

val map : ('a, 'b) t -> ('b -> 'c) -> ('a, 'c) t

val mapi : ('a, 'b) t -> ('a -> 'b -> 'c) -> ('a, 'c) t

val fold : ('a, 'b) t -> 'c -> ('a -> 'b -> 'c -> 'c) -> 'c

val for_all : ('a, 'b) t -> ('a -> 'b -> bool) -> bool

val exists : ('a, 'b) t -> ('a -> 'b -> bool) -> bool

val join : ('a, 'b) t -> 'a -> 'b -> ('a, 'b) t -> ('a, 'b) t

val concat : ('a, 'b) t -> ('a, 'b) t -> ('a, 'b) t

val concat_or_join : ('a, 'b) t -> 'a -> 'b option -> ('a, 'b) t -> ('a, 'b) t

module type S = sig
  type key

  type +'a t

  val empty : 'a t

  val compare_key : key -> key -> int

  val is_empty : 'a t -> bool

  val mem : 'a t -> key -> bool

  val to_sorted_array : 'a t -> (key * 'a) array

  val to_sorted_array_with_f : 'a t -> (key -> 'a -> 'b) -> 'b array

  val add : 'a t -> key -> 'a -> 'a t

  val adjust : 'a t -> key -> ('a option -> 'a) -> 'a t

  val singleton : key -> 'a -> 'a t

  val remove : 'a t -> key -> 'a t

  (* val merge :
     'a t -> 'b t -> (key -> 'a option -> 'b option -> 'c option) -> 'c t *)
  val disjoint_merge_exn : 'a t -> 'a t -> (key -> 'a -> 'a -> exn) -> 'a t

  val iter : 'a t -> (key -> 'a -> unit) -> unit

  val fold : 'a t -> 'b -> (key -> 'a -> 'b -> 'b) -> 'b

  val for_all : 'a t -> (key -> 'a -> bool) -> bool

  val exists : 'a t -> (key -> 'a -> bool) -> bool

  (* val filter : 'a t -> (key -> 'a -> bool) -> 'a t *)
  (* val partition : 'a t -> (key -> 'a -> bool) -> 'a t * 'a t *)
  val cardinal : 'a t -> int

  val bindings : 'a t -> (key * 'a) list

  val keys : 'a t -> key list
  (* val choose : 'a t -> key * 'a *)

  val find_exn : 'a t -> key -> 'a

  val find_opt : 'a t -> key -> 'a option

  val find_default : 'a t -> key -> 'a -> 'a

  val map : 'a t -> ('a -> 'b) -> 'b t

  val mapi : 'a t -> (key -> 'a -> 'b) -> 'b t

  val of_list : (key * 'a) list -> 'a t

  val of_array : (key * 'a) array -> 'a t

  val add_list : (key * 'b) list -> 'b t -> 'b t
end

end = struct
#1 "map_gen.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the GNU Library General Public License, with    *)
(*  the special exception on linking described in file ../LICENSE.     *)
(*                                                                     *)
(***********************************************************************)

[@@@warnerror "+55"]
(* adapted from stdlib *)

type ('key, 'a) t0 =
  | Empty
  | Leaf of { k : 'key; v : 'a }
  | Node of { l : ('key, 'a) t0; k : 'key; v : 'a; r : ('key, 'a) t0; h : int }

type ('key, 'a) parital_node = {
  l : ('key, 'a) t0;
  k : 'key;
  v : 'a;
  r : ('key, 'a) t0;
  h : int;
}

external ( ~! ) : ('key, 'a) t0 -> ('key, 'a) parital_node = "%identity"

let empty = Empty

let rec map x f =
  match x with
  | Empty -> Empty
  | Leaf { k; v } -> Leaf { k; v = f v }
  | Node ({ l; v; r } as x) ->
      let l' = map l f in
      let d' = f v in
      let r' = map r f in
      Node { x with l = l'; v = d'; r = r' }

let rec mapi x f =
  match x with
  | Empty -> Empty
  | Leaf { k; v } -> Leaf { k; v = f k v }
  | Node ({ l; k; v; r } as x) ->
      let l' = mapi l f in
      let v' = f k v in
      let r' = mapi r f in
      Node { x with l = l'; v = v'; r = r' }

let[@inline] calc_height a b = (if a >= b then a else b) + 1

let[@inline] singleton k v = Leaf { k; v }

let[@inline] height = function Empty -> 0 | Leaf _ -> 1 | Node { h } -> h

let[@inline] unsafe_node k v l r h = Node { l; k; v; r; h }

let[@inline] unsafe_two_elements k1 v1 k2 v2 =
  unsafe_node k2 v2 (singleton k1 v1) empty 2

let[@inline] unsafe_node_maybe_leaf k v l r h =
  if h = 1 then Leaf { k; v } else Node { l; k; v; r; h }

type ('key, +'a) t = ('key, 'a) t0 = private
  | Empty
  | Leaf of { k : 'key; v : 'a }
  | Node of { l : ('key, 'a) t; k : 'key; v : 'a; r : ('key, 'a) t; h : int }

let rec cardinal_aux acc = function
  | Empty -> acc
  | Leaf _ -> acc + 1
  | Node { l; r } -> cardinal_aux (cardinal_aux (acc + 1) r) l

let cardinal s = cardinal_aux 0 s

let rec bindings_aux accu = function
  | Empty -> accu
  | Leaf { k; v } -> (k, v) :: accu
  | Node { l; k; v; r } -> bindings_aux ((k, v) :: bindings_aux accu r) l

let bindings s = bindings_aux [] s

let rec fill_array_with_f (s : _ t) i arr f : int =
  match s with
  | Empty -> i
  | Leaf { k; v } ->
      Array.unsafe_set arr i (f k v);
      i + 1
  | Node { l; k; v; r } ->
      let inext = fill_array_with_f l i arr f in
      Array.unsafe_set arr inext (f k v);
      fill_array_with_f r (inext + 1) arr f

let rec fill_array_aux (s : _ t) i arr : int =
  match s with
  | Empty -> i
  | Leaf { k; v } ->
      Array.unsafe_set arr i (k, v);
      i + 1
  | Node { l; k; v; r } ->
      let inext = fill_array_aux l i arr in
      Array.unsafe_set arr inext (k, v);
      fill_array_aux r (inext + 1) arr

let to_sorted_array (s : ('key, 'a) t) : ('key * 'a) array =
  match s with
  | Empty -> [||]
  | Leaf { k; v } -> [| (k, v) |]
  | Node { l; k; v; r } ->
      let len = cardinal_aux (cardinal_aux 1 r) l in
      let arr = Array.make len (k, v) in
      ignore (fill_array_aux s 0 arr : int);
      arr

let to_sorted_array_with_f (type key a b) (s : (key, a) t) (f : key -> a -> b) :
    b array =
  match s with
  | Empty -> [||]
  | Leaf { k; v } -> [| f k v |]
  | Node { l; k; v; r } ->
      let len = cardinal_aux (cardinal_aux 1 r) l in
      let arr = Array.make len (f k v) in
      ignore (fill_array_with_f s 0 arr f : int);
      arr

let rec keys_aux accu = function
  | Empty -> accu
  | Leaf { k } -> k :: accu
  | Node { l; k; r } -> keys_aux (k :: keys_aux accu r) l

let keys s = keys_aux [] s

let bal l x d r =
  let hl = height l in
  let hr = height r in
  if hl > hr + 2 then
    let { l = ll; r = lr; v = lv; k = lk; h = _ } = ~!l in
    let hll = height ll in
    let hlr = height lr in
    if hll >= hlr then
      let hnode = calc_height hlr hr in
      unsafe_node lk lv ll
        (unsafe_node_maybe_leaf x d lr r hnode)
        (calc_height hll hnode)
    else
      let { l = lrl; r = lrr; k = lrk; v = lrv } = ~!lr in
      let hlrl = height lrl in
      let hlrr = height lrr in
      let hlnode = calc_height hll hlrl in
      let hrnode = calc_height hlrr hr in
      unsafe_node lrk lrv
        (unsafe_node_maybe_leaf lk lv ll lrl hlnode)
        (unsafe_node_maybe_leaf x d lrr r hrnode)
        (calc_height hlnode hrnode)
  else if hr > hl + 2 then
    let { l = rl; r = rr; k = rk; v = rv } = ~!r in
    let hrr = height rr in
    let hrl = height rl in
    if hrr >= hrl then
      let hnode = calc_height hl hrl in
      unsafe_node rk rv
        (unsafe_node_maybe_leaf x d l rl hnode)
        rr (calc_height hnode hrr)
    else
      let { l = rll; r = rlr; k = rlk; v = rlv } = ~!rl in
      let hrll = height rll in
      let hrlr = height rlr in
      let hlnode = calc_height hl hrll in
      let hrnode = calc_height hrlr hrr in
      unsafe_node rlk rlv
        (unsafe_node_maybe_leaf x d l rll hlnode)
        (unsafe_node_maybe_leaf rk rv rlr rr hrnode)
        (calc_height hlnode hrnode)
  else unsafe_node_maybe_leaf x d l r (calc_height hl hr)

let[@inline] is_empty = function Empty -> true | _ -> false

let rec min_binding_exn = function
  | Empty -> raise Not_found
  | Leaf { k; v } -> (k, v)
  | Node { l; k; v } -> (
      match l with Empty -> (k, v) | Leaf _ | Node _ -> min_binding_exn l)

let rec remove_min_binding = function
  | Empty -> invalid_arg "Map.remove_min_elt"
  | Leaf _ -> empty
  | Node { l = Empty; r } -> r
  | Node { l; k; v; r } -> bal (remove_min_binding l) k v r

let merge t1 t2 =
  match (t1, t2) with
  | Empty, t -> t
  | t, Empty -> t
  | _, _ ->
      let x, d = min_binding_exn t2 in
      bal t1 x d (remove_min_binding t2)

let rec iter x f =
  match x with
  | Empty -> ()
  | Leaf { k; v } -> (f k v : unit)
  | Node { l; k; v; r } ->
      iter l f;
      f k v;
      iter r f

let rec fold m accu f =
  match m with
  | Empty -> accu
  | Leaf { k; v } -> f k v accu
  | Node { l; k; v; r } -> fold r (f k v (fold l accu f)) f

let rec for_all x p =
  match x with
  | Empty -> true
  | Leaf { k; v } -> p k v
  | Node { l; k; v; r } -> p k v && for_all l p && for_all r p

let rec exists x p =
  match x with
  | Empty -> false
  | Leaf { k; v } -> p k v
  | Node { l; k; v; r } -> p k v || exists l p || exists r p

(* Beware: those two functions assume that the added k is *strictly*
   smaller (or bigger) than all the present keys in the tree; it
   does not test for equality with the current min (or max) key.

   Indeed, they are only used during the "join" operation which
   respects this precondition.
*)

let rec add_min k v = function
  | Empty -> singleton k v
  | Leaf l -> unsafe_two_elements k v l.k l.v
  | Node tree -> bal (add_min k v tree.l) tree.k tree.v tree.r

let rec add_max k v = function
  | Empty -> singleton k v
  | Leaf l -> unsafe_two_elements l.k l.v k v
  | Node tree -> bal tree.l tree.k tree.v (add_max k v tree.r)

(* Same as create and bal, but no assumptions are made on the
   relative heights of l and r. *)

let rec join l v d r =
  match l with
  | Empty -> add_min v d r
  | Leaf leaf -> add_min leaf.k leaf.v (add_min v d r)
  | Node xl -> (
      match r with
      | Empty -> add_max v d l
      | Leaf leaf -> add_max leaf.k leaf.v (add_max v d l)
      | Node xr ->
          let lh = xl.h in
          let rh = xr.h in
          if lh > rh + 2 then bal xl.l xl.k xl.v (join xl.r v d r)
          else if rh > lh + 2 then bal (join l v d xr.l) xr.k xr.v xr.r
          else unsafe_node v d l r (calc_height lh rh))

(* Merge two trees l and r into one.
   All elements of l must precede the elements of r.
   No assumption on the heights of l and r. *)

let concat t1 t2 =
  match (t1, t2) with
  | Empty, t -> t
  | t, Empty -> t
  | _, _ ->
      let x, d = min_binding_exn t2 in
      join t1 x d (remove_min_binding t2)

let concat_or_join t1 v d t2 =
  match d with Some d -> join t1 v d t2 | None -> concat t1 t2

module type S = sig
  type key

  type +'a t

  val empty : 'a t

  val compare_key : key -> key -> int

  val is_empty : 'a t -> bool

  val mem : 'a t -> key -> bool

  val to_sorted_array : 'a t -> (key * 'a) array

  val to_sorted_array_with_f : 'a t -> (key -> 'a -> 'b) -> 'b array

  val add : 'a t -> key -> 'a -> 'a t
  (** [add x y m] 
      If [x] was already bound in [m], its previous binding disappears. *)

  val adjust : 'a t -> key -> ('a option -> 'a) -> 'a t
  (** [adjust acc k replace ] if not exist [add (replace None ], otherwise 
      [add k v (replace (Some old))]
  *)

  val singleton : key -> 'a -> 'a t

  val remove : 'a t -> key -> 'a t
  (** [remove x m] returns a map containing the same bindings as
      [m], except for [x] which is unbound in the returned map. *)

  (* val merge:
       'a t -> 'b t ->
       (key -> 'a option -> 'b option -> 'c option) ->  'c t *)
  (** [merge f m1 m2] computes a map whose keys is a subset of keys of [m1]
      and of [m2]. The presence of each such binding, and the corresponding
      value, is determined with the function [f].
      @since 3.12.0
  *)

  val disjoint_merge_exn : 'a t -> 'a t -> (key -> 'a -> 'a -> exn) -> 'a t
  (* merge two maps, will raise if they have the same key *)

  val iter : 'a t -> (key -> 'a -> unit) -> unit
  (** [iter f m] applies [f] to all bindings in map [m].
      The bindings are passed to [f] in increasing order. *)

  val fold : 'a t -> 'b -> (key -> 'a -> 'b -> 'b) -> 'b
  (** [fold f m a] computes [(f kN dN ... (f k1 d1 a)...)],
      where [k1 ... kN] are the keys of all bindings in [m]
      (in increasing order) *)

  val for_all : 'a t -> (key -> 'a -> bool) -> bool
  (** [for_all p m] checks if all the bindings of the map.
      order unspecified
  *)

  val exists : 'a t -> (key -> 'a -> bool) -> bool
  (** [exists p m] checks if at least one binding of the map
      satisfy the predicate [p]. 
      order unspecified
  *)

  (* val filter: 'a t -> (key -> 'a -> bool) -> 'a t *)
  (** [filter p m] returns the map with all the bindings in [m]
      that satisfy predicate [p].
      order unspecified
  *)

  (* val partition: 'a t -> (key -> 'a -> bool) ->  'a t * 'a t *)
  (** [partition p m] returns a pair of maps [(m1, m2)], where
      [m1] contains all the bindings of [s] that satisfy the
      predicate [p], and [m2] is the map with all the bindings of
      [s] that do not satisfy [p].
  *)

  val cardinal : 'a t -> int
  (** Return the number of bindings of a map. *)

  val bindings : 'a t -> (key * 'a) list
  (** Return the list of all bindings of the given map.
      The returned list is sorted in increasing order with respect
      to the ordering *)

  val keys : 'a t -> key list
  (* Increasing order *)

  (* val split: 'a t -> key -> 'a t * 'a option * 'a t *)
  (** [split x m] returns a triple [(l, data, r)], where
        [l] is the map with all the bindings of [m] whose key
      is strictly less than [x];
        [r] is the map with all the bindings of [m] whose key
      is strictly greater than [x];
        [data] is [None] if [m] contains no binding for [x],
        or [Some v] if [m] binds [v] to [x].
      @since 3.12.0
  *)

  val find_exn : 'a t -> key -> 'a
  (** [find x m] returns the current binding of [x] in [m],
      or raises [Not_found] if no such binding exists. *)

  val find_opt : 'a t -> key -> 'a option

  val find_default : 'a t -> key -> 'a -> 'a

  val map : 'a t -> ('a -> 'b) -> 'b t
  (** [map f m] returns a map with same domain as [m], where the
      associated value [a] of all bindings of [m] has been
      replaced by the result of the application of [f] to [a].
      The bindings are passed to [f] in increasing order
      with respect to the ordering over the type of the keys. *)

  val mapi : 'a t -> (key -> 'a -> 'b) -> 'b t
  (** Same as {!Map.S.map}, but the function receives as arguments both the
      key and the associated value for each binding of the map. *)

  val of_list : (key * 'a) list -> 'a t

  val of_array : (key * 'a) array -> 'a t

  val add_list : (key * 'b) list -> 'b t -> 'b t
end

end
module Map_string : sig 
#1 "map_string.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

include Map_gen.S with type key = string

end = struct
#1 "map_string.ml"

# 2 "ext/map.cppo.ml"
(* we don't create [map_poly], since some operations require raise an exception which carries [key] *)

# 5 "ext/map.cppo.ml"
type key = string 
let compare_key = Ext_string.compare
let [@inline] eq_key (x : key) y = x = y
    
# 19 "ext/map.cppo.ml"
    (* let [@inline] (=) (a : int) b = a = b *)
type + 'a t = (key,'a) Map_gen.t

let empty = Map_gen.empty 
let is_empty = Map_gen.is_empty
let iter = Map_gen.iter
let fold = Map_gen.fold
let for_all = Map_gen.for_all 
let exists = Map_gen.exists 
let singleton = Map_gen.singleton 
let cardinal = Map_gen.cardinal
let bindings = Map_gen.bindings
let to_sorted_array = Map_gen.to_sorted_array
let to_sorted_array_with_f = Map_gen.to_sorted_array_with_f
let keys = Map_gen.keys



let map = Map_gen.map 
let mapi = Map_gen.mapi
let bal = Map_gen.bal 
let height = Map_gen.height 


let rec add (tree : _ Map_gen.t as 'a) x data  : 'a = match tree with 
  | Empty ->
    singleton x data
  | Leaf {k;v} ->
    let c = compare_key x k in 
    if c = 0 then singleton x data else
    if c < 0 then 
      Map_gen.unsafe_two_elements x data k v 
    else 
      Map_gen.unsafe_two_elements k v x data  
  | Node {l; k ; v ; r; h} ->
    let c = compare_key x k in
    if c = 0 then
      Map_gen.unsafe_node x data l r h (* at least need update data *)
    else if c < 0 then
      bal (add l x data ) k v r
    else
      bal l k v (add r x data )


let rec adjust (tree : _ Map_gen.t as 'a) x replace  : 'a = 
  match tree with 
  | Empty ->
    singleton x (replace None)
  | Leaf {k ; v} -> 
    let c = compare_key x k in 
    if c = 0 then singleton x (replace (Some v)) else 
    if c < 0 then 
      Map_gen.unsafe_two_elements x (replace None) k v   
    else
      Map_gen.unsafe_two_elements k v x (replace None)   
  | Node ({l; k ; r} as tree) ->
    let c = compare_key x k in
    if c = 0 then
      Map_gen.unsafe_node x (replace  (Some tree.v)) l r tree.h
    else if c < 0 then
      bal (adjust l x  replace ) k tree.v r
    else
      bal l k tree.v (adjust r x  replace )


let rec find_exn (tree : _ Map_gen.t ) x = match tree with 
  | Empty ->
    raise Not_found
  | Leaf leaf -> 
    if eq_key x leaf.k then leaf.v else raise Not_found  
  | Node tree ->
    let c = compare_key x tree.k in
    if c = 0 then tree.v
    else find_exn (if c < 0 then tree.l else tree.r) x

let rec find_opt (tree : _ Map_gen.t ) x = match tree with 
  | Empty -> None 
  | Leaf leaf -> 
    if eq_key x leaf.k then Some leaf.v else None
  | Node tree ->
    let c = compare_key x tree.k in
    if c = 0 then Some tree.v
    else find_opt (if c < 0 then tree.l else tree.r) x

let rec find_default (tree : _ Map_gen.t ) x  default     = match tree with 
  | Empty -> default  
  | Leaf leaf -> 
    if eq_key x leaf.k then  leaf.v else default
  | Node tree ->
    let c = compare_key x tree.k in
    if c = 0 then tree.v
    else find_default (if c < 0 then tree.l else tree.r) x default

let rec mem (tree : _ Map_gen.t )  x= match tree with 
  | Empty ->
    false
  | Leaf leaf -> eq_key x leaf.k 
  | Node{l; k ;  r} ->
    let c = compare_key x k in
    c = 0 || mem (if c < 0 then l else r) x 

let rec remove (tree : _ Map_gen.t as 'a) x : 'a = match tree with 
  | Empty -> empty
  | Leaf leaf -> 
    if eq_key x leaf.k then empty 
    else tree
  | Node{l; k ; v; r} ->
    let c = compare_key x k in
    if c = 0 then
      Map_gen.merge l r
    else if c < 0 then
      bal (remove l x) k v r
    else
      bal l k v (remove r x )

type 'a split = 
  | Yes of {l : (key,'a) Map_gen.t; r : (key,'a)Map_gen.t ; v : 'a}
  | No of {l : (key,'a) Map_gen.t; r : (key,'a)Map_gen.t }


let rec split  (tree : (key,'a) Map_gen.t) x : 'a split  = 
  match tree with 
  | Empty ->
    No {l = empty; r = empty}
  | Leaf leaf -> 
    let c = compare_key x leaf.k in 
    if c = 0 then Yes {l = empty; v= leaf.v; r = empty} 
    else if c < 0 then No { l = empty; r = tree }
    else  No { l = tree; r = empty}
  | Node {l; k ; v ; r} ->
    let c = compare_key x k in
    if c = 0 then Yes {l; v; r}
    else if c < 0 then      
      match  split l x with 
      | Yes result -> Yes {result with r = Map_gen.join result.r k v r }
      | No result -> No {result with r = Map_gen.join result.r k v r } 
    else
      match split r x with 
      | Yes result -> 
        Yes {result with l = Map_gen.join l k v result.l}
      | No result -> 
        No {result with l = Map_gen.join l k v result.l}


let rec disjoint_merge_exn  
    (s1 : _ Map_gen.t) 
    (s2  : _ Map_gen.t) 
    fail : _ Map_gen.t =
  match s1 with
  | Empty -> s2  
  | Leaf ({k } as l1)  -> 
    begin match s2 with 
      | Empty -> s1 
      | Leaf l2 -> 
        let c = compare_key k l2.k in 
        if c = 0 then raise_notrace (fail k l1.v l2.v)
        else if c < 0 then Map_gen.unsafe_two_elements l1.k l1.v l2.k l2.v
        else Map_gen.unsafe_two_elements l2.k l2.v k l1.v
      | Node _ -> 
        adjust s2 k (fun data -> 
            match data with 
            |  None -> l1.v
            | Some s2v  -> raise_notrace (fail k l1.v s2v)
          )        
    end
  | Node ({k} as xs1) -> 
    if  xs1.h >= height s2 then
      begin match split s2 k with 
        | No {l; r} -> 
          Map_gen.join 
            (disjoint_merge_exn  xs1.l l fail)
            k 
            xs1.v 
            (disjoint_merge_exn xs1.r r fail)
        | Yes { v =  s2v} ->
          raise_notrace (fail k xs1.v s2v)
      end        
    else let [@warning "-8"] (Node ({k} as s2) : _ Map_gen.t)  = s2 in 
      begin match  split s1 k with 
        | No {l;  r} -> 
          Map_gen.join 
            (disjoint_merge_exn  l s2.l fail) k s2.v 
            (disjoint_merge_exn  r s2.r fail)
        | Yes { v = s1v} -> 
          raise_notrace (fail k s1v s2.v)
      end






let add_list (xs : _ list ) init = 
  Ext_list.fold_left xs init (fun  acc (k,v) -> add acc k v )

let of_list xs = add_list xs empty

let of_array xs = 
  Ext_array.fold_left xs empty (fun acc (k,v) -> add acc k v ) 

end
module Bsb_db : sig 
#1 "bsb_db.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** Store a file called [.bsbuild] that can be communicated 
    between [bsb.exe] and [bsb_helper.exe]. 
    [bsb.exe] stores such data which would be retrieved by 
    [bsb_helper.exe]. It is currently used to combine with 
    ocamldep to figure out which module->file it depends on
*)

type case = bool

type info =
  | Intf
  (* intemediate state *)
  | Impl
  | Impl_intf

type syntax_kind = Ml | Reason | Res

type module_info = {
  mutable info : info;
  dir : string;
  syntax_kind : syntax_kind;
  (* This is actually not stored in bsbuild meta info
     since creating .d file only emit .cmj/.cmi dependencies, so it does not
     need know which syntax it is written
  *)
  case : bool;
  name_sans_extension : string;
}

type map = module_info Map_string.t

type 'a cat = { mutable lib : 'a; mutable dev : 'a }

type t = map cat

(** store  the meta data indexed by {!Bsb_dir_index}
    {[
      0 --> lib group
        1 --> dev 1 group
                    .

    ]}
*)

end = struct
#1 "bsb_db.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type case = bool
(** true means upper case*)

type info =
  | Intf
  (* intemediate state *)
  | Impl
  | Impl_intf

type syntax_kind = Ml | Reason | Res

type module_info = {
  mutable info : info;
  dir : string;
  syntax_kind : syntax_kind;
  case : bool;
  name_sans_extension : string;
}

type map = module_info Map_string.t

type 'a cat = { mutable lib : 'a; mutable dev : 'a }

type t = map cat
(** indexed by the group *)

end
module Ext_pervasives : sig 
#1 "ext_pervasives.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** Extension to standard library [Pervavives] module, safe to open 
*)

external reraise : exn -> 'a = "%reraise"

val finally : 'a -> clean:('a -> unit) -> ('a -> 'b) -> 'b

(* val try_it : (unit -> 'a) ->  unit  *)

val with_file_as_chan : string -> (out_channel -> 'a) -> 'a

val max_int : int -> int -> int

val min_int : int -> int -> int

val max_int_option : int option -> int option -> int option

(* external id : 'a -> 'a = "%identity" *)

(** Copied from {!Btype.hash_variant}:
    need sync up and add test case
*)
(* val hash_variant : string -> int *)

(* val todo : string -> 'a *)

val nat_of_string_exn : string -> int

val parse_nat_of_string : string -> int ref -> int

end = struct
#1 "ext_pervasives.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

external reraise : exn -> 'a = "%reraise"

let finally v ~clean:action f =
  match f v with
  | exception e ->
      action v;
      reraise e
  | e ->
      action v;
      e

(* let try_it f  =
   try ignore (f ()) with _ -> () *)

let with_file_as_chan filename f =
  finally (open_out_bin filename) ~clean:close_out f

let max_int (x : int) y = if x >= y then x else y

let min_int (x : int) y = if x < y then x else y

let max_int_option (x : int option) y =
  match (x, y) with
  | None, _ -> y
  | Some _, None -> x
  | Some x0, Some y0 -> if x0 >= y0 then x else y

(* external id : 'a -> 'a = "%identity" *)

(*
   let hash_variant s =
     let accu = ref 0 in
     for i = 0 to String.length s - 1 do
       accu := 223 * !accu + Char.code s.[i]
     done;
     (* reduce to 31 bits *)
     accu := !accu land (1 lsl 31 - 1);
     (* make it signed for 64 bits architectures *)
     if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu *)

(* let todo loc =
   failwith (loc ^ " Not supported yet")
*)

let rec int_of_string_aux s acc off len =
  if off >= len then acc
  else
    let d = Char.code (String.unsafe_get s off) - 48 in
    if d >= 0 && d <= 9 then int_of_string_aux s ((10 * acc) + d) (off + 1) len
    else -1
(* error *)

let nat_of_string_exn (s : string) =
  let acc = int_of_string_aux s 0 0 (String.length s) in
  if acc < 0 then invalid_arg s else acc

(** return index *)
let parse_nat_of_string (s : string) (cursor : int ref) =
  let current = !cursor in
  assert (current >= 0);
  let acc = ref 0 in
  let s_len = String.length s in
  let todo = ref true in
  let cur = ref current in
  while !todo && !cursor < s_len do
    let d = Char.code (String.unsafe_get s !cur) - 48 in
    if d >= 0 && d <= 9 then (
      acc := (10 * !acc) + d;
      incr cur)
    else todo := false
  done;
  cursor := !cur;
  !acc

end
module Ext_io : sig 
#1 "ext_io.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val load_file : string -> string

val rev_lines_of_file : string -> string list

val rev_lines_of_chann : in_channel -> string list

val write_file : string -> string -> unit

end = struct
#1 "ext_io.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** on 32 bit , there are 16M limitation *)
let load_file f =
  Ext_pervasives.finally (open_in_bin f) ~clean:close_in (fun ic ->
      let n = in_channel_length ic in
      let s = Bytes.create n in
      really_input ic s 0 n;
      Bytes.unsafe_to_string s)

let rev_lines_of_chann chan =
  let rec loop acc chan =
    match input_line chan with
    | line -> loop (line :: acc) chan
    | exception End_of_file ->
        close_in chan;
        acc
  in
  loop [] chan

let rev_lines_of_file file =
  Ext_pervasives.finally ~clean:close_in (open_in_bin file) rev_lines_of_chann

let write_file f content =
  Ext_pervasives.finally ~clean:close_out (open_out_bin f) (fun oc ->
      output_string oc content)

end
module Ext_string_array : sig 
#1 "ext_string_array.mli"
(* Copyright (C) 2020 - Present Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val cmp : string -> string -> int

val find_sorted : string array -> string -> int option

val find_sorted_assoc : (string * 'a) array -> string -> 'a option

end = struct
#1 "ext_string_array.ml"
(* Copyright (C) 2020 - Present Hongbo Zhang, Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(* Invariant: the same as encoding Map_string.compare_key  *)
let cmp = Ext_string.compare

let rec binarySearchAux (arr : string array) (lo : int) (hi : int)
    (key : string) : _ option =
  let mid = (lo + hi) / 2 in
  let midVal = Array.unsafe_get arr mid in
  let c = cmp key midVal in
  if c = 0 then Some mid
  else if c < 0 then
    (*  a[lo] =< key < a[mid] <= a[hi] *)
    if hi = mid then
      let loVal = Array.unsafe_get arr lo in
      if loVal = key then Some lo else None
    else binarySearchAux arr lo mid key
  else if (*  a[lo] =< a[mid] < key <= a[hi] *)
          lo = mid then
    let hiVal = Array.unsafe_get arr hi in
    if hiVal = key then Some hi else None
  else binarySearchAux arr mid hi key

let find_sorted sorted key : int option =
  let len = Array.length sorted in
  if len = 0 then None
  else
    let lo = Array.unsafe_get sorted 0 in
    let c = cmp key lo in
    if c < 0 then None
    else
      let hi = Array.unsafe_get sorted (len - 1) in
      let c2 = cmp key hi in
      if c2 > 0 then None else binarySearchAux sorted 0 (len - 1) key

let rec binarySearchAssoc (arr : (string * _) array) (lo : int) (hi : int)
    (key : string) : _ option =
  let mid = (lo + hi) / 2 in
  let midVal = Array.unsafe_get arr mid in
  let c = cmp key (fst midVal) in
  if c = 0 then Some (snd midVal)
  else if c < 0 then
    (*  a[lo] =< key < a[mid] <= a[hi] *)
    if hi = mid then
      let loVal = Array.unsafe_get arr lo in
      if fst loVal = key then Some (snd loVal) else None
    else binarySearchAssoc arr lo mid key
  else if (*  a[lo] =< a[mid] < key <= a[hi] *)
          lo = mid then
    let hiVal = Array.unsafe_get arr hi in
    if fst hiVal = key then Some (snd hiVal) else None
  else binarySearchAssoc arr mid hi key

let find_sorted_assoc (type a) (sorted : (string * a) array) (key : string) :
    a option =
  let len = Array.length sorted in
  if len = 0 then None
  else
    let lo = Array.unsafe_get sorted 0 in
    let c = cmp key (fst lo) in
    if c < 0 then None
    else
      let hi = Array.unsafe_get sorted (len - 1) in
      let c2 = cmp key (fst hi) in
      if c2 > 0 then None else binarySearchAssoc sorted 0 (len - 1) key

end
module Literals
= struct
#1 "literals.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let js_array_ctor = "Array"

let js_type_number = "number"

let js_type_string = "string"

let js_type_object = "object"

let js_type_boolean = "boolean"

let js_undefined = "undefined"

let js_prop_length = "length"

let prim = "prim"

let param = "param"

let partial_arg = "partial_arg"

let tmp = "tmp"

let create = "create" (* {!Caml_exceptions.create}*)

let runtime = "runtime" (* runtime directory *)

let stdlib = "stdlib"

let imul = "imul" (* signed int32 mul *)

let setter_suffix = "#="

let setter_suffix_len = String.length setter_suffix

let debugger = "debugger"

let fn_run = "fn_run"

let method_run = "method_run"

let fn_method = "fn_method"

let fn_mk = "fn_mk"
(*let js_fn_runmethod = "js_fn_runmethod"*)

(** nodejs *)
let node_modules = "node_modules"

let node_modules_length = String.length "node_modules"

let package_json = "package.json"

let bsconfig_json = "bsconfig.json"

let build_ninja = "build.ninja"

(* Name of the library file created for each external dependency. *)
let library_file = "lib"

let suffix_a = ".a"

let suffix_cmj = ".cmj"

let suffix_cmo = ".cmo"

let suffix_cma = ".cma"

let suffix_cmi = ".cmi"

let suffix_cmx = ".cmx"

let suffix_cmxa = ".cmxa"

let suffix_mll = ".mll"

let suffix_ml = ".ml"

let suffix_mli = ".mli"

let suffix_re = ".re"

let suffix_rei = ".rei"

let suffix_res = ".res"

let suffix_resi = ".resi"

let suffix_mlmap = ".mlmap"

let suffix_cmt = ".cmt"

let suffix_cmti = ".cmti"

let suffix_ast = ".ast"

let suffix_iast = ".iast"

let suffix_d = ".d"

let suffix_js = ".js"

let suffix_bs_js = ".bs.js"

let suffix_mjs = ".mjs"

let suffix_cjs = ".cjs"

let suffix_gen_js = ".gen.js"

let suffix_gen_tsx = ".gen.tsx"

let commonjs = "commonjs"

let es6 = "es6"

let es6_global = "es6-global"

let unused_attribute = "Unused attribute "

(** Used when produce node compatible paths *)
let node_sep = "/"

let node_parent = ".."

let node_current = "."

let gentype_import = "genType.import"

let bsbuild_cache = ".bsbuild"

let sourcedirs_meta = ".sourcedirs.json"

(* Note the build system should check the validity of filenames
   espeically, it should not contain '-'
*)
let ns_sep_char = '-'

let ns_sep = "-"

let exception_id = "RE_EXN_ID"

let polyvar_hash = "NAME"

let polyvar_value = "VAL"

let cons = "::"

let hd = "hd"

let tl = "tl"

let lazy_done = "LAZY_DONE"

let lazy_val = "VAL"

let pure = "@__PURE__"

end
module Bsb_db_decode : sig 
#1 "bsb_db_decode.mli"
(* Copyright (C) 2019 - Present Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type group = private
  | Dummy
  | Group of {
      modules : string array;
      dir_length : int;
      dir_info_offset : int;
      module_info_offset : int;
    }

type t = {
  lib : group;
  dev : group;
  content : string; (* string is whole content*)
}

val read_build_cache : dir:string -> t

type module_info = { case : bool; (* Bsb_db.case*) dir_name : string }

val find :
  t ->
  (* contains global info *)
  string ->
  (* module name *)
  bool ->
  (* more likely to be zero *)
  module_info option

val decode : string -> t

end = struct
#1 "bsb_db_decode.ml"
(* Copyright (C) 2019 - Present Hongbo Zhang, Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let bsbuild_cache = Literals.bsbuild_cache

type group =
  | Dummy
  | Group of {
      modules : string array;
      dir_length : int;
      dir_info_offset : int;
      module_info_offset : int;
    }

type t = {
  lib : group;
  dev : group;
  content : string; (* string is whole content*)
}

type cursor = int ref

(*TODO: special case when module_count is zero *)
let rec decode (x : string) : t =
  let (offset : cursor) = ref 0 in
  let lib = decode_single x offset in
  let dev = decode_single x offset in
  { lib; dev; content = x }

and decode_single (x : string) (offset : cursor) : group =
  let module_number = Ext_pervasives.parse_nat_of_string x offset in
  incr offset;
  if module_number <> 0 then (
    let modules = decode_modules x offset module_number in
    let dir_info_offset = !offset in
    let module_info_offset = String.index_from x dir_info_offset '\n' + 1 in
    let dir_length = Char.code x.[module_info_offset] - 48 (* Char.code '0'*) in
    offset := module_info_offset + 1 + (dir_length * module_number) + 1;
    Group { modules; dir_info_offset; module_info_offset; dir_length })
  else Dummy

and decode_modules (x : string) (offset : cursor) module_number : string array =
  let result = Array.make module_number "" in
  let last = ref !offset in
  let cur = ref !offset in
  let tasks = ref 0 in
  while !tasks <> module_number do
    if String.unsafe_get x !cur = '\n' then (
      let offs = !last in
      let len = !cur - !last in
      Array.unsafe_set result !tasks (Ext_string.unsafe_sub x offs len);
      incr tasks;
      last := !cur + 1);
    incr cur
  done;
  offset := !cur;
  result

(* TODO: shall we check the consistency of digest *)
let read_build_cache ~dir : t =
  let all_content = Ext_io.load_file (Filename.concat dir bsbuild_cache) in
  decode all_content

type module_info = { case : bool; (* which is Bsb_db.case*)
                                  dir_name : string }

let find_opt ({ content = whole } as db : t) lib (key : string) :
    module_info option =
  match if lib then db.lib else db.dev with
  | Dummy -> None
  | Group ({ modules } as group) -> (
      let i = Ext_string_array.find_sorted modules key in
      match i with
      | None -> None
      | Some count ->
          let encode_len = group.dir_length in
          let index =
            Ext_string.get_1_2_3_4 whole
              ~off:(group.module_info_offset + 1 + (count * encode_len))
              encode_len
          in
          let case = not (index mod 2 = 0) in
          let ith = index lsr 1 in
          let dir_name_start =
            if ith = 0 then group.dir_info_offset
            else Ext_string.index_count whole group.dir_info_offset '\t' ith + 1
          in
          let dir_name_finish = String.index_from whole dir_name_start '\t' in
          Some
            {
              case;
              dir_name =
                String.sub whole dir_name_start
                  (dir_name_finish - dir_name_start);
            })

let find db dependent_module is_not_lib_dir =
  let opt = find_opt db true dependent_module in
  match opt with
  | Some _ -> opt
  | None -> if is_not_lib_dir then find_opt db false dependent_module else None

end
module Ext_buffer : sig 
#1 "ext_buffer.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*  Pierre Weis and Xavier Leroy, projet Cristal, INRIA Rocquencourt   *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the GNU Library General Public License, with    *)
(*  the special exception on linking described in file ../LICENSE.     *)
(*                                                                     *)
(***********************************************************************)

(** Extensible buffers.

    This module implements buffers that automatically expand
    as necessary.  It provides accumulative concatenation of strings
    in quasi-linear time (instead of quadratic time when strings are
    concatenated pairwise).
*)

(* ReScript customization: customized for efficient digest *)

type t
(** The abstract type of buffers. *)

val create : int -> t
(** [create n] returns a fresh buffer, initially empty.
    The [n] parameter is the initial size of the internal byte sequence
    that holds the buffer contents. That byte sequence is automatically
    reallocated when more than [n] characters are stored in the buffer,
    but shrinks back to [n] characters when [reset] is called.
    For best performance, [n] should be of the same order of magnitude
    as the number of characters that are expected to be stored in
    the buffer (for instance, 80 for a buffer that holds one output
    line).  Nothing bad will happen if the buffer grows beyond that
    limit, however. In doubt, take [n = 16] for instance.
    If [n] is not between 1 and {!Sys.max_string_length}, it will
    be clipped to that interval. *)

val contents : t -> string
(** Return a copy of the current contents of the buffer.
    The buffer itself is unchanged. *)

val length : t -> int
(** Return the number of characters currently contained in the buffer. *)

val is_empty : t -> bool

val clear : t -> unit
(** Empty the buffer. *)

val add_char : t -> char -> unit
  [@@inline]
(** [add_char b c] appends the character [c] at the end of the buffer [b]. *)

val add_string : t -> string -> unit
(** [add_string b s] appends the string [s] at the end of the buffer [b]. *)

(* val add_bytes : t -> bytes -> unit *)
(** [add_string b s] appends the string [s] at the end of the buffer [b].
    @since 4.02 *)

(* val add_substring : t -> string -> int -> int -> unit *)
(** [add_substring b s ofs len] takes [len] characters from offset
    [ofs] in string [s] and appends them at the end of the buffer [b]. *)

(* val add_subbytes : t -> bytes -> int -> int -> unit *)
(** [add_substring b s ofs len] takes [len] characters from offset
    [ofs] in byte sequence [s] and appends them at the end of the buffer [b].
    @since 4.02 *)

(* val add_buffer : t -> t -> unit *)
(** [add_buffer b1 b2] appends the current contents of buffer [b2]
    at the end of buffer [b1].  [b2] is not modified. *)

(* val add_channel : t -> in_channel -> int -> unit *)
(** [add_channel b ic n] reads exactly [n] character from the
    input channel [ic] and stores them at the end of buffer [b].
    Raise [End_of_file] if the channel contains fewer than [n]
    characters. *)

val output_buffer : out_channel -> t -> unit
(** [output_buffer oc b] writes the current contents of buffer [b]
    on the output channel [oc]. *)

val digest : t -> Digest.t

val not_equal : t -> string -> bool

val add_int_1 : t -> int -> unit

val add_int_2 : t -> int -> unit

val add_int_3 : t -> int -> unit

val add_int_4 : t -> int -> unit

val add_string_char : t -> string -> char -> unit

val add_ninja_prefix_var : t -> string -> unit

val add_char_string : t -> char -> string -> unit

end = struct
#1 "ext_buffer.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*    Pierre Weis and Xavier Leroy, projet Cristal, INRIA Rocquencourt    *)
(*                                                                        *)
(*   Copyright 1999 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Extensible buffers *)

type t = {
  mutable buffer : bytes;
  mutable position : int;
  mutable length : int;
}

let create n =
  let n = if n < 1 then 1 else n in
  let s = Bytes.create n in
  { buffer = s; position = 0; length = n }

let contents b = Bytes.sub_string b.buffer 0 b.position
(* let to_bytes b = Bytes.sub b.buffer 0 b.position  *)

(* let sub b ofs len =
   if ofs < 0 || len < 0 || ofs > b.position - len
   then invalid_arg "Ext_buffer.sub"
   else Bytes.sub_string b.buffer ofs len *)

(* let blit src srcoff dst dstoff len =
   if len < 0 || srcoff < 0 || srcoff > src.position - len
             || dstoff < 0 || dstoff > (Bytes.length dst) - len
   then invalid_arg "Ext_buffer.blit"
   else
    Bytes.unsafe_blit src.buffer srcoff dst dstoff len *)

let length b = b.position

let is_empty b = b.position = 0

let clear b = b.position <- 0

(* let reset b =
   b.position <- 0; b.buffer <- b.initial_buffer;
   b.length <- Bytes.length b.buffer *)

let resize b more =
  let len = b.length in
  let new_len = ref len in
  while b.position + more > !new_len do
    new_len := 2 * !new_len
  done;
  let new_buffer = Bytes.create !new_len in
  (* PR#6148: let's keep using [blit] rather than [unsafe_blit] in
     this tricky function that is slow anyway. *)
  Bytes.blit b.buffer 0 new_buffer 0 b.position;
  b.buffer <- new_buffer;
  b.length <- !new_len;
  assert (b.position + more <= b.length)

let[@inline] add_char b c =
  let pos = b.position in
  if pos >= b.length then resize b 1;
  Bytes.unsafe_set b.buffer pos c;
  b.position <- pos + 1

(* let add_substring b s offset len =
   if offset < 0 || len < 0 || offset > String.length s - len
   then invalid_arg "Ext_buffer.add_substring/add_subbytes";
   let new_position = b.position + len in
   if new_position > b.length then resize b len;
   Ext_bytes.unsafe_blit_string s offset b.buffer b.position len;
   b.position <- new_position *)

(* let add_subbytes b s offset len =
   add_substring b (Bytes.unsafe_to_string s) offset len *)

let add_string b s =
  let len = String.length s in
  let new_position = b.position + len in
  if new_position > b.length then resize b len;
  Ext_bytes.unsafe_blit_string s 0 b.buffer b.position len;
  b.position <- new_position

(* TODO: micro-optimzie *)
let add_string_char b s c =
  let s_len = String.length s in
  let len = s_len + 1 in
  let new_position = b.position + len in
  if new_position > b.length then resize b len;
  let b_buffer = b.buffer in
  Ext_bytes.unsafe_blit_string s 0 b_buffer b.position s_len;
  Bytes.unsafe_set b_buffer (new_position - 1) c;
  b.position <- new_position

let add_char_string b c s =
  let s_len = String.length s in
  let len = s_len + 1 in
  let new_position = b.position + len in
  if new_position > b.length then resize b len;
  let b_buffer = b.buffer in
  let b_position = b.position in
  Bytes.unsafe_set b_buffer b_position c;
  Ext_bytes.unsafe_blit_string s 0 b_buffer (b_position + 1) s_len;
  b.position <- new_position

(* equivalent to add_char " "; add_char "$"; add_string s  *)
let add_ninja_prefix_var b s =
  let s_len = String.length s in
  let len = s_len + 2 in
  let new_position = b.position + len in
  if new_position > b.length then resize b len;
  let b_buffer = b.buffer in
  let b_position = b.position in
  Bytes.unsafe_set b_buffer b_position ' ';
  Bytes.unsafe_set b_buffer (b_position + 1) '$';
  Ext_bytes.unsafe_blit_string s 0 b_buffer (b_position + 2) s_len;
  b.position <- new_position

(* let add_bytes b s = add_string b (Bytes.unsafe_to_string s)

   let add_buffer b bs =
   add_subbytes b bs.buffer 0 bs.position *)

(* let add_channel b ic len =
   if len < 0
    || len > Sys.max_string_length
    then   (* PR#5004 *)
    invalid_arg "Ext_buffer.add_channel";
   if b.position + len > b.length then resize b len;
   really_input ic b.buffer b.position len;
   b.position <- b.position + len *)

let output_buffer oc b = output oc b.buffer 0 b.position

external unsafe_string : bytes -> int -> int -> Digest.t = "caml_md5_string"

let digest b = unsafe_string b.buffer 0 b.position

let rec not_equal_aux (b : bytes) (s : string) i len =
  if i >= len then false
  else
    Bytes.unsafe_get b i <> String.unsafe_get s i
    || not_equal_aux b s (i + 1) len

(** avoid a large copy *)
let not_equal (b : t) (s : string) =
  let b_len = b.position in
  let s_len = String.length s in
  b_len <> s_len || not_equal_aux b.buffer s 0 s_len

(**
   It could be one byte, two bytes, three bytes and four bytes 
   TODO: inline for better performance
*)
let add_int_1 (b : t) (x : int) =
  let c = Char.unsafe_chr (x land 0xff) in
  let pos = b.position in
  if pos >= b.length then resize b 1;
  Bytes.unsafe_set b.buffer pos c;
  b.position <- pos + 1

let add_int_2 (b : t) (x : int) =
  let c1 = Char.unsafe_chr (x land 0xff) in
  let c2 = Char.unsafe_chr ((x lsr 8) land 0xff) in
  let pos = b.position in
  if pos + 1 >= b.length then resize b 2;
  let b_buffer = b.buffer in
  Bytes.unsafe_set b_buffer pos c1;
  Bytes.unsafe_set b_buffer (pos + 1) c2;
  b.position <- pos + 2

let add_int_3 (b : t) (x : int) =
  let c1 = Char.unsafe_chr (x land 0xff) in
  let c2 = Char.unsafe_chr ((x lsr 8) land 0xff) in
  let c3 = Char.unsafe_chr ((x lsr 16) land 0xff) in
  let pos = b.position in
  if pos + 2 >= b.length then resize b 3;
  let b_buffer = b.buffer in
  Bytes.unsafe_set b_buffer pos c1;
  Bytes.unsafe_set b_buffer (pos + 1) c2;
  Bytes.unsafe_set b_buffer (pos + 2) c3;
  b.position <- pos + 3

let add_int_4 (b : t) (x : int) =
  let c1 = Char.unsafe_chr (x land 0xff) in
  let c2 = Char.unsafe_chr ((x lsr 8) land 0xff) in
  let c3 = Char.unsafe_chr ((x lsr 16) land 0xff) in
  let c4 = Char.unsafe_chr ((x lsr 24) land 0xff) in
  let pos = b.position in
  if pos + 3 >= b.length then resize b 4;
  let b_buffer = b.buffer in
  Bytes.unsafe_set b_buffer pos c1;
  Bytes.unsafe_set b_buffer (pos + 1) c2;
  Bytes.unsafe_set b_buffer (pos + 2) c3;
  Bytes.unsafe_set b_buffer (pos + 3) c4;
  b.position <- pos + 4

end
module Bs_hash_stubs
= struct
#1 "bs_hash_stubs.pp.ml"


external hash_string :  string -> int = "caml_bs_hash_string" [@@noalloc];;

external hash_string_int :  string -> int  -> int = "caml_bs_hash_string_and_int" [@@noalloc];;

external hash_string_small_int :  string -> int  -> int = "caml_bs_hash_string_and_small_int" [@@noalloc];;

external hash_stamp_and_name : int -> string -> int = "caml_bs_hash_stamp_and_name" [@@noalloc];;

external hash_small_int : int -> int = "caml_bs_hash_small_int" [@@noalloc];;

external hash_int :  int  -> int = "caml_bs_hash_int" [@@noalloc];;

external string_length_based_compare : string -> string -> int  = "caml_string_length_based_compare" [@@noalloc];;

external    
  int_unsafe_blit : 
  int array -> int -> int array -> int -> int -> unit = "caml_int_array_blit" [@@noalloc];;

external set_as_old_file : string -> unit = "caml_stale_file"




end
module Ext_util : sig 
#1 "ext_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val power_2_above : int -> int -> int

val stats_to_string : Hashtbl.statistics -> string

end = struct
#1 "ext_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(**
   {[
     (power_2_above 16 63 = 64)
       (power_2_above 16 76 = 128)
   ]}
*)
let rec power_2_above x n =
  if x >= n then x
  else if x * 2 > Sys.max_array_length then x
  else power_2_above (x * 2) n

let stats_to_string
    ({ num_bindings; num_buckets; max_bucket_length; bucket_histogram } :
      Hashtbl.statistics) =
  Printf.sprintf "bindings: %d,buckets: %d, longest: %d, hist:[%s]" num_bindings
    num_buckets max_bucket_length
    (String.concat ","
       (Array.to_list (Array.map string_of_int bucket_histogram)))

end
module Hash_gen
= struct
#1 "hash_gen.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the GNU Library General Public License, with    *)
(*  the special exception on linking described in file ../LICENSE.     *)
(*                                                                     *)
(***********************************************************************)

(* Hash tables *)

(* We do dynamic hashing, and resize the table and rehash the elements
   when buckets become too long. *)

type ('a, 'b) bucket =
  | Empty
  | Cons of {
      mutable key : 'a;
      mutable data : 'b;
      mutable next : ('a, 'b) bucket;
    }

type ('a, 'b) t = {
  mutable size : int;
  (* number of entries *)
  mutable data : ('a, 'b) bucket array;
  (* the buckets *)
  initial_size : int; (* initial array size *)
}

let create initial_size =
  let s = Ext_util.power_2_above 16 initial_size in
  { initial_size = s; size = 0; data = Array.make s Empty }

let clear h =
  h.size <- 0;
  let len = Array.length h.data in
  for i = 0 to len - 1 do
    Array.unsafe_set h.data i Empty
  done

let reset h =
  h.size <- 0;
  h.data <- Array.make h.initial_size Empty

let length h = h.size

let resize indexfun h =
  let odata = h.data in
  let osize = Array.length odata in
  let nsize = osize * 2 in
  if nsize < Sys.max_array_length then (
    let ndata = Array.make nsize Empty in
    let ndata_tail = Array.make nsize Empty in
    h.data <- ndata;
    (* so that indexfun sees the new bucket count *)
    let rec insert_bucket = function
      | Empty -> ()
      | Cons { key; next } as cell ->
          let nidx = indexfun h key in
          (match Array.unsafe_get ndata_tail nidx with
          | Empty -> Array.unsafe_set ndata nidx cell
          | Cons tail -> tail.next <- cell);
          Array.unsafe_set ndata_tail nidx cell;
          insert_bucket next
    in
    for i = 0 to osize - 1 do
      insert_bucket (Array.unsafe_get odata i)
    done;
    for i = 0 to nsize - 1 do
      match Array.unsafe_get ndata_tail i with
      | Empty -> ()
      | Cons tail -> tail.next <- Empty
    done)

let iter h f =
  let rec do_bucket = function
    | Empty -> ()
    | Cons l ->
        f l.key l.data;
        do_bucket l.next
  in
  let d = h.data in
  for i = 0 to Array.length d - 1 do
    do_bucket (Array.unsafe_get d i)
  done

let fold h init f =
  let rec do_bucket b accu =
    match b with
    | Empty -> accu
    | Cons l -> do_bucket l.next (f l.key l.data accu)
  in
  let d = h.data in
  let accu = ref init in
  for i = 0 to Array.length d - 1 do
    accu := do_bucket (Array.unsafe_get d i) !accu
  done;
  !accu

let to_list h f = fold h [] (fun k data acc -> f k data :: acc)

let rec small_bucket_mem (lst : _ bucket) eq key =
  match lst with
  | Empty -> false
  | Cons lst -> (
      eq key lst.key
      ||
      match lst.next with
      | Empty -> false
      | Cons lst -> (
          eq key lst.key
          ||
          match lst.next with
          | Empty -> false
          | Cons lst -> eq key lst.key || small_bucket_mem lst.next eq key))

let rec small_bucket_opt eq key (lst : _ bucket) : _ option =
  match lst with
  | Empty -> None
  | Cons lst -> (
      if eq key lst.key then Some lst.data
      else
        match lst.next with
        | Empty -> None
        | Cons lst -> (
            if eq key lst.key then Some lst.data
            else
              match lst.next with
              | Empty -> None
              | Cons lst ->
                  if eq key lst.key then Some lst.data
                  else small_bucket_opt eq key lst.next))

let rec small_bucket_key_opt eq key (lst : _ bucket) : _ option =
  match lst with
  | Empty -> None
  | Cons { key = k; next } -> (
      if eq key k then Some k
      else
        match next with
        | Empty -> None
        | Cons { key = k; next } -> (
            if eq key k then Some k
            else
              match next with
              | Empty -> None
              | Cons { key = k; next } ->
                  if eq key k then Some k else small_bucket_key_opt eq key next)
      )

let rec small_bucket_default eq key default (lst : _ bucket) =
  match lst with
  | Empty -> default
  | Cons lst -> (
      if eq key lst.key then lst.data
      else
        match lst.next with
        | Empty -> default
        | Cons lst -> (
            if eq key lst.key then lst.data
            else
              match lst.next with
              | Empty -> default
              | Cons lst ->
                  if eq key lst.key then lst.data
                  else small_bucket_default eq key default lst.next))

let rec remove_bucket h (i : int) key ~(prec : _ bucket) (buck : _ bucket)
    eq_key =
  match buck with
  | Empty -> ()
  | Cons { key = k; next } ->
      if eq_key k key then (
        h.size <- h.size - 1;
        match prec with
        | Empty -> Array.unsafe_set h.data i next
        | Cons c -> c.next <- next)
      else remove_bucket h i key ~prec:buck next eq_key

let rec replace_bucket key data (buck : _ bucket) eq_key =
  match buck with
  | Empty -> true
  | Cons slot ->
      if eq_key slot.key key then (
        slot.key <- key;
        slot.data <- data;
        false)
      else replace_bucket key data slot.next eq_key

module type S = sig
  type key

  type 'a t

  val create : int -> 'a t

  val clear : 'a t -> unit

  val reset : 'a t -> unit

  val add : 'a t -> key -> 'a -> unit

  val add_or_update : 'a t -> key -> update:('a -> 'a) -> 'a -> unit

  val remove : 'a t -> key -> unit

  val find_exn : 'a t -> key -> 'a

  val find_all : 'a t -> key -> 'a list

  val find_opt : 'a t -> key -> 'a option

  val find_key_opt : 'a t -> key -> key option
  (** return the key found in the hashtbl.
      Use case: when you find the key existed in hashtbl, 
      you want to use the one stored in the hashtbl. 
      (they are semantically equivlanent, but may have other information different) 
  *)

  val find_default : 'a t -> key -> 'a -> 'a

  val replace : 'a t -> key -> 'a -> unit

  val mem : 'a t -> key -> bool

  val iter : 'a t -> (key -> 'a -> unit) -> unit

  val fold : 'a t -> 'b -> (key -> 'a -> 'b -> 'b) -> 'b

  val length : 'a t -> int

  (* val stats: 'a t -> Hashtbl.statistics *)
  val to_list : 'a t -> (key -> 'a -> 'c) -> 'c list

  val of_list2 : key list -> 'a list -> 'a t
end

end
module Hash_string : sig 
#1 "hash_string.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

include Hash_gen.S with type key = string

end = struct
#1 "hash_string.ml"
# 9 "ext/hash.cppo.ml"
type key = string
type 'a t = (key, 'a)  Hash_gen.t 
let key_index (h : _ t ) (key : key) =
  (Bs_hash_stubs.hash_string  key ) land (Array.length h.data - 1)
let eq_key = Ext_string.equal 

  
# 33 "ext/hash.cppo.ml"
  type ('a, 'b) bucket = ('a,'b) Hash_gen.bucket
  let create = Hash_gen.create
  let clear = Hash_gen.clear
  let reset = Hash_gen.reset
  let iter = Hash_gen.iter
  let to_list = Hash_gen.to_list
  let fold = Hash_gen.fold
  let length = Hash_gen.length
  (* let stats = Hash_gen.stats *)



  let add (h : _ t) key data =
    let i = key_index h key in
    let h_data = h.data in   
    Array.unsafe_set h_data i (Cons{key; data; next=Array.unsafe_get h_data i});
    h.size <- h.size + 1;
    if h.size > Array.length h_data lsl 1 then Hash_gen.resize key_index h

  (* after upgrade to 4.04 we should provide an efficient [replace_or_init] *)
  let add_or_update 
      (h : 'a t) 
      (key : key) 
      ~update:(modf : 'a -> 'a) 
      (default :  'a) : unit =
    let rec find_bucket (bucketlist : _ bucket) : bool =
      match bucketlist with
      | Cons rhs  ->
        if eq_key rhs.key key then begin rhs.data <- modf rhs.data; false end
        else find_bucket rhs.next
      | Empty -> true in
    let i = key_index h key in 
    let h_data = h.data in 
    if find_bucket (Array.unsafe_get h_data i) then
      begin 
        Array.unsafe_set h_data i  (Cons{key; data=default; next = Array.unsafe_get h_data i});
        h.size <- h.size + 1 ;
        if h.size > Array.length h_data lsl 1 then Hash_gen.resize key_index h 
      end

  let remove (h : _ t ) key =
    let i = key_index h key in
    let h_data = h.data in 
    Hash_gen.remove_bucket h i key ~prec:Empty (Array.unsafe_get h_data i) eq_key

  (* for short bucket list, [find_rec is not called ] *)
  let rec find_rec key (bucketlist : _ bucket) = match bucketlist with  
    | Empty ->
      raise Not_found
    | Cons rhs  ->
      if eq_key key rhs.key then rhs.data else find_rec key rhs.next

  let find_exn (h : _ t) key =
    match Array.unsafe_get h.data (key_index h key) with
    | Empty -> raise Not_found
    | Cons rhs  ->
      if eq_key key rhs.key then rhs.data else
        match rhs.next with
        | Empty -> raise Not_found
        | Cons rhs  ->
          if eq_key key rhs.key then rhs.data else
            match rhs.next with
            | Empty -> raise Not_found
            | Cons rhs ->
              if eq_key key rhs.key  then rhs.data else find_rec key rhs.next

  let find_opt (h : _ t) key =
    Hash_gen.small_bucket_opt eq_key key (Array.unsafe_get h.data (key_index h key))

  let find_key_opt (h : _ t) key =
    Hash_gen.small_bucket_key_opt eq_key key (Array.unsafe_get h.data (key_index h key))

  let find_default (h : _ t) key default = 
    Hash_gen.small_bucket_default eq_key key default (Array.unsafe_get h.data (key_index h key))

  let find_all (h : _ t) key =
    let rec find_in_bucket (bucketlist : _ bucket) = match bucketlist with 
      | Empty ->
        []
      | Cons rhs  ->
        if eq_key key rhs.key
        then rhs.data :: find_in_bucket rhs.next
        else find_in_bucket rhs.next in
    find_in_bucket (Array.unsafe_get h.data (key_index h key))


  let replace h key data =
    let i = key_index h key in
    let h_data = h.data in 
    let l = Array.unsafe_get h_data i in
    if Hash_gen.replace_bucket key data l eq_key then 
      begin 
        Array.unsafe_set h_data i (Cons{key; data; next=l});
        h.size <- h.size + 1;
        if h.size > Array.length h_data lsl 1 then Hash_gen.resize key_index h;
      end 

  let mem (h : _ t) key = 
    Hash_gen.small_bucket_mem 
      (Array.unsafe_get h.data (key_index h key))
      eq_key key 


  let of_list2 ks vs = 
    let len = List.length ks in 
    let map = create len in 
    List.iter2 (fun k v -> add map k v) ks vs ; 
    map


end
module Bsb_db_encode : sig 
#1 "bsb_db_encode.mli"
(* Copyright (C) 2019 - Present Hongbo Zhang, Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val encode : Bsb_db.t -> Ext_buffer.t -> unit

val write_build_cache : dir:string -> Bsb_db.t -> string

end = struct
#1 "bsb_db_encode.ml"
(* Copyright (C) 2019 - Present Hongbo Zhang, Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let bsbuild_cache = Literals.bsbuild_cache

let nl buf = Ext_buffer.add_char buf '\n'

(* IDEAS:
   Pros:
   - could be even shortened to a single byte
     Cons:
   - decode would allocate
   - code too verbose
   - not readable
*)

let make_encoding length buf : Ext_buffer.t -> int -> unit =
  let max_range = (length lsl 1) + 1 in
  if max_range <= 0xff then (
    Ext_buffer.add_char buf '1';
    Ext_buffer.add_int_1)
  else if max_range <= 0xff_ff then (
    Ext_buffer.add_char buf '2';
    Ext_buffer.add_int_2)
  else if length <= 0x7f_ff_ff then (
    Ext_buffer.add_char buf '3';
    Ext_buffer.add_int_3)
  else if length <= 0x7f_ff_ff_ff then (
    Ext_buffer.add_char buf '4';
    Ext_buffer.add_int_4)
  else assert false

(* Make sure [tmp_buf1] and [tmp_buf2] is cleared ,
   they are only used to control the order.
   Strictly speaking, [tmp_buf1] is not needed
*)
let encode_single (db : Bsb_db.map) (buf : Ext_buffer.t) =
  (* module name section *)
  let len = Map_string.cardinal db in
  Ext_buffer.add_string_char buf (string_of_int len) '\n';
  if len <> 0 then (
    let mapping = Hash_string.create 50 in
    Map_string.iter db (fun name { dir } ->
        Ext_buffer.add_string_char buf name '\n';
        if not (Hash_string.mem mapping dir) then
          Hash_string.add mapping dir (Hash_string.length mapping));
    let length = Hash_string.length mapping in
    let rev_mapping = Array.make length "" in
    Hash_string.iter mapping (fun k i -> Array.unsafe_set rev_mapping i k);
    (* directory name section *)
    Ext_array.iter rev_mapping (fun s -> Ext_buffer.add_string_char buf s '\t');
    nl buf;
    (* module name info section *)
    let len_encoding = make_encoding length buf in
    Map_string.iter db (fun _ module_info ->
        len_encoding buf
          ((Hash_string.find_exn mapping module_info.dir lsl 1)
          + (Obj.magic (module_info.case : bool) : int)));
    nl buf)

let encode (dbs : Bsb_db.t) buf =
  encode_single dbs.lib buf;
  encode_single dbs.dev buf

(* shall we avoid writing such file (checking the digest)?
   It is expensive to start scanning the whole code base,
   we should we avoid it in the first place, if we do start scanning,
   this operation seems affordable
*)
let write_build_cache ~dir (bs_files : Bsb_db.t) : string =
  let oc = open_out_bin (Filename.concat dir bsbuild_cache) in
  let buf = Ext_buffer.create 100_000 in
  encode bs_files buf;
  Ext_buffer.output_buffer oc buf;
  close_out oc;
  let digest = Ext_buffer.digest buf in
  Digest.to_hex digest

end
module Bsb_pkg_types : sig 
#1 "bsb_pkg_types.mli"
(* Copyright (C) 2019- Hongbo Zhang, Authors of ReScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Global of string | Scope of string * scope

and scope = string

val to_string : t -> string

val print : Format.formatter -> t -> unit

val equal : t -> t -> bool

(* The second element could be empty or dropped 
*)
val extract_pkg_name_and_file : string -> t * string

val string_as_package : string -> t

end = struct
#1 "bsb_pkg_types.ml"
(* Copyright (C) 2018- Hongbo Zhang, Authors of ReScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let ( // ) = Filename.concat

type t = Global of string | Scope of string * scope

and scope = string

let to_string (x : t) =
  match x with Global s -> s | Scope (s, scope) -> scope // s

let print fmt (x : t) =
  match x with
  | Global s -> Format.pp_print_string fmt s
  | Scope (name, scope) -> Format.fprintf fmt "%s/%s" scope name

let equal (x : t) y =
  match (x, y) with
  | Scope (a0, a1), Scope (b0, b1) -> a0 = b0 && a1 = b1
  | Global a0, Global b0 -> a0 = b0
  | Scope _, Global _ | Global _, Scope _ -> false

(**
   input: {[
     @hello/yy/xx
        hello/yy
   ]}
   FIXME: fix invalid input
   {[
     hello//xh//helo
   ]}
*)
let extract_pkg_name_and_file (s : string) =
  let len = String.length s in
  assert (len > 0);
  let v = String.unsafe_get s 0 in
  if v = '@' then (
    let scope_id = Ext_string.no_slash_idx s in
    assert (scope_id > 0);
    let pkg_id = Ext_string.no_slash_idx_from s (scope_id + 1) in
    let scope = String.sub s 0 scope_id in

    if pkg_id < 0 then
      (Scope (String.sub s (scope_id + 1) (len - scope_id - 1), scope), "")
    else
      ( Scope (String.sub s (scope_id + 1) (pkg_id - scope_id - 1), scope),
        String.sub s (pkg_id + 1) (len - pkg_id - 1) ))
  else
    let pkg_id = Ext_string.no_slash_idx s in
    if pkg_id < 0 then (Global s, "")
    else
      ( Global (String.sub s 0 pkg_id),
        String.sub s (pkg_id + 1) (len - pkg_id - 1) )

let string_as_package (s : string) : t =
  let len = String.length s in
  assert (len > 0);
  let v = String.unsafe_get s 0 in
  if v = '@' then (
    let scope_id = Ext_string.no_slash_idx s in
    assert (scope_id > 0);
    (* better-eror message for invalid scope package:
       @rescript/std
    *)
    Scope
      (String.sub s (scope_id + 1) (len - scope_id - 1), String.sub s 0 scope_id))
  else Global s

end
module Ounit_bsb_pkg_tests
= struct
#1 "ounit_bsb_pkg_tests.ml"


let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let printer_string = fun x -> x 
let (=~) = OUnit.assert_equal  ~printer:printer_string  


let scope_test s (a,b,c)= 
  match Bsb_pkg_types.extract_pkg_name_and_file s with 
  | Scope(a0,b0),c0 -> 
    a =~ a0 ; b =~ b0 ; c =~ c0
  | Global _,_ -> OUnit.assert_failure __LOC__

let global_test s (a,b) = 
  match Bsb_pkg_types.extract_pkg_name_and_file s with 
  | Scope _, _ -> 
    OUnit.assert_failure __LOC__
  | Global a0, b0-> 
    a=~a0; b=~b0

let s_test0 s (a,b)=     
  match Bsb_pkg_types.string_as_package s with 
  | Scope(name,scope) -> 
      a =~ name ; b =~scope 
  | _ -> OUnit.assert_failure __LOC__     

let s_test1 s a =     
  match Bsb_pkg_types.string_as_package s with 
  | Global x  -> 
      a =~ x
  | _ -> OUnit.assert_failure __LOC__       

let group0 = Map_string.of_list [
  "Liba", 
  {Bsb_db.info = Impl_intf; dir= "a";syntax_kind=Ml;case = false;
  name_sans_extension = "liba"}
]
let group1 =  Map_string.of_list [
  "Ciba", 
  {Bsb_db.info = Impl_intf; dir= "b";syntax_kind=Ml;case = false;
  name_sans_extension = "liba"}
] 

let parse_db db : Bsb_db_decode.t =   
  let buf = Ext_buffer.create 10_000 in   
  Bsb_db_encode.encode db buf;
  let s = Ext_buffer.contents buf in
  Bsb_db_decode.decode s

let suites = 
  __FILE__ >::: [
    __LOC__ >:: begin fun _ -> 
      scope_test "@hello/hi"
        ("hi", "@hello","");

      scope_test "@hello/hi/x"
        ("hi", "@hello","x");

      
      scope_test "@hello/hi/x/y"
        ("hi", "@hello","x/y");  
  end ;
  __LOC__ >:: begin fun _ -> 
    global_test "hello"
      ("hello","");
    global_test "hello/x"
      ("hello","x");  
    global_test "hello/x/y"
      ("hello","x/y")    
  end ;
  __LOC__ >:: begin fun _ -> 
    s_test0 "@x/y" ("y","@x");
    s_test0 "@x/y/z" ("y/z","@x");
    s_test1 "xx" "xx";
    s_test1 "xx/yy/zz" "xx/yy/zz"
  end;

  __LOC__ >:: begin fun _ ->
    match parse_db {lib= group0; dev = group1}with 
    | {lib = Group {modules = [|"Liba"|]};
       dev = Group {modules = [|"Ciba"|]}}
        -> OUnit.assert_bool __LOC__ true
    | _ ->
      OUnit.assert_failure __LOC__    
  end  ;
  __LOC__ >:: begin fun _ -> 
    match parse_db {lib = group0;dev = Map_string.empty } with
    | {lib = Group {modules = [|"Liba"|]};
      dev = Dummy}
      -> OUnit.assert_bool __LOC__ true
    | _ ->
      OUnit.assert_failure __LOC__    
  end  ;
  __LOC__ >:: begin fun _ -> 
    match parse_db {lib = Map_string.empty ; dev = group1} with
    | {lib = Dummy;
       dev = Group {modules = [|"Ciba"|]}
       }
      -> OUnit.assert_bool __LOC__ true
    | _ ->
      OUnit.assert_failure __LOC__    
  end
  (* __LOC__ >:: begin fun _ -> 
  OUnit.assert_equal parse_data_one  data_one
  end ;
  __LOC__ >:: begin fun _ -> 
  
  OUnit.assert_equal parse_data_two data_two
  end  *)
  ]




end
module Bsb_regex : sig 
#1 "bsb_regex.mli"
(* Copyright (C) 2017 Hongbo Zhang, Authors of ReScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val global_substitute :
  string -> reg:string -> (string -> string list -> string) -> string
(** Used in `bsb -init` command *)

end = struct
#1 "bsb_regex.ml"
(* Copyright (C) 2017 Hongbo Zhang, Authors of ReScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let string_after s n = String.sub s n (String.length s - n)

(* There seems to be a bug in {!Str.global_substitute}
   {[
     Str.global_substitute (Str.regexp "\\${rescript:\\([-a-zA-Z0-9]+\\)}") (fun x -> (x^":found")) {|   ${rescript:hello-world}  ${rescript:x} ${x}|}  ;;
     - : bytes =
     "      ${rescript:hello-world}  ${rescript:x} ${x}:found     ${rescript:hello-world}  ${rescript:x} ${x}:found ${x}"
   ]}
*)
let global_substitute text ~reg:expr repl_fun =
  let text_len = String.length text in
  let expr = Str.regexp expr in
  let rec replace accu start last_was_empty =
    let startpos = if last_was_empty then start + 1 else start in
    if startpos > text_len then string_after text start :: accu
    else
      match Str.search_forward expr text startpos with
      | exception Not_found -> string_after text start :: accu
      | pos ->
          let end_pos = Str.match_end () in
          let matched = Str.matched_string text in
          let groups =
            let rec aux n acc =
              match Str.matched_group n text with
              | exception (Not_found | Invalid_argument _) -> acc
              | v -> aux (succ n) (v :: acc)
            in
            aux 1 []
          in
          let repl_text = repl_fun matched groups in
          replace
            (repl_text :: String.sub text start (pos - start) :: accu)
            end_pos (end_pos = pos)
  in
  String.concat "" (List.rev (replace [] 0 false))

end
module Ounit_bsb_regex_tests
= struct
#1 "ounit_bsb_regex_tests.ml"


let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal


let test_eq x y  = 
    Bsb_regex.global_substitute ~reg:"\\${rescript:\\([-a-zA-Z0-9]+\\)}" x
        (fun _ groups -> 
            match groups with 
            | x::_ -> x 
            | _ -> assert false 
        )  =~ y 


let suites = 
    __FILE__ 
    >:::
    [
        __LOC__ >:: begin fun _ -> 
        test_eq 
        {| hi hi hi ${rescript:name}
        ${rescript:x}
        ${rescript:u}
        |}        
        {| hi hi hi name
        x
        u
        |}
    end;
    __LOC__ >:: begin  fun _ ->
    test_eq  "xx" "xx";
    test_eq "${rescript:x}" "x";
    test_eq "a${rescript:x}" "ax";
    
    end;

    __LOC__ >:: begin fun _ ->
        test_eq "${rescript:x}x" "xx"
    end;

    __LOC__ >:: begin fun _ -> 
        test_eq {|
{
  "name": "${rescript:name}",
  "version": "${rescript:proj-version}",
  "sources": [
    "src"
  ],
  "reason" : { "react-jsx" : true},
  "bs-dependencies" : [
      // add your bs-dependencies here 
  ]
}
|} {|
{
  "name": "name",
  "version": "proj-version",
  "sources": [
    "src"
  ],
  "reason" : { "react-jsx" : true},
  "bs-dependencies" : [
      // add your bs-dependencies here 
  ]
}
|}
    end

    ;
    __LOC__ >:: begin fun _ -> 
    test_eq {|
{
  "name": "${rescript:name}",
  "version": "${rescript:proj-version}",
  "scripts": {
    "clean": "bsb -clean",
    "clean:all": "bsb -clean-world",
    "build": "bsb",
    "build:all": "bsb -make-world",
    "watch": "bsb -w",
  },
  "keywords": [
    "Bucklescript"
  ],
  "license": "MIT",
  "devDependencies": {
    "bs-platform": "${rescript:bs-version}"
  }
}
|} {|
{
  "name": "name",
  "version": "proj-version",
  "scripts": {
    "clean": "bsb -clean",
    "clean:all": "bsb -clean-world",
    "build": "bsb",
    "build:all": "bsb -make-world",
    "watch": "bsb -w",
  },
  "keywords": [
    "Bucklescript"
  ],
  "license": "MIT",
  "devDependencies": {
    "bs-platform": "bs-version"
  }
}
|}
    end;
    __LOC__ >:: begin fun _ -> 
    test_eq {|
{
    "version": "0.1.0",
    "command": "${rescript:bsb}",
    "options": {
        "cwd": "${workspaceRoot}"
    },
    "isShellCommand": true,
    "args": [
        "-w"
    ],
    "showOutput": "always",
    "isWatching": true,
    "problemMatcher": {
        "fileLocation": "absolute",
        "owner": "ocaml",
        "watching": {
            "activeOnStart": true,
            "beginsPattern": ">>>> Start compiling",
            "endsPattern": ">>>> Finish compiling"
        },
        "pattern": [
            {
                "regexp": "^File \"(.*)\", line (\\d+)(?:, characters (\\d+)-(\\d+))?:$",
                "file": 1,
                "line": 2,
                "column": 3,
                "endColumn": 4
            },
            {
                "regexp": "^(?:(?:Parse\\s+)?(Warning|[Ee]rror)(?:\\s+\\d+)?:)?\\s+(.*)$",
                "severity": 1,
                "message": 2,
                "loop": true
            }
        ]
    }
}
|} {|
{
    "version": "0.1.0",
    "command": "bsb",
    "options": {
        "cwd": "${workspaceRoot}"
    },
    "isShellCommand": true,
    "args": [
        "-w"
    ],
    "showOutput": "always",
    "isWatching": true,
    "problemMatcher": {
        "fileLocation": "absolute",
        "owner": "ocaml",
        "watching": {
            "activeOnStart": true,
            "beginsPattern": ">>>> Start compiling",
            "endsPattern": ">>>> Finish compiling"
        },
        "pattern": [
            {
                "regexp": "^File \"(.*)\", line (\\d+)(?:, characters (\\d+)-(\\d+))?:$",
                "file": 1,
                "line": 2,
                "column": 3,
                "endColumn": 4
            },
            {
                "regexp": "^(?:(?:Parse\\s+)?(Warning|[Ee]rror)(?:\\s+\\d+)?:)?\\s+(.*)$",
                "severity": 1,
                "message": 2,
                "loop": true
            }
        ]
    }
}
|}
    end
    ]
end
module Ounit_cmd_util : sig 
#1 "ounit_cmd_util.mli"
type output = {
  stderr : string ; 
  stdout : string ;
  exit_code : int 
}


val perform : string -> string array -> output 


val perform_bsc : string array -> output 


val bsc_check_eval : string -> output  

val debug_output : output -> unit 
end = struct
#1 "ounit_cmd_util.ml"
let (//) = Filename.concat

(** may nonterminate when [cwd] is '.' *)
let rec unsafe_root_dir_aux cwd  = 
  if Sys.file_exists (cwd//Literals.bsconfig_json) then cwd 
  else unsafe_root_dir_aux (Filename.dirname cwd)     

let project_root = unsafe_root_dir_aux (Sys.getcwd ())
let jscomp = project_root // "jscomp"


let bsc_exe = project_root // "bsc"
let runtime_dir = jscomp // "runtime"
let others_dir = jscomp // "others"


let stdlib_dir = jscomp // "stdlib-406"

(* let rec safe_dup fd =
  let new_fd = Unix.dup fd in
  if (Obj.magic new_fd : int) >= 3 then
    new_fd (* [dup] can not be 0, 1, 2*)
  else begin
    let res = safe_dup fd in
    Unix.close new_fd;
    res
  end *)

let safe_close fd =
  try Unix.close fd with Unix.Unix_error(_,_,_) -> ()


type output = {
  stderr : string ; 
  stdout : string ;
  exit_code : int 
}

let perform command args = 
  let new_fd_in, new_fd_out = Unix.pipe () in 
  let err_fd_in, err_fd_out = Unix.pipe () in 
  match Unix.fork () with 
  | 0 -> 
    begin try 
        safe_close new_fd_in;  
        safe_close err_fd_in;
        Unix.dup2 err_fd_out Unix.stderr ; 
        Unix.dup2 new_fd_out Unix.stdout; 
        Unix.execv command args 
      with _ -> 
        exit 127
    end
  | pid ->
    (* when all the descriptors on a pipe's input are closed and the pipe is 
        empty, a call to [read] on its output returns zero: end of file.
       when all the descriptiors on a pipe's output are closed, a call to 
       [write] on its input kills the writing process (EPIPE).
    *)
    safe_close new_fd_out ; 
    safe_close err_fd_out ; 
    let in_chan = Unix.in_channel_of_descr new_fd_in in 
    let err_in_chan = Unix.in_channel_of_descr err_fd_in in 
    let buf = Buffer.create 1024 in 
    let err_buf = Buffer.create 1024 in 
    (try 
       while true do 
         Buffer.add_string buf (input_line in_chan );             
         Buffer.add_char buf '\n'
       done;
     with
       End_of_file -> ()) ; 
    (try 
       while true do 
         Buffer.add_string err_buf (input_line err_in_chan );
         Buffer.add_char err_buf '\n'
       done;
     with
       End_of_file -> ()) ; 
    let exit_code = match snd @@ Unix.waitpid [] pid with 
      | Unix.WEXITED exit_code -> exit_code 
      | Unix.WSIGNALED _signal_number 
      | Unix.WSTOPPED _signal_number  -> 127 in 
    {
      stdout = Buffer.contents buf ; 
      stderr = Buffer.contents err_buf;
      exit_code 
    }


let perform_bsc args = 
  perform bsc_exe 
    (Array.append 
       [|bsc_exe ; 
         "-bs-package-name" ; "bs-platform"; 
         "-bs-no-version-header"; 
         "-bs-cross-module-opt";
         "-w";
         "-40";
         "-I" ;
         runtime_dir ; 
         "-I"; 
         others_dir ; 
         "-I" ; 
         stdlib_dir
       |] args)

let bsc_check_eval str = 
  perform_bsc [|"-bs-eval"; str|]        

  let debug_output o = 
  Printf.printf "\nexit_code:%d\nstdout:%s\nstderr:%s\n"
    o.exit_code o.stdout o.stderr

end
module Ounit_cmd_tests
= struct
#1 "ounit_cmd_tests.ml"
let (//) = Filename.concat




let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal





(* let output_of_exec_command command args =
    let readme, writeme = Unix.pipe () in
    let pid = Unix.create_process command args Unix.stdin writeme Unix.stderr in
    let in_chan = Unix.in_channel_of_descr readme *)



let perform_bsc = Ounit_cmd_util.perform_bsc
let bsc_check_eval = Ounit_cmd_util.bsc_check_eval

let ok b output = 
  if not b then 
    Ounit_cmd_util.debug_output output;
  OUnit.assert_bool __LOC__ b  

let suites =
  __FILE__
  >::: [
    __LOC__ >:: begin fun _ ->
      let v_output = perform_bsc  [| "-v" |] in
      OUnit.assert_bool __LOC__ ((perform_bsc [| "-h" |]).exit_code  = 0  );
      OUnit.assert_bool __LOC__ (v_output.exit_code = 0);
      (* Printf.printf "\n*>%s" v_output.stdout; *)
      (* Printf.printf "\n*>%s" v_output.stderr ; *)
    end;
    __LOC__ >:: begin fun _ ->
      let v_output =
        perform_bsc  [| "-bs-eval"; {|let str = "'a'" |}|] in
      ok (v_output.exit_code = 0) v_output
    end;
    __LOC__ >:: begin fun _ -> 
      let v_output = perform_bsc [|"-bs-eval"; {|type 'a arra = 'a array
    external
      f : 
      int -> int -> int arra -> unit
      = ""
      [@@bs.send.pipe:int]
      [@@bs.splice]|}|] in  
      OUnit.assert_bool __LOC__ (Ext_string.contain_substring v_output.stderr "variadic")
    end;
    __LOC__ >:: begin fun _ -> 
      let v_output = perform_bsc [|"-bs-eval"; {|external
  f2 : 
  int -> int -> ?y:int array -> unit  
  = ""
  [@@bs.send.pipe:int]
  [@@bs.splice]  |}|] in  
      OUnit.assert_bool __LOC__ (Ext_string.contain_substring v_output.stderr "variadic")
    end;

    __LOC__ >:: begin fun _ ->
      let should_be_warning =
        bsc_check_eval  {|let bla4 foo x y= foo##(method1 x y [@bs]) |} in
      (* debug_output should_be_warning; *)
      OUnit.assert_bool __LOC__ (Ext_string.contain_substring
                                   should_be_warning.stderr "Unused")
    end;
    __LOC__ >:: begin fun _ ->
      let should_be_warning =
        bsc_check_eval  {| external mk : int -> ([`a|`b [@bs.string]]) = "mk" [@@bs.val] |} in
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring
           should_be_warning.stderr "Unused")
    end;
    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
external ff :
    resp -> (_ [@bs.as "x"]) -> int -> unit =
    "x" [@@bs.set]
      |} in
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring should_err.stderr
           "Ill defined"
        )
    end;

    __LOC__ >:: begin fun _ ->
      (* used in return value
          This should fail, we did not
          support uncurry return value yet
      *)
      let should_err = bsc_check_eval {|
    external v3 :
    int -> int -> (int -> int -> int [@bs.uncurry])
    = "v3"[@@bs.val]

    |} in
      (* Ounit_cmd_util.debug_output should_err;*)
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring
           should_err.stderr "bs.uncurry")
    end ;

    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
    external v4 :
    (int -> int -> int [@bs.uncurry]) = ""
    [@@bs.val]

    |} in
      (* Ounit_cmd_util.debug_output should_err ; *)
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring
           should_err.stderr "uncurry")
    end ;

    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
      {js| \uFFF|js}
      |} in
      OUnit.assert_bool __LOC__ (not @@ Ext_string.is_empty should_err.stderr)
    end;

    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
      external mk : int -> ([`a|`b] [@bs.string]) = "" [@@bs.val]
      |} in
      OUnit.assert_bool __LOC__ (not @@ Ext_string.is_empty should_err.stderr)
    end;

    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
      external mk : int -> ([`a|`b] ) = "mk" [@@bs.val]
      |} in
      OUnit.assert_bool __LOC__ ( Ext_string.is_empty should_err.stderr)
      (* give a warning or ?
         ( [`a | `b ] [@bs.string] )
         (* auto-convert to ocaml poly-variant *)
      *)
    end;

    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
      type t
      external mk : int -> (_ [@bs.as {json| { x : 3 } |json}]) ->  t = "mk" [@@bs.val]
      |} in
      OUnit.assert_bool __LOC__ (Ext_string.is_empty should_err.stderr)
    end
    ;
    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
      type t
      external mk : int -> (_ [@bs.as {json| { "x" : 3 } |json}]) ->  t = "mk" [@@bs.val]
      |} in
      OUnit.assert_bool __LOC__ (Ext_string.is_empty should_err.stderr)
    end
    ;
    (* #1510 *)
    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
       let should_fail = fun [@bs.this] (Some x) y u -> y + u
      |} in
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring  should_err.stderr "simple")
    end;

    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
       let should_fail = fun [@bs.this] (Some x as v) y u -> y + u
      |} in
      (* Ounit_cmd_util.debug_output should_err; *)
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring  should_err.stderr "simple")
    end;

    (* __LOC__ >:: begin fun _ ->
       let should_err = bsc_check_eval {|
       external f : string -> unit -> unit = "x.y" [@@bs.send]
       |} in
       OUnit.assert_bool __LOC__
        (Ext_string.contain_substring should_err.stderr "Not a valid method name")
       end; *)


    __LOC__ >:: begin fun _ -> 
      let should_err = bsc_check_eval {|
      (* let rec must be rejected *)
type t10 = A of t10 [@@ocaml.unboxed];;
let rec x = A x;;
      |} in 
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring should_err.stderr "This kind of expression is not allowed")
    end;

    __LOC__ >:: begin fun _ -> 
      let should_err = bsc_check_eval {|
      type t = {x: int64} [@@unboxed];;
let rec x = {x = y} and y = 3L;;
      |} in 
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring should_err.stderr "This kind of expression is not allowed")
    end;
    __LOC__ >:: begin fun _ -> 
      let should_err = bsc_check_eval {|
      type r = A of r [@@unboxed];;
let rec y = A y;;
      |} in 
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring should_err.stderr "This kind of expression is not allowed")
    end;

    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
          external f : int = "%identity"
|} in
      OUnit.assert_bool __LOC__
        (not (Ext_string.is_empty should_err.stderr))
    end;

    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
          external f : int -> int = "%identity"
|} in
      OUnit.assert_bool __LOC__
        (Ext_string.is_empty should_err.stderr)
    end;
    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
          external f : int -> int -> int = "%identity"
|} in
      OUnit.assert_bool __LOC__
        (not (Ext_string.is_empty should_err.stderr))
    end;
    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
          external f : (int -> int) -> int = "%identity"
|} in
      OUnit.assert_bool __LOC__
        ( (Ext_string.is_empty should_err.stderr))

    end;

    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
          external f : int -> (int-> int) = "%identity"
|} in
      OUnit.assert_bool __LOC__
        (not (Ext_string.is_empty should_err.stderr))

    end;
    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
    external foo_bar :
    (_ [@bs.as "foo"]) ->
    string ->
    string = "bar"
  [@@bs.send]
    |} in
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring should_err.stderr "Ill defined attribute")
    end;
    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
      let bla4 foo x y = foo##(method1 x y [@bs])
    |} in
      (* Ounit_cmd_util.debug_output should_err ;  *)
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring should_err.stderr
           "Unused")
    end;
    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
    external mk : int ->
  (
    [`a|`b]
     [@bs.string]
  ) = "mk" [@@bs.val]
    |} in
      (* Ounit_cmd_util.debug_output should_err ;  *)
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring should_err.stderr
           "Unused")
    end;
    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
    type -'a t = {k : 'a } [@@bs.deriving abstract]
    |} in
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring should_err.stderr "contravariant")
    end;
    __LOC__ >:: begin fun _ ->
      let should_err = bsc_check_eval {|
    let u = [||]
    |} in
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring should_err.stderr "cannot be generalized")
    end;
    __LOC__ >:: begin fun _ -> 
      let should_err = bsc_check_eval {|  
external push : 'a array -> 'a -> unit = "push" [@@send]
let a = [||]
let () = 
  push a 3 |. ignore ; 
  push a "3" |. ignore  
  |} in
      OUnit.assert_bool __LOC__
        (Ext_string.contain_substring should_err.stderr "has type string")
    end
    (* __LOC__ >:: begin fun _ ->  *)
    (*   let should_infer = perform_bsc [| "-i"; "-bs-eval"|] {| *)
         (*      let  f = fun [@bs] x -> let (a,b) = x in a + b  *)
         (* |}  in  *)
    (*   let infer_type  = bsc_eval (Printf.sprintf {| *)

         (*      let f : %s  = fun [@bs] x -> let (a,b) = x in a + b  *)
         (*  |} should_infer.stdout ) in  *)
    (*  begin  *)
    (*    Ounit_cmd_util.debug_output should_infer ; *)
    (*    Ounit_cmd_util.debug_output infer_type ; *)
    (*    OUnit.assert_bool __LOC__  *)
    (*      ((Ext_string.is_empty infer_type.stderr)) *)
    (*  end *)
    (* end *)
  ]


end
module Misc : sig 
#1 "misc.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Miscellaneous useful types and functions *)


val fatal_error: string -> 'a
val fatal_errorf: ('a, Format.formatter, unit, 'b) format4 -> 'a
exception Fatal_error

val try_finally : (unit -> 'a) -> (unit -> unit) -> 'a;;

val map_end: ('a -> 'b) -> 'a list -> 'b list -> 'b list
        (* [map_end f l t] is [map f l @ t], just more efficient. *)
val map_left_right: ('a -> 'b) -> 'a list -> 'b list
        (* Like [List.map], with guaranteed left-to-right evaluation order *)
val for_all2: ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
        (* Same as [List.for_all] but for a binary predicate.
           In addition, this [for_all2] never fails: given two lists
           with different lengths, it returns false. *)
val replicate_list: 'a -> int -> 'a list
        (* [replicate_list elem n] is the list with [n] elements
           all identical to [elem]. *)
val list_remove: 'a -> 'a list -> 'a list
        (* [list_remove x l] returns a copy of [l] with the first
           element equal to [x] removed. *)
val split_last: 'a list -> 'a list * 'a
        (* Return the last element and the other elements of the given list. *)
val may: ('a -> unit) -> 'a option -> unit
val may_map: ('a -> 'b) -> 'a option -> 'b option

type ref_and_value = R : 'a ref * 'a -> ref_and_value

val protect_refs : ref_and_value list -> (unit -> 'a) -> 'a
(** [protect_refs l f] temporarily sets [r] to [v] for each [R (r, v)] in [l]
    while executing [f]. The previous contents of the references is restored
    even if [f] raises an exception. *)

module Stdlib : sig
  module List : sig
    type 'a t = 'a list

    val compare : ('a -> 'a -> int) -> 'a t -> 'a t -> int
    (** The lexicographic order supported by the provided order.
        There is no constraint on the relative lengths of the lists. *)

    val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
    (** Returns [true] iff the given lists have the same length and content
        with respect to the given equality function. *)

    val filter_map : ('a -> 'b option) -> 'a t -> 'b t
    (** [filter_map f l] applies [f] to every element of [l], filters
        out the [None] elements and returns the list of the arguments of
        the [Some] elements. *)

    val some_if_all_elements_are_some : 'a option t -> 'a t option
    (** If all elements of the given list are [Some _] then [Some xs]
        is returned with the [xs] being the contents of those [Some]s, with
        order preserved.  Otherwise return [None]. *)

    val map2_prefix : ('a -> 'b -> 'c) -> 'a t -> 'b t -> ('c t * 'b t)
    (** [let r1, r2 = map2_prefix f l1 l2]
        If [l1] is of length n and [l2 = h2 @ t2] with h2 of length n,
        r1 is [List.map2 f l1 h1] and r2 is t2. *)

    val split_at : int -> 'a t -> 'a t * 'a t
    (** [split_at n l] returns the pair [before, after] where [before] is
        the [n] first elements of [l] and [after] the remaining ones.
        If [l] has less than [n] elements, raises Invalid_argument. *)
  end

  module Option : sig
    type 'a t = 'a option

    val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool

    val iter : ('a -> unit) -> 'a t -> unit
    val map : ('a -> 'b) -> 'a t -> 'b t
    val fold : ('a -> 'b -> 'b) -> 'a t -> 'b -> 'b
    val value_default : ('a -> 'b) -> default:'b -> 'a t -> 'b
  end

  module Array : sig
    val exists2 : ('a -> 'b -> bool) -> 'a array -> 'b array -> bool
    (* Same as [Array.exists], but for a two-argument predicate. Raise
       Invalid_argument if the two arrays are determined to have
       different lengths. *)
  end
end

val find_in_path: string list -> string -> string
        (* Search a file in a list of directories. *)
val find_in_path_rel: string list -> string -> string
        (* Search a relative file in a list of directories. *)
val find_in_path_uncap: string list -> string -> string
        (* Same, but search also for uncapitalized name, i.e.
           if name is Foo.ml, allow /path/Foo.ml and /path/foo.ml
           to match. *)
val remove_file: string -> unit
        (* Delete the given file if it exists. Never raise an error. *)
val expand_directory: string -> string -> string
        (* [expand_directory alt file] eventually expands a [+] at the
           beginning of file into [alt] (an alternate root directory) *)

val create_hashtable: int -> ('a * 'b) list -> ('a, 'b) Hashtbl.t
        (* Create a hashtable of the given size and fills it with the
           given bindings. *)

val copy_file: in_channel -> out_channel -> unit
        (* [copy_file ic oc] reads the contents of file [ic] and copies
           them to [oc]. It stops when encountering EOF on [ic]. *)
val copy_file_chunk: in_channel -> out_channel -> int -> unit
        (* [copy_file_chunk ic oc n] reads [n] bytes from [ic] and copies
           them to [oc]. It raises [End_of_file] when encountering
           EOF on [ic]. *)
val string_of_file: in_channel -> string
        (* [string_of_file ic] reads the contents of file [ic] and copies
           them to a string. It stops when encountering EOF on [ic]. *)
           
val output_to_bin_file_directly: string -> (string -> out_channel -> 'a) -> 'a

val output_to_file_via_temporary:
      ?mode:open_flag list -> string -> (string -> out_channel -> 'a) -> 'a
        (* Produce output in temporary file, then rename it
           (as atomically as possible) to the desired output file name.
           [output_to_file_via_temporary filename fn] opens a temporary file
           which is passed to [fn] (name + output channel).  When [fn] returns,
           the channel is closed and the temporary file is renamed to
           [filename]. *)

val log2: int -> int
        (* [log2 n] returns [s] such that [n = 1 lsl s]
           if [n] is a power of 2*)
val align: int -> int -> int
        (* [align n a] rounds [n] upwards to a multiple of [a]
           (a power of 2). *)
val no_overflow_add: int -> int -> bool
        (* [no_overflow_add n1 n2] returns [true] if the computation of
           [n1 + n2] does not overflow. *)
val no_overflow_sub: int -> int -> bool
        (* [no_overflow_sub n1 n2] returns [true] if the computation of
           [n1 - n2] does not overflow. *)
val no_overflow_mul: int -> int -> bool
        (* [no_overflow_mul n1 n2] returns [true] if the computation of
           [n1 * n2] does not overflow. *)
val no_overflow_lsl: int -> int -> bool
        (* [no_overflow_lsl n k] returns [true] if the computation of
           [n lsl k] does not overflow. *)

module Int_literal_converter : sig
  val int : string -> int
  val int32 : string -> int32
  val int64 : string -> int64
  val nativeint : string -> nativeint
end

val chop_extensions: string -> string
        (* Return the given file name without its extensions. The extensions
           is the longest suffix starting with a period and not including
           a directory separator, [.xyz.uvw] for instance.

           Return the given name if it does not contain an extension. *)

val search_substring: string -> string -> int -> int
        (* [search_substring pat str start] returns the position of the first
           occurrence of string [pat] in string [str].  Search starts
           at offset [start] in [str].  Raise [Not_found] if [pat]
           does not occur. *)

val replace_substring: before:string -> after:string -> string -> string
        (* [replace_substring ~before ~after str] replaces all
           occurrences of [before] with [after] in [str] and returns
           the resulting string. *)

val rev_split_words: string -> string list
        (* [rev_split_words s] splits [s] in blank-separated words, and returns
           the list of words in reverse order. *)

val get_ref: 'a list ref -> 'a list
        (* [get_ref lr] returns the content of the list reference [lr] and reset
           its content to the empty list. *)


val fst3: 'a * 'b * 'c -> 'a
val snd3: 'a * 'b * 'c -> 'b
val thd3: 'a * 'b * 'c -> 'c

val fst4: 'a * 'b * 'c * 'd -> 'a
val snd4: 'a * 'b * 'c * 'd -> 'b
val thd4: 'a * 'b * 'c * 'd -> 'c
val for4: 'a * 'b * 'c * 'd -> 'd

module LongString :
  sig
    type t = bytes array
    val create : int -> t
    val length : t -> int
    val get : t -> int -> char
    val set : t -> int -> char -> unit
    val blit : t -> int -> t -> int -> int -> unit
    val output : out_channel -> t -> int -> int -> unit
    val unsafe_blit_to_bytes : t -> int -> bytes -> int -> int -> unit
    val input_bytes : in_channel -> int -> t
  end

val edit_distance : string -> string -> int -> int option
(** [edit_distance a b cutoff] computes the edit distance between
    strings [a] and [b]. To help efficiency, it uses a cutoff: if the
    distance [d] is smaller than [cutoff], it returns [Some d], else
    [None].

    The distance algorithm currently used is Damerau-Levenshtein: it
    computes the number of insertion, deletion, substitution of
    letters, or swapping of adjacent letters to go from one word to the
    other. The particular algorithm may change in the future.
*)

val spellcheck : string list -> string -> string list
(** [spellcheck env name] takes a list of names [env] that exist in
    the current environment and an erroneous [name], and returns a
    list of suggestions taken from [env], that are close enough to
    [name] that it may be a typo for one of them. *)

val did_you_mean : Format.formatter -> (unit -> string list) -> unit
(** [did_you_mean ppf get_choices] hints that the user may have meant
    one of the option returned by calling [get_choices]. It does nothing
    if the returned list is empty.

    The [unit -> ...] thunking is meant to delay any potentially-slow
    computation (typically computing edit-distance with many things
    from the current environment) to when the hint message is to be
    printed. You should print an understandable error message before
    calling [did_you_mean], so that users get a clear notification of
    the failure even if producing the hint is slow.
*)

val cut_at : string -> char -> string * string
(** [String.cut_at s c] returns a pair containing the sub-string before
   the first occurrence of [c] in [s], and the sub-string after the
   first occurrence of [c] in [s].
   [let (before, after) = String.cut_at s c in
    before ^ String.make 1 c ^ after] is the identity if [s] contains [c].

   Raise [Not_found] if the character does not appear in the string
   @since 4.01
*)


module StringSet: Set.S with type elt = string
module StringMap: Map.S with type key = string
(* TODO: replace all custom instantiations of StringSet/StringMap in various
   compiler modules with this one. *)

(* Color handling *)
module Color : sig
  type color =
    | Black
    | Red
    | Green
    | Yellow
    | Blue
    | Magenta
    | Cyan
    | White
  ;;

  type style =
    | FG of color (* foreground *)
    | BG of color (* background *)
    | Bold
    | Reset
    | Dim


  val ansi_of_style_l : style list -> string
  (* ANSI escape sequence for the given style *)

  type styles = {
    error: style list;
    warning: style list;
    loc: style list;
  }

  val default_styles: styles
  val get_styles: unit -> styles
  val set_styles: styles -> unit

  type setting = Auto | Always | Never

  val setup : setting option -> unit
  (* [setup opt] will enable or disable color handling on standard formatters
     according to the value of color setting [opt].
     Only the first call to this function has an effect. *)

  val set_color_tag_handling : Format.formatter -> unit
  (* adds functions to support color tags to the given formatter. *)
end

val normalise_eol : string -> string
(** [normalise_eol s] returns a fresh copy of [s] with any '\r' characters
   removed. Intended for pre-processing text which will subsequently be printed
   on a channel which performs EOL transformations (i.e. Windows) *)

val delete_eol_spaces : string -> string
(** [delete_eol_spaces s] returns a fresh copy of [s] with any end of
   line spaces removed. Intended to normalize the output of the
   toplevel for tests. *)



(** {1 Hook machinery}

    Hooks machinery:
   [add_hook name f] will register a function that will be called on the
    argument of a later call to [apply_hooks]. Hooks are applied in the
    lexicographical order of their names.
*)

type hook_info = {
  sourcefile : string;
}

exception HookExnWrapper of
    {
      error: exn;
      hook_name: string;
      hook_info: hook_info;
    }
    (** An exception raised by a hook will be wrapped into a
        [HookExnWrapper] constructor by the hook machinery.  *)


val raise_direct_hook_exn: exn -> 'a
  (** A hook can use [raise_unwrapped_hook_exn] to raise an exception that will
      not be wrapped into a {!HookExnWrapper}. *)

module type HookSig = sig
  type t
  val add_hook : string -> (hook_info -> t -> t) -> unit
  val apply_hooks : hook_info -> t -> t
end

module MakeHooks : functor (M : sig type t end) -> HookSig with type t = M.t

end = struct
#1 "misc.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Errors *)

exception Fatal_error



let fatal_error msg =
  prerr_string ">> Fatal error: "; prerr_endline msg; raise Fatal_error

let fatal_errorf fmt = Format.kasprintf fatal_error fmt

(* Exceptions *)

let try_finally work cleanup =
  let result = (try work () with e -> cleanup (); raise e) in
  cleanup ();
  result
;;

type ref_and_value = R : 'a ref * 'a -> ref_and_value

let protect_refs =
  let set_refs l = List.iter (fun (R (r, v)) -> r := v) l in
  fun refs f ->
    let backup = List.map (fun (R (r, _)) -> R (r, !r)) refs in
    set_refs refs;
    match f () with
    | x           -> set_refs backup; x
    | exception e -> set_refs backup; raise e

(* List functions *)

let rec map_end f l1 l2 =
  match l1 with
    [] -> l2
  | hd::tl -> f hd :: map_end f tl l2

let rec map_left_right f = function
    [] -> []
  | hd::tl -> let res = f hd in res :: map_left_right f tl

let rec for_all2 pred l1 l2 =
  match (l1, l2) with
    ([], []) -> true
  | (hd1::tl1, hd2::tl2) -> pred hd1 hd2 && for_all2 pred tl1 tl2
  | (_, _) -> false

let rec replicate_list elem n =
  if n <= 0 then [] else elem :: replicate_list elem (n-1)

let rec list_remove x = function
    [] -> []
  | hd :: tl ->
      if hd = x then tl else hd :: list_remove x tl

let rec split_last = function
    [] -> assert false
  | [x] -> ([], x)
  | hd :: tl ->
      let (lst, last) = split_last tl in
      (hd :: lst, last)

module Stdlib = struct
  module List = struct
    type 'a t = 'a list

    let rec compare cmp l1 l2 =
      match l1, l2 with
      | [], [] -> 0
      | [], _::_ -> -1
      | _::_, [] -> 1
      | h1::t1, h2::t2 ->
        let c = cmp h1 h2 in
        if c <> 0 then c
        else compare cmp t1 t2

    let rec equal eq l1 l2 =
      match l1, l2 with
      | ([], []) -> true
      | (hd1 :: tl1, hd2 :: tl2) -> eq hd1 hd2 && equal eq tl1 tl2
      | (_, _) -> false

    let filter_map f l =
      let rec aux acc l =
        match l with
        | [] -> List.rev acc
        | h :: t ->
          match f h with
          | None -> aux acc t
          | Some v -> aux (v :: acc) t
      in
      aux [] l

    let map2_prefix f l1 l2 =
      let rec aux acc l1 l2 =
        match l1, l2 with
        | [], _ -> (List.rev acc, l2)
        | _ :: _, [] -> raise (Invalid_argument "map2_prefix")
        | h1::t1, h2::t2 ->
          let h = f h1 h2 in
          aux (h :: acc) t1 t2
      in
      aux [] l1 l2

    let some_if_all_elements_are_some l =
      let rec aux acc l =
        match l with
        | [] -> Some (List.rev acc)
        | None :: _ -> None
        | Some h :: t -> aux (h :: acc) t
      in
      aux [] l

    let split_at n l =
      let rec aux n acc l =
        if n = 0
        then List.rev acc, l
        else
          match l with
          | [] -> raise (Invalid_argument "split_at")
          | t::q -> aux (n-1) (t::acc) q
      in
      aux n [] l
  end

  module Option = struct
    type 'a t = 'a option

    let equal eq o1 o2 =
      match o1, o2 with
      | None, None -> true
      | Some e1, Some e2 -> eq e1 e2
      | _, _ -> false

    let iter f = function
      | Some x -> f x
      | None -> ()

    let map f = function
      | Some x -> Some (f x)
      | None -> None

    let fold f a b =
      match a with
      | None -> b
      | Some a -> f a b

    let value_default f ~default a =
      match a with
      | None -> default
      | Some a -> f a
  end

  module Array = struct
    let exists2 p a1 a2 =
      let n = Array.length a1 in
      if Array.length a2 <> n then invalid_arg "Misc.Stdlib.Array.exists2";
      let rec loop i =
        if i = n then false
        else if p (Array.unsafe_get a1 i) (Array.unsafe_get a2 i) then true
        else loop (succ i) in
      loop 0
  end
end

let may = Stdlib.Option.iter
let may_map = Stdlib.Option.map

(* File functions *)

let find_in_path path name =
  if not (Filename.is_implicit name) then
    if Sys.file_exists name then name else raise Not_found
  else begin
    let rec try_dir = function
      [] -> raise Not_found
    | dir::rem ->
        let fullname = Filename.concat dir name in
        if Sys.file_exists fullname then fullname else try_dir rem
    in try_dir path
  end

let find_in_path_rel path name =
  let rec simplify s =
    let open Filename in
    let base = basename s in
    let dir = dirname s in
    if dir = s then dir
    else if base = current_dir_name then simplify dir
    else concat (simplify dir) base
  in
  let rec try_dir = function
    [] -> raise Not_found
  | dir::rem ->
      let fullname = simplify (Filename.concat dir name) in
      if Sys.file_exists fullname then fullname else try_dir rem
  in try_dir path

let find_in_path_uncap path name =
  let uname = String.uncapitalize_ascii name in
  let rec try_dir = function
    [] -> raise Not_found
  | dir::rem ->
      let fullname = Filename.concat dir name
      and ufullname = Filename.concat dir uname in
      if Sys.file_exists ufullname then ufullname
      else if Sys.file_exists fullname then fullname
      else try_dir rem
  in try_dir path

let remove_file filename =
  try
    if Sys.file_exists filename
    then Sys.remove filename
  with Sys_error _msg ->
    ()

(* Expand a -I option: if it starts with +, make it relative to the standard
   library directory *)

let expand_directory alt s =
  if String.length s > 0 && s.[0] = '+'
  then Filename.concat alt
                       (String.sub s 1 (String.length s - 1))
  else s

(* Hashtable functions *)

let create_hashtable size init =
  let tbl = Hashtbl.create size in
  List.iter (fun (key, data) -> Hashtbl.add tbl key data) init;
  tbl

(* File copy *)

let copy_file ic oc =
  let buff = Bytes.create 0x1000 in
  let rec copy () =
    let n = input ic buff 0 0x1000 in
    if n = 0 then () else (output oc buff 0 n; copy())
  in copy()

let copy_file_chunk ic oc len =
  let buff = Bytes.create 0x1000 in
  let rec copy n =
    if n <= 0 then () else begin
      let r = input ic buff 0 (min n 0x1000) in
      if r = 0 then raise End_of_file else (output oc buff 0 r; copy(n-r))
    end
  in copy len

let string_of_file ic =
  let b = Buffer.create 0x10000 in
  let buff = Bytes.create 0x1000 in
  let rec copy () =
    let n = input ic buff 0 0x1000 in
    if n = 0 then Buffer.contents b else
      (Buffer.add_subbytes b buff 0 n; copy())
  in copy()

let output_to_bin_file_directly filename fn =  
  let oc = Pervasives.open_out_bin filename in 
  match fn filename oc with 
  | v -> close_out oc ; v 
  | exception e -> close_out oc ; raise e

let output_to_file_via_temporary ?(mode = [Open_text]) filename fn =
  let (temp_filename, oc) =
    Filename.open_temp_file
       ~mode ~perms:0o666 ~temp_dir:(Filename.dirname filename)
       (Filename.basename filename) ".tmp" in
    (* The 0o666 permissions will be modified by the umask.  It's just
       like what [open_out] and [open_out_bin] do.
       With temp_dir = dirname filename, we ensure that the returned
       temp file is in the same directory as filename itself, making
       it safe to rename temp_filename to filename later.
       With prefix = basename filename, we are almost certain that
       the first generated name will be unique.  A fixed prefix
       would work too but might generate more collisions if many
       files are being produced simultaneously in the same directory. *)
  match fn temp_filename oc with
  | res ->
      close_out oc;
      begin try
        Sys.rename temp_filename filename; res
      with exn ->
        remove_file temp_filename; raise exn
      end
  | exception exn ->
      close_out oc; remove_file temp_filename; raise exn

(* Integer operations *)

let rec log2 n =
  if n <= 1 then 0 else 1 + log2(n asr 1)

let align n a =
  if n >= 0 then (n + a - 1) land (-a) else n land (-a)

let no_overflow_add a b = (a lxor b) lor (a lxor (lnot (a+b))) < 0

let no_overflow_sub a b = (a lxor (lnot b)) lor (b lxor (a-b)) < 0

let no_overflow_mul a b = b <> 0 && (a * b) / b = a

let no_overflow_lsl a k =
  0 <= k && k < Sys.word_size && min_int asr k <= a && a <= max_int asr k

module Int_literal_converter = struct
  (* To convert integer literals, allowing max_int + 1 (PR#4210) *)
  let cvt_int_aux str neg of_string =
    if String.length str = 0 || str.[0]= '-'
    then of_string str
    else neg (of_string ("-" ^ str))
  let int s = cvt_int_aux s (~-) int_of_string
  let int32 s = cvt_int_aux s Int32.neg Int32.of_string
  let int64 s = cvt_int_aux s Int64.neg Int64.of_string
  let nativeint s = cvt_int_aux s Nativeint.neg Nativeint.of_string
end

(* String operations *)

let chop_extensions file =
  let dirname = Filename.dirname file and basename = Filename.basename file in
  try
    let pos = String.index basename '.' in
    let basename = String.sub basename 0 pos in
    if Filename.is_implicit file && dirname = Filename.current_dir_name then
      basename
    else
      Filename.concat dirname basename
  with Not_found -> file

let search_substring pat str start =
  let rec search i j =
    if j >= String.length pat then i
    else if i + j >= String.length str then raise Not_found
    else if str.[i + j] = pat.[j] then search i (j+1)
    else search (i+1) 0
  in search start 0

let replace_substring ~before ~after str =
  let rec search acc curr =
    match search_substring before str curr with
      | next ->
         let prefix = String.sub str curr (next - curr) in
         search (prefix :: acc) (next + String.length before)
      | exception Not_found ->
        let suffix = String.sub str curr (String.length str - curr) in
        List.rev (suffix :: acc)
  in String.concat after (search [] 0)

let rev_split_words s =
  let rec split1 res i =
    if i >= String.length s then res else begin
      match s.[i] with
        ' ' | '\t' | '\r' | '\n' -> split1 res (i+1)
      | _ -> split2 res i (i+1)
    end
  and split2 res i j =
    if j >= String.length s then String.sub s i (j-i) :: res else begin
      match s.[j] with
        ' ' | '\t' | '\r' | '\n' -> split1 (String.sub s i (j-i) :: res) (j+1)
      | _ -> split2 res i (j+1)
    end
  in split1 [] 0

let get_ref r =
  let v = !r in
  r := []; v

let fst3 (x, _, _) = x
let snd3 (_,x,_) = x
let thd3 (_,_,x) = x

let fst4 (x, _, _, _) = x
let snd4 (_,x,_, _) = x
let thd4 (_,_,x,_) = x
let for4 (_,_,_,x) = x


module LongString = struct
  type t = bytes array

  let create str_size =
    let tbl_size = str_size / Sys.max_string_length + 1 in
    let tbl = Array.make tbl_size Bytes.empty in
    for i = 0 to tbl_size - 2 do
      tbl.(i) <- Bytes.create Sys.max_string_length;
    done;
    tbl.(tbl_size - 1) <- Bytes.create (str_size mod Sys.max_string_length);
    tbl

  let length tbl =
    let tbl_size = Array.length tbl in
    Sys.max_string_length * (tbl_size - 1) + Bytes.length tbl.(tbl_size - 1)

  let get tbl ind =
    Bytes.get tbl.(ind / Sys.max_string_length) (ind mod Sys.max_string_length)

  let set tbl ind c =
    Bytes.set tbl.(ind / Sys.max_string_length) (ind mod Sys.max_string_length)
              c

  let blit src srcoff dst dstoff len =
    for i = 0 to len - 1 do
      set dst (dstoff + i) (get src (srcoff + i))
    done

  let output oc tbl pos len =
    for i = pos to pos + len - 1 do
      output_char oc (get tbl i)
    done

  let unsafe_blit_to_bytes src srcoff dst dstoff len =
    for i = 0 to len - 1 do
      Bytes.unsafe_set dst (dstoff + i) (get src (srcoff + i))
    done

  let input_bytes ic len =
    let tbl = create len in
    Array.iter (fun str -> really_input ic str 0 (Bytes.length str)) tbl;
    tbl
end


let edit_distance a b cutoff =
  let la, lb = String.length a, String.length b in
  let cutoff =
    (* using max_int for cutoff would cause overflows in (i + cutoff + 1);
       we bring it back to the (max la lb) worstcase *)
    min (max la lb) cutoff in
  if abs (la - lb) > cutoff then None
  else begin
    (* initialize with 'cutoff + 1' so that not-yet-written-to cases have
       the worst possible cost; this is useful when computing the cost of
       a case just at the boundary of the cutoff diagonal. *)
    let m = Array.make_matrix (la + 1) (lb + 1) (cutoff + 1) in
    m.(0).(0) <- 0;
    for i = 1 to la do
      m.(i).(0) <- i;
    done;
    for j = 1 to lb do
      m.(0).(j) <- j;
    done;
    for i = 1 to la do
      for j = max 1 (i - cutoff - 1) to min lb (i + cutoff + 1) do
        let cost = if a.[i-1] = b.[j-1] then 0 else 1 in
        let best =
          (* insert, delete or substitute *)
          min (1 + min m.(i-1).(j) m.(i).(j-1)) (m.(i-1).(j-1) + cost)
        in
        let best =
          (* swap two adjacent letters; we use "cost" again in case of
             a swap between two identical letters; this is slightly
             redundant as this is a double-substitution case, but it
             was done this way in most online implementations and
             imitation has its virtues *)
          if not (i > 1 && j > 1 && a.[i-1] = b.[j-2] && a.[i-2] = b.[j-1])
          then best
          else min best (m.(i-2).(j-2) + cost)
        in
        m.(i).(j) <- best
      done;
    done;
    let result = m.(la).(lb) in
    if result > cutoff
    then None
    else Some result
  end

let spellcheck env name =
  let cutoff =
    match String.length name with
      | 1 | 2 -> 0
      | 3 | 4 -> 1
      | 5 | 6 -> 2
      | _ -> 3
  in
  let compare target acc head =
    match edit_distance target head cutoff with
      | None -> acc
      | Some dist ->
         let (best_choice, best_dist) = acc in
         if dist < best_dist then ([head], dist)
         else if dist = best_dist then (head :: best_choice, dist)
         else acc
  in
  fst (List.fold_left (compare name) ([], max_int) env)

let did_you_mean ppf get_choices =
  (* flush now to get the error report early, in the (unheard of) case
     where the search in the get_choices function would take a bit of
     time; in the worst case, the user has seen the error, she can
     interrupt the process before the spell-checking terminates. *)
  Format.fprintf ppf "@?";
  match get_choices () with
  | [] -> ()
  | choices ->
     let rest, last = split_last choices in
     Format.fprintf ppf "@\nHint: Did you mean %s%s%s?@?"
       (String.concat ", " rest)
       (if rest = [] then "" else " or ")
       last

let cut_at s c =
  let pos = String.index s c in
  String.sub s 0 pos, String.sub s (pos+1) (String.length s - pos - 1)


module StringSet = Set.Make(struct type t = string let compare = compare end)
module StringMap = Map.Make(struct type t = string let compare = compare end)

(* Color handling *)
module Color = struct
  (* use ANSI color codes, see https://en.wikipedia.org/wiki/ANSI_escape_code *)
  type color =
    | Black
    | Red
    | Green
    | Yellow
    | Blue
    | Magenta
    | Cyan
    | White
  ;;

  type style =
    | FG of color (* foreground *)
    | BG of color (* background *)
    | Bold
    | Reset
    | Dim


  let ansi_of_color = function
    | Black -> "0"
    | Red -> "1"
    | Green -> "2"
    | Yellow -> "3"
    | Blue -> "4"
    | Magenta -> "5"
    | Cyan -> "6"
    | White -> "7"

  let code_of_style = function
    | FG c -> "3" ^ ansi_of_color c
    | BG c -> "4" ^ ansi_of_color c
    | Bold -> "1"
    | Reset -> "0"
    | Dim -> "2"


  let ansi_of_style_l l =
    let s = match l with
      | [] -> code_of_style Reset
      | [s] -> code_of_style s
      | _ -> String.concat ";" (List.map code_of_style l)
    in
    "\x1b[" ^ s ^ "m"

  type styles = {
    error: style list;
    warning: style list;
    loc: style list;
  }

  let default_styles = {
    warning = [Bold; FG Magenta];
    error = [Bold; FG Red];
    loc = [Bold];
  }

  let cur_styles = ref default_styles
  let get_styles () = !cur_styles
  let set_styles s = cur_styles := s

  (* map a tag to a style, if the tag is known.
     @raise Not_found otherwise *)
  let style_of_tag s = match s with
    | "error" -> (!cur_styles).error
    | "warning" -> (!cur_styles).warning
    | "loc" -> (!cur_styles).loc
    | "info" -> [Bold; FG Yellow]
    | "dim" -> [Dim]
    | "filename" -> [FG Cyan]
    | _ -> raise Not_found

  let color_enabled = ref true

  (* either prints the tag of [s] or delegates to [or_else] *)
  let mark_open_tag ~or_else s =
    try
      let style = style_of_tag s in
      if !color_enabled then ansi_of_style_l style else ""
    with Not_found -> or_else s

  let mark_close_tag ~or_else s =
    try
      let _ = style_of_tag s in
      if !color_enabled then ansi_of_style_l [Reset] else ""
    with Not_found -> or_else s

  (* add color handling to formatter [ppf] *)
  let set_color_tag_handling ppf =
    let open Format in
    let functions = pp_get_formatter_tag_functions ppf () in
    let functions' = {functions with
      mark_open_tag=(mark_open_tag ~or_else:functions.mark_open_tag);
      mark_close_tag=(mark_close_tag ~or_else:functions.mark_close_tag);
    } in
    pp_set_mark_tags ppf true; (* enable tags *)
    pp_set_formatter_tag_functions ppf functions';
    (* also setup margins *)
    pp_set_margin ppf (pp_get_margin std_formatter());
    ()

  external isatty : out_channel -> bool = "caml_sys_isatty"

  (* reasonable heuristic on whether colors should be enabled *)
  let should_enable_color () =
    let term = try Sys.getenv "TERM" with Not_found -> "" in
    term <> "dumb"
    && term <> ""
    && isatty stderr

  type setting = Auto | Always | Never

  let setup =
    let first = ref true in (* initialize only once *)
    let formatter_l =
      [Format.std_formatter; Format.err_formatter; Format.str_formatter]
    in
    fun o ->
      if !first then (
        first := false;
        Format.set_mark_tags true;
        List.iter set_color_tag_handling formatter_l;
        color_enabled := (match o with
            | Some Always -> true
            | Some Auto -> should_enable_color ()
            | Some Never -> false
            | None -> should_enable_color ())
      );
      ()
end

let normalise_eol s =
  let b = Buffer.create 80 in
    for i = 0 to String.length s - 1 do
      if s.[i] <> '\r' then Buffer.add_char b s.[i]
    done;
    Buffer.contents b

let delete_eol_spaces src =
  let len_src = String.length src in
  let dst = Bytes.create len_src in
  let rec loop i_src i_dst =
    if i_src = len_src then
      i_dst
    else
      match src.[i_src] with
      | ' ' | '\t' ->
        loop_spaces 1 (i_src + 1) i_dst
      | c ->
        Bytes.set dst i_dst c;
        loop (i_src + 1) (i_dst + 1)
  and loop_spaces spaces i_src i_dst =
    if i_src = len_src then
      i_dst
    else
      match src.[i_src] with
      | ' ' | '\t' ->
        loop_spaces (spaces + 1) (i_src + 1) i_dst
      | '\n' ->
        Bytes.set dst i_dst '\n';
        loop (i_src + 1) (i_dst + 1)
      | _ ->
        for n = 0 to spaces do
          Bytes.set dst (i_dst + n) src.[i_src - spaces + n]
        done;
        loop (i_src + 1) (i_dst + spaces + 1)
  in
  let stop = loop 0 0 in
  Bytes.sub_string dst 0 stop

type hook_info = {
  sourcefile : string;
}

exception HookExnWrapper of
    {
      error: exn;
      hook_name: string;
      hook_info: hook_info;
    }

exception HookExn of exn

let raise_direct_hook_exn e = raise (HookExn e)

let fold_hooks list hook_info ast =
  List.fold_left (fun ast (hook_name,f) ->
    try
      f hook_info ast
    with
    | HookExn e -> raise e
    | error -> raise (HookExnWrapper {error; hook_name; hook_info})
       (* when explicit reraise with backtrace will be available,
          it should be used here *)

  ) ast (List.sort compare list)

module type HookSig = sig
  type t

  val add_hook : string -> (hook_info -> t -> t) -> unit
  val apply_hooks : hook_info -> t -> t
end

module MakeHooks(M: sig
    type t
  end) : HookSig with type t = M.t
= struct

  type t = M.t

  let hooks = ref []
  let add_hook name f = hooks := (name, f) :: !hooks
  let apply_hooks sourcefile intf =
    fold_hooks !hooks sourcefile intf
end

end
module Clflags : sig 
#1 "clflags.mli"
val output_name : string option ref
val include_dirs : string list ref

val debug : bool ref
val fast : bool ref

val nopervasives : bool ref
val open_modules : string list ref
val preprocessor : string option ref
val all_ppx : string list ref
val annotations : bool ref
val binary_annotations : bool ref
val noassert : bool ref
val verbose : bool ref
val real_paths : bool ref
val applicative_functors : bool ref
val error_size : int ref
val transparent_modules : bool ref
val dump_source : bool ref
val dump_parsetree : bool ref
val dump_typedtree : bool ref
val dump_rawlambda : bool ref
val dump_lambda : bool ref
val dont_write_files : bool ref
val keep_docs : bool ref
val keep_locs : bool ref


val parse_color_setting : string -> Misc.Color.setting option
val color : Misc.Color.setting option ref

val unboxed_types : bool ref

val reset_dump_state: unit -> unit 


type mli_status =  Mli_exists | Mli_non_exists
val assume_no_mli : mli_status ref
val bs_vscode : bool
val dont_record_crc_unit : string option ref
val bs_gentype : string option ref
val no_assert_false : bool ref
val dump_location : bool ref


end = struct
#1 "clflags.ml"




let  output_name = ref (None : string option) (* -o *)
and include_dirs = ref ([] : string list)(* -I *)
and debug = ref false                   (* -g *)
and fast = ref false                    (* -unsafe *)

and nopervasives = ref false            (* -nopervasives *)
and preprocessor = ref(None : string option) (* -pp *)
and all_ppx = ref ([] : string list)        (* -ppx *)
let annotations = ref false             (* -annot *)
let binary_annotations = ref false      (* -annot *)
and noassert = ref false                (* -noassert *)
and verbose = ref false                 (* -verbose *)
and open_modules = ref []               (* -open *)

and real_paths = ref true               (* -short-paths *)
and applicative_functors = ref true     (* -no-app-funct *)
and error_size = ref 500                (* -error-size *)
and transparent_modules = ref false     (* -trans-mod *)
let dump_source = ref false             (* -dsource *)
let dump_parsetree = ref false          (* -dparsetree *)
and dump_typedtree = ref false          (* -dtypedtree *)
and dump_rawlambda = ref false          (* -drawlambda *)
and dump_lambda = ref false             (* -dlambda *)


let dont_write_files = ref false        (* set to true under ocamldoc *)


let reset_dump_state () = begin 
  dump_source := false;
  dump_parsetree := false;
  dump_typedtree := false;
  dump_rawlambda := false
end




let keep_docs = ref false              (* -keep-docs *)
let keep_locs = ref true               (* -keep-locs *)




let parse_color_setting = function
  | "auto" -> Some Misc.Color.Auto
  | "always" -> Some Misc.Color.Always
  | "never" -> Some Misc.Color.Never
  | _ -> None
let color = ref None ;; (* -color *)

let unboxed_types = ref false




type mli_status =  Mli_exists | Mli_non_exists
let assume_no_mli = ref Mli_non_exists
let bs_vscode =
    try ignore @@ Sys.getenv "BS_VSCODE" ; true with _ -> false
    (* We get it from environment variable mostly due to
       we don't want to rebuild when flip on or off
    *)
let dont_record_crc_unit : string option ref = ref None
let bs_gentype = ref None
let no_assert_false = ref false
let dump_location = ref true

end
module Bsc_warnings
= struct
#1 "bsc_warnings.ml"
(* Copyright (C) 2020- Hongbo Zhang, Authors of ReScript 
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(**
   See the meanings of the warning codes here: https://caml.inria.fr/pub/docs/manual-ocaml/comp.html#sec281

   - 30 Two labels or constructors of the same name are defined in two mutually recursive types.
   - 40 Constructor or label name used out of scope.

   - 6 Label omitted in function application.
   - 7 Method overridden.
   - 9 Missing fields in a record pattern. (*Not always desired, in some cases need [@@@warning "+9"] *)
   - 27 Innocuous unused variable: unused variable that is not bound with let nor as, and doesn’t start with an underscore (_) character.
   - 29 Unescaped end-of-line in a string constant (non-portable code).
   - 32 .. 39 Unused blabla
   - 44 Open statement shadows an already defined identifier.
   - 45 Open statement shadows an already defined label or constructor.
   - 48 Implicit elimination of optional arguments. https://caml.inria.fr/mantis/view.php?id=6352
   - 101 (bsb-specific) unsafe polymorphic comparison.
*)

(*
  The purpose of default warning set is to make it strict while
  not annoy user too much

  -4 Fragile pattern matching: matching that will remain complete even if additional con- structors are added to one of the variant types matched.
  We turn it off since common pattern
   {[
     match x with | A -> .. |  _ -> false
   ]}

   -9 Missing fields in a record pattern.
   only in some special cases that we need all fields being listed

   We encourage people to write code based on type based disambigution
   40,41,42 are enabled for compatiblity reasons  
   -40 Constructor or label name used out of scope
   This is intentional, we should never warn it
   - 41 Ambiguous constructor or label name.
     It is turned off since it prevents such cases below:
   {[
     type a = A |B 
     type b = A | B | C
   ]}
   - 42 Disambiguated constructor or label name (compatibility warning).

   - 50 Unexpected documentation comment.

   - 102 Bs_polymorphic_comparison
*)
let defaults_w = "+a-4-9-20-40-41-42-50-61-102"

let defaults_warn_error = "-a+5+6+101+109"
(*TODO: add +10*)

end
module Config : sig 
#1 "config.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* System configuration *)

val version : string
(* The current version number of the system *)

val standard_library : string
(* The directory containing the standard libraries *)

val syntax_kind : [ `ml | `rescript ] ref

val bs_only : bool ref

val unsafe_empty_array : bool ref

val load_path : string list ref
(* Directories in the search path for .cmi and .cmo files *)

val interface_suffix : string ref
(* Suffix for interface file names *)

val cmi_magic_number : string

(* Magic number for compiled interface files *)
val ast_intf_magic_number : string

(* Magic number for file holding an interface syntax tree *)
val ast_impl_magic_number : string

(* Magic number for file holding an implementation syntax tree *)
val cmt_magic_number : string
(* Magic number for compiled interface files *)

val default_uncurry : bool ref

val print_config : out_channel -> unit

end = struct
#1 "config.ml"
let version = "4.06.1+BS"

let standard_library =
  let ( // ) = Filename.concat in
  Filename.dirname Sys.executable_name
  // Filename.parent_dir_name // "lib" // "ocaml"

let standard_library_default = standard_library

let syntax_kind = ref `ml

let bs_only = ref true

let unsafe_empty_array = ref false

and cmi_magic_number = "Caml1999I022"

and ast_impl_magic_number = "Caml1999M022"

and ast_intf_magic_number = "Caml1999N022"

and cmt_magic_number = "Caml1999T022"

let load_path = ref ([] : string list)

let interface_suffix = ref ".mli"

(* This is normally the same as in obj.ml, but we have to define it
   separately because it can differ when we're in the middle of a
   bootstrapping phase. *)

let default_uncurry = ref false

let print_config oc =
  let p name valu = Printf.fprintf oc "%s: %s\n" name valu in
  p "version" version;
  p "standard_library_default" standard_library_default;
  p "standard_library" standard_library;

  (* print the magic number *)
  p "cmi_magic_number" cmi_magic_number;
  p "ast_impl_magic_number" ast_impl_magic_number;
  p "ast_intf_magic_number" ast_intf_magic_number;
  p "cmt_magic_number" cmt_magic_number;
  flush oc

end
module Warnings : sig 
#1 "warnings.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Pierre Weis && Damien Doligez, INRIA Rocquencourt          *)
(*                                                                        *)
(*   Copyright 1998 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

type loc = {
  loc_start : Lexing.position;
  loc_end : Lexing.position;
  loc_ghost : bool;
}

type t =
  | Comment_start (*  1 *)
  | Comment_not_end (*  2 *)
  | Deprecated of string * loc * loc (*  3 *)
  | Fragile_match of string (*  4 *)
  | Partial_application (*  5 *)
  | Method_override of string list (*  7 *)
  | Partial_match of string (*  8 *)
  | Non_closed_record_pattern of string (*  9 *)
  | Statement_type (* 10 *)
  | Unused_match (* 11 *)
  | Unused_pat (* 12 *)
  | Instance_variable_override of string list (* 13 *)
  | Illegal_backslash (* 14 *)
  | Implicit_public_methods of string list (* 15 *)
  | Unerasable_optional_argument (* 16 *)
  | Unused_argument (* 20 *)
  | Nonreturning_statement (* 21 *)
  | Preprocessor of string (* 22 *)
  | Useless_record_with (* 23 *)
  | Bad_module_name of string (* 24 *)
  | All_clauses_guarded (* 8, used to be 25 *)
  | Unused_var of string (* 26 *)
  | Unused_var_strict of string (* 27 *)
  | Wildcard_arg_to_constant_constr (* 28 *)
  | Eol_in_string (* 29 *)
  | Duplicate_definitions of string * string * string * string (* 30 *)
  | Unused_value_declaration of string (* 32 *)
  | Unused_open of string (* 33 *)
  | Unused_type_declaration of string (* 34 *)
  | Unused_for_index of string (* 35 *)
  | Unused_constructor of string * bool * bool (* 37 *)
  | Unused_extension of string * bool * bool * bool (* 38 *)
  | Unused_rec_flag (* 39 *)
  | Ambiguous_name of string list * string list * bool (* 41 *)
  | Nonoptional_label of string (* 43 *)
  | Open_shadow_identifier of string * string (* 44 *)
  | Open_shadow_label_constructor of string * string (* 45 *)
  | Attribute_payload of string * string (* 47 *)
  | Eliminated_optional_arguments of string list (* 48 *)
  | No_cmi_file of string * string option (* 49 *)
  | Bad_docstring of bool (* 50 *)
  | Fragile_literal_pattern (* 52 *)
  | Misplaced_attribute of string (* 53 *)
  | Duplicated_attribute of string (* 54 *)
  | Unreachable_case (* 56 *)
  | Ambiguous_pattern of string list (* 57 *)
  | Unused_module of string (* 60 *)
  | Constraint_on_gadt (* 62 *)
  | Bs_unused_attribute of string (* 101 *)
  | Bs_polymorphic_comparison (* 102 *)
  | Bs_ffi_warning of string (* 103 *)
  | Bs_derive_warning of string (* 104 *)
  | Bs_fragile_external of string (* 105 *)
  | Bs_unimplemented_primitive of string (* 106 *)
  | Bs_integer_literal_overflow (* 107 *)
  | Bs_uninterpreted_delimiters of string (* 108 *)
  | Bs_toplevel_expression_unit (* 109 *)
  | Bs_nested_promise of string (* 110 *)

val parse_options : bool -> string -> unit

val without_warnings : (unit -> 'a) -> 'a

val is_active : t -> bool

val is_error : t -> bool

type reporting_information = {
  number : int;
  message : string;
  is_error : bool;
  sub_locs : (loc * string) list;
}

val report : t -> [ `Active of reporting_information | `Inactive ]

exception Errors

val check_fatal : unit -> unit

val reset_fatal : unit -> unit

val help_warnings : unit -> unit

type state

val backup : unit -> state

val restore : state -> unit

val mk_lazy : (unit -> 'a) -> 'a Lazy.t
(** Like [Lazy.of_fun], but the function is applied with
        the warning settings at the time [mk_lazy] is called. *)

val has_warnings : bool ref

val nerrors : int ref

val message : t -> string

val number : t -> int

val reset : unit -> unit

end = struct
#1 "warnings.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Pierre Weis && Damien Doligez, INRIA Rocquencourt          *)
(*                                                                        *)
(*   Copyright 1998 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* When you change this, you need to update the documentation:
   - man/ocamlc.m
   - man/ocamlopt.m
   - manual/manual/cmds/comp.etex
   - manual/manual/cmds/native.etex
*)

type loc = {
  loc_start : Lexing.position;
  loc_end : Lexing.position;
  loc_ghost : bool;
}

type t =
  | Comment_start (*  1 *)
  | Comment_not_end (*  2 *)
  | Deprecated of string * loc * loc (*  3 *)
  | Fragile_match of string (*  4 *)
  | Partial_application (*  5 *)
  | Method_override of string list (*  7 *)
  | Partial_match of string (*  8 *)
  | Non_closed_record_pattern of string (*  9 *)
  | Statement_type (* 10 *)
  | Unused_match (* 11 *)
  | Unused_pat (* 12 *)
  | Instance_variable_override of string list (* 13 *)
  | Illegal_backslash (* 14 *)
  | Implicit_public_methods of string list (* 15 *)
  | Unerasable_optional_argument (* 16 *)
  | Unused_argument (* 20 *)
  | Nonreturning_statement (* 21 *)
  | Preprocessor of string (* 22 *)
  | Useless_record_with (* 23 *)
  | Bad_module_name of string (* 24 *)
  | All_clauses_guarded (* 8, used to be 25 *)
  | Unused_var of string (* 26 *)
  | Unused_var_strict of string (* 27 *)
  | Wildcard_arg_to_constant_constr (* 28 *)
  | Eol_in_string (* 29 *)
  | Duplicate_definitions of string * string * string * string (*30 *)
  | Unused_value_declaration of string (* 32 *)
  | Unused_open of string (* 33 *)
  | Unused_type_declaration of string (* 34 *)
  | Unused_for_index of string (* 35 *)
  | Unused_constructor of string * bool * bool (* 37 *)
  | Unused_extension of string * bool * bool * bool (* 38 *)
  | Unused_rec_flag (* 39 *)
  | Ambiguous_name of string list * string list * bool (* 41 *)
  | Nonoptional_label of string (* 43 *)
  | Open_shadow_identifier of string * string (* 44 *)
  | Open_shadow_label_constructor of string * string (* 45 *)
  | Attribute_payload of string * string (* 47 *)
  | Eliminated_optional_arguments of string list (* 48 *)
  | No_cmi_file of string * string option (* 49 *)
  | Bad_docstring of bool (* 50 *)
  | Fragile_literal_pattern (* 52 *)
  | Misplaced_attribute of string (* 53 *)
  | Duplicated_attribute of string (* 54 *)
  | Unreachable_case (* 56 *)
  | Ambiguous_pattern of string list (* 57 *)
  | Unused_module of string (* 60 *)
  | Constraint_on_gadt (* 62 *)
  | Bs_unused_attribute of string (* 101 *)
  | Bs_polymorphic_comparison (* 102 *)
  | Bs_ffi_warning of string (* 103 *)
  | Bs_derive_warning of string (* 104 *)
  | Bs_fragile_external of string (* 105 *)
  | Bs_unimplemented_primitive of string (* 106 *)
  | Bs_integer_literal_overflow (* 107 *)
  | Bs_uninterpreted_delimiters of string (* 108 *)
  | Bs_toplevel_expression_unit (* 109 *)
  | Bs_nested_promise of string (* 110 *)

(* If you remove a warning, leave a hole in the numbering.  NEVER change
   the numbers of existing warnings.
   If you add a new warning, add it at the end with a new number;
   do NOT reuse one of the holes.
*)

let number = function
  | Comment_start -> 1
  | Comment_not_end -> 2
  | Deprecated _ -> 3
  | Fragile_match _ -> 4
  | Partial_application -> 5
  | Method_override _ -> 7
  | Partial_match _ -> 8
  | Non_closed_record_pattern _ -> 9
  | Statement_type -> 10
  | Unused_match -> 11
  | Unused_pat -> 12
  | Instance_variable_override _ -> 13
  | Illegal_backslash -> 14
  | Implicit_public_methods _ -> 15
  | Unerasable_optional_argument -> 16
  | Unused_argument -> 20
  | Nonreturning_statement -> 21
  | Preprocessor _ -> 22
  | Useless_record_with -> 23
  | Bad_module_name _ -> 24
  | All_clauses_guarded -> 8 (* used to be 25 *)
  | Unused_var _ -> 26
  | Unused_var_strict _ -> 27
  | Wildcard_arg_to_constant_constr -> 28
  | Eol_in_string -> 29
  | Duplicate_definitions _ -> 30
  | Unused_value_declaration _ -> 32
  | Unused_open _ -> 33
  | Unused_type_declaration _ -> 34
  | Unused_for_index _ -> 35
  | Unused_constructor _ -> 37
  | Unused_extension _ -> 38
  | Unused_rec_flag -> 39
  | Ambiguous_name _ -> 41
  | Nonoptional_label _ -> 43
  | Open_shadow_identifier _ -> 44
  | Open_shadow_label_constructor _ -> 45
  | Attribute_payload _ -> 47
  | Eliminated_optional_arguments _ -> 48
  | No_cmi_file _ -> 49
  | Bad_docstring _ -> 50
  | Fragile_literal_pattern -> 52
  | Misplaced_attribute _ -> 53
  | Duplicated_attribute _ -> 54
  | Unreachable_case -> 56
  | Ambiguous_pattern _ -> 57
  | Unused_module _ -> 60
  | Constraint_on_gadt -> 62
  | Bs_unused_attribute _ -> 101
  | Bs_polymorphic_comparison -> 102
  | Bs_ffi_warning _ -> 103
  | Bs_derive_warning _ -> 104
  | Bs_fragile_external _ -> 105
  | Bs_unimplemented_primitive _ -> 106
  | Bs_integer_literal_overflow -> 107
  | Bs_uninterpreted_delimiters _ -> 108
  | Bs_toplevel_expression_unit -> 109
  | Bs_nested_promise _ -> 110

let last_warning_number = 110

let letter_all =
  let rec loop i = if i = 0 then [] else i :: loop (i - 1) in
  loop last_warning_number

(* Must be the max number returned by the [number] function. *)

let letter = function
  | 'a' -> letter_all
  | 'b' -> []
  | 'c' -> [ 1; 2 ]
  | 'd' -> [ 3 ]
  | 'e' -> [ 4 ]
  | 'f' -> [ 5 ]
  | 'g' -> []
  | 'h' -> []
  | 'i' -> []
  | 'j' -> []
  | 'k' -> [ 32; 33; 34; 35; 36; 37; 38; 39 ]
  | 'l' -> [ 6 ]
  | 'm' -> [ 7 ]
  | 'n' -> []
  | 'o' -> []
  | 'p' -> [ 8 ]
  | 'q' -> []
  | 'r' -> [ 9 ]
  | 's' -> [ 10 ]
  | 't' -> []
  | 'u' -> [ 11; 12 ]
  | 'v' -> [ 13 ]
  | 'w' -> []
  | 'x' -> [ 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 30 ]
  | 'y' -> [ 26 ]
  | 'z' -> [ 27 ]
  | _ -> assert false

type state = { active : bool array; error : bool array }

let current =
  ref
    {
      active = Array.make (last_warning_number + 1) true;
      error = Array.make (last_warning_number + 1) false;
    }

let disabled = ref false

let without_warnings f = Misc.protect_refs [ Misc.R (disabled, true) ] f

let backup () = !current

let restore x = current := x

let is_active x = (not !disabled) && !current.active.(number x)

let is_error x = (not !disabled) && !current.error.(number x)

let mk_lazy f =
  let state = backup () in
  lazy
    (let prev = backup () in
     restore state;
     try
       let r = f () in
       restore prev;
       r
     with exn ->
       restore prev;
       raise exn)

let parse_opt error active flags s =
  let set i = flags.(i) <- true in
  let clear i = flags.(i) <- false in
  let set_all i =
    active.(i) <- true;
    error.(i) <- true
  in
  let error () = raise (Arg.Bad "Ill-formed list of warnings") in
  let rec get_num n i =
    if i >= String.length s then (i, n)
    else
      match s.[i] with
      | '0' .. '9' ->
          get_num ((10 * n) + Char.code s.[i] - Char.code '0') (i + 1)
      | _ -> (i, n)
  in
  let get_range i =
    let i, n1 = get_num 0 i in
    if i + 2 < String.length s && s.[i] = '.' && s.[i + 1] = '.' then (
      let i, n2 = get_num 0 (i + 2) in
      if n2 < n1 then error ();
      (i, n1, n2))
    else (i, n1, n1)
  in
  let rec loop i =
    if i >= String.length s then ()
    else
      match s.[i] with
      | 'A' .. 'Z' ->
          List.iter set (letter (Char.lowercase_ascii s.[i]));
          loop (i + 1)
      | 'a' .. 'z' ->
          List.iter clear (letter s.[i]);
          loop (i + 1)
      | '+' -> loop_letter_num set (i + 1)
      | '-' -> loop_letter_num clear (i + 1)
      | '@' -> loop_letter_num set_all (i + 1)
      | _ -> error ()
  and loop_letter_num myset i =
    if i >= String.length s then error ()
    else
      match s.[i] with
      | '0' .. '9' ->
          let i, n1, n2 = get_range i in
          for n = n1 to Ext_pervasives.min_int n2 last_warning_number do
            myset n
          done;
          loop i
      | 'A' .. 'Z' ->
          List.iter myset (letter (Char.lowercase_ascii s.[i]));
          loop (i + 1)
      | 'a' .. 'z' ->
          List.iter myset (letter s.[i]);
          loop (i + 1)
      | _ -> error ()
  in
  loop 0

let parse_options errflag s =
  let error = Array.copy !current.error in
  let active = Array.copy !current.active in
  parse_opt error active (if errflag then error else active) s;
  current := { error; active }

let reset () =
  parse_options false Bsc_warnings.defaults_w;
  parse_options true Bsc_warnings.defaults_warn_error

let () = reset ()

let message = function
  | Comment_start -> "this is the start of a comment."
  | Comment_not_end -> "this is not the end of a comment."
  | Deprecated (s, _, _) ->
      (* Reduce \r\n to \n:
           - Prevents any \r characters being printed on Unix when processing
             Windows sources
           - Prevents \r\r\n being generated on Windows, which affects the
             testsuite
      *)
      "deprecated: " ^ Misc.normalise_eol s
  | Fragile_match "" -> "this pattern-matching is fragile."
  | Fragile_match s ->
      "this pattern-matching is fragile.\n\
       It will remain exhaustive when constructors are added to type " ^ s ^ "."
  | Partial_application ->
      "this function application is partial,\nmaybe some arguments are missing."
  | Method_override [ lab ] -> "the method " ^ lab ^ " is overridden."
  | Method_override (cname :: slist) ->
      String.concat " "
        ("the following methods are overridden by the class" :: cname :: ":\n "
       :: slist)
  | Method_override [] -> assert false
  | Partial_match "" ->
      "You forgot to handle a possible case here, though we don't have more \
       information on the value."
  | Partial_match s ->
      "You forgot to handle a possible case here, for example: \n  " ^ s
  | Non_closed_record_pattern s ->
      "the following labels are not bound in this record pattern: " ^ s
      ^ "\nEither bind these labels explicitly or add ', _' to the pattern."
  | Statement_type ->
      "This expression returns a value, but you're not doing anything with it. \
       If this is on purpose, wrap it with `ignore`."
  | Unused_match -> "this match case is unused."
  | Unused_pat -> "this sub-pattern is unused."
  | Instance_variable_override [ lab ] ->
      "the instance variable " ^ lab ^ " is overridden.\n"
      ^ "The behaviour changed in ocaml 3.10 (previous behaviour was hiding.)"
  | Instance_variable_override (cname :: slist) ->
      String.concat " "
        ("the following instance variables are overridden by the class" :: cname
       :: ":\n " :: slist)
      ^ "\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)"
  | Instance_variable_override [] -> assert false
  | Illegal_backslash -> "illegal backslash escape in string."
  | Implicit_public_methods l ->
      "the following private methods were made public implicitly:\n "
      ^ String.concat " " l ^ "."
  | Unerasable_optional_argument ->
      String.concat ""
        [
          "This optional parameter in final position will, in practice, not be \
           optional.\n";
          "  Reorder the parameters so that at least one non-optional one is \
           in final position or, if all parameters are optional, insert a \
           final ().\n\n";
          "  Explanation: If the final parameter is optional, it'd be unclear \
           whether a function application that omits it should be considered \
           fully applied, or partially applied. Imagine writing `let title = \
           display(\"hello!\")`, only to realize `title` isn't your desired \
           result, but a curried call that takes a final optional argument, \
           e.g. `~showDate`.\n\n";
          "  Formal rule: an optional argument is considered intentionally \
           omitted when the 1st positional (i.e. neither labeled nor optional) \
           argument defined after it is passed in.";
        ]
  | Unused_argument -> "this argument will not be used by the function."
  | Nonreturning_statement ->
      "this statement never returns (or has an unsound type.)"
  | Preprocessor s -> s
  | Useless_record_with -> (
      match !Config.syntax_kind with
      | `ml ->
          "all the fields are explicitly listed in this record:\n\
           the 'with' clause is useless."
      | `rescript ->
          "All the fields are already explicitly listed in this record. You \
           can remove the `...` spread.")
  | Bad_module_name modname ->
      "This file's name is potentially invalid. The build systems \
       conventionally turn a file name into a module name by upper-casing the \
       first letter. " ^ modname ^ " isn't a valid module name.\n"
      ^ "Note: some build systems might e.g. turn kebab-case into CamelCase \
         module, which is why this isn't a hard error."
  | All_clauses_guarded ->
      "this pattern-matching is not exhaustive.\n\
       All clauses in this pattern-matching are guarded."
  | Unused_var v | Unused_var_strict v -> "unused variable " ^ v ^ "."
  | Wildcard_arg_to_constant_constr ->
      "wildcard pattern given as argument to a constant constructor"
  | Eol_in_string ->
      "unescaped end-of-line in a string constant (non-portable code)"
  | Duplicate_definitions (kind, cname, tc1, tc2) ->
      Printf.sprintf "the %s %s is defined in both types %s and %s." kind cname
        tc1 tc2
  | Unused_value_declaration v -> "unused value " ^ v ^ "."
  | Unused_open s -> "unused open " ^ s ^ "."
  | Unused_type_declaration s -> "unused type " ^ s ^ "."
  | Unused_for_index s -> "unused for-loop index " ^ s ^ "."
  | Unused_constructor (s, false, false) -> "unused constructor " ^ s ^ "."
  | Unused_constructor (s, true, _) ->
      "constructor " ^ s
      ^ " is never used to build values.\n\
         (However, this constructor appears in patterns.)"
  | Unused_constructor (s, false, true) ->
      "constructor " ^ s
      ^ " is never used to build values.\n\
         Its type is exported as a private type."
  | Unused_extension (s, is_exception, cu_pattern, cu_privatize) -> (
      let kind =
        if is_exception then "exception" else "extension constructor"
      in
      let name = kind ^ " " ^ s in
      match (cu_pattern, cu_privatize) with
      | false, false -> "unused " ^ name
      | true, _ ->
          name
          ^ " is never used to build values.\n\
             (However, this constructor appears in patterns.)"
      | false, true ->
          name
          ^ " is never used to build values.\n\
             It is exported or rebound as a private extension.")
  | Unused_rec_flag -> "unused rec flag."
  | Ambiguous_name ([ s ], tl, false) ->
      s ^ " belongs to several types: " ^ String.concat " " tl
      ^ "\nThe first one was selected. Please disambiguate if this is wrong."
  | Ambiguous_name (_, _, false) -> assert false
  | Ambiguous_name (_slist, tl, true) ->
      "these field labels belong to several types: " ^ String.concat " " tl
      ^ "\nThe first one was selected. Please disambiguate if this is wrong."
  | Nonoptional_label s -> "the label " ^ s ^ " is not optional."
  | Open_shadow_identifier (kind, s) ->
      Printf.sprintf
        "this open statement shadows the %s identifier %s (which is later used)"
        kind s
  | Open_shadow_label_constructor (kind, s) ->
      Printf.sprintf
        "this open statement shadows the %s %s (which is later used)" kind s
  | Attribute_payload (a, s) ->
      Printf.sprintf "illegal payload for attribute '%s'.\n%s" a s
  | Eliminated_optional_arguments sl ->
      Printf.sprintf "implicit elimination of optional argument%s %s"
        (if List.length sl = 1 then "" else "s")
        (String.concat ", " sl)
  | No_cmi_file (name, None) ->
      "no cmi file was found in path for module " ^ name
  | No_cmi_file (name, Some msg) ->
      Printf.sprintf "no valid cmi file was found in path for module %s. %s"
        name msg
  | Bad_docstring unattached ->
      if unattached then "unattached documentation comment (ignored)"
      else "ambiguous documentation comment"
  | Fragile_literal_pattern ->
      Printf.sprintf
        "Code should not depend on the actual values of\n\
         this constructor's arguments. They are only for information\n\
         and may change in future versions. (See manual section 8.5)"
  | Unreachable_case ->
      "this match case is unreachable.\n\
       Consider replacing it with a refutation case '<pat> -> .'"
  | Misplaced_attribute attr_name ->
      Printf.sprintf "the %S attribute cannot appear in this context" attr_name
  | Duplicated_attribute attr_name ->
      Printf.sprintf
        "the %S attribute is used more than once on this expression" attr_name
  | Ambiguous_pattern vars ->
      let msg =
        let vars = List.sort String.compare vars in
        match vars with
        | [] -> assert false
        | [ x ] -> "variable " ^ x
        | _ :: _ -> "variables " ^ String.concat "," vars
      in
      Printf.sprintf
        "Ambiguous or-pattern variables under guard;\n\
         %s may match different arguments. (See manual section 8.5)" msg
  | Unused_module s -> "unused module " ^ s ^ "."
  | Constraint_on_gadt ->
      "Type constraints do not apply to GADT cases of variant types."
  | Bs_unused_attribute s ->
      "Unused attribute: " ^ s
      ^ "\n\
         This means such annotation is not annotated properly. \n\
         for example, some annotations is only meaningful in externals \n"
  | Bs_polymorphic_comparison ->
      "Polymorphic comparison introduced (maybe unsafe)"
  | Bs_ffi_warning s -> "FFI warning: " ^ s
  | Bs_derive_warning s -> "bs.deriving warning: " ^ s
  | Bs_fragile_external s ->
      s
      ^ " : using an empty string as a shorthand to infer the external's name \
         from the value's name is dangerous when refactoring, and therefore \
         deprecated"
  | Bs_unimplemented_primitive s -> "Unimplemented primitive used:" ^ s
  | Bs_integer_literal_overflow ->
      "Integer literal exceeds the range of representable integers of type int"
  | Bs_uninterpreted_delimiters s -> "Uninterpreted delimiters " ^ s
  | Bs_toplevel_expression_unit ->
      "Toplevel expression is expected to have unit type."
  | Bs_nested_promise s ->
      "Expression uses nested promise type " ^ s ^ " which is unsafe."

let sub_locs = function
  | Deprecated (_, def, use) ->
      [ (def, "Definition"); (use, "Expected signature") ]
  | _ -> []

let has_warnings = ref false

let nerrors = ref 0

type reporting_information = {
  number : int;
  message : string;
  is_error : bool;
  sub_locs : (loc * string) list;
}

let report w =
  match is_active w with
  | false -> `Inactive
  | true ->
      has_warnings := true;
      if is_error w then incr nerrors;
      `Active
        {
          number = number w;
          message = message w;
          is_error = is_error w;
          sub_locs = sub_locs w;
        }

exception Errors

let reset_fatal () = nerrors := 0

let check_fatal () =
  if !nerrors > 0 then (
    nerrors := 0;
    raise Errors)

let descriptions =
  [
    (1, "Suspicious-looking start-of-comment mark.");
    (2, "Suspicious-looking end-of-comment mark.");
    (3, "Deprecated feature.");
    ( 4,
      "Fragile pattern matching: matching that will remain complete even\n\
      \    if additional constructors are added to one of the variant types\n\
      \    matched." );
    ( 5,
      "Partially applied function: expression whose result has function\n\
      \    type and is ignored." );
    (6, "Label omitted in function application.");
    (7, "Method overridden.");
    (8, "Partial match: missing cases in pattern-matching.");
    (9, "Missing fields in a record pattern.");
    ( 10,
      "Expression on the left-hand side of a sequence that doesn't have type\n\
      \    \"unit\" (and that is not a function, see warning number 5)." );
    (11, "Redundant case in a pattern matching (unused match case).");
    (12, "Redundant sub-pattern in a pattern-matching.");
    (13, "Instance variable overridden.");
    (14, "Illegal backslash escape in a string constant.");
    (15, "Private method made public implicitly.");
    (16, "Unerasable optional argument.");
    (17, "Undeclared virtual method.");
    (18, "Non-principal type.");
    (19, "Type without principality.");
    (20, "Unused function argument.");
    (21, "Non-returning statement.");
    (22, "Preprocessor warning.");
    (23, "Useless record \"with\" clause.");
    ( 24,
      "Bad module name: the source file name is not a valid OCaml module name."
    );
    (25, "Deprecated: now part of warning 8.");
    ( 26,
      "Suspicious unused variable: unused variable that is bound\n\
      \    with \"let\" or \"as\", and doesn't start with an underscore (\"_\")\n\
      \    character." );
    ( 27,
      "Innocuous unused variable: unused variable that is not bound with\n\
      \    \"let\" nor \"as\", and doesn't start with an underscore (\"_\")\n\
      \    character." );
    (28, "Wildcard pattern given as argument to a constant constructor.");
    (29, "Unescaped end-of-line in a string constant (non-portable code).");
    ( 30,
      "Two labels or constructors of the same name are defined in two\n\
      \    mutually recursive types." );
    (31, "A module is linked twice in the same executable.");
    (32, "Unused value declaration.");
    (33, "Unused open statement.");
    (34, "Unused type declaration.");
    (35, "Unused for-loop index.");
    (36, "Unused ancestor variable.");
    (37, "Unused constructor.");
    (38, "Unused extension constructor.");
    (39, "Unused rec flag.");
    (41, "Ambiguous constructor or label name.");
    (43, "Nonoptional label applied as optional.");
    (44, "Open statement shadows an already defined identifier.");
    (45, "Open statement shadows an already defined label or constructor.");
    (46, "Error in environment variable.");
    (47, "Illegal attribute payload.");
    (48, "Implicit elimination of optional arguments.");
    (49, "Absent cmi file when looking up module alias.");
    (50, "Unexpected documentation comment.");
    (51, "Warning on non-tail calls if @tailcall present.");
    (52, "Fragile constant pattern.");
    (53, "Attribute cannot appear in this context");
    (54, "Attribute used more than once on an expression");
    (55, "Inlining impossible");
    (56, "Unreachable case in a pattern-matching (based on type information).");
    (57, "Ambiguous or-pattern variables under guard");
    (59, "Assignment to non-mutable value");
    (60, "Unused module declaration");
    (61, "Unboxable type in primitive declaration");
    (62, "Type constraint on GADT type declaration");
    (101, "Unused bs attributes");
    (102, "Polymorphic comparison introduced (maybe unsafe)");
    (103, "Fragile FFI definitions");
    (104, "bs.deriving warning with customized message ");
    ( 105,
      "External name is inferred from val name is unsafe from refactoring when \
       changing value name" );
    (106, "Unimplemented primitive used:");
    ( 107,
      "Integer literal exceeds the range of representable integers of type int"
    );
    (108, "Uninterpreted delimiters (for unicode)");
    (109, "Toplevel expression has unit type");
    (110, "Expression has nested promise type");
  ]

let help_warnings () =
  List.iter (fun (i, s) -> Printf.printf "%3i %s\n" i s) descriptions;
  print_endline "  A all warnings";
  for i = Char.code 'b' to Char.code 'z' do
    let c = Char.chr i in
    match letter c with
    | [] -> ()
    | [ n ] ->
        Printf.printf "  %c Alias for warning %i.\n" (Char.uppercase_ascii c) n
    | l ->
        Printf.printf "  %c warnings %s.\n" (Char.uppercase_ascii c)
          (String.concat ", " (List.map string_of_int l))
  done;
  exit 0

end
module Location : sig 
#1 "location.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Source code locations (ranges of positions), used in parsetree. *)

open Format

type t = Warnings.loc = {
  loc_start: Lexing.position;
  loc_end: Lexing.position;
  loc_ghost: bool;
}

(** Note on the use of Lexing.position in this module.
   If [pos_fname = ""], then use [!input_name] instead.
   If [pos_lnum = -1], then [pos_bol = 0]. Use [pos_cnum] and
     re-parse the file to get the line and character numbers.
   Else all fields are correct.
*)

val none : t
(** An arbitrary value of type [t]; describes an empty ghost range. *)

val in_file : string -> t
(** Return an empty ghost range located in a given file. *)

val init : Lexing.lexbuf -> string -> unit
(** Set the file name and line number of the [lexbuf] to be the start
    of the named file. *)

val curr : Lexing.lexbuf -> t
(** Get the location of the current token from the [lexbuf]. *)

val symbol_rloc: unit -> t
val symbol_gloc: unit -> t

(** [rhs_loc n] returns the location of the symbol at position [n], starting
  at 1, in the current parser rule. *)
val rhs_loc: int -> t

val input_name: string ref
val set_input_name: string -> unit 
val input_lexbuf: Lexing.lexbuf option ref

val get_pos_info: Lexing.position -> string * int * int (* file, line, char *)
val print_loc: formatter -> t -> unit
val print_error: formatter -> t -> unit
val print_error_cur_file: formatter -> unit -> unit

val prerr_warning: t -> Warnings.t -> unit
val echo_eof: unit -> unit
val reset: unit -> unit

val default_printer : formatter -> t -> unit
val printer : (formatter -> t -> unit) ref

val warning_printer : (t -> formatter -> Warnings.t -> unit) ref
(** Hook for intercepting warnings. *)

val formatter_for_warnings : formatter ref

val default_warning_printer : t -> formatter -> Warnings.t -> unit
(** Original warning printer for use in hooks. *)

type 'a loc = {
  txt : 'a;
  loc : t;
}

val mknoloc : 'a -> 'a loc
val mkloc : 'a -> t -> 'a loc

val print: formatter -> t -> unit
val print_compact: formatter -> t -> unit
val print_filename: formatter -> string -> unit

val absolute_path: string -> string

val show_filename: string -> string
    (** In -absname mode, return the absolute path for this filename.
        Otherwise, returns the filename unchanged. *)


val absname: bool ref

(** Support for located errors *)

type error =
  {
    loc: t;
    msg: string;
    sub: error list;
    if_highlight: string; (* alternative message if locations are highlighted *)
  }

exception Already_displayed_error
exception Error of error

val error: ?loc:t -> ?sub:error list -> ?if_highlight:string -> string -> error


val print_error_prefix : Format.formatter -> unit
val pp_ksprintf : ?before:(formatter -> unit) -> (string -> 'a) -> ('b, formatter, unit, 'a) format4 -> 'b 


val errorf: ?loc:t -> ?sub:error list -> ?if_highlight:string
            -> ('a, Format.formatter, unit, error) format4 -> 'a

val raise_errorf: ?loc:t -> ?sub:error list -> ?if_highlight:string
            -> ('a, Format.formatter, unit, 'b) format4 -> 'a

val error_of_printer: t -> (formatter -> 'a -> unit) -> 'a -> error

val error_of_printer_file: (formatter -> 'a -> unit) -> 'a -> error

val error_of_exn: exn -> [ `Ok of error | `Already_displayed ] option

val register_error_of_exn: (exn -> error option) -> unit
(** Each compiler module which defines a custom type of exception
    which can surface as a user-visible error should register
    a "printer" for this exception using [register_error_of_exn].
    The result of the printer is an [error] value containing
    a location, a message, and optionally sub-messages (each of them
    being located as well). *)

val report_error: formatter -> error -> unit

val error_reporter : (formatter -> error -> unit) ref
(** Hook for intercepting error reports. *)

val default_error_reporter : formatter -> error -> unit
(** Original error reporter for use in hooks. *)

val report_exception: formatter -> exn -> unit
(** Reraise the exception if it is unknown. *)

val deprecated: ?def:t -> ?use:t -> t -> string -> unit

end = struct
#1 "location.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

open Lexing

let absname = ref false
    (* This reference should be in Clflags, but it would create an additional
       dependency and make bootstrapping Camlp4 more difficult. *)

type t = Warnings.loc = { loc_start: position; loc_end: position; loc_ghost: bool };;

let in_file name =
  let loc = {
    pos_fname = name;
    pos_lnum = 1;
    pos_bol = 0;
    pos_cnum = -1;
  } in
  { loc_start = loc; loc_end = loc; loc_ghost = true }
;;

let none = in_file "_none_";;

let curr lexbuf = {
  loc_start = lexbuf.lex_start_p;
  loc_end = lexbuf.lex_curr_p;
  loc_ghost = false
};;

let init lexbuf fname =
  lexbuf.lex_curr_p <- {
    pos_fname = fname;
    pos_lnum = 1;
    pos_bol = 0;
    pos_cnum = 0;
  }
;;

let symbol_rloc () = {
  loc_start = Parsing.symbol_start_pos ();
  loc_end = Parsing.symbol_end_pos ();
  loc_ghost = false;
};;

let symbol_gloc () = {
  loc_start = Parsing.symbol_start_pos ();
  loc_end = Parsing.symbol_end_pos ();
  loc_ghost = true;
};;

let rhs_loc n = {
  loc_start = Parsing.rhs_start_pos n;
  loc_end = Parsing.rhs_end_pos n;
  loc_ghost = false;
};;

let input_name = ref "_none_"
let input_lexbuf = ref (None : lexbuf option)
let set_input_name name =
  if name <> "" then input_name := name
(* Terminal info *)



let num_loc_lines = ref 0 (* number of lines already printed after input *)

(* Print the location in some way or another *)

open Format

let absolute_path s = (* This function could go into Filename *)
  let open Filename in
  let s = if is_relative s then concat (Sys.getcwd ()) s else s in
  (* Now simplify . and .. components *)
  let rec aux s =
    let base = basename s in
    let dir = dirname s in
    if dir = s then dir
    else if base = current_dir_name then aux dir
    else if base = parent_dir_name then dirname (aux dir)
    else concat (aux dir) base
  in
  aux s

let show_filename file =
  let file = if file = "_none_"  then !input_name else file in 
  if !absname then absolute_path file else file

let print_filename ppf file =
  Format.fprintf ppf "%s" (show_filename file)

let reset () =
  num_loc_lines := 0

let (msg_file, msg_line, msg_chars, msg_to, msg_colon) =
  ("File \"", "\", line ", ", characters ", "-", ":")

(* return file, line, char from the given position *)
let get_pos_info pos =
  (pos.pos_fname, pos.pos_lnum, pos.pos_cnum - pos.pos_bol)
;;

let setup_colors () =
  Misc.Color.setup !Clflags.color

let print_loc ppf loc =
  setup_colors ();
  let (file, line, startchar) = get_pos_info loc.loc_start in
  let startchar =  startchar + 1 in 
  let endchar = loc.loc_end.pos_cnum - loc.loc_start.pos_cnum + startchar in
  begin
    fprintf ppf "%s@{<loc>%a%s%i" msg_file print_filename file msg_line line;
    if startchar >= 0 then
      fprintf ppf "%s%i%s%i" msg_chars startchar msg_to endchar;
    fprintf ppf "@}"
  end
;;

let default_printer ppf loc =
  setup_colors ();
  fprintf ppf "@{<loc>%a@}%s@," print_loc loc msg_colon
;;

let printer = ref default_printer
let print ppf loc = !printer ppf loc

let error_prefix = "Error"
let warning_prefix = "Warning"

let print_error_prefix ppf =
  setup_colors ();
  fprintf ppf "@{<error>%s@}" error_prefix;
;;

let print_compact ppf loc =
  begin
    let (file, line, startchar) = get_pos_info loc.loc_start in
    let endchar = loc.loc_end.pos_cnum - loc.loc_start.pos_cnum + startchar in
    fprintf ppf "%a:%i" print_filename file line;
    if startchar >= 0 then fprintf ppf ",%i--%i" startchar endchar
  end
;;

let print_error ppf loc =
  fprintf ppf "%a%t:" print loc print_error_prefix;
;;

let print_error_cur_file ppf () = print_error ppf (in_file !input_name);;

let default_warning_printer loc ppf w =
  match Warnings.report w with
  | `Inactive -> ()
  | `Active { Warnings. number; message; is_error; sub_locs } ->
    setup_colors ();
    fprintf ppf "@[<v>";
    print ppf loc;
    if is_error
    then
      fprintf ppf "%t (%s %d): %s@," print_error_prefix
           (String.uncapitalize_ascii warning_prefix) number message
    else fprintf ppf "@{<warning>%s@} %d: %s@," warning_prefix number message;
    List.iter
      (fun (loc, msg) ->
         if loc <> none then fprintf ppf "  %a  %s@," print loc msg
      )
      sub_locs;
    fprintf ppf "@]"
;;

let warning_printer = ref default_warning_printer ;;

let print_warning loc ppf w = 
  !warning_printer loc ppf w  
;;

let formatter_for_warnings = ref err_formatter;;
let prerr_warning loc w = 
    print_warning loc !formatter_for_warnings w;;

let echo_eof () =
  print_newline ();
  incr num_loc_lines

type 'a loc = {
  txt : 'a;
  loc : t;
}

let mkloc txt loc = { txt ; loc }
let mknoloc txt = mkloc txt none


type error =
  {
    loc: t;
    msg: string;
    sub: error list;
    if_highlight: string; (* alternative message if locations are highlighted *)
  }

let pp_ksprintf ?before k fmt =
  let buf = Buffer.create 64 in
  let ppf = Format.formatter_of_buffer buf in
  Misc.Color.set_color_tag_handling ppf;
  begin match before with
    | None -> ()
    | Some f -> f ppf
  end;
  kfprintf
    (fun _ ->
      pp_print_flush ppf ();
      let msg = Buffer.contents buf in
      k msg)
    ppf fmt

(* Shift the formatter's offset by the length of the error prefix, which
   is always added by the compiler after the message has been formatted *)
let print_phanton_error_prefix ppf =
  Format.pp_print_as ppf (String.length error_prefix + 2 (* ": " *)) ""

let errorf ?(loc = none) ?(sub = []) ?(if_highlight = "") fmt =
  pp_ksprintf
    ~before:print_phanton_error_prefix
    (fun msg -> {loc; msg; sub; if_highlight})
    fmt

let error ?(loc = none) ?(sub = []) ?(if_highlight = "") msg =
  {loc; msg; sub; if_highlight}

let error_of_exn : (exn -> error option) list ref = ref []

let register_error_of_exn f = error_of_exn := f :: !error_of_exn

exception Already_displayed_error = Warnings.Errors

let error_of_exn exn =
  match exn with
  | Already_displayed_error -> Some `Already_displayed
  | _ ->
     let rec loop = function
       | [] -> None
       | f :: rest ->
          match f exn with
          | Some error -> Some (`Ok error)
          | None -> loop rest
     in
     loop !error_of_exn


let rec default_error_reporter ppf ({loc; msg; sub}) =
    fprintf ppf "@[<v>%a %s" print_error loc msg;
    List.iter (Format.fprintf ppf "@,@[<2>%a@]" default_error_reporter) sub;
    fprintf ppf "@]"
    
let error_reporter = ref default_error_reporter

let report_error ppf err =
   !error_reporter ppf err
;;

let error_of_printer loc print x =
  errorf ~loc "%a@?" print x

let error_of_printer_file print x =
  error_of_printer (in_file !input_name) print x

let () =
  register_error_of_exn
    (function
      | Sys_error msg ->
          Some (errorf ~loc:(in_file !input_name)
                "I/O error: %s" msg)

      | Misc.HookExnWrapper {error = e; hook_name;
                             hook_info={Misc.sourcefile}} ->
          let sub = match error_of_exn e with
            | None | Some `Already_displayed -> error (Printexc.to_string e)
            | Some (`Ok err) -> err
          in
          Some
            (errorf ~loc:(in_file sourcefile)
               "In hook %S:" hook_name
               ~sub:[sub])
      | _ -> None
    )

external reraise : exn -> 'a = "%reraise"

let rec report_exception_rec n ppf exn =
  try
    match error_of_exn exn with
    | None -> reraise exn
    | Some `Already_displayed -> ()
    | Some (`Ok err) -> fprintf ppf "@[%a@]@." report_error err
  with exn when n > 0 -> report_exception_rec (n-1) ppf exn

let report_exception ppf exn = report_exception_rec 5 ppf exn


exception Error of error

let () =
  register_error_of_exn
    (function
      | Error e -> Some e
      | _ -> None
    )

let raise_errorf ?(loc = none) ?(sub = []) ?(if_highlight = "") =
  pp_ksprintf
    ~before:print_phanton_error_prefix
    (fun msg -> raise (Error ({loc; msg; sub; if_highlight})))

let deprecated ?(def = none) ?(use = none) loc msg =
  prerr_warning loc (Warnings.Deprecated (msg, def, use))

end
module Asttypes
= struct
#1 "asttypes.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Auxiliary AST types used by parsetree and typedtree. *)

type constant =
    Const_int of int
  | Const_char of char
  | Const_string of string * string option
  | Const_float of string
  | Const_int32 of int32
  | Const_int64 of int64
  | Const_nativeint of nativeint

type rec_flag = Nonrecursive | Recursive

type direction_flag = Upto | Downto

(* Order matters, used in polymorphic comparison *)
type private_flag = Private | Public

type mutable_flag = Immutable | Mutable

type virtual_flag = Virtual | Concrete

type override_flag = Override | Fresh

type closed_flag = Closed | Open

type label = string

type arg_label =
    Nolabel
  | Labelled of string (*  label:T -> ... *)
  | Optional of string (* ?label:T -> ... *)

type 'a loc = 'a Location.loc = {
  txt : 'a;
  loc : Location.t;
}


type variance =
  | Covariant
  | Contravariant
  | Invariant


let same_arg_label (x : arg_label) y = 
  match x with 
  | Nolabel -> y = Nolabel
  | Labelled s ->
    begin match y with 
    | Labelled s0 -> s = s0 
    | _ -> false 
    end 
  | Optional s ->
      begin match y with 
      | Optional s0 -> s = s0
      | _ -> false  
      end  
end
module Longident : sig 
#1 "longident.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Long identifiers, used in parsetree. *)

type t =
    Lident of string
  | Ldot of t * string
  | Lapply of t * t

val cmp : t -> t -> int   
val flatten: t -> string list
val unflatten: string list -> t option
val last: t -> string
val parse: string -> t

end = struct
#1 "longident.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

type t =
    Lident of string
  | Ldot of t * string
  | Lapply of t * t
let rec cmp : t -> t -> int =
 fun a b ->
  if a == b then 0
  else
    match (a, b) with
    | Lident a, Lident b -> compare a b
    | Lident _, _ -> -1
    | _, Lident _ -> 1
    | Ldot (a, b), Ldot (c, d) -> (
        match cmp a c with 0 -> compare b d | n -> n)
    | Ldot _, _ -> -1
    | _, Ldot _ -> 1
    | Lapply (a, b), Lapply (c, d) -> (
        match cmp a c with 0 -> cmp b d | n -> n)

let rec flat accu = function
    Lident s -> s :: accu
  | Ldot(lid, s) -> flat (s :: accu) lid
  | Lapply(_, _) -> Misc.fatal_error "Longident.flat"

let flatten lid = flat [] lid

let last = function
    Lident s -> s
  | Ldot(_, s) -> s
  | Lapply(_, _) -> Misc.fatal_error "Longident.last"

let rec split_at_dots s pos =
  try
    let dot = String.index_from s pos '.' in
    String.sub s pos (dot - pos) :: split_at_dots s (dot + 1)
  with Not_found ->
    [String.sub s pos (String.length s - pos)]

let unflatten l =
  match l with
  | [] -> None
  | hd :: tl -> Some (List.fold_left (fun p s -> Ldot(p, s)) (Lident hd) tl)

let parse s =
  match unflatten (split_at_dots s 0) with
  | None -> Lident ""  (* should not happen, but don't put assert false
                          so as not to crash the toplevel (see Genprintval) *)
  | Some v -> v

end
module Parsetree
= struct
#1 "parsetree.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Abstract syntax tree produced by parsing *)

open Asttypes

type constant =
    Pconst_integer of string * char option
  (* 3 3l 3L 3n

     Suffixes [g-z][G-Z] are accepted by the parser.
     Suffixes except 'l', 'L' and 'n' are rejected by the typechecker
  *)
  | Pconst_char of char
  (* 'c' *)
  | Pconst_string of string * string option
  (* "constant"
     {delim|other constant|delim}
  *)
  | Pconst_float of string * char option
  (* 3.4 2e5 1.4e-4

     Suffixes [g-z][G-Z] are accepted by the parser.
     Suffixes are rejected by the typechecker.
  *)

(** {1 Extension points} *)

type attribute = string loc * payload
       (* [@id ARG]
          [@@id ARG]

          Metadata containers passed around within the AST.
          The compiler ignores unknown attributes.
       *)

and extension = string loc * payload
      (* [%id ARG]
         [%%id ARG]

         Sub-language placeholder -- rejected by the typechecker.
      *)

and attributes = attribute list

and payload =
  | PStr of structure
  | PSig of signature (* : SIG *)
  | PTyp of core_type  (* : T *)
  | PPat of pattern * expression option  (* ? P  or  ? P when E *)

(** {1 Core language} *)

(* Type expressions *)

and core_type =
    {
     ptyp_desc: core_type_desc;
     ptyp_loc: Location.t;
     ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and core_type_desc =
  | Ptyp_any
        (*  _ *)
  | Ptyp_var of string
        (* 'a *)
  | Ptyp_arrow of arg_label * core_type * core_type
        (* T1 -> T2       Simple
           ~l:T1 -> T2    Labelled
           ?l:T1 -> T2    Optional
         *)
  | Ptyp_tuple of core_type list
        (* T1 * ... * Tn

           Invariant: n >= 2
        *)
  | Ptyp_constr of Longident.t loc * core_type list
        (* tconstr
           T tconstr
           (T1, ..., Tn) tconstr
         *)
  | Ptyp_object of object_field list * closed_flag
        (* < l1:T1; ...; ln:Tn >     (flag = Closed)
           < l1:T1; ...; ln:Tn; .. > (flag = Open)
         *)
  | Ptyp_class of Longident.t loc * core_type list
        (* #tconstr
           T #tconstr
           (T1, ..., Tn) #tconstr
         *)
  | Ptyp_alias of core_type * string
        (* T as 'a *)
  | Ptyp_variant of row_field list * closed_flag * label list option
        (* [ `A|`B ]         (flag = Closed; labels = None)
           [> `A|`B ]        (flag = Open;   labels = None)
           [< `A|`B ]        (flag = Closed; labels = Some [])
           [< `A|`B > `X `Y ](flag = Closed; labels = Some ["X";"Y"])
         *)
  | Ptyp_poly of string loc list * core_type
        (* 'a1 ... 'an. T

           Can only appear in the following context:

           - As the core_type of a Ppat_constraint node corresponding
             to a constraint on a let-binding: let x : 'a1 ... 'an. T
             = e ...

           - Under Cfk_virtual for methods (not values).

           - As the core_type of a Pctf_method node.

           - As the core_type of a Pexp_poly node.

           - As the pld_type field of a label_declaration.

           - As a core_type of a Ptyp_object node.
         *)

  | Ptyp_package of package_type
        (* (module S) *)
  | Ptyp_extension of extension
        (* [%id] *)

and package_type = Longident.t loc * (Longident.t loc * core_type) list
      (*
        (module S)
        (module S with type t1 = T1 and ... and tn = Tn)
       *)

and row_field =
  | Rtag of label loc * attributes * bool * core_type list
        (* [`A]                   ( true,  [] )
           [`A of T]              ( false, [T] )
           [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )
           [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )

          - The 2nd field is true if the tag contains a
            constant (empty) constructor.
          - '&' occurs when several types are used for the same constructor
            (see 4.2 in the manual)

          - TODO: switch to a record representation, and keep location
        *)
  | Rinherit of core_type
        (* [ T ] *)

and object_field =
  | Otag of label loc * attributes * core_type
  | Oinherit of core_type

(* Patterns *)

and pattern =
    {
     ppat_desc: pattern_desc;
     ppat_loc: Location.t;
     ppat_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and pattern_desc =
  | Ppat_any
        (* _ *)
  | Ppat_var of string loc
        (* x *)
  | Ppat_alias of pattern * string loc
        (* P as 'a *)
  | Ppat_constant of constant
        (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
  | Ppat_interval of constant * constant
        (* 'a'..'z'

           Other forms of interval are recognized by the parser
           but rejected by the type-checker. *)
  | Ppat_tuple of pattern list
        (* (P1, ..., Pn)

           Invariant: n >= 2
        *)
  | Ppat_construct of Longident.t loc * pattern option
        (* C                None
           C P              Some P
           C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])
         *)
  | Ppat_variant of label * pattern option
        (* `A             (None)
           `A P           (Some P)
         *)
  | Ppat_record of (Longident.t loc * pattern) list * closed_flag
        (* { l1=P1; ...; ln=Pn }     (flag = Closed)
           { l1=P1; ...; ln=Pn; _}   (flag = Open)

           Invariant: n > 0
         *)
  | Ppat_array of pattern list
        (* [| P1; ...; Pn |] *)
  | Ppat_or of pattern * pattern
        (* P1 | P2 *)
  | Ppat_constraint of pattern * core_type
        (* (P : T) *)
  | Ppat_type of Longident.t loc
        (* #tconst *)
  | Ppat_lazy of pattern
        (* lazy P *)
  | Ppat_unpack of string loc
        (* (module P)
           Note: (module P : S) is represented as
           Ppat_constraint(Ppat_unpack, Ptyp_package)
         *)
  | Ppat_exception of pattern
        (* exception P *)
  | Ppat_extension of extension
        (* [%id] *)
  | Ppat_open of Longident.t loc * pattern
        (* M.(P) *)

(* Value expressions *)

and expression =
    {
     pexp_desc: expression_desc;
     pexp_loc: Location.t;
     pexp_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and expression_desc =
  | Pexp_ident of Longident.t loc
        (* x
           M.x
         *)
  | Pexp_constant of constant
        (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
  | Pexp_let of rec_flag * value_binding list * expression
        (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
           let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
         *)
  | Pexp_function of case list
        (* function P1 -> E1 | ... | Pn -> En *)
  | Pexp_fun of arg_label * expression option * pattern * expression
        (* fun P -> E1                          (Simple, None)
           fun ~l:P -> E1                       (Labelled l, None)
           fun ?l:P -> E1                       (Optional l, None)
           fun ?l:(P = E0) -> E1                (Optional l, Some E0)

           Notes:
           - If E0 is provided, only Optional is allowed.
           - "fun P1 P2 .. Pn -> E1" is represented as nested Pexp_fun.
           - "let f P = E" is represented using Pexp_fun.
         *)
  | Pexp_apply of expression * (arg_label * expression) list
        (* E0 ~l1:E1 ... ~ln:En
           li can be empty (non labeled argument) or start with '?'
           (optional argument).

           Invariant: n > 0
         *)
  | Pexp_match of expression * case list
        (* match E0 with P1 -> E1 | ... | Pn -> En *)
  | Pexp_try of expression * case list
        (* try E0 with P1 -> E1 | ... | Pn -> En *)
  | Pexp_tuple of expression list
        (* (E1, ..., En)

           Invariant: n >= 2
        *)
  | Pexp_construct of Longident.t loc * expression option
        (* C                None
           C E              Some E
           C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])
        *)
  | Pexp_variant of label * expression option
        (* `A             (None)
           `A E           (Some E)
         *)
  | Pexp_record of (Longident.t loc * expression) list * expression option
        (* { l1=P1; ...; ln=Pn }     (None)
           { E0 with l1=P1; ...; ln=Pn }   (Some E0)

           Invariant: n > 0
         *)
  | Pexp_field of expression * Longident.t loc
        (* E.l *)
  | Pexp_setfield of expression * Longident.t loc * expression
        (* E1.l <- E2 *)
  | Pexp_array of expression list
        (* [| E1; ...; En |] *)
  | Pexp_ifthenelse of expression * expression * expression option
        (* if E1 then E2 else E3 *)
  | Pexp_sequence of expression * expression
        (* E1; E2 *)
  | Pexp_while of expression * expression
        (* while E1 do E2 done *)
  | Pexp_for of
      pattern *  expression * expression * direction_flag * expression
        (* for i = E1 to E2 do E3 done      (flag = Upto)
           for i = E1 downto E2 do E3 done  (flag = Downto)
         *)
  | Pexp_constraint of expression * core_type
        (* (E : T) *)
  | Pexp_coerce of expression * core_type option * core_type
        (* (E :> T)        (None, T)
           (E : T0 :> T)   (Some T0, T)
         *)
  | Pexp_send of expression * label loc
        (*  E # m *)
  | Pexp_new of Longident.t loc
        (* new M.c *)
  | Pexp_setinstvar of label loc * expression
        (* x <- 2 *)
  | Pexp_override of (label loc * expression) list
        (* {< x1 = E1; ...; Xn = En >} *)
  | Pexp_letmodule of string loc * module_expr * expression
        (* let module M = ME in E *)
  | Pexp_letexception of extension_constructor * expression
        (* let exception C in E *)
  | Pexp_assert of expression
        (* assert E
           Note: "assert false" is treated in a special way by the
           type-checker. *)
  | Pexp_lazy of expression
        (* lazy E *)
  | Pexp_poly of expression * core_type option
        (* Used for method bodies.

           Can only be used as the expression under Cfk_concrete
           for methods (not values). *)
  | Pexp_object of class_structure
        (* object ... end *)
  | Pexp_newtype of string loc * expression
        (* fun (type t) -> E *)
  | Pexp_pack of module_expr
        (* (module ME)

           (module ME : S) is represented as
           Pexp_constraint(Pexp_pack, Ptyp_package S) *)
  | Pexp_open of override_flag * Longident.t loc * expression
        (* M.(E)
           let open M in E
           let! open M in E *)
  | Pexp_extension of extension
        (* [%id] *)
  | Pexp_unreachable
        (* . *)

and case =   (* (P -> E) or (P when E0 -> E) *)
    {
     pc_lhs: pattern;
     pc_guard: expression option;
     pc_rhs: expression;
    }

(* Value descriptions *)

and value_description =
    {
     pval_name: string loc;
     pval_type: core_type;
     pval_prim: string list;
     pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)
     pval_loc: Location.t;
    }

(*
  val x: T                            (prim = [])
  external x: T = "s1" ... "sn"       (prim = ["s1";..."sn"])
*)

(* Type declarations *)

and type_declaration =
    {
     ptype_name: string loc;
     ptype_params: (core_type * variance) list;
           (* ('a1,...'an) t; None represents  _*)
     ptype_cstrs: (core_type * core_type * Location.t) list;
           (* ... constraint T1=T1'  ... constraint Tn=Tn' *)
     ptype_kind: type_kind;
     ptype_private: private_flag;   (* = private ... *)
     ptype_manifest: core_type option;  (* = T *)
     ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)
     ptype_loc: Location.t;
    }

(*
  type t                     (abstract, no manifest)
  type t = T0                (abstract, manifest=T0)
  type t = C of T | ...      (variant,  no manifest)
  type t = T0 = C of T | ... (variant,  manifest=T0)
  type t = {l: T; ...}       (record,   no manifest)
  type t = T0 = {l : T; ...} (record,   manifest=T0)
  type t = ..                (open,     no manifest)
*)

and type_kind =
  | Ptype_abstract
  | Ptype_variant of constructor_declaration list
        (* Invariant: non-empty list *)
  | Ptype_record of label_declaration list
        (* Invariant: non-empty list *)
  | Ptype_open

and label_declaration =
    {
     pld_name: string loc;
     pld_mutable: mutable_flag;
     pld_type: core_type;
     pld_loc: Location.t;
     pld_attributes: attributes; (* l : T [@id1] [@id2] *)
    }

(*  { ...; l: T; ... }            (mutable=Immutable)
    { ...; mutable l: T; ... }    (mutable=Mutable)

    Note: T can be a Ptyp_poly.
*)

and constructor_declaration =
    {
     pcd_name: string loc;
     pcd_args: constructor_arguments;
     pcd_res: core_type option;
     pcd_loc: Location.t;
     pcd_attributes: attributes; (* C of ... [@id1] [@id2] *)
    }

and constructor_arguments =
  | Pcstr_tuple of core_type list
  | Pcstr_record of label_declaration list

(*
  | C of T1 * ... * Tn     (res = None,    args = Pcstr_tuple [])
  | C: T0                  (res = Some T0, args = [])
  | C: T1 * ... * Tn -> T0 (res = Some T0, args = Pcstr_tuple)
  | C of {...}             (res = None,    args = Pcstr_record)
  | C: {...} -> T0         (res = Some T0, args = Pcstr_record)
  | C of {...} as t        (res = None,    args = Pcstr_record)
*)

and type_extension =
    {
     ptyext_path: Longident.t loc;
     ptyext_params: (core_type * variance) list;
     ptyext_constructors: extension_constructor list;
     ptyext_private: private_flag;
     ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)
    }
(*
  type t += ...
*)

and extension_constructor =
    {
     pext_name: string loc;
     pext_kind : extension_constructor_kind;
     pext_loc : Location.t;
     pext_attributes: attributes; (* C of ... [@id1] [@id2] *)
    }

and extension_constructor_kind =
    Pext_decl of constructor_arguments * core_type option
      (*
         | C of T1 * ... * Tn     ([T1; ...; Tn], None)
         | C: T0                  ([], Some T0)
         | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)
       *)
  | Pext_rebind of Longident.t loc
      (*
         | C = D
       *)

(** {1 Class language} *)

(* Type expressions for the class language *)

and class_type =
    {
     pcty_desc: class_type_desc;
     pcty_loc: Location.t;
     pcty_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and class_type_desc =
  | Pcty_constr of Longident.t loc * core_type list
        (* c
           ['a1, ..., 'an] c *)
  | Pcty_signature of class_signature
        (* object ... end *)
  | Pcty_arrow of arg_label * core_type * class_type
        (* T -> CT       Simple
           ~l:T -> CT    Labelled l
           ?l:T -> CT    Optional l
         *)
  | Pcty_extension of extension
        (* [%id] *)
  | Pcty_open of override_flag * Longident.t loc * class_type
        (* let open M in CT *)

and class_signature =
    {
     pcsig_self: core_type;
     pcsig_fields: class_type_field list;
    }
(* object('selfpat) ... end
   object ... end             (self = Ptyp_any)
 *)

and class_type_field =
    {
     pctf_desc: class_type_field_desc;
     pctf_loc: Location.t;
     pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)
    }

and class_type_field_desc =
  | Pctf_inherit of class_type
        (* inherit CT *)
  | Pctf_val of (label loc * mutable_flag * virtual_flag * core_type)
        (* val x: T *)
  | Pctf_method  of (label loc * private_flag * virtual_flag * core_type)
        (* method x: T

           Note: T can be a Ptyp_poly.
         *)
  | Pctf_constraint  of (core_type * core_type)
        (* constraint T1 = T2 *)
  | Pctf_attribute of attribute
        (* [@@@id] *)
  | Pctf_extension of extension
        (* [%%id] *)

and 'a class_infos =
    {
     pci_virt: virtual_flag;
     pci_params: (core_type * variance) list;
     pci_name: string loc;
     pci_expr: 'a;
     pci_loc: Location.t;
     pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)
    }
(* class c = ...
   class ['a1,...,'an] c = ...
   class virtual c = ...

   Also used for "class type" declaration.
*)



and class_type_declaration = class_type class_infos

(* Value expressions for the class language *)

and class_expr =
    {
     pcl_desc: class_expr_desc;
     pcl_loc: Location.t;
     pcl_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and class_expr_desc =
  | Pcl_constr of Longident.t loc * core_type list
        (* c
           ['a1, ..., 'an] c *)
  | Pcl_structure of class_structure
        (* object ... end *)
  | Pcl_fun of arg_label * expression option * pattern * class_expr
        (* fun P -> CE                          (Simple, None)
           fun ~l:P -> CE                       (Labelled l, None)
           fun ?l:P -> CE                       (Optional l, None)
           fun ?l:(P = E0) -> CE                (Optional l, Some E0)
         *)
  | Pcl_apply of class_expr * (arg_label * expression) list
        (* CE ~l1:E1 ... ~ln:En
           li can be empty (non labeled argument) or start with '?'
           (optional argument).

           Invariant: n > 0
         *)
  | Pcl_let of rec_flag * value_binding list * class_expr
        (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)
           let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)
         *)
  | Pcl_constraint of class_expr * class_type
        (* (CE : CT) *)
  | Pcl_extension of extension
  (* [%id] *)
  | Pcl_open of override_flag * Longident.t loc * class_expr
  (* let open M in CE *)


and class_structure =
    {
     pcstr_self: pattern;
     pcstr_fields: class_field list;
    }
(* object(selfpat) ... end
   object ... end           (self = Ppat_any)
 *)

and class_field =
    {
     pcf_desc: class_field_desc;
     pcf_loc: Location.t;
     pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)
    }

and class_field_desc =
  | Pcf_inherit of unit
        (* inherit CE
           inherit CE as x
           inherit! CE
           inherit! CE as x
         *)
  | Pcf_val of (label loc * mutable_flag * class_field_kind)
        (* val x = E
           val virtual x: T
         *)
  | Pcf_method of (label loc * private_flag * class_field_kind)
        (* method x = E            (E can be a Pexp_poly)
           method virtual x: T     (T can be a Ptyp_poly)
         *)
  | Pcf_constraint of (core_type * core_type)
        (* constraint T1 = T2 *)
  | Pcf_initializer of expression
        (* initializer E *)
  | Pcf_attribute of attribute
        (* [@@@id] *)
  | Pcf_extension of extension
        (* [%%id] *)

and class_field_kind =
  | Cfk_virtual of core_type
  | Cfk_concrete of override_flag * expression



(** {1 Module language} *)

(* Type expressions for the module language *)

and module_type =
    {
     pmty_desc: module_type_desc;
     pmty_loc: Location.t;
     pmty_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and module_type_desc =
  | Pmty_ident of Longident.t loc
        (* S *)
  | Pmty_signature of signature
        (* sig ... end *)
  | Pmty_functor of string loc * module_type option * module_type
        (* functor(X : MT1) -> MT2 *)
  | Pmty_with of module_type * with_constraint list
        (* MT with ... *)
  | Pmty_typeof of module_expr
        (* module type of ME *)
  | Pmty_extension of extension
        (* [%id] *)
  | Pmty_alias of Longident.t loc
        (* (module M) *)

and signature = signature_item list

and signature_item =
    {
     psig_desc: signature_item_desc;
     psig_loc: Location.t;
    }

and signature_item_desc =
  | Psig_value of value_description
        (*
          val x: T
          external x: T = "s1" ... "sn"
         *)
  | Psig_type of rec_flag * type_declaration list
        (* type t1 = ... and ... and tn = ... *)
  | Psig_typext of type_extension
        (* type t1 += ... *)
  | Psig_exception of extension_constructor
        (* exception C of T *)
  | Psig_module of module_declaration
        (* module X : MT *)
  | Psig_recmodule of module_declaration list
        (* module rec X1 : MT1 and ... and Xn : MTn *)
  | Psig_modtype of module_type_declaration
        (* module type S = MT
           module type S *)
  | Psig_open of open_description
        (* open X *)
  | Psig_include of include_description
        (* include MT *)
  | Psig_class of unit
        (* class c1 : ... and ... and cn : ... *)
  | Psig_class_type of class_type_declaration list
        (* class type ct1 = ... and ... and ctn = ... *)
  | Psig_attribute of attribute
        (* [@@@id] *)
  | Psig_extension of extension * attributes
        (* [%%id] *)

and module_declaration =
    {
     pmd_name: string loc;
     pmd_type: module_type;
     pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)
     pmd_loc: Location.t;
    }
(* S : MT *)

and module_type_declaration =
    {
     pmtd_name: string loc;
     pmtd_type: module_type option;
     pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)
     pmtd_loc: Location.t;
    }
(* S = MT
   S       (abstract module type declaration, pmtd_type = None)
*)

and open_description =
    {
     popen_lid: Longident.t loc;
     popen_override: override_flag;
     popen_loc: Location.t;
     popen_attributes: attributes;
    }
(* open! X - popen_override = Override (silences the 'used identifier
                              shadowing' warning)
   open  X - popen_override = Fresh
 *)

and 'a include_infos =
    {
     pincl_mod: 'a;
     pincl_loc: Location.t;
     pincl_attributes: attributes;
    }

and include_description = module_type include_infos
(* include MT *)

and include_declaration = module_expr include_infos
(* include ME *)

and with_constraint =
  | Pwith_type of Longident.t loc * type_declaration
        (* with type X.t = ...

           Note: the last component of the longident must match
           the name of the type_declaration. *)
  | Pwith_module of Longident.t loc * Longident.t loc
        (* with module X.Y = Z *)
  | Pwith_typesubst of Longident.t loc * type_declaration
        (* with type X.t := ..., same format as [Pwith_type] *)
  | Pwith_modsubst of Longident.t loc * Longident.t loc
        (* with module X.Y := Z *)

(* Value expressions for the module language *)

and module_expr =
    {
     pmod_desc: module_expr_desc;
     pmod_loc: Location.t;
     pmod_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and module_expr_desc =
  | Pmod_ident of Longident.t loc
        (* X *)
  | Pmod_structure of structure
        (* struct ... end *)
  | Pmod_functor of string loc * module_type option * module_expr
        (* functor(X : MT1) -> ME *)
  | Pmod_apply of module_expr * module_expr
        (* ME1(ME2) *)
  | Pmod_constraint of module_expr * module_type
        (* (ME : MT) *)
  | Pmod_unpack of expression
        (* (val E) *)
  | Pmod_extension of extension
        (* [%id] *)

and structure = structure_item list

and structure_item =
    {
     pstr_desc: structure_item_desc;
     pstr_loc: Location.t;
    }

and structure_item_desc =
  | Pstr_eval of expression * attributes
        (* E *)
  | Pstr_value of rec_flag * value_binding list
        (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)
           let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)
         *)
  | Pstr_primitive of value_description
        (*  val x: T
            external x: T = "s1" ... "sn" *)
  | Pstr_type of rec_flag * type_declaration list
        (* type t1 = ... and ... and tn = ... *)
  | Pstr_typext of type_extension
        (* type t1 += ... *)
  | Pstr_exception of extension_constructor
        (* exception C of T
           exception C = M.X *)
  | Pstr_module of module_binding
        (* module X = ME *)
  | Pstr_recmodule of module_binding list
        (* module rec X1 = ME1 and ... and Xn = MEn *)
  | Pstr_modtype of module_type_declaration
        (* module type S = MT *)
  | Pstr_open of open_description
        (* open X *)
  | Pstr_class of unit
        (* Dummy AST node *)
  | Pstr_class_type of class_type_declaration list
        (* class type ct1 = ... and ... and ctn = ... *)
  | Pstr_include of include_declaration
        (* include ME *)
  | Pstr_attribute of attribute
        (* [@@@id] *)
  | Pstr_extension of extension * attributes
        (* [%%id] *)

and value_binding =
  {
    pvb_pat: pattern;
    pvb_expr: expression;
    pvb_attributes: attributes;
    pvb_loc: Location.t;
  }

and module_binding =
    {
     pmb_name: string loc;
     pmb_expr: module_expr;
     pmb_attributes: attributes;
     pmb_loc: Location.t;
    }
(* X = ME *)


end
module Builtin_attributes : sig 
#1 "builtin_attributes.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2012 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Support for some of the builtin attributes:

   ocaml.deprecated
   ocaml.error
   ocaml.ppwarning
   ocaml.warning
   ocaml.warnerror
   ocaml.explicit_arity (for camlp4/camlp5)
   ocaml.warn_on_literal_pattern
   ocaml.deprecated_mutable
   ocaml.immediate
   ocaml.boxed / ocaml.unboxed
*)


val check_deprecated: Location.t -> Parsetree.attributes -> string -> unit
val check_deprecated_inclusion:
  def:Location.t -> use:Location.t -> Location.t -> Parsetree.attributes ->
  Parsetree.attributes -> string -> unit
val deprecated_of_attrs: Parsetree.attributes -> string option
val deprecated_of_sig: Parsetree.signature -> string option
val deprecated_of_str: Parsetree.structure -> string option

val check_deprecated_mutable:
    Location.t -> Parsetree.attributes -> string -> unit
val check_deprecated_mutable_inclusion:
  def:Location.t -> use:Location.t -> Location.t -> Parsetree.attributes ->
  Parsetree.attributes -> string -> unit

val check_bs_attributes_inclusion:
  (Parsetree.attributes ->
  Parsetree.attributes -> string -> (string*string) option ) ref

val check_duplicated_labels: 
  (Parsetree.label_declaration list ->
    string Asttypes.loc option
  ) ref    
val error_of_extension: Parsetree.extension -> Location.error

val warning_attribute: ?ppwarning:bool -> Parsetree.attribute -> unit
  (** Apply warning settings from the specified attribute.
      "ocaml.warning"/"ocaml.warnerror" (and variants without the prefix)
      are processed and other attributes are ignored.

      Also implement ocaml.ppwarning (unless ~ppwarning:false is
      passed).
  *)

val warning_scope:
  ?ppwarning:bool ->
  Parsetree.attributes -> (unit -> 'a) -> 'a
  (** Execute a function in a new scope for warning settings.  This
      means that the effect of any call to [warning_attribute] during
      the execution of this function will be discarded after
      execution.

      The function also takes a list of attributes which are processed
      with [warning_attribute] in the fresh scope before the function
      is executed.
  *)

val warn_on_literal_pattern: Parsetree.attributes -> bool
val explicit_arity: Parsetree.attributes -> bool


val immediate: Parsetree.attributes -> bool

val has_unboxed: Parsetree.attributes -> bool
val has_boxed: Parsetree.attributes -> bool

end = struct
#1 "builtin_attributes.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2012 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

open Asttypes
open Parsetree

let string_of_cst = function
  | Pconst_string(s, _) -> Some s
  | _ -> None

let string_of_payload = function
  | PStr[{pstr_desc=Pstr_eval({pexp_desc=Pexp_constant c},_)}] ->
      string_of_cst c
  | _ -> None

let string_of_opt_payload p =
  match string_of_payload p with
  | Some s -> s
  | None -> ""

let rec error_of_extension ext =
  match ext with
  | ({txt = ("ocaml.error"|"error") as txt; loc}, p) ->
    let rec sub_from inner =
      match inner with
      | {pstr_desc=Pstr_extension (ext, _)} :: rest ->
          error_of_extension ext :: sub_from rest
      | _ :: rest ->
          (Location.errorf ~loc
             "Invalid syntax for sub-error of extension '%s'." txt) ::
            sub_from rest
      | [] -> []
    in
    begin match p with
    | PStr [] -> raise Location.Already_displayed_error
    | PStr({pstr_desc=Pstr_eval
              ({pexp_desc=Pexp_constant(Pconst_string(msg,_))}, _)}::
           {pstr_desc=Pstr_eval
              ({pexp_desc=Pexp_constant(Pconst_string(if_highlight,_))}, _)}::
           inner) ->
        Location.error ~loc ~if_highlight ~sub:(sub_from inner) msg
    | PStr({pstr_desc=Pstr_eval
              ({pexp_desc=Pexp_constant(Pconst_string(msg,_))}, _)}::inner) ->
        Location.error ~loc ~sub:(sub_from inner) msg
    | _ -> Location.errorf ~loc "Invalid syntax for extension '%s'." txt
    end
  | ({txt; loc}, _) ->
      Location.errorf ~loc "Uninterpreted extension '%s'." txt

let cat s1 s2 =
  if s2 = "" then s1 else
    if Clflags.bs_vscode then s1 ^ " " ^ s2
    (* 2 spaces indentation for the next line *)
    else s1 ^ "\n  " ^ s2 

let rec deprecated_of_attrs = function
  | [] -> None
  | ({txt = "ocaml.deprecated"|"deprecated"; _}, p) :: _ ->
      Some (string_of_opt_payload p)
  | _ :: tl -> deprecated_of_attrs tl

let check_deprecated loc attrs s =
  match deprecated_of_attrs attrs with
  | None -> ()
  | Some txt -> Location.deprecated loc (cat s txt)

let check_deprecated_inclusion ~def ~use loc attrs1 attrs2 s =
  match deprecated_of_attrs attrs1, deprecated_of_attrs attrs2 with
  | None, _ | Some _, Some _ -> ()
  | Some txt, None -> Location.deprecated ~def ~use loc (cat s txt)

let rec deprecated_mutable_of_attrs = function
  | [] -> None
  | ({txt = "ocaml.deprecated_mutable"|"deprecated_mutable"; _}, p) :: _ ->
      Some (string_of_opt_payload p)
  | _ :: tl -> deprecated_mutable_of_attrs tl

let check_deprecated_mutable loc attrs s =
  match deprecated_mutable_of_attrs attrs with
  | None -> ()
  | Some txt ->
      Location.deprecated loc (Printf.sprintf "mutating field %s" (cat s txt))

let check_deprecated_mutable_inclusion ~def ~use loc attrs1 attrs2 s =
  match deprecated_mutable_of_attrs attrs1,
        deprecated_mutable_of_attrs attrs2
  with
  | None, _ | Some _, Some _ -> ()
  | Some txt, None ->
      Location.deprecated ~def ~use loc
        (Printf.sprintf "mutating field %s" (cat s txt))

let check_bs_attributes_inclusion = 
  ref (fun _attrs1 _attrs2 _s -> 
      None
    )  

let check_duplicated_labels : (_ -> _ option ) ref = ref (fun _lbls -> 
  None
)

let rec deprecated_of_sig = function
  | {psig_desc = Psig_attribute a} :: tl ->
      begin match deprecated_of_attrs [a] with
      | None -> deprecated_of_sig tl
      | Some _ as r -> r
      end
  | _ -> None


let rec deprecated_of_str = function
  | {pstr_desc = Pstr_attribute a} :: tl ->
      begin match deprecated_of_attrs [a] with
      | None -> deprecated_of_str tl
      | Some _ as r -> r
      end
  | _ -> None


let warning_attribute ?(ppwarning = true) =
  let process loc txt errflag payload =
    match string_of_payload payload with
    | Some s ->
        begin try Warnings.parse_options errflag s
        with Arg.Bad _ ->
          Location.prerr_warning loc
            (Warnings.Attribute_payload
               (txt, "Ill-formed list of warnings"))
        end
    | None ->
        Location.prerr_warning loc
          (Warnings.Attribute_payload
             (txt, "A single string literal is expected"))
  in
  function
  | ({txt = ("ocaml.warning"|"warning") as txt; loc}, payload) ->
      process loc txt false payload
  | ({txt = ("ocaml.warnerror"|"warnerror") as txt; loc}, payload) ->
      process loc txt true payload
  | {txt="ocaml.ppwarning"|"ppwarning"},
    PStr[{pstr_desc=Pstr_eval({pexp_desc=Pexp_constant
                                   (Pconst_string (s, _))},_);
          pstr_loc}] when ppwarning ->
      Location.prerr_warning pstr_loc (Warnings.Preprocessor s)
  | _ ->
      ()

let warning_scope ?ppwarning attrs f =
  let prev = Warnings.backup () in
  try
    List.iter (warning_attribute ?ppwarning) (List.rev attrs);
    let ret = f () in
    Warnings.restore prev;
    ret
  with exn ->
    Warnings.restore prev;
    raise exn


let warn_on_literal_pattern =
  List.exists
    (function
      | ({txt="ocaml.warn_on_literal_pattern"|"warn_on_literal_pattern"; _}, _)
        -> true
      | _ -> false
    )

let explicit_arity =
  List.exists
    (function
      | ({txt="ocaml.explicit_arity"|"explicit_arity"; _}, _) -> true
      | _ -> false
    )

let immediate =
  List.exists
    (function
      | ({txt="ocaml.immediate"|"immediate"; _}, _) -> true
      | _ -> false
    )

(* The "ocaml.boxed (default)" and "ocaml.unboxed (default)"
   attributes cannot be input by the user, they are added by the
   compiler when applying the default setting. This is done to record
   in the .cmi the default used by the compiler when compiling the
   source file because the default can change between compiler
   invocations. *)

let check l (x, _) = List.mem x.txt l

let has_unboxed attr =
  List.exists (check ["ocaml.unboxed"; "unboxed"])
    attr

let has_boxed attr =
  List.exists (check ["ocaml.boxed"; "boxed"]) attr

end
module Depend : sig 
#1 "depend.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1999 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Module dependencies. *)

module StringSet : Set.S with type elt = string
module StringMap : Map.S with type key = string

type map_tree = Node of StringSet.t * bound_map
and  bound_map = map_tree StringMap.t
val make_leaf : string -> map_tree
val make_node : bound_map -> map_tree
val weaken_map : StringSet.t -> map_tree -> map_tree

val free_structure_names : StringSet.t ref

(* dependencies found by preprocessing tools (plugins) *)
val pp_deps : string list ref

val open_module : bound_map -> Longident.t -> bound_map



val add_signature : bound_map -> Parsetree.signature -> unit

val add_implementation : bound_map -> Parsetree.structure -> unit

val add_implementation_binding : bound_map -> Parsetree.structure -> bound_map
val add_signature_binding : bound_map -> Parsetree.signature -> bound_map

end = struct
#1 "depend.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1999 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

open Asttypes
open Location
open Longident
open Parsetree

let pp_deps = ref []

module StringSet = Set.Make(struct type t = string let compare = compare end)
module StringMap = Map.Make(String)

(* Module resolution map *)
(* Node (set of imports for this path, map for submodules) *)
type map_tree = Node of StringSet.t * bound_map
and  bound_map = map_tree StringMap.t
let bound = Node (StringSet.empty, StringMap.empty)

(*let get_free (Node (s, _m)) = s*)
let get_map (Node (_s, m)) = m
let make_leaf s = Node (StringSet.singleton s, StringMap.empty)
let make_node m =  Node (StringSet.empty, m)
let rec weaken_map s (Node(s0,m0)) =
  Node (StringSet.union s s0, StringMap.map (weaken_map s) m0)
let rec collect_free (Node (s, m)) =
  StringMap.fold (fun _ n -> StringSet.union (collect_free n)) m s

(* Returns the imports required to access the structure at path p *)
(* Only raises Not_found if the head of p is not in the toplevel map *)
let rec lookup_free p m =
  match p with
    [] -> raise Not_found
  | s::p ->
      let Node (f, m') = StringMap.find s m  in
      try lookup_free p m' with Not_found -> f

(* Returns the node corresponding to the structure at path p *)
let rec lookup_map lid m =
  match lid with
    Lident s    -> StringMap.find s m
  | Ldot (l, s) -> StringMap.find s (get_map (lookup_map l m))
  | Lapply _    -> raise Not_found

(* Collect free module identifiers in the a.s.t. *)

let free_structure_names = ref StringSet.empty

let add_names s =
  free_structure_names := StringSet.union s !free_structure_names

let rec add_path bv ?(p=[]) = function
  | Lident s ->
      let free =
        try lookup_free (s::p) bv with Not_found -> StringSet.singleton s
      in
      (*StringSet.iter (fun s -> Printf.eprintf "%s " s) free;
        prerr_endline "";*)
      add_names free
  | Ldot(l, s) -> add_path bv ~p:(s::p) l
  | Lapply(l1, l2) -> add_path bv l1; add_path bv l2

let open_module bv lid =
  match lookup_map lid bv with
  | Node (s, m) ->
      add_names s;
      StringMap.fold StringMap.add m bv
  | exception Not_found ->
      add_path bv lid; bv

let add_parent bv lid =
  match lid.txt with
    Ldot(l, _s) -> add_path bv l
  | _ -> ()

let add = add_parent

let addmodule bv lid = add_path bv lid.txt

let handle_extension ext =
  match (fst ext).txt with
  | "error" | "ocaml.error" ->
    raise (Location.Error
             (Builtin_attributes.error_of_extension ext))
  | _ ->
    ()

let rec add_type bv ty =
  match ty.ptyp_desc with
    Ptyp_any -> ()
  | Ptyp_var _ -> ()
  | Ptyp_arrow(_, t1, t2) -> add_type bv t1; add_type bv t2
  | Ptyp_tuple tl -> List.iter (add_type bv) tl
  | Ptyp_constr(c, tl) -> add bv c; List.iter (add_type bv) tl
  | Ptyp_object (fl, _) ->
      List.iter
       (function Otag (_, _, t) -> add_type bv t
         | Oinherit t -> add_type bv t) fl
  | Ptyp_class(c, tl) -> add bv c; List.iter (add_type bv) tl
  | Ptyp_alias(t, _) -> add_type bv t
  | Ptyp_variant(fl, _, _) ->
      List.iter
        (function Rtag(_,_,_,stl) -> List.iter (add_type bv) stl
          | Rinherit sty -> add_type bv sty)
        fl
  | Ptyp_poly(_, t) -> add_type bv t
  | Ptyp_package pt -> add_package_type bv pt
  | Ptyp_extension e -> handle_extension e

and add_package_type bv (lid, l) =
  add bv lid;
  List.iter (add_type bv) (List.map (fun (_, e) -> e) l)

let add_opt add_fn bv = function
    None -> ()
  | Some x -> add_fn bv x

let add_constructor_arguments bv = function
  | Pcstr_tuple l -> List.iter (add_type bv) l
  | Pcstr_record l -> List.iter (fun l -> add_type bv l.pld_type) l

let add_constructor_decl bv pcd =
  add_constructor_arguments bv pcd.pcd_args;
  Misc.may (add_type bv) pcd.pcd_res

let add_type_declaration bv td =
  List.iter
    (fun (ty1, ty2, _) -> add_type bv ty1; add_type bv ty2)
    td.ptype_cstrs;
  add_opt add_type bv td.ptype_manifest;
  let add_tkind = function
    Ptype_abstract -> ()
  | Ptype_variant cstrs ->
      List.iter (add_constructor_decl bv) cstrs
  | Ptype_record lbls ->
      List.iter (fun pld -> add_type bv pld.pld_type) lbls
  | Ptype_open -> () in
  add_tkind td.ptype_kind

let add_extension_constructor bv ext =
  match ext.pext_kind with
    Pext_decl(args, rty) ->
      add_constructor_arguments bv args;
      Misc.may (add_type bv) rty
  | Pext_rebind lid -> add bv lid

let add_type_extension bv te =
  add bv te.ptyext_path;
  List.iter (add_extension_constructor bv) te.ptyext_constructors

let rec add_class_type bv cty =
  match cty.pcty_desc with
    Pcty_constr(l, tyl) ->
      add bv l; List.iter (add_type bv) tyl
  | Pcty_signature { pcsig_self = ty; pcsig_fields = fieldl } ->
      add_type bv ty;
      List.iter (add_class_type_field bv) fieldl
  | Pcty_arrow(_, ty1, cty2) ->
      add_type bv ty1; add_class_type bv cty2
  | Pcty_extension e -> handle_extension e
  | Pcty_open (_ovf, m, e) ->
      let bv = open_module bv m.txt in add_class_type bv e

and add_class_type_field bv pctf =
  match pctf.pctf_desc with
    Pctf_inherit cty -> add_class_type bv cty
  | Pctf_val(_, _, _, ty) -> add_type bv ty
  | Pctf_method(_, _, _, ty) -> add_type bv ty
  | Pctf_constraint(ty1, ty2) -> add_type bv ty1; add_type bv ty2
  | Pctf_attribute _ -> ()
  | Pctf_extension e -> handle_extension e

let add_class_description bv infos =
  add_class_type bv infos.pci_expr

let add_class_type_declaration = add_class_description

let pattern_bv = ref StringMap.empty

let rec add_pattern bv pat =
  match pat.ppat_desc with
    Ppat_any -> ()
  | Ppat_var _ -> ()
  | Ppat_alias(p, _) -> add_pattern bv p
  | Ppat_interval _
  | Ppat_constant _ -> ()
  | Ppat_tuple pl -> List.iter (add_pattern bv) pl
  | Ppat_construct(c, op) -> add bv c; add_opt add_pattern bv op
  | Ppat_record(pl, _) ->
      List.iter (fun (lbl, p) -> add bv lbl; add_pattern bv p) pl
  | Ppat_array pl -> List.iter (add_pattern bv) pl
  | Ppat_or(p1, p2) -> add_pattern bv p1; add_pattern bv p2
  | Ppat_constraint(p, ty) -> add_pattern bv p; add_type bv ty
  | Ppat_variant(_, op) -> add_opt add_pattern bv op
  | Ppat_type li -> add bv li
  | Ppat_lazy p -> add_pattern bv p
  | Ppat_unpack id -> pattern_bv := StringMap.add id.txt bound !pattern_bv
  | Ppat_open ( m, p) -> let bv = open_module bv m.txt in add_pattern bv p
  | Ppat_exception p -> add_pattern bv p
  | Ppat_extension e -> handle_extension e

let add_pattern bv pat =
  pattern_bv := bv;
  add_pattern bv pat;
  !pattern_bv

let rec add_expr bv exp =
  match exp.pexp_desc with
    Pexp_ident l -> add bv l
  | Pexp_constant _ -> ()
  | Pexp_let(rf, pel, e) ->
      let bv = add_bindings rf bv pel in add_expr bv e
  | Pexp_fun (_, opte, p, e) ->
      add_opt add_expr bv opte; add_expr (add_pattern bv p) e
  | Pexp_function pel ->
      add_cases bv pel
  | Pexp_apply(e, el) ->
      add_expr bv e; List.iter (fun (_,e) -> add_expr bv e) el
  | Pexp_match(e, pel) -> add_expr bv e; add_cases bv pel
  | Pexp_try(e, pel) -> add_expr bv e; add_cases bv pel
  | Pexp_tuple el -> List.iter (add_expr bv) el
  | Pexp_construct(c, opte) -> add bv c; add_opt add_expr bv opte
  | Pexp_variant(_, opte) -> add_opt add_expr bv opte
  | Pexp_record(lblel, opte) ->
      List.iter (fun (lbl, e) -> add bv lbl; add_expr bv e) lblel;
      add_opt add_expr bv opte
  | Pexp_field(e, fld) -> add_expr bv e; add bv fld
  | Pexp_setfield(e1, fld, e2) -> add_expr bv e1; add bv fld; add_expr bv e2
  | Pexp_array el -> List.iter (add_expr bv) el
  | Pexp_ifthenelse(e1, e2, opte3) ->
      add_expr bv e1; add_expr bv e2; add_opt add_expr bv opte3
  | Pexp_sequence(e1, e2) -> add_expr bv e1; add_expr bv e2
  | Pexp_while(e1, e2) -> add_expr bv e1; add_expr bv e2
  | Pexp_for( _, e1, e2, _, e3) ->
      add_expr bv e1; add_expr bv e2; add_expr bv e3
  | Pexp_coerce(e1, oty2, ty3) ->
      add_expr bv e1;
      add_opt add_type bv oty2;
      add_type bv ty3
  | Pexp_constraint(e1, ty2) ->
      add_expr bv e1;
      add_type bv ty2
  | Pexp_send(e, _m) -> add_expr bv e
  | Pexp_new li -> add bv li
  | Pexp_setinstvar(_v, e) -> add_expr bv e
  | Pexp_override sel -> List.iter (fun (_s, e) -> add_expr bv e) sel
  | Pexp_letmodule(id, m, e) ->
      let b = add_module_binding bv m in
      add_expr (StringMap.add id.txt b bv) e
  | Pexp_letexception(_, e) -> add_expr bv e
  | Pexp_assert (e) -> add_expr bv e
  | Pexp_lazy (e) -> add_expr bv e
  | Pexp_poly (e, t) -> add_expr bv e; add_opt add_type bv t
  | Pexp_object { pcstr_self = pat; pcstr_fields = fieldl } ->
      let bv = add_pattern bv pat in List.iter (add_class_field bv) fieldl
  | Pexp_newtype (_, e) -> add_expr bv e
  | Pexp_pack m -> add_module bv m
  | Pexp_open (_ovf, m, e) ->
      let bv = open_module bv m.txt in add_expr bv e
  | Pexp_extension (({ txt = ("ocaml.extension_constructor"|
                              "extension_constructor"); _ },
                     PStr [item]) as e) ->
      begin match item.pstr_desc with
      | Pstr_eval ({ pexp_desc = Pexp_construct (c, None) }, _) -> add bv c
      | _ -> handle_extension e
      end
  | Pexp_extension e -> handle_extension e
  | Pexp_unreachable -> ()

and add_cases bv cases =
  List.iter (add_case bv) cases

and add_case bv {pc_lhs; pc_guard; pc_rhs} =
  let bv = add_pattern bv pc_lhs in
  add_opt add_expr bv pc_guard;
  add_expr bv pc_rhs

and add_bindings recf bv pel =
  let bv' = List.fold_left (fun bv x -> add_pattern bv x.pvb_pat) bv pel in
  let bv = if recf = Recursive then bv' else bv in
  List.iter (fun x -> add_expr bv x.pvb_expr) pel;
  bv'

and add_modtype bv mty =
  match mty.pmty_desc with
    Pmty_ident l -> add bv l
  | Pmty_alias l -> addmodule bv l
  | Pmty_signature s -> add_signature bv s
  | Pmty_functor(id, mty1, mty2) ->
      Misc.may (add_modtype bv) mty1;
      add_modtype (StringMap.add id.txt bound bv) mty2
  | Pmty_with(mty, cstrl) ->
      add_modtype bv mty;
      List.iter
        (function
          | Pwith_type (_, td) -> add_type_declaration bv td
          | Pwith_module (_, lid) -> addmodule bv lid
          | Pwith_typesubst (_, td) -> add_type_declaration bv td
          | Pwith_modsubst (_, lid) -> addmodule bv lid
        )
        cstrl
  | Pmty_typeof m -> add_module bv m
  | Pmty_extension e -> handle_extension e

and add_module_alias bv l =
  try
    add_parent bv l;
    lookup_map l.txt bv
  with Not_found ->
    match l.txt with
      Lident s -> make_leaf s
    | _ -> addmodule bv l; bound (* cannot delay *)

and add_modtype_binding bv mty =
  if not !Clflags.transparent_modules then add_modtype bv mty;
  match mty.pmty_desc with
    Pmty_alias l ->
      add_module_alias bv l
  | Pmty_signature s ->
      make_node (add_signature_binding bv s)
  | Pmty_typeof modl ->
      add_module_binding bv modl
  | _ ->
      if !Clflags.transparent_modules then add_modtype bv mty; bound

and add_signature bv sg =
  ignore (add_signature_binding bv sg)

and add_signature_binding bv sg =
  snd (List.fold_left add_sig_item (bv, StringMap.empty) sg)

and add_sig_item (bv, m) item =
  match item.psig_desc with
    Psig_value vd ->
      add_type bv vd.pval_type; (bv, m)
  | Psig_type (_, dcls) ->
      List.iter (add_type_declaration bv) dcls; (bv, m)
  | Psig_typext te ->
      add_type_extension bv te; (bv, m)
  | Psig_exception pext ->
      add_extension_constructor bv pext; (bv, m)
  | Psig_module pmd ->
      let m' = add_modtype_binding bv pmd.pmd_type in
      let add = StringMap.add pmd.pmd_name.txt m' in
      (add bv, add m)
  | Psig_recmodule decls ->
      let add =
        List.fold_right (fun pmd -> StringMap.add pmd.pmd_name.txt bound)
                        decls
      in
      let bv' = add bv and m' = add m in
      List.iter (fun pmd -> add_modtype bv' pmd.pmd_type) decls;
      (bv', m')
  | Psig_modtype x ->
      begin match x.pmtd_type with
        None -> ()
      | Some mty -> add_modtype bv mty
      end;
      (bv, m)
  | Psig_open od ->
      (open_module bv od.popen_lid.txt, m)
  | Psig_include incl ->
      let Node (s, m') = add_modtype_binding bv incl.pincl_mod in
      add_names s;
      let add = StringMap.fold StringMap.add m' in
      (add bv, add m)
  | Psig_class () ->
      (bv, m)
  | Psig_class_type cdtl ->
      List.iter (add_class_type_declaration bv) cdtl; (bv, m)
  | Psig_attribute _ -> (bv, m)
  | Psig_extension (e, _) ->
      handle_extension e;
      (bv, m)

and add_module_binding bv modl =
  if not !Clflags.transparent_modules then add_module bv modl;
  match modl.pmod_desc with
    Pmod_ident l ->
      begin try
        add_parent bv l;
        lookup_map l.txt bv
      with Not_found ->
        match l.txt with
          Lident s -> make_leaf s
        | _ ->  addmodule bv l; bound
      end
  | Pmod_structure s ->
      make_node (snd (add_structure_binding bv s))
  | _ ->
      if !Clflags.transparent_modules then add_module bv modl; bound

and add_module bv modl =
  match modl.pmod_desc with
    Pmod_ident l -> addmodule bv l
  | Pmod_structure s -> ignore (add_structure bv s)
  | Pmod_functor(id, mty, modl) ->
      Misc.may (add_modtype bv) mty;
      add_module (StringMap.add id.txt bound bv) modl
  | Pmod_apply(mod1, mod2) ->
      add_module bv mod1; add_module bv mod2
  | Pmod_constraint(modl, mty) ->
      add_module bv modl; add_modtype bv mty
  | Pmod_unpack(e) ->
      add_expr bv e
  | Pmod_extension e ->
      handle_extension e

and add_structure bv item_list =
  let (bv, m) = add_structure_binding bv item_list in
  add_names (collect_free (make_node m));
  bv

and add_structure_binding bv item_list =
  List.fold_left add_struct_item (bv, StringMap.empty) item_list

and add_struct_item (bv, m) item : _ StringMap.t * _ StringMap.t =
  match item.pstr_desc with
    Pstr_eval (e, _attrs) ->
      add_expr bv e; (bv, m)
  | Pstr_value(rf, pel) ->
      let bv = add_bindings rf bv pel in (bv, m)
  | Pstr_primitive vd ->
      add_type bv vd.pval_type; (bv, m)
  | Pstr_type (_, dcls) ->
      List.iter (add_type_declaration bv) dcls; (bv, m)
  | Pstr_typext te ->
      add_type_extension bv te;
      (bv, m)
  | Pstr_exception pext ->
      add_extension_constructor bv pext; (bv, m)
  | Pstr_module x ->
      let b = add_module_binding bv x.pmb_expr in
      let add = StringMap.add x.pmb_name.txt b in
      (add bv, add m)
  | Pstr_recmodule bindings ->
      let add =
        List.fold_right (fun x -> StringMap.add x.pmb_name.txt bound) bindings
      in
      let bv' = add bv and m = add m in
      List.iter
        (fun x -> add_module bv' x.pmb_expr)
        bindings;
      (bv', m)
  | Pstr_modtype x ->
      begin match x.pmtd_type with
        None -> ()
      | Some mty -> add_modtype bv mty
      end;
      (bv, m)
  | Pstr_open od ->
      (open_module bv od.popen_lid.txt, m)
  | Pstr_class () ->
      (bv,m)
  | Pstr_class_type cdtl ->
      List.iter (add_class_type_declaration bv) cdtl; (bv, m)
  | Pstr_include incl ->
      let Node (s, m') = add_module_binding bv incl.pincl_mod in
      add_names s;
      let add = StringMap.fold StringMap.add m' in
      (add bv, add m)
  | Pstr_attribute _ -> (bv, m)
  | Pstr_extension (e, _) ->
      handle_extension e;
      (bv, m)


and add_implementation bv l =
  if !Clflags.transparent_modules then
    ignore (add_structure_binding bv l)
  else ignore (add_structure bv l)

and add_implementation_binding bv l =
  snd (add_structure_binding bv l)



and add_class_field bv pcf =
  match pcf.pcf_desc with
    Pcf_inherit() -> ()
  | Pcf_val(_, _, Cfk_concrete (_, e))
  | Pcf_method(_, _, Cfk_concrete (_, e)) -> add_expr bv e
  | Pcf_val(_, _, Cfk_virtual ty)
  | Pcf_method(_, _, Cfk_virtual ty) -> add_type bv ty
  | Pcf_constraint(ty1, ty2) -> add_type bv ty1; add_type bv ty2
  | Pcf_initializer e -> add_expr bv e
  | Pcf_attribute _ -> ()
  | Pcf_extension e -> handle_extension e


end
module Ext_ref : sig 
#1 "ext_ref.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** [non_exn_protect ref value f] assusme [f()] 
    would not raise
*)

val non_exn_protect : 'a ref -> 'a -> (unit -> 'b) -> 'b

val protect : 'a ref -> 'a -> (unit -> 'b) -> 'b

val protect2 : 'a ref -> 'b ref -> 'a -> 'b -> (unit -> 'c) -> 'c

val non_exn_protect2 : 'a ref -> 'b ref -> 'a -> 'b -> (unit -> 'c) -> 'c
(** [non_exn_protect2 refa refb va vb f ]
    assume [f ()] would not raise
*)

val protect_list : ('a ref * 'a) list -> (unit -> 'b) -> 'b

end = struct
#1 "ext_ref.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let non_exn_protect r v body =
  let old = !r in
  r := v;
  let res = body () in
  r := old;
  res

let protect r v body =
  let old = !r in
  try
    r := v;
    let res = body () in
    r := old;
    res
  with x ->
    r := old;
    raise x

let non_exn_protect2 r1 r2 v1 v2 body =
  let old1 = !r1 in
  let old2 = !r2 in
  r1 := v1;
  r2 := v2;
  let res = body () in
  r1 := old1;
  r2 := old2;
  res

let protect2 r1 r2 v1 v2 body =
  let old1 = !r1 in
  let old2 = !r2 in
  try
    r1 := v1;
    r2 := v2;
    let res = body () in
    r1 := old1;
    r2 := old2;
    res
  with x ->
    r1 := old1;
    r2 := old2;
    raise x

let protect_list rvs body =
  let olds = Ext_list.map rvs (fun (x, _) -> !x) in
  let () = List.iter (fun (x, y) -> x := y) rvs in
  try
    let res = body () in
    List.iter2 (fun (x, _) old -> x := old) rvs olds;
    res
  with e ->
    List.iter2 (fun (x, _) old -> x := old) rvs olds;
    raise e

end
module Ml_binary : sig 
#1 "ml_binary.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(* This file was used to read reason ast
   and part of parsing binary ast
*)
type _ kind = Ml : Parsetree.structure kind | Mli : Parsetree.signature kind

val read_ast : 'a kind -> in_channel -> 'a

val write_ast : 'a kind -> string -> 'a -> out_channel -> unit

val magic_of_kind : 'a kind -> string

end = struct
#1 "ml_binary.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type _ kind = Ml : Parsetree.structure kind | Mli : Parsetree.signature kind

(** [read_ast kind ic] assume [ic] channel is 
    in the right position *)
let read_ast (type t) (kind : t kind) ic : t =
  let magic =
    match kind with
    | Ml -> Config.ast_impl_magic_number
    | Mli -> Config.ast_intf_magic_number
  in
  let buffer = really_input_string ic (String.length magic) in
  assert (buffer = magic);
  (* already checked by apply_rewriter *)
  Location.set_input_name (input_value ic);
  input_value ic

let write_ast (type t) (kind : t kind) (fname : string) (pt : t) oc =
  let magic =
    match kind with
    | Ml -> Config.ast_impl_magic_number
    | Mli -> Config.ast_intf_magic_number
  in
  output_string oc magic;
  output_value oc fname;
  output_value oc pt

let magic_of_kind : type a. a kind -> string = function
  | Ml -> Config.ast_impl_magic_number
  | Mli -> Config.ast_intf_magic_number

end
module Ast_extract : sig 
#1 "ast_extract.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

module Set_string = Depend.StringSet

val read_parse_and_extract : 'a Ml_binary.kind -> 'a -> Set_string.t

end = struct
#1 "ast_extract.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(* type module_name = private string *)

module Set_string = Depend.StringSet

(* FIXME: [Clflags.open_modules] seems not to be properly used *)
module SMap = Depend.StringMap

let bound_vars = SMap.empty

type 'a kind = 'a Ml_binary.kind

let read_parse_and_extract (type t) (k : t kind) (ast : t) : Set_string.t =
  Depend.free_structure_names := Set_string.empty;
  Ext_ref.protect Clflags.transparent_modules false (fun _ ->
      List.iter (* check *)
        (fun modname ->
          ignore @@ Depend.open_module bound_vars (Longident.Lident modname))
        !Clflags.open_modules;
      (match k with
      | Ml_binary.Ml -> Depend.add_implementation bound_vars ast
      | Ml_binary.Mli -> Depend.add_signature bound_vars ast);
      !Depend.free_structure_names)

end
module Docstrings : sig 
#1 "docstrings.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                               Leo White                                *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Documentation comments *)

(** (Re)Initialise all docstring state *)
val init : unit -> unit

(** Emit warnings for unattached and ambiguous docstrings *)
val warn_bad_docstrings : unit -> unit

(** {2 Docstrings} *)

(** Documentation comments *)
type docstring

(** Create a docstring *)
val docstring : string -> Location.t -> docstring

(** Register a docstring *)
val register : docstring -> unit

(** Get the text of a docstring *)
val docstring_body : docstring -> string

(** Get the location of a docstring *)
val docstring_loc : docstring -> Location.t

(** {2 Set functions}

   These functions are used by the lexer to associate docstrings to
   the locations of tokens. *)

(** Docstrings immediately preceding a token *)
val set_pre_docstrings : Lexing.position -> docstring list -> unit

(** Docstrings immediately following a token *)
val set_post_docstrings : Lexing.position -> docstring list -> unit

(** Docstrings not immediately adjacent to a token *)
val set_floating_docstrings : Lexing.position -> docstring list -> unit

(** Docstrings immediately following the token which precedes this one *)
val set_pre_extra_docstrings : Lexing.position -> docstring list -> unit

(** Docstrings immediately preceding the token which follows this one *)
val set_post_extra_docstrings : Lexing.position -> docstring list -> unit

(** {2 Items}

    The {!docs} type represents documentation attached to an item. *)

type docs =
  { docs_pre: docstring option;
    docs_post: docstring option; }

val empty_docs : docs

val docs_attr : docstring -> Parsetree.attribute

(** Convert item documentation to attributes and add them to an
    attribute list *)
val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes

(** Fetch the item documentation for the current symbol. This also
    marks this documentation (for ambiguity warnings). *)
val symbol_docs : unit -> docs
val symbol_docs_lazy : unit -> docs Lazy.t

(** Fetch the item documentation for the symbols between two
    positions. This also marks this documentation (for ambiguity
    warnings). *)
val rhs_docs : int -> int -> docs
val rhs_docs_lazy : int -> int -> docs Lazy.t

(** Mark the item documentation for the current symbol (for ambiguity
    warnings). *)
val mark_symbol_docs : unit -> unit

(** Mark as associated the item documentation for the symbols between
    two positions (for ambiguity warnings) *)
val mark_rhs_docs : int -> int -> unit

(** {2 Fields and constructors}

    The {!info} type represents documentation attached to a field or
    constructor. *)

type info = docstring option

val empty_info : info

val info_attr : docstring -> Parsetree.attribute

(** Convert field info to attributes and add them to an
    attribute list *)
val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes

(** Fetch the field info for the current symbol. *)
val symbol_info : unit -> info

(** Fetch the field info following the symbol at a given position. *)
val rhs_info : int -> info

(** {2 Unattached comments}

    The {!text} type represents documentation which is not attached to
    anything. *)

type text = docstring list

val empty_text : text
val empty_text_lazy : text Lazy.t

val text_attr : docstring -> Parsetree.attribute

(** Convert text to attributes and add them to an attribute list *)
val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes

(** Fetch the text preceding the current symbol. *)
val symbol_text : unit -> text
val symbol_text_lazy : unit -> text Lazy.t

(** Fetch the text preceding the symbol at the given position. *)
val rhs_text : int -> text
val rhs_text_lazy : int -> text Lazy.t

(** {2 Extra text}

    There may be additional text attached to the delimiters of a block
    (e.g. [struct] and [end]). This is fetched by the following
    functions, which are applied to the contents of the block rather
    than the delimiters. *)

(** Fetch additional text preceding the current symbol *)
val symbol_pre_extra_text : unit -> text

(** Fetch additional text following the current symbol *)
val symbol_post_extra_text : unit -> text

(** Fetch additional text preceding the symbol at the given position *)
val rhs_pre_extra_text : int -> text

(** Fetch additional text following the symbol at the given position *)
val rhs_post_extra_text : int -> text

end = struct
#1 "docstrings.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                               Leo White                                *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

open Location

(* Docstrings *)

(* A docstring is "attached" if it has been inserted in the AST. This
   is used for generating unexpected docstring warnings. *)
type ds_attached =
  | Unattached   (* Not yet attached anything.*)
  | Info         (* Attached to a field or constructor. *)
  | Docs         (* Attached to an item or as floating text. *)

(* A docstring is "associated" with an item if there are no blank lines between
   them. This is used for generating docstring ambiguity warnings. *)
type ds_associated =
  | Zero             (* Not associated with an item *)
  | One              (* Associated with one item *)
  | Many             (* Associated with multiple items (ambiguity) *)

type docstring =
  { ds_body: string;
    ds_loc: Location.t;
    mutable ds_attached: ds_attached;
    mutable ds_associated: ds_associated; }

(* List of docstrings *)

let docstrings : docstring list ref = ref []

(* Warn for unused and ambiguous docstrings *)

let warn_bad_docstrings () =
  if Warnings.is_active (Warnings.Bad_docstring true) then begin
    List.iter
      (fun ds ->
         match ds.ds_attached with
         | Info -> ()
         | Unattached ->
           prerr_warning ds.ds_loc (Warnings.Bad_docstring true)
         | Docs ->
             match ds.ds_associated with
             | Zero | One -> ()
             | Many ->
               prerr_warning ds.ds_loc (Warnings.Bad_docstring false))
      (List.rev !docstrings)
end

(* Docstring constructors and destructors *)

let docstring body loc =
  let ds =
    { ds_body = body;
      ds_loc = loc;
      ds_attached = Unattached;
      ds_associated = Zero; }
  in
  ds

let register ds =
  docstrings := ds :: !docstrings

let docstring_body ds = ds.ds_body

let docstring_loc ds = ds.ds_loc

(* Docstrings attached to items *)

type docs =
  { docs_pre: docstring option;
    docs_post: docstring option; }

let empty_docs = { docs_pre = None; docs_post = None }

let doc_loc = {txt = "ocaml.doc"; loc = Location.none}

let docs_attr ds =
  let open Parsetree in
  let exp =
    { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
      pexp_loc = ds.ds_loc;
      pexp_attributes = []; }
  in
  let item =
    { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
  in
    (doc_loc, PStr [item])

let add_docs_attrs docs attrs =
  let attrs =
    match docs.docs_pre with
    | None | Some { ds_body=""; _ } -> attrs
    | Some ds -> docs_attr ds :: attrs
  in
  let attrs =
    match docs.docs_post with
    | None | Some { ds_body=""; _ } -> attrs
    | Some ds -> attrs @ [docs_attr ds]
  in
  attrs

(* Docstrings attached to constructors or fields *)

type info = docstring option

let empty_info = None

let info_attr = docs_attr

let add_info_attrs info attrs =
  match info with
  | None | Some {ds_body=""; _} -> attrs
  | Some ds -> attrs @ [info_attr ds]

(* Docstrings not attached to a specific item *)

type text = docstring list

let empty_text = []
let empty_text_lazy = lazy []

let text_loc = {txt = "ocaml.text"; loc = Location.none}

let text_attr ds =
  let open Parsetree in
  let exp =
    { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
      pexp_loc = ds.ds_loc;
      pexp_attributes = []; }
  in
  let item =
    { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
  in
    (text_loc, PStr [item])

let add_text_attrs dsl attrs =
  let fdsl = Ext_list.filter dsl (function {ds_body=""} -> false| _ ->true) in
  (List.map text_attr fdsl) @ attrs

(* Find the first non-info docstring in a list, attach it and return it *)
let get_docstring ~info dsl =
  let rec loop = function
    | [] -> None
    | {ds_attached = Info; _} :: rest -> loop rest
    | ds :: _ ->
        ds.ds_attached <- if info then Info else Docs;
        Some ds
  in
  loop dsl

(* Find all the non-info docstrings in a list, attach them and return them *)
let get_docstrings dsl =
  let rec loop acc = function
    | [] -> List.rev acc
    | {ds_attached = Info; _} :: rest -> loop acc rest
    | ds :: rest ->
        ds.ds_attached <- Docs;
        loop (ds :: acc) rest
  in
    loop [] dsl

(* "Associate" all the docstrings in a list *)
let associate_docstrings dsl =
  List.iter
    (fun ds ->
       match ds.ds_associated with
       | Zero -> ds.ds_associated <- One
       | (One | Many) -> ds.ds_associated <- Many)
    dsl

(* Map from positions to pre docstrings *)

let pre_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_pre_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add pre_table pos dsl

let get_pre_docs pos =
  try
    let dsl = Hashtbl.find pre_table pos in
      associate_docstrings dsl;
      get_docstring ~info:false dsl
  with Not_found -> None

let mark_pre_docs pos =
  try
    let dsl = Hashtbl.find pre_table pos in
      associate_docstrings dsl
  with Not_found -> ()

(* Map from positions to post docstrings *)

let post_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_post_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add post_table pos dsl

let get_post_docs pos =
  try
    let dsl = Hashtbl.find post_table pos in
      associate_docstrings dsl;
      get_docstring ~info:false dsl
  with Not_found -> None

let mark_post_docs pos =
  try
    let dsl = Hashtbl.find post_table pos in
      associate_docstrings dsl
  with Not_found -> ()

let get_info pos =
  try
    let dsl = Hashtbl.find post_table pos in
      get_docstring ~info:true dsl
  with Not_found -> None

(* Map from positions to floating docstrings *)

let floating_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_floating_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add floating_table pos dsl

let get_text pos =
  try
    let dsl = Hashtbl.find floating_table pos in
      get_docstrings dsl
  with Not_found -> []

(* Maps from positions to extra docstrings *)

let pre_extra_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_pre_extra_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add pre_extra_table pos dsl

let get_pre_extra_text pos =
  try
    let dsl = Hashtbl.find pre_extra_table pos in
      get_docstrings dsl
  with Not_found -> []

let post_extra_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_post_extra_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add post_extra_table pos dsl

let get_post_extra_text pos =
  try
    let dsl = Hashtbl.find post_extra_table pos in
      get_docstrings dsl
  with Not_found -> []

(* Docstrings from parser actions *)

let symbol_docs () =
  { docs_pre = get_pre_docs (Parsing.symbol_start_pos ());
    docs_post = get_post_docs (Parsing.symbol_end_pos ()); }

let symbol_docs_lazy () =
  let p1 = Parsing.symbol_start_pos () in
  let p2 = Parsing.symbol_end_pos () in
    lazy { docs_pre = get_pre_docs p1;
           docs_post = get_post_docs p2; }

let rhs_docs pos1 pos2 =
  { docs_pre = get_pre_docs (Parsing.rhs_start_pos pos1);
    docs_post = get_post_docs (Parsing.rhs_end_pos pos2); }

let rhs_docs_lazy pos1 pos2 =
  let p1 = Parsing.rhs_start_pos pos1 in
  let p2 = Parsing.rhs_end_pos pos2 in
    lazy { docs_pre = get_pre_docs p1;
           docs_post = get_post_docs p2; }

let mark_symbol_docs () =
  mark_pre_docs (Parsing.symbol_start_pos ());
  mark_post_docs (Parsing.symbol_end_pos ())

let mark_rhs_docs pos1 pos2 =
  mark_pre_docs (Parsing.rhs_start_pos pos1);
  mark_post_docs (Parsing.rhs_end_pos pos2)

let symbol_info () =
  get_info (Parsing.symbol_end_pos ())

let rhs_info pos =
  get_info (Parsing.rhs_end_pos pos)

let symbol_text () =
  get_text (Parsing.symbol_start_pos ())

let symbol_text_lazy () =
  let pos = Parsing.symbol_start_pos () in
    lazy (get_text pos)

let rhs_text pos =
  get_text (Parsing.rhs_start_pos pos)

let rhs_text_lazy pos =
  let pos = Parsing.rhs_start_pos pos in
    lazy (get_text pos)

let symbol_pre_extra_text () =
  get_pre_extra_text (Parsing.symbol_start_pos ())

let symbol_post_extra_text () =
  get_post_extra_text (Parsing.symbol_end_pos ())

let rhs_pre_extra_text pos =
  get_pre_extra_text (Parsing.rhs_start_pos pos)

let rhs_post_extra_text pos =
  get_post_extra_text (Parsing.rhs_end_pos pos)


(* (Re)Initialise all comment state *)

let init () =
  docstrings := [];
  Hashtbl.reset pre_table;
  Hashtbl.reset post_table;
  Hashtbl.reset floating_table;
  Hashtbl.reset pre_extra_table;
  Hashtbl.reset post_extra_table

end
module Syntaxerr : sig 
#1 "syntaxerr.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1997 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Auxiliary type for reporting syntax errors *)

open Format

type error =
    Unclosed of Location.t * string * Location.t * string
  | Expecting of Location.t * string
  | Not_expecting of Location.t * string
  | Applicative_path of Location.t
  | Variable_in_scope of Location.t * string
  | Other of Location.t
  | Ill_formed_ast of Location.t * string
  | Invalid_package_type of Location.t * string

exception Error of error
exception Escape_error

val report_error: formatter -> error -> unit
 (** @deprecated Use {!Location.error_of_exn}, {!Location.report_error}. *)

val location_of_error: error -> Location.t
val ill_formed_ast: Location.t -> string -> 'a

end = struct
#1 "syntaxerr.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1997 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Auxiliary type for reporting syntax errors *)

type error =
    Unclosed of Location.t * string * Location.t * string
  | Expecting of Location.t * string
  | Not_expecting of Location.t * string
  | Applicative_path of Location.t
  | Variable_in_scope of Location.t * string
  | Other of Location.t
  | Ill_formed_ast of Location.t * string
  | Invalid_package_type of Location.t * string

exception Error of error
exception Escape_error

let prepare_error = function
  | Unclosed(opening_loc, opening, closing_loc, closing) ->
      Location.errorf ~loc:closing_loc
        ~sub:[
          Location.errorf ~loc:opening_loc
            "This '%s' might be unmatched" opening
        ]
        ~if_highlight:
          (Printf.sprintf "Syntax error: '%s' expected, \
                           the highlighted '%s' might be unmatched"
             closing opening)
        "Syntax error: '%s' expected" closing

  | Expecting (loc, nonterm) ->
      Location.errorf ~loc "Syntax error: %s expected." nonterm
  | Not_expecting (loc, nonterm) ->
      Location.errorf ~loc "Syntax error: %s not expected." nonterm
  | Applicative_path loc ->
      Location.errorf ~loc
        "Syntax error: applicative paths of the form F(X).t \
         are not supported when the option -no-app-func is set."
  | Variable_in_scope (loc, var) ->
      Location.errorf ~loc
        "In this scoped type, variable '%s \
         is reserved for the local type %s."
         var var
  | Other loc ->
      Location.errorf ~loc "Syntax error"
  | Ill_formed_ast (loc, s) ->
      Location.errorf ~loc "broken invariant in parsetree: %s" s
  | Invalid_package_type (loc, s) ->
      Location.errorf ~loc "invalid package type: %s" s

let () =
  Location.register_error_of_exn
    (function
      | Error err -> Some (prepare_error err)
      | _ -> None
    )


let report_error ppf err =
  Location.report_error ppf (prepare_error err)

let location_of_error = function
  | Unclosed(l,_,_,_)
  | Applicative_path l
  | Variable_in_scope(l,_)
  | Other l
  | Not_expecting (l, _)
  | Ill_formed_ast (l, _)
  | Invalid_package_type (l, _)
  | Expecting (l, _) -> l


let ill_formed_ast loc s =
  raise (Error (Ill_formed_ast (loc, s)))

end
module Ast_helper : sig 
#1 "ast_helper.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2012 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Helpers to produce Parsetree fragments *)

open Asttypes
open Docstrings
open Parsetree

type lid = Longident.t loc
type str = string loc
type loc = Location.t
type attrs = attribute list

(** {1 Default locations} *)

val default_loc: loc ref
    (** Default value for all optional location arguments. *)

val with_default_loc: loc -> (unit -> 'a) -> 'a
    (** Set the [default_loc] within the scope of the execution
        of the provided function. *)

(** {1 Constants} *)

module Const : sig
  val char : char -> constant
  val string : ?quotation_delimiter:string -> string -> constant
  val integer : ?suffix:char -> string -> constant
  val int : ?suffix:char -> int -> constant
  val int32 : ?suffix:char -> int32 -> constant
  val int64 : ?suffix:char -> int64 -> constant
  val nativeint : ?suffix:char -> nativeint -> constant
  val float : ?suffix:char -> string -> constant
end

(** {1 Core language} *)

(** Type expressions *)
module Typ :
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
    val attr: core_type -> attribute -> core_type

    val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type
    val var: ?loc:loc -> ?attrs:attrs -> string -> core_type
    val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type -> core_type
               -> core_type
    val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type
    val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
    val object_: ?loc:loc -> ?attrs:attrs -> object_field list
                   -> closed_flag -> core_type
    val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
    val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
    val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                 -> label list option -> core_type
    val poly: ?loc:loc -> ?attrs:attrs -> str list -> core_type -> core_type
    val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list
                 -> core_type
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type

    val force_poly: core_type -> core_type

    val varify_constructors: str list -> core_type -> core_type
    (** [varify_constructors newtypes te] is type expression [te], of which
        any of nullary type constructor [tc] is replaced by type variable of
        the same name, if [tc]'s name appears in [newtypes].
        Raise [Syntaxerr.Variable_in_scope] if any type variable inside [te]
        appears in [newtypes].
        @since 4.05
     *)
  end

(** Patterns *)
module Pat:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern
    val attr:pattern -> attribute -> pattern

    val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern
    val var: ?loc:loc -> ?attrs:attrs -> str -> pattern
    val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern
    val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern
    val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
    val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
    val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern
    val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
    val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
                -> pattern
    val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
    val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
    val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
    val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
    val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
    val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern
    val open_: ?loc:loc -> ?attrs:attrs  -> lid -> pattern -> pattern
    val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
  end

(** Expressions *)
module Exp:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression
    val attr: expression -> attribute -> expression

    val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression
    val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression
    val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list
              -> expression -> expression
    val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option
              -> pattern -> expression -> expression
    val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression
    val apply: ?loc:loc -> ?attrs:attrs -> expression
               -> (arg_label * expression) list -> expression
    val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list
                -> expression
    val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression
    val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression
    val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option
                   -> expression
    val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option
                 -> expression
    val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list
                -> expression option -> expression
    val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
    val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                  -> expression
    val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
    val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
                    -> expression option -> expression
    val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
                  -> expression
    val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
                -> expression
    val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression
              -> direction_flag -> expression -> expression
    val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                -> core_type -> expression
    val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type
                     -> expression
    val send: ?loc:loc -> ?attrs:attrs -> expression -> str -> expression
    val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression
    val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
    val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list
                  -> expression
    val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression
                   -> expression
    val letexception:
      ?loc:loc -> ?attrs:attrs -> extension_constructor -> expression
      -> expression
    val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression
    val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression
    val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
              -> expression
    val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
    val newtype: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
    val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
    val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression
               -> expression
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression
    val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression

    val case: pattern -> ?guard:expression -> expression -> case
  end

(** Value declarations *)
module Val:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
      ?prim:string list -> str -> core_type -> value_description
  end

(** Type declarations *)
module Type:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      ?params:(core_type * variance) list ->
      ?cstrs:(core_type * core_type * loc) list ->
      ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->
      type_declaration

    val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->
      ?args:constructor_arguments -> ?res:core_type -> str ->
      constructor_declaration
    val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->
      ?mut:mutable_flag -> str -> core_type -> label_declaration
  end

(** Type extensions *)
module Te:
  sig
    val mk: ?attrs:attrs -> ?docs:docs ->
      ?params:(core_type * variance) list -> ?priv:private_flag ->
      lid -> extension_constructor list -> type_extension

    val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
      str -> extension_constructor_kind -> extension_constructor

    val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
      ?args:constructor_arguments -> ?res:core_type -> str ->
      extension_constructor
    val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
      str -> lid -> extension_constructor
  end

(** {1 Module language} *)

(** Module type expressions *)
module Mty:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type
    val attr: module_type -> attribute -> module_type

    val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type
    val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type
    val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type
    val functor_: ?loc:loc -> ?attrs:attrs ->
      str -> module_type option -> module_type -> module_type
    val with_: ?loc:loc -> ?attrs:attrs -> module_type ->
      with_constraint list -> module_type
    val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type
  end

(** Module expressions *)
module Mod:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr
    val attr: module_expr -> attribute -> module_expr

    val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr
    val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr
    val functor_: ?loc:loc -> ?attrs:attrs ->
      str -> module_type option -> module_expr -> module_expr
    val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr ->
      module_expr
    val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type ->
      module_expr
    val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr
  end

(** Signature items *)
module Sig:
  sig
    val mk: ?loc:loc -> signature_item_desc -> signature_item

    val value: ?loc:loc -> value_description -> signature_item
    val type_: ?loc:loc -> rec_flag -> type_declaration list -> signature_item
    val type_extension: ?loc:loc -> type_extension -> signature_item
    val exception_: ?loc:loc -> extension_constructor -> signature_item
    val module_: ?loc:loc -> module_declaration -> signature_item
    val rec_module: ?loc:loc -> module_declaration list -> signature_item
    val modtype: ?loc:loc -> module_type_declaration -> signature_item
    val open_: ?loc:loc -> open_description -> signature_item
    val include_: ?loc:loc -> include_description -> signature_item
    val class_type: ?loc:loc -> class_type_declaration list -> signature_item
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item
    val attribute: ?loc:loc -> attribute -> signature_item
    val text: text -> signature_item list
  end

(** Structure items *)
module Str:
  sig
    val mk: ?loc:loc -> structure_item_desc -> structure_item

    val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item
    val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item
    val primitive: ?loc:loc -> value_description -> structure_item
    val type_: ?loc:loc -> rec_flag -> type_declaration list -> structure_item
    val type_extension: ?loc:loc -> type_extension -> structure_item
    val exception_: ?loc:loc -> extension_constructor -> structure_item
    val module_: ?loc:loc -> module_binding -> structure_item
    val rec_module: ?loc:loc -> module_binding list -> structure_item
    val modtype: ?loc:loc -> module_type_declaration -> structure_item
    val open_: ?loc:loc -> open_description -> structure_item
    val class_type: ?loc:loc -> class_type_declaration list -> structure_item
    val include_: ?loc:loc -> include_declaration -> structure_item
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item
    val attribute: ?loc:loc -> attribute -> structure_item
    val text: text -> structure_item list
  end

(** Module declarations *)
module Md:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      str -> module_type -> module_declaration
  end

(** Module type declarations *)
module Mtd:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      ?typ:module_type -> str -> module_type_declaration
  end

(** Module bindings *)
module Mb:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      str -> module_expr -> module_binding
  end

(** Opens *)
module Opn:
  sig
    val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->
      ?override:override_flag -> lid -> open_description
  end

(** Includes *)
module Incl:
  sig
    val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos
  end

(** Value bindings *)
module Vb:
  sig
    val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      pattern -> expression -> value_binding
  end


(** {1 Class language} *)

(** Class type expressions *)
module Cty:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type
    val attr: class_type -> attribute -> class_type

    val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type
    val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type
    val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type ->
      class_type -> class_type
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type
    val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> class_type
               -> class_type
  end

(** Class type fields *)
module Ctf:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
      class_type_field_desc -> class_type_field
    val attr: class_type_field -> attribute -> class_type_field

    val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field
    val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
      virtual_flag -> core_type -> class_type_field
    val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
      virtual_flag -> core_type -> class_type_field
    val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
      class_type_field
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field
    val attribute: ?loc:loc -> attribute -> class_type_field
    val text: text -> class_type_field list
  end

(** Class expressions *)
module Cl:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr
    val attr: class_expr -> attribute -> class_expr

    val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr
    val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr
    val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option ->
      pattern -> class_expr -> class_expr
    val apply: ?loc:loc -> ?attrs:attrs -> class_expr ->
      (arg_label * expression) list -> class_expr
    val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list ->
      class_expr -> class_expr
    val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type ->
      class_expr
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr
    val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> class_expr
               -> class_expr
  end

(** Class fields *)
module Cf:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc ->
      class_field
    val attr: class_field -> attribute -> class_field

    val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
      class_field_kind -> class_field
    val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
      class_field_kind -> class_field
    val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
      class_field
    val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field
    val attribute: ?loc:loc -> attribute -> class_field
    val text: text -> class_field list

    val virtual_: core_type -> class_field_kind
    val concrete: override_flag -> expression -> class_field_kind

  end

(** Classes *)
module Ci:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      ?virt:virtual_flag -> ?params:(core_type * variance) list ->
      str -> 'a -> 'a class_infos
  end

(** Class signatures *)
module Csig:
  sig
    val mk: core_type -> class_type_field list -> class_signature
  end

(** Class structures *)
module Cstr:
  sig
    val mk: pattern -> class_field list -> class_structure
  end

end = struct
#1 "ast_helper.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2012 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Helpers to produce Parsetree fragments *)

open Asttypes
open Parsetree
open Docstrings

type lid = Longident.t loc
type str = string loc
type loc = Location.t
type attrs = attribute list

let default_loc = ref Location.none

let with_default_loc l f =
  let old = !default_loc in
  default_loc := l;
  try let r = f () in default_loc := old; r
  with exn -> default_loc := old; raise exn

module Const = struct
  let integer ?suffix i = Pconst_integer (i, suffix)
  let int ?suffix i = integer ?suffix (string_of_int i)
  let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)
  let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)
  let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)
  let float ?suffix f = Pconst_float (f, suffix)
  let char c = Pconst_char c
  let string ?quotation_delimiter s = Pconst_string (s, quotation_delimiter)
end

module Typ = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
  let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}

  let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any
  let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)
  let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))
  let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)
  let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))
  let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
  let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
  let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
  let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))
  let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))
  let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)

  let force_poly t =
    match t.ptyp_desc with
    | Ptyp_poly _ -> t
    | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)

  let varify_constructors var_names t =
    let check_variable vl loc v =
      if List.mem v vl then
        raise Syntaxerr.(Error(Variable_in_scope(loc,v))) in
    let var_names = List.map (fun v -> v.txt) var_names in
    let rec loop t =
      let desc =
        match t.ptyp_desc with
        | Ptyp_any -> Ptyp_any
        | Ptyp_var x ->
            check_variable var_names t.ptyp_loc x;
            Ptyp_var x
        | Ptyp_arrow (label,core_type,core_type') ->
            Ptyp_arrow(label, loop core_type, loop core_type')
        | Ptyp_tuple lst -> Ptyp_tuple (List.map loop lst)
        | Ptyp_constr( { txt = Longident.Lident s }, [])
          when List.mem s var_names ->
            Ptyp_var s
        | Ptyp_constr(longident, lst) ->
            Ptyp_constr(longident, List.map loop lst)
        | Ptyp_object (lst, o) ->
            Ptyp_object (List.map loop_object_field lst, o)
        | Ptyp_class (longident, lst) ->
            Ptyp_class (longident, List.map loop lst)
        | Ptyp_alias(core_type, string) ->
            check_variable var_names t.ptyp_loc string;
            Ptyp_alias(loop core_type, string)
        | Ptyp_variant(row_field_list, flag, lbl_lst_option) ->
            Ptyp_variant(List.map loop_row_field row_field_list,
                         flag, lbl_lst_option)
        | Ptyp_poly(string_lst, core_type) ->
          List.iter (fun v ->
            check_variable var_names t.ptyp_loc v.txt) string_lst;
            Ptyp_poly(string_lst, loop core_type)
        | Ptyp_package(longident,lst) ->
            Ptyp_package(longident,List.map (fun (n,typ) -> (n,loop typ) ) lst)
        | Ptyp_extension (s, arg) ->
            Ptyp_extension (s, arg)
      in
      {t with ptyp_desc = desc}
    and loop_row_field  =
      function
        | Rtag(label,attrs,flag,lst) ->
            Rtag(label,attrs,flag,List.map loop lst)
        | Rinherit t ->
            Rinherit (loop t)
    and loop_object_field =
      function
        | Otag(label, attrs, t) ->
            Otag(label, attrs, loop t)
        | Oinherit t ->
            Oinherit (loop t)
    in
    loop t

end

module Pat = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}
  let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}

  let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any
  let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)
  let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))
  let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)
  let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))
  let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
  let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
  let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
  let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
  let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
  let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
  let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
  let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
  let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
  let open_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_open (a, b))
  let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
  let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
end

module Exp = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}
  let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}

  let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)
  let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)
  let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))
  let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))
  let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)
  let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))
  let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))
  let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))
  let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)
  let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))
  let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
  let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
  let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
  let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
  let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
  let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
  let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
  let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
  let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
  let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))
  let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))
  let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)
  let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))
  let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)
  let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))
  let letexception ?loc ?attrs a b = mk ?loc ?attrs (Pexp_letexception (a, b))
  let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)
  let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)
  let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
  let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
  let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
  let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
  let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)
  let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable

  let case lhs ?guard rhs =
    {
     pc_lhs = lhs;
     pc_guard = guard;
     pc_rhs = rhs;
    }
end

module Mty = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}
  let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}

  let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)
  let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)
  let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)
  let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))
  let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))
  let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)
end

module Mod = struct
let mk ?(loc = !default_loc) ?(attrs = []) d =
  {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}
  let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}

  let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)
  let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)
  let functor_ ?loc ?attrs arg arg_ty body =
    mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))
  let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))
  let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))
  let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
end

module Sig = struct
  let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}

  let value ?loc a = mk ?loc (Psig_value a)
  let type_ ?loc rec_flag a = mk ?loc (Psig_type (rec_flag, a))
  let type_extension ?loc a = mk ?loc (Psig_typext a)
  let exception_ ?loc a = mk ?loc (Psig_exception a)
  let module_ ?loc a = mk ?loc (Psig_module a)
  let rec_module ?loc a = mk ?loc (Psig_recmodule a)
  let modtype ?loc a = mk ?loc (Psig_modtype a)
  let open_ ?loc a = mk ?loc (Psig_open a)
  let include_ ?loc a = mk ?loc (Psig_include a)

  let class_type ?loc a = mk ?loc (Psig_class_type a)
  let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))
  let attribute ?loc a = mk ?loc (Psig_attribute a)
  let text txt =
    let f_txt = Ext_list.filter txt (fun ds -> docstring_body ds <> "") in
    List.map
      (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
      f_txt
end

module Str = struct
  let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}

  let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))
  let value ?loc a b = mk ?loc (Pstr_value (a, b))
  let primitive ?loc a = mk ?loc (Pstr_primitive a)
  let type_ ?loc rec_flag a = mk ?loc (Pstr_type (rec_flag, a))
  let type_extension ?loc a = mk ?loc (Pstr_typext a)
  let exception_ ?loc a = mk ?loc (Pstr_exception a)
  let module_ ?loc a = mk ?loc (Pstr_module a)
  let rec_module ?loc a = mk ?loc (Pstr_recmodule a)
  let modtype ?loc a = mk ?loc (Pstr_modtype a)
  let open_ ?loc a = mk ?loc (Pstr_open a)
  let class_type ?loc a = mk ?loc (Pstr_class_type a)
  let include_ ?loc a = mk ?loc (Pstr_include a)
  let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))
  let attribute ?loc a = mk ?loc (Pstr_attribute a)
  let text txt =
    let f_txt = Ext_list.filter txt (fun ds -> docstring_body ds <> "") in
    List.map
      (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
      f_txt
end

module Cl = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {
     pcl_desc = d;
     pcl_loc = loc;
     pcl_attributes = attrs;
    }
  let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}

  let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))
  let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)
  let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))
  let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))
  let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)
  let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_open (a, b, c))
end

module Cty = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {
     pcty_desc = d;
     pcty_loc = loc;
     pcty_attributes = attrs;
    }
  let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}

  let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))
  let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)
  let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)
  let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_open (a, b, c))
end

module Ctf = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
           ?(docs = empty_docs) d =
    {
     pctf_desc = d;
     pctf_loc = loc;
     pctf_attributes = add_docs_attrs docs attrs;
    }

  let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)
  let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))
  let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)
  let attribute ?loc a = mk ?loc (Pctf_attribute a)
  let text txt =
   let f_txt = Ext_list.filter txt (fun ds -> docstring_body ds <> "")in
     List.map
      (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
      f_txt

  let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}

end

module Cf = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) d =
    {
     pcf_desc = d;
     pcf_loc = loc;
     pcf_attributes = add_docs_attrs docs attrs;
    }

  
  let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))
  let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))
  let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)
  let attribute ?loc a = mk ?loc (Pcf_attribute a)
  let text txt =
    let f_txt = Ext_list.filter txt (fun ds -> docstring_body ds <> "")in
    List.map
      (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
      f_txt

  let virtual_ ct = Cfk_virtual ct
  let concrete o e = Cfk_concrete (o, e)

  let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}

end

module Val = struct
  let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
        ?(prim = []) name typ =
    {
     pval_name = name;
     pval_type = typ;
     pval_attributes = add_docs_attrs docs attrs;
     pval_loc = loc;
     pval_prim = prim;
    }
end

module Md = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = []) name typ =
    {
     pmd_name = name;
     pmd_type = typ;
     pmd_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pmd_loc = loc;
    }
end

module Mtd = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = []) ?typ name =
    {
     pmtd_name = name;
     pmtd_type = typ;
     pmtd_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pmtd_loc = loc;
    }
end

module Mb = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = []) name expr =
    {
     pmb_name = name;
     pmb_expr = expr;
     pmb_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pmb_loc = loc;
    }
end

module Opn = struct
  let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
        ?(override = Fresh) lid =
    {
     popen_lid = lid;
     popen_override = override;
     popen_loc = loc;
     popen_attributes = add_docs_attrs docs attrs;
    }
end

module Incl = struct
  let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =
    {
     pincl_mod = mexpr;
     pincl_loc = loc;
     pincl_attributes = add_docs_attrs docs attrs;
    }

end

module Vb = struct
  let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
        ?(text = []) pat expr =
    {
     pvb_pat = pat;
     pvb_expr = expr;
     pvb_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pvb_loc = loc;
    }
end

module Ci = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = [])
        ?(virt = Concrete) ?(params = []) name expr =
    {
     pci_virt = virt;
     pci_params = params;
     pci_name = name;
     pci_expr = expr;
     pci_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pci_loc = loc;
    }
end

module Type = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = [])
      ?(params = [])
      ?(cstrs = [])
      ?(kind = Ptype_abstract)
      ?(priv = Public)
      ?manifest
      name =
    {
     ptype_name = name;
     ptype_params = params;
     ptype_cstrs = cstrs;
     ptype_kind = kind;
     ptype_private = priv;
     ptype_manifest = manifest;
     ptype_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     ptype_loc = loc;
    }

  let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
        ?(args = Pcstr_tuple []) ?res name =
    {
     pcd_name = name;
     pcd_args = args;
     pcd_res = res;
     pcd_loc = loc;
     pcd_attributes = add_info_attrs info attrs;
    }

  let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
        ?(mut = Immutable) name typ =
    {
     pld_name = name;
     pld_mutable = mut;
     pld_type = typ;
     pld_loc = loc;
     pld_attributes = add_info_attrs info attrs;
    }

end

(** Type extensions *)
module Te = struct
  let mk ?(attrs = []) ?(docs = empty_docs)
        ?(params = []) ?(priv = Public) path constructors =
    {
     ptyext_path = path;
     ptyext_params = params;
     ptyext_constructors = constructors;
     ptyext_private = priv;
     ptyext_attributes = add_docs_attrs docs attrs;
    }

  let constructor ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(info = empty_info) name kind =
    {
     pext_name = name;
     pext_kind = kind;
     pext_loc = loc;
     pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
    }

  let decl ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
             ?(info = empty_info) ?(args = Pcstr_tuple []) ?res name =
    {
     pext_name = name;
     pext_kind = Pext_decl(args, res);
     pext_loc = loc;
     pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
    }

  let rebind ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(info = empty_info) name lid =
    {
     pext_name = name;
     pext_kind = Pext_rebind lid;
     pext_loc = loc;
     pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
    }

end

module Csig = struct
  let mk self fields =
    {
     pcsig_self = self;
     pcsig_fields = fields;
    }
end

module Cstr = struct
  let mk self fields =
    {
     pcstr_self = self;
     pcstr_fields = fields;
    }
end

end
module Parser : sig 
#1 "parser.mli"
type token =
  | AMPERAMPER
  | AMPERSAND
  | AND
  | AS
  | ASSERT
  | BACKQUOTE
  | BANG
  | BAR
  | BARBAR
  | BARRBRACKET
  | BEGIN
  | CHAR of (char)
  | CLASS
  | COLON
  | COLONCOLON
  | COLONEQUAL
  | COLONGREATER
  | COMMA
  | CONSTRAINT
  | DO
  | DONE
  | DOT
  | DOTDOT
  | DOWNTO
  | ELSE
  | END
  | EOF
  | EQUAL
  | EXCEPTION
  | EXTERNAL
  | FALSE
  | FLOAT of (string * char option)
  | FOR
  | FUN
  | FUNCTION
  | FUNCTOR
  | GREATER
  | GREATERRBRACE
  | GREATERRBRACKET
  | IF
  | IN
  | INCLUDE
  | INFIXOP0 of (string)
  | INFIXOP1 of (string)
  | INFIXOP2 of (string)
  | INFIXOP3 of (string)
  | INFIXOP4 of (string)
  | DOTOP of (string)
  | INHERIT
  | INITIALIZER
  | INT of (string * char option)
  | LABEL of (string)
  | LAZY
  | LBRACE
  | LBRACELESS
  | LBRACKET
  | LBRACKETBAR
  | LBRACKETLESS
  | LBRACKETGREATER
  | LBRACKETPERCENT
  | LBRACKETPERCENTPERCENT
  | LESS
  | LESSMINUS
  | LET
  | LIDENT of (string)
  | LPAREN
  | LBRACKETAT
  | LBRACKETATAT
  | LBRACKETATATAT
  | MATCH
  | METHOD
  | MINUS
  | MINUSDOT
  | MINUSGREATER
  | MODULE
  | MUTABLE
  | NEW
  | NONREC
  | OBJECT
  | OF
  | OPEN
  | OPTLABEL of (string)
  | OR
  | PERCENT
  | PLUS
  | PLUSDOT
  | PLUSEQ
  | PREFIXOP of (string)
  | PRIVATE
  | QUESTION
  | QUOTE
  | RBRACE
  | RBRACKET
  | REC
  | RPAREN
  | SEMI
  | SEMISEMI
  | HASH
  | HASHOP of (string)
  | SIG
  | STAR
  | STRING of (string * string option)
  | STRUCT
  | THEN
  | TILDE
  | TO
  | TRUE
  | TRY
  | TYPE
  | UIDENT of (string)
  | UNDERSCORE
  | VAL
  | VIRTUAL
  | WHEN
  | WHILE
  | WITH
  | COMMENT of (string * Location.t)
  | DOCSTRING of (Docstrings.docstring)
  | EOL

val implementation :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.structure
val interface :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.signature
val parse_core_type :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.core_type
val parse_expression :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.expression
val parse_pattern :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.pattern

end = struct
#1 "parser.ml"
type token =
  | AMPERAMPER
  | AMPERSAND
  | AND
  | AS
  | ASSERT
  | BACKQUOTE
  | BANG
  | BAR
  | BARBAR
  | BARRBRACKET
  | BEGIN
  | CHAR of (char)
  | CLASS
  | COLON
  | COLONCOLON
  | COLONEQUAL
  | COLONGREATER
  | COMMA
  | CONSTRAINT
  | DO
  | DONE
  | DOT
  | DOTDOT
  | DOWNTO
  | ELSE
  | END
  | EOF
  | EQUAL
  | EXCEPTION
  | EXTERNAL
  | FALSE
  | FLOAT of (string * char option)
  | FOR
  | FUN
  | FUNCTION
  | FUNCTOR
  | GREATER
  | GREATERRBRACE
  | GREATERRBRACKET
  | IF
  | IN
  | INCLUDE
  | INFIXOP0 of (string)
  | INFIXOP1 of (string)
  | INFIXOP2 of (string)
  | INFIXOP3 of (string)
  | INFIXOP4 of (string)
  | DOTOP of (string)
  | INHERIT
  | INITIALIZER
  | INT of (string * char option)
  | LABEL of (string)
  | LAZY
  | LBRACE
  | LBRACELESS
  | LBRACKET
  | LBRACKETBAR
  | LBRACKETLESS
  | LBRACKETGREATER
  | LBRACKETPERCENT
  | LBRACKETPERCENTPERCENT
  | LESS
  | LESSMINUS
  | LET
  | LIDENT of (string)
  | LPAREN
  | LBRACKETAT
  | LBRACKETATAT
  | LBRACKETATATAT
  | MATCH
  | METHOD
  | MINUS
  | MINUSDOT
  | MINUSGREATER
  | MODULE
  | MUTABLE
  | NEW
  | NONREC
  | OBJECT
  | OF
  | OPEN
  | OPTLABEL of (string)
  | OR
  | PERCENT
  | PLUS
  | PLUSDOT
  | PLUSEQ
  | PREFIXOP of (string)
  | PRIVATE
  | QUESTION
  | QUOTE
  | RBRACE
  | RBRACKET
  | REC
  | RPAREN
  | SEMI
  | SEMISEMI
  | HASH
  | HASHOP of (string)
  | SIG
  | STAR
  | STRING of (string * string option)
  | STRUCT
  | THEN
  | TILDE
  | TO
  | TRUE
  | TRY
  | TYPE
  | UIDENT of (string)
  | UNDERSCORE
  | VAL
  | VIRTUAL
  | WHEN
  | WHILE
  | WITH
  | COMMENT of (string * Location.t)
  | DOCSTRING of (Docstrings.docstring)
  | EOL

open Parsing;;
let _ = parse_error;;
# 19 "ml/parser.mly"
open Location
open Asttypes
open Longident
open Parsetree
open Ast_helper
open Docstrings

let mktyp d = Typ.mk ~loc:(symbol_rloc()) d
let mkpat d = Pat.mk ~loc:(symbol_rloc()) d
let mkexp d = Exp.mk ~loc:(symbol_rloc()) d
let mkmty ?attrs d = Mty.mk ~loc:(symbol_rloc()) ?attrs d
let mksig d = Sig.mk ~loc:(symbol_rloc()) d
let mkmod ?attrs d = Mod.mk ~loc:(symbol_rloc()) ?attrs d
let mkstr d = Str.mk ~loc:(symbol_rloc()) d
let mkcty ?attrs d = Cty.mk ~loc:(symbol_rloc()) ?attrs d
let mkctf ?attrs ?docs d =
  Ctf.mk ~loc:(symbol_rloc()) ?attrs ?docs d
let mkcf ?attrs ?docs d =
  Cf.mk ~loc:(symbol_rloc()) ?attrs ?docs d

let mkrhs rhs pos = mkloc rhs (rhs_loc pos)

let reloc_pat x = { x with ppat_loc = symbol_rloc () };;
let reloc_exp x = { x with pexp_loc = symbol_rloc () };;

let mkoperator name pos =
  let loc = rhs_loc pos in
  Exp.mk ~loc (Pexp_ident(mkloc (Lident name) loc))

let mkpatvar name pos =
  Pat.mk ~loc:(rhs_loc pos) (Ppat_var (mkrhs name pos))

(*
  Ghost expressions and patterns:
  expressions and patterns that do not appear explicitly in the
  source file they have the loc_ghost flag set to true.
  Then the profiler will not try to instrument them and the
  -annot option will not try to display their type.

  Every grammar rule that generates an element with a location must
  make at most one non-ghost element, the topmost one.

  How to tell whether your location must be ghost:
  A location corresponds to a range of characters in the source file.
  If the location contains a piece of code that is syntactically
  valid (according to the documentation), and corresponds to the
  AST node, then the location must be real; in all other cases,
  it must be ghost.
*)
let ghexp d = Exp.mk ~loc:(symbol_gloc ()) d
let ghpat d = Pat.mk ~loc:(symbol_gloc ()) d
let ghtyp d = Typ.mk ~loc:(symbol_gloc ()) d
let ghloc d = { txt = d; loc = symbol_gloc () }
let ghstr d = Str.mk ~loc:(symbol_gloc()) d
let ghsig d = Sig.mk ~loc:(symbol_gloc()) d

let mkinfix arg1 name arg2 =
  mkexp(Pexp_apply(mkoperator name 2, [Nolabel, arg1; Nolabel, arg2]))

let neg_string f =
  if String.length f > 0 && f.[0] = '-'
  then String.sub f 1 (String.length f - 1)
  else "-" ^ f

let mkuminus name arg =
  match name, arg.pexp_desc with
  | "-", Pexp_constant(Pconst_integer (n,m)) ->
      mkexp(Pexp_constant(Pconst_integer(neg_string n,m)))
  | ("-" | "-."), Pexp_constant(Pconst_float (f, m)) ->
      mkexp(Pexp_constant(Pconst_float(neg_string f, m)))
  | _ ->
      mkexp(Pexp_apply(mkoperator ("~" ^ name) 1, [Nolabel, arg]))

let mkuplus name arg =
  let desc = arg.pexp_desc in
  match name, desc with
  | "+", Pexp_constant(Pconst_integer _)
  | ("+" | "+."), Pexp_constant(Pconst_float _) -> mkexp desc
  | _ ->
      mkexp(Pexp_apply(mkoperator ("~" ^ name) 1, [Nolabel, arg]))

let mkexp_cons consloc args loc =
  Exp.mk ~loc (Pexp_construct(mkloc (Lident "::") consloc, Some args))

let mkpat_cons consloc args loc =
  Pat.mk ~loc (Ppat_construct(mkloc (Lident "::") consloc, Some args))

let rec mktailexp nilloc = function
    [] ->
      let loc = { nilloc with loc_ghost = true } in
      let nil = { txt = Lident "[]"; loc = loc } in
      Exp.mk ~loc (Pexp_construct (nil, None))
  | e1 :: el ->
      let exp_el = mktailexp nilloc el in
      let loc = {loc_start = e1.pexp_loc.loc_start;
               loc_end = exp_el.pexp_loc.loc_end;
               loc_ghost = true}
      in
      let arg = Exp.mk ~loc (Pexp_tuple [e1; exp_el]) in
      mkexp_cons {loc with loc_ghost = true} arg loc

let rec mktailpat nilloc = function
    [] ->
      let loc = { nilloc with loc_ghost = true } in
      let nil = { txt = Lident "[]"; loc = loc } in
      Pat.mk ~loc (Ppat_construct (nil, None))
  | p1 :: pl ->
      let pat_pl = mktailpat nilloc pl in
      let loc = {loc_start = p1.ppat_loc.loc_start;
               loc_end = pat_pl.ppat_loc.loc_end;
               loc_ghost = true}
      in
      let arg = Pat.mk ~loc (Ppat_tuple [p1; pat_pl]) in
      mkpat_cons {loc with loc_ghost = true} arg loc

let mkstrexp e attrs =
  { pstr_desc = Pstr_eval (e, attrs); pstr_loc = e.pexp_loc }

let mkexp_constraint e (t1, t2) =
  match t1, t2 with
  | Some t, None -> ghexp(Pexp_constraint(e, t))
  | _, Some t -> ghexp(Pexp_coerce(e, t1, t))
  | None, None -> assert false

let mkexp_opt_constraint e = function
  | None -> e
  | Some constraint_ -> mkexp_constraint e constraint_

let mkpat_opt_constraint p = function
  | None -> p
  | Some typ -> mkpat (Ppat_constraint(p, typ))

let array_function str name =
  ghloc (Ldot(Lident str, (if !Clflags.fast then "unsafe_" ^ name else name)))

let syntax_error () =
  raise Syntaxerr.Escape_error

let unclosed opening_name opening_num closing_name closing_num =
  raise(Syntaxerr.Error(Syntaxerr.Unclosed(rhs_loc opening_num, opening_name,
                                           rhs_loc closing_num, closing_name)))

let expecting pos nonterm =
    raise Syntaxerr.(Error(Expecting(rhs_loc pos, nonterm)))

let not_expecting pos nonterm =
    raise Syntaxerr.(Error(Not_expecting(rhs_loc pos, nonterm)))


let lapply p1 p2 =
  if !Clflags.applicative_functors
  then Lapply(p1, p2)
  else raise (Syntaxerr.Error(Syntaxerr.Applicative_path (symbol_rloc())))

let exp_of_label lbl pos =
  mkexp (Pexp_ident(mkrhs (Lident(Longident.last lbl)) pos))

let pat_of_label lbl pos =
  mkpat (Ppat_var (mkrhs (Longident.last lbl) pos))

let mk_newtypes newtypes exp =
  List.fold_right (fun newtype exp -> mkexp (Pexp_newtype (newtype, exp)))
    newtypes exp

let wrap_type_annotation newtypes core_type body =
  let exp = mkexp(Pexp_constraint(body,core_type)) in
  let exp = mk_newtypes newtypes exp in
  (exp, ghtyp(Ptyp_poly(newtypes, Typ.varify_constructors newtypes core_type)))

let wrap_exp_attrs body (ext, attrs) =
  (* todo: keep exact location for the entire attribute *)
  let body = {body with pexp_attributes = attrs @ body.pexp_attributes} in
  match ext with
  | None -> body
  | Some id -> ghexp(Pexp_extension (id, PStr [mkstrexp body []]))

let mkexp_attrs d attrs =
  wrap_exp_attrs (mkexp d) attrs

let wrap_typ_attrs typ (ext, attrs) =
  (* todo: keep exact location for the entire attribute *)
  let typ = {typ with ptyp_attributes = attrs @ typ.ptyp_attributes} in
  match ext with
  | None -> typ
  | Some id -> ghtyp(Ptyp_extension (id, PTyp typ))

let mktyp_attrs d attrs =
  wrap_typ_attrs (mktyp d) attrs

let wrap_pat_attrs pat (ext, attrs) =
  (* todo: keep exact location for the entire attribute *)
  let pat = {pat with ppat_attributes = attrs @ pat.ppat_attributes} in
  match ext with
  | None -> pat
  | Some id -> ghpat(Ppat_extension (id, PPat (pat, None)))

let mkpat_attrs d attrs =
  wrap_pat_attrs (mkpat d) attrs

let wrap_class_type_attrs body attrs =
  {body with pcty_attributes = attrs @ body.pcty_attributes}
let wrap_mod_attrs body attrs =
  {body with pmod_attributes = attrs @ body.pmod_attributes}
let wrap_mty_attrs body attrs =
  {body with pmty_attributes = attrs @ body.pmty_attributes}

let wrap_str_ext body ext =
  match ext with
  | None -> body
  | Some id -> ghstr(Pstr_extension ((id, PStr [body]), []))

let mkstr_ext d ext =
  wrap_str_ext (mkstr d) ext

let wrap_sig_ext body ext =
  match ext with
  | None -> body
  | Some id -> ghsig(Psig_extension ((id, PSig [body]), []))

let mksig_ext d ext =
  wrap_sig_ext (mksig d) ext

let text_str pos = Str.text (rhs_text pos)
let text_sig pos = Sig.text (rhs_text pos)
let text_cstr pos = Cf.text (rhs_text pos)
let text_csig pos = Ctf.text (rhs_text pos)


let extra_text text pos items =
  let pre_extras = rhs_pre_extra_text pos in
  let post_extras = rhs_post_extra_text pos in
    text pre_extras @ items @ text post_extras

let extra_str pos items = extra_text Str.text pos items
let extra_sig pos items = extra_text Sig.text pos items
let extra_cstr pos items = extra_text Cf.text pos items
let extra_csig pos items = extra_text Ctf.text pos items

let extra_rhs_core_type ct ~pos =
  let docs = rhs_info pos in
  { ct with ptyp_attributes = add_info_attrs docs ct.ptyp_attributes }

type let_binding =
  { lb_pattern: pattern;
    lb_expression: expression;
    lb_attributes: attributes;
    lb_docs: docs Lazy.t;
    lb_text: text Lazy.t;
    lb_loc: Location.t; }

type let_bindings =
  { lbs_bindings: let_binding list;
    lbs_rec: rec_flag;
    lbs_extension: string Asttypes.loc option;
    lbs_loc: Location.t }

let mklb first (p, e) attrs =
  { lb_pattern = p;
    lb_expression = e;
    lb_attributes = attrs;
    lb_docs = symbol_docs_lazy ();
    lb_text = if first then empty_text_lazy
              else symbol_text_lazy ();
    lb_loc = symbol_rloc (); }

let mklbs ext rf lb =
  { lbs_bindings = [lb];
    lbs_rec = rf;
    lbs_extension = ext ;
    lbs_loc = symbol_rloc (); }

let addlb lbs lb =
  { lbs with lbs_bindings = lb :: lbs.lbs_bindings }

let val_of_let_bindings lbs =
  let bindings =
    List.map
      (fun lb ->
         Vb.mk ~loc:lb.lb_loc ~attrs:lb.lb_attributes
           ~docs:(Lazy.force lb.lb_docs)
           ~text:(Lazy.force lb.lb_text)
           lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
  let str = mkstr(Pstr_value(lbs.lbs_rec, List.rev bindings)) in
  match lbs.lbs_extension with
  | None -> str
  | Some id -> ghstr (Pstr_extension((id, PStr [str]), []))

let expr_of_let_bindings lbs body =
  let bindings =
    List.map
      (fun lb ->
         Vb.mk ~loc:lb.lb_loc ~attrs:lb.lb_attributes
           lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
    mkexp_attrs (Pexp_let(lbs.lbs_rec, List.rev bindings, body))
      (lbs.lbs_extension, [])



(* Alternatively, we could keep the generic module type in the Parsetree
   and extract the package type during type-checking. In that case,
   the assertions below should be turned into explicit checks. *)
let package_type_of_module_type pmty =
  let err loc s =
    raise (Syntaxerr.Error (Syntaxerr.Invalid_package_type (loc, s)))
  in
  let map_cstr = function
    | Pwith_type (lid, ptyp) ->
        let loc = ptyp.ptype_loc in
        if ptyp.ptype_params <> [] then
          err loc "parametrized types are not supported";
        if ptyp.ptype_cstrs <> [] then
          err loc "constrained types are not supported";
        if ptyp.ptype_private <> Public then
          err loc "private types are not supported";

        (* restrictions below are checked by the 'with_constraint' rule *)
        assert (ptyp.ptype_kind = Ptype_abstract);
        assert (ptyp.ptype_attributes = []);
        let ty =
          match ptyp.ptype_manifest with
          | Some ty -> ty
          | None -> assert false
        in
        (lid, ty)
    | _ ->
        err pmty.pmty_loc "only 'with type t =' constraints are supported"
  in
  match pmty with
  | {pmty_desc = Pmty_ident lid} -> (lid, [])
  | {pmty_desc = Pmty_with({pmty_desc = Pmty_ident lid}, cstrs)} ->
      (lid, List.map map_cstr cstrs)
  | _ ->
      err pmty.pmty_loc
        "only module type identifier and 'with type' constraints are supported"


# 466 "ml/parser.ml"
let yytransl_const = [|
  257 (* AMPERAMPER *);
  258 (* AMPERSAND *);
  259 (* AND *);
  260 (* AS *);
  261 (* ASSERT *);
  262 (* BACKQUOTE *);
  263 (* BANG *);
  264 (* BAR *);
  265 (* BARBAR *);
  266 (* BARRBRACKET *);
  267 (* BEGIN *);
  269 (* CLASS *);
  270 (* COLON *);
  271 (* COLONCOLON *);
  272 (* COLONEQUAL *);
  273 (* COLONGREATER *);
  274 (* COMMA *);
  275 (* CONSTRAINT *);
  276 (* DO *);
  277 (* DONE *);
  278 (* DOT *);
  279 (* DOTDOT *);
  280 (* DOWNTO *);
  281 (* ELSE *);
  282 (* END *);
    0 (* EOF *);
  283 (* EQUAL *);
  284 (* EXCEPTION *);
  285 (* EXTERNAL *);
  286 (* FALSE *);
  288 (* FOR *);
  289 (* FUN *);
  290 (* FUNCTION *);
  291 (* FUNCTOR *);
  292 (* GREATER *);
  293 (* GREATERRBRACE *);
  294 (* GREATERRBRACKET *);
  295 (* IF *);
  296 (* IN *);
  297 (* INCLUDE *);
  304 (* INHERIT *);
  305 (* INITIALIZER *);
  308 (* LAZY *);
  309 (* LBRACE *);
  310 (* LBRACELESS *);
  311 (* LBRACKET *);
  312 (* LBRACKETBAR *);
  313 (* LBRACKETLESS *);
  314 (* LBRACKETGREATER *);
  315 (* LBRACKETPERCENT *);
  316 (* LBRACKETPERCENTPERCENT *);
  317 (* LESS *);
  318 (* LESSMINUS *);
  319 (* LET *);
  321 (* LPAREN *);
  322 (* LBRACKETAT *);
  323 (* LBRACKETATAT *);
  324 (* LBRACKETATATAT *);
  325 (* MATCH *);
  326 (* METHOD *);
  327 (* MINUS *);
  328 (* MINUSDOT *);
  329 (* MINUSGREATER *);
  330 (* MODULE *);
  331 (* MUTABLE *);
  332 (* NEW *);
  333 (* NONREC *);
  334 (* OBJECT *);
  335 (* OF *);
  336 (* OPEN *);
  338 (* OR *);
  339 (* PERCENT *);
  340 (* PLUS *);
  341 (* PLUSDOT *);
  342 (* PLUSEQ *);
  344 (* PRIVATE *);
  345 (* QUESTION *);
  346 (* QUOTE *);
  347 (* RBRACE *);
  348 (* RBRACKET *);
  349 (* REC *);
  350 (* RPAREN *);
  351 (* SEMI *);
  352 (* SEMISEMI *);
  353 (* HASH *);
  355 (* SIG *);
  356 (* STAR *);
  358 (* STRUCT *);
  359 (* THEN *);
  360 (* TILDE *);
  361 (* TO *);
  362 (* TRUE *);
  363 (* TRY *);
  364 (* TYPE *);
  366 (* UNDERSCORE *);
  367 (* VAL *);
  368 (* VIRTUAL *);
  369 (* WHEN *);
  370 (* WHILE *);
  371 (* WITH *);
  374 (* EOL *);
    0|]

let yytransl_block = [|
  268 (* CHAR *);
  287 (* FLOAT *);
  298 (* INFIXOP0 *);
  299 (* INFIXOP1 *);
  300 (* INFIXOP2 *);
  301 (* INFIXOP3 *);
  302 (* INFIXOP4 *);
  303 (* DOTOP *);
  306 (* INT *);
  307 (* LABEL *);
  320 (* LIDENT *);
  337 (* OPTLABEL *);
  343 (* PREFIXOP *);
  354 (* HASHOP *);
  357 (* STRING *);
  365 (* UIDENT *);
  372 (* COMMENT *);
  373 (* DOCSTRING *);
    0|]

let yylhs = "\255\255\
\001\000\002\000\003\000\004\000\005\000\011\000\011\000\012\000\
\012\000\014\000\014\000\015\000\015\000\015\000\015\000\015\000\
\015\000\015\000\015\000\015\000\018\000\018\000\018\000\018\000\
\018\000\018\000\018\000\018\000\018\000\018\000\018\000\006\000\
\006\000\024\000\024\000\024\000\025\000\025\000\025\000\025\000\
\025\000\025\000\025\000\025\000\025\000\025\000\025\000\025\000\
\025\000\025\000\037\000\041\000\041\000\041\000\032\000\033\000\
\033\000\042\000\043\000\013\000\013\000\013\000\013\000\013\000\
\013\000\013\000\013\000\013\000\013\000\013\000\007\000\007\000\
\007\000\046\000\046\000\046\000\046\000\046\000\046\000\046\000\
\046\000\046\000\046\000\046\000\046\000\046\000\046\000\035\000\
\052\000\054\000\054\000\054\000\049\000\050\000\051\000\051\000\
\055\000\056\000\057\000\057\000\034\000\059\000\059\000\061\000\
\062\000\062\000\062\000\063\000\063\000\064\000\064\000\064\000\
\064\000\064\000\064\000\065\000\065\000\065\000\065\000\066\000\
\066\000\066\000\066\000\066\000\075\000\075\000\075\000\075\000\
\075\000\075\000\075\000\078\000\079\000\079\000\080\000\080\000\
\081\000\081\000\081\000\081\000\081\000\081\000\082\000\082\000\
\082\000\085\000\067\000\036\000\036\000\086\000\087\000\009\000\
\009\000\009\000\009\000\089\000\089\000\089\000\089\000\089\000\
\089\000\089\000\089\000\094\000\094\000\091\000\091\000\090\000\
\090\000\092\000\093\000\093\000\021\000\021\000\021\000\021\000\
\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\
\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\
\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\
\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\
\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\
\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\
\021\000\021\000\021\000\021\000\021\000\021\000\096\000\096\000\
\096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
\096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
\096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
\096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
\096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
\096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
\096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
\096\000\096\000\096\000\096\000\097\000\097\000\115\000\115\000\
\116\000\116\000\116\000\116\000\117\000\074\000\074\000\118\000\
\118\000\118\000\118\000\118\000\118\000\026\000\026\000\123\000\
\124\000\126\000\126\000\073\000\073\000\073\000\100\000\100\000\
\127\000\127\000\127\000\101\000\101\000\101\000\101\000\102\000\
\102\000\111\000\111\000\129\000\129\000\129\000\130\000\130\000\
\114\000\114\000\132\000\132\000\112\000\112\000\070\000\070\000\
\070\000\070\000\070\000\131\000\131\000\010\000\010\000\010\000\
\010\000\010\000\010\000\010\000\010\000\010\000\010\000\121\000\
\121\000\121\000\121\000\121\000\121\000\121\000\121\000\121\000\
\134\000\134\000\134\000\134\000\095\000\095\000\122\000\122\000\
\122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
\122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
\122\000\122\000\122\000\122\000\138\000\138\000\138\000\138\000\
\138\000\138\000\138\000\133\000\133\000\133\000\135\000\135\000\
\135\000\140\000\140\000\139\000\139\000\139\000\139\000\141\000\
\141\000\142\000\142\000\028\000\143\000\143\000\027\000\029\000\
\029\000\144\000\145\000\149\000\149\000\148\000\148\000\148\000\
\148\000\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
\147\000\147\000\147\000\152\000\153\000\153\000\155\000\155\000\
\156\000\154\000\154\000\154\000\157\000\060\000\060\000\150\000\
\150\000\150\000\158\000\159\000\031\000\031\000\048\000\098\000\
\161\000\161\000\161\000\161\000\162\000\162\000\151\000\151\000\
\151\000\164\000\165\000\030\000\047\000\167\000\167\000\167\000\
\167\000\167\000\167\000\168\000\168\000\168\000\169\000\170\000\
\171\000\172\000\045\000\045\000\173\000\173\000\173\000\173\000\
\174\000\174\000\120\000\120\000\071\000\071\000\166\000\166\000\
\008\000\008\000\175\000\175\000\177\000\177\000\177\000\177\000\
\177\000\128\000\128\000\179\000\179\000\179\000\179\000\179\000\
\179\000\179\000\179\000\179\000\179\000\179\000\179\000\179\000\
\179\000\179\000\179\000\179\000\179\000\179\000\022\000\183\000\
\183\000\184\000\184\000\182\000\182\000\186\000\186\000\187\000\
\187\000\185\000\185\000\178\000\178\000\076\000\076\000\163\000\
\163\000\180\000\180\000\180\000\180\000\180\000\180\000\180\000\
\190\000\188\000\189\000\068\000\110\000\110\000\110\000\110\000\
\136\000\136\000\136\000\136\000\136\000\058\000\058\000\119\000\
\119\000\119\000\119\000\119\000\191\000\191\000\191\000\191\000\
\191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
\191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
\191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
\191\000\160\000\160\000\160\000\160\000\160\000\160\000\109\000\
\109\000\103\000\103\000\103\000\103\000\103\000\103\000\103\000\
\108\000\108\000\137\000\137\000\016\000\016\000\176\000\176\000\
\176\000\044\000\044\000\077\000\077\000\181\000\181\000\104\000\
\125\000\125\000\146\000\146\000\105\000\105\000\072\000\072\000\
\069\000\069\000\084\000\084\000\083\000\083\000\083\000\083\000\
\083\000\053\000\053\000\099\000\099\000\113\000\113\000\106\000\
\106\000\107\000\107\000\192\000\192\000\192\000\192\000\192\000\
\192\000\192\000\192\000\192\000\192\000\192\000\192\000\192\000\
\192\000\192\000\192\000\192\000\192\000\192\000\192\000\192\000\
\192\000\192\000\192\000\192\000\192\000\192\000\192\000\192\000\
\192\000\192\000\192\000\192\000\192\000\192\000\192\000\192\000\
\192\000\192\000\192\000\192\000\192\000\192\000\192\000\192\000\
\192\000\192\000\192\000\192\000\192\000\192\000\088\000\088\000\
\019\000\194\000\039\000\023\000\023\000\017\000\017\000\040\000\
\040\000\040\000\020\000\038\000\193\000\193\000\193\000\193\000\
\193\000\000\000\000\000\000\000\000\000\000\000"

let yylen = "\002\000\
\002\000\002\000\002\000\002\000\002\000\002\000\005\000\001\000\
\001\000\002\000\001\000\001\000\004\000\004\000\005\000\002\000\
\003\000\001\000\002\000\001\000\005\000\005\000\003\000\003\000\
\005\000\007\000\009\000\007\000\006\000\006\000\005\000\003\000\
\001\000\000\000\002\000\002\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\002\000\001\000\004\000\002\000\004\000\002\000\005\000\001\000\
\002\000\006\000\005\000\001\000\004\000\004\000\005\000\003\000\
\003\000\005\000\003\000\003\000\001\000\002\000\000\000\002\000\
\002\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\002\000\001\000\005\000\
\004\000\002\000\006\000\003\000\005\000\006\000\001\000\002\000\
\007\000\006\000\000\000\002\000\006\000\000\000\003\000\002\000\
\003\000\005\000\000\000\000\000\002\000\003\000\003\000\004\000\
\004\000\002\000\001\000\007\000\007\000\006\000\007\000\007\000\
\007\000\005\000\008\000\011\000\004\000\001\000\004\000\004\000\
\002\000\001\000\007\000\002\000\003\000\000\000\000\000\002\000\
\004\000\004\000\007\000\004\000\002\000\001\000\005\000\005\000\
\003\000\003\000\003\000\001\000\002\000\009\000\008\000\001\000\
\002\000\003\000\005\000\005\000\002\000\005\000\002\000\004\000\
\002\000\002\000\001\000\001\000\001\000\000\000\002\000\001\000\
\003\000\001\000\001\000\003\000\001\000\002\000\003\000\007\000\
\006\000\007\000\004\000\004\000\007\000\006\000\006\000\005\000\
\001\000\002\000\002\000\007\000\005\000\006\000\010\000\003\000\
\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
\003\000\003\000\003\000\003\000\002\000\002\000\005\000\007\000\
\007\000\007\000\007\000\007\000\009\000\009\000\009\000\003\000\
\003\000\003\000\004\000\004\000\002\000\001\000\001\000\001\000\
\001\000\001\000\003\000\003\000\004\000\003\000\004\000\004\000\
\003\000\005\000\004\000\005\000\005\000\005\000\005\000\005\000\
\005\000\005\000\005\000\005\000\005\000\005\000\007\000\007\000\
\007\000\007\000\007\000\007\000\005\000\003\000\003\000\005\000\
\005\000\004\000\004\000\002\000\006\000\004\000\006\000\004\000\
\004\000\006\000\004\000\006\000\002\000\002\000\003\000\003\000\
\002\000\005\000\004\000\005\000\003\000\003\000\005\000\007\000\
\006\000\009\000\008\000\001\000\001\000\002\000\001\000\001\000\
\002\000\002\000\002\000\002\000\001\000\001\000\002\000\002\000\
\004\000\007\000\008\000\003\000\005\000\001\000\002\000\005\000\
\004\000\001\000\003\000\002\000\002\000\005\000\001\000\003\000\
\003\000\005\000\003\000\002\000\004\000\002\000\005\000\003\000\
\003\000\003\000\001\000\001\000\003\000\002\000\004\000\002\000\
\002\000\003\000\003\000\001\000\001\000\003\000\002\000\004\000\
\002\000\002\000\002\000\001\000\000\000\003\000\003\000\001\000\
\003\000\003\000\003\000\003\000\003\000\002\000\001\000\003\000\
\003\000\001\000\003\000\003\000\003\000\003\000\002\000\001\000\
\001\000\002\000\002\000\003\000\001\000\001\000\001\000\001\000\
\003\000\001\000\001\000\002\000\001\000\003\000\004\000\004\000\
\005\000\005\000\004\000\003\000\003\000\005\000\005\000\004\000\
\005\000\007\000\007\000\001\000\003\000\003\000\004\000\004\000\
\004\000\002\000\004\000\003\000\003\000\003\000\003\000\003\000\
\003\000\001\000\003\000\001\000\002\000\004\000\003\000\004\000\
\002\000\002\000\000\000\006\000\001\000\002\000\008\000\001\000\
\002\000\008\000\007\000\003\000\000\000\000\000\002\000\003\000\
\002\000\003\000\002\000\003\000\005\000\005\000\005\000\007\000\
\000\000\001\000\003\000\002\000\001\000\003\000\002\000\001\000\
\002\000\000\000\001\000\001\000\002\000\001\000\003\000\001\000\
\001\000\002\000\003\000\004\000\001\000\007\000\006\000\003\000\
\000\000\002\000\004\000\002\000\001\000\003\000\001\000\001\000\
\002\000\005\000\007\000\009\000\009\000\001\000\001\000\001\000\
\001\000\002\000\002\000\001\000\001\000\002\000\003\000\004\000\
\004\000\005\000\001\000\003\000\006\000\005\000\004\000\004\000\
\001\000\002\000\002\000\003\000\001\000\003\000\001\000\003\000\
\001\000\002\000\001\000\004\000\001\000\006\000\004\000\005\000\
\003\000\001\000\003\000\002\000\001\000\001\000\002\000\004\000\
\003\000\002\000\002\000\003\000\005\000\003\000\004\000\005\000\
\004\000\002\000\004\000\006\000\005\000\001\000\001\000\001\000\
\003\000\001\000\001\000\005\000\002\000\001\000\000\000\001\000\
\003\000\001\000\002\000\001\000\003\000\001\000\003\000\001\000\
\003\000\002\000\002\000\001\000\001\000\001\000\001\000\001\000\
\004\000\006\000\002\000\001\000\001\000\001\000\001\000\001\000\
\001\000\002\000\002\000\002\000\002\000\001\000\001\000\001\000\
\003\000\003\000\002\000\003\000\001\000\001\000\001\000\001\000\
\001\000\001\000\003\000\004\000\003\000\004\000\003\000\004\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\002\000\002\000\003\000\001\000\001\000\001\000\
\003\000\001\000\005\000\002\000\002\000\003\000\001\000\001\000\
\001\000\003\000\001\000\003\000\001\000\003\000\001\000\003\000\
\004\000\001\000\003\000\001\000\003\000\001\000\003\000\002\000\
\000\000\001\000\000\000\001\000\001\000\001\000\000\000\001\000\
\000\000\001\000\000\000\001\000\000\000\001\000\001\000\002\000\
\002\000\000\000\001\000\000\000\001\000\000\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\003\000\
\004\000\004\000\004\000\000\000\002\000\000\000\002\000\000\000\
\002\000\003\000\004\000\004\000\001\000\002\000\002\000\002\000\
\004\000\002\000\002\000\002\000\002\000\002\000"

let yydefred = "\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\054\002\000\000\000\000\000\000\111\002\056\002\
\000\000\000\000\000\000\000\000\000\000\053\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\152\002\153\002\000\000\000\000\000\000\154\002\
\155\002\000\000\000\000\055\002\112\002\000\000\000\000\117\002\
\230\000\000\000\000\000\226\002\000\000\000\000\000\000\036\001\
\000\000\033\000\000\000\000\000\038\000\039\000\000\000\041\000\
\042\000\043\000\000\000\045\000\046\000\000\000\048\000\000\000\
\050\000\056\000\205\001\000\000\148\000\000\000\000\000\000\000\
\000\000\000\000\000\000\231\000\232\000\104\002\054\001\168\001\
\000\000\000\000\000\000\000\000\000\000\227\002\000\000\075\000\
\074\000\000\000\082\000\083\000\000\000\000\000\087\000\000\000\
\077\000\078\000\079\000\080\000\000\000\084\000\095\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\119\002\005\002\228\002\000\000\022\002\000\000\006\002\
\249\001\000\000\000\000\253\001\000\000\229\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\064\002\000\000\000\000\
\000\000\000\000\119\001\230\002\000\000\000\000\140\001\113\001\
\000\000\000\000\057\002\117\001\118\001\000\000\103\001\000\000\
\125\001\000\000\000\000\000\000\000\000\063\002\062\002\128\002\
\022\001\233\000\234\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\075\001\000\000\025\001\052\002\000\000\000\000\
\000\000\108\002\000\000\000\000\012\001\000\000\158\002\159\002\
\160\002\161\002\162\002\163\002\164\002\165\002\166\002\167\002\
\168\002\169\002\170\002\171\002\172\002\173\002\174\002\175\002\
\176\002\177\002\178\002\179\002\180\002\181\002\182\002\156\002\
\183\002\184\002\185\002\186\002\187\002\188\002\189\002\190\002\
\191\002\192\002\193\002\194\002\195\002\196\002\197\002\198\002\
\199\002\200\002\201\002\157\002\202\002\203\002\204\002\205\002\
\206\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\067\002\094\002\093\002\000\000\092\002\000\000\095\002\088\002\
\090\002\070\002\071\002\072\002\073\002\074\002\000\000\089\002\
\000\000\000\000\000\000\091\002\097\002\000\000\000\000\096\002\
\000\000\109\002\081\002\087\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\147\002\000\000\021\001\035\000\000\000\
\000\000\000\000\000\000\001\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\229\000\
\000\000\036\000\000\000\000\000\000\000\055\001\000\000\169\001\
\000\000\057\000\000\000\149\000\049\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\037\001\040\001\000\000\000\000\000\000\213\000\214\000\000\000\
\000\000\000\000\072\000\000\000\002\000\086\000\073\000\000\000\
\096\000\000\000\115\002\000\000\027\002\000\000\000\000\149\002\
\000\000\018\002\000\000\048\002\010\002\000\000\000\000\000\000\
\000\000\000\000\000\000\045\002\000\000\000\000\000\000\000\000\
\000\000\000\000\004\002\126\002\000\000\011\002\003\000\250\001\
\000\000\000\000\000\000\000\000\000\000\000\000\007\002\004\000\
\000\000\000\000\113\002\000\000\000\000\000\000\000\000\000\000\
\000\000\146\001\000\000\082\002\000\000\086\002\000\000\000\000\
\084\002\069\002\000\000\059\002\058\002\061\002\060\002\124\001\
\000\000\000\000\000\000\000\000\005\000\102\001\000\000\114\001\
\115\001\000\000\000\000\000\000\000\000\217\002\000\000\000\000\
\000\000\000\000\238\000\000\000\000\000\102\002\000\000\000\000\
\103\002\098\002\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\163\000\122\001\123\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\018\000\020\000\
\000\000\000\000\000\000\000\000\000\000\092\001\000\000\007\001\
\006\001\000\000\000\000\024\001\023\001\000\000\081\001\000\000\
\000\000\000\000\000\000\000\000\221\002\000\000\000\000\000\000\
\000\000\000\000\000\000\130\002\000\000\110\002\000\000\000\000\
\000\000\068\002\000\000\236\000\235\000\000\000\066\002\065\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\108\000\
\000\000\000\000\132\002\000\000\000\000\000\000\000\000\032\000\
\213\002\000\000\000\000\000\000\000\000\000\000\118\002\105\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\154\000\000\000\
\000\000\175\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\045\001\043\001\029\001\000\000\042\001\038\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\069\000\060\000\
\122\002\000\000\000\000\000\000\000\000\000\000\026\002\000\000\
\024\002\000\000\029\002\014\002\000\000\000\000\000\000\000\000\
\051\002\009\002\042\002\043\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\040\002\000\000\116\002\120\002\000\000\
\000\000\000\000\012\002\101\001\116\001\000\000\000\000\000\000\
\142\001\141\001\000\000\000\000\000\000\000\000\000\000\133\001\
\000\000\132\001\095\001\094\001\100\001\000\000\098\001\000\000\
\150\001\000\000\000\000\000\000\126\001\000\000\121\001\000\000\
\218\002\215\002\000\000\000\000\000\000\241\000\000\000\000\000\
\000\000\239\000\237\000\140\002\000\000\099\002\000\000\100\002\
\000\000\000\000\000\000\000\000\085\002\000\000\083\002\000\000\
\000\000\162\000\000\000\164\000\000\000\165\000\159\000\170\000\
\000\000\157\000\000\000\161\000\000\000\000\000\000\000\000\000\
\180\000\000\000\000\000\063\001\000\000\000\000\000\000\000\000\
\000\000\000\000\016\000\019\000\051\000\000\000\000\000\074\001\
\090\001\000\000\091\001\000\000\000\000\077\001\000\000\082\001\
\000\000\017\001\016\001\011\001\010\001\222\002\000\000\000\000\
\219\002\208\002\220\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\112\001\000\000\000\000\000\000\000\000\
\000\000\240\000\211\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\228\000\227\000\000\000\000\000\
\000\000\000\000\196\001\195\001\000\000\186\001\000\000\000\000\
\000\000\000\000\000\000\027\001\000\000\019\001\000\000\014\001\
\000\000\000\000\000\000\243\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\070\000\089\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\015\002\030\002\000\000\000\000\
\000\000\019\002\017\002\000\000\000\000\000\000\247\001\000\000\
\000\000\000\000\000\000\000\000\008\002\000\000\000\000\127\002\
\000\000\000\000\121\002\252\001\114\002\000\000\000\000\000\000\
\159\001\000\000\144\001\143\001\147\001\145\001\000\000\136\001\
\000\000\127\001\131\001\128\001\000\000\209\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\101\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\210\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\068\001\070\001\000\000\000\000\
\000\000\000\000\011\000\000\000\000\000\024\000\000\000\023\000\
\000\000\017\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\056\001\000\000\000\000\000\000\000\000\048\001\000\000\
\000\000\000\000\000\000\000\000\000\000\111\001\000\000\000\000\
\080\002\078\002\076\002\000\000\031\001\000\000\000\000\000\000\
\000\000\000\000\000\000\006\000\008\000\009\000\000\000\054\000\
\055\000\000\000\105\000\000\000\000\000\000\000\000\000\000\000\
\115\000\109\000\088\000\184\000\000\000\189\001\000\000\000\000\
\000\000\000\000\192\001\188\001\000\000\000\000\210\002\009\001\
\008\001\028\001\026\001\000\000\000\000\107\002\000\000\244\000\
\242\000\155\000\057\001\000\000\000\000\000\000\005\001\248\000\
\000\000\246\000\000\000\000\000\000\000\000\000\000\000\254\000\
\000\000\250\000\000\000\252\000\000\000\000\000\068\000\067\000\
\000\000\000\000\000\000\000\000\000\000\000\000\235\001\000\000\
\123\002\000\000\000\000\000\000\000\000\000\000\093\000\000\000\
\000\000\025\002\032\002\000\000\016\002\034\002\000\000\000\000\
\000\000\000\000\000\000\000\000\021\002\013\002\000\000\041\002\
\000\000\151\002\158\001\000\000\137\001\135\001\134\001\130\001\
\129\001\247\000\245\000\000\000\000\000\000\000\253\000\249\000\
\251\000\000\000\000\000\198\001\000\000\138\002\000\000\000\000\
\215\001\000\000\000\000\000\000\000\000\207\001\000\000\134\002\
\133\002\000\000\047\001\000\000\000\000\000\000\000\000\000\000\
\000\000\160\000\000\000\000\000\067\001\065\001\000\000\064\001\
\000\000\000\000\010\000\000\000\000\000\014\000\013\000\000\000\
\225\002\177\000\208\001\000\000\000\000\000\000\000\000\060\001\
\000\000\000\000\000\000\058\001\061\001\105\001\104\001\110\001\
\000\000\108\001\000\000\153\001\000\000\052\001\000\000\000\000\
\033\001\000\000\000\000\000\000\101\000\058\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\114\000\
\000\000\000\000\187\001\000\000\173\001\000\000\191\001\164\001\
\190\000\020\001\018\001\015\001\013\001\000\000\173\001\059\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\062\000\061\000\000\000\000\000\000\000\
\000\000\094\000\092\000\000\000\000\000\000\000\000\000\028\002\
\020\002\035\002\248\001\244\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\103\000\000\000\193\001\000\000\000\000\
\214\001\217\001\211\001\000\000\206\001\000\000\000\000\000\000\
\181\000\000\000\167\000\158\000\156\000\000\000\069\001\000\000\
\000\000\000\000\000\000\031\000\000\000\000\000\025\000\022\000\
\021\000\176\000\178\000\000\000\000\000\000\000\049\001\000\000\
\000\000\032\001\000\000\000\000\106\000\000\000\000\000\000\000\
\000\000\111\000\000\000\110\000\190\001\000\000\179\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\200\001\201\001\
\000\000\000\000\136\002\000\000\000\000\000\000\000\000\000\000\
\000\000\004\001\000\000\000\001\000\000\002\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\236\001\
\097\000\000\000\000\000\098\000\033\002\050\002\139\001\138\001\
\003\001\255\000\001\001\199\001\197\001\000\000\000\000\124\002\
\000\000\130\000\000\000\126\000\000\000\000\000\166\001\167\001\
\000\000\071\001\066\001\029\000\000\000\030\000\000\000\000\000\
\000\000\000\000\059\001\053\001\007\000\000\000\112\000\113\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\180\001\
\000\000\000\000\000\000\000\000\202\001\000\000\000\000\170\001\
\000\000\000\000\000\000\222\001\223\001\224\001\225\001\035\001\
\000\000\171\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\228\001\
\229\001\000\000\000\000\000\000\129\000\150\000\000\000\000\000\
\000\000\000\000\026\000\028\000\000\000\000\000\062\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\203\001\000\000\172\001\000\000\000\000\000\000\220\001\
\226\001\227\001\034\001\151\000\000\000\000\000\000\000\238\001\
\242\001\173\001\091\000\000\000\221\001\230\001\000\000\000\000\
\000\000\000\000\135\000\125\002\000\000\191\000\000\000\000\000\
\050\001\000\000\000\000\000\000\122\000\000\000\000\000\000\000\
\000\000\204\001\183\001\000\000\000\000\181\001\000\000\000\000\
\000\000\000\000\231\001\000\000\125\000\000\000\000\000\128\000\
\127\000\000\000\000\000\027\000\051\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\118\000\000\000\000\000\
\000\000\000\000\232\001\233\001\000\000\133\000\000\000\000\000\
\000\000\000\000\000\000\142\000\136\000\219\001\120\000\121\000\
\000\000\000\000\000\000\000\000\000\000\119\000\184\001\234\001\
\000\000\000\000\000\000\000\000\000\000\141\000\000\000\123\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\140\000\137\000\144\002\145\002\
\000\000\000\000\000\000\000\000\138\000\000\000\000\000\000\000\
\000\000\000\000\124\000\000\000\000\000\000\000\139\000\000\000\
\000\000"

let yydgoto = "\006\000\
\052\000\094\000\124\000\134\000\148\000\245\001\095\000\153\005\
\054\000\171\001\250\002\175\003\065\003\132\003\200\002\055\000\
\190\001\223\001\072\001\056\000\057\000\066\003\046\001\058\000\
\059\000\136\000\061\000\062\000\063\000\064\000\065\000\066\000\
\067\000\068\000\069\000\070\000\071\000\072\000\073\000\000\001\
\251\002\074\000\082\001\088\002\238\003\104\000\105\000\075\000\
\107\000\108\000\109\000\110\000\037\001\049\003\111\000\113\001\
\168\003\089\002\102\003\026\004\015\002\016\002\255\002\186\003\
\103\004\101\004\199\004\076\000\031\004\075\004\154\005\213\004\
\076\004\117\003\003\005\136\001\004\005\114\005\115\005\146\005\
\173\005\203\005\199\005\165\002\092\005\077\000\084\001\250\000\
\192\002\120\003\047\004\121\003\119\003\183\002\152\000\078\000\
\096\001\228\002\121\001\195\002\193\002\079\000\080\000\081\000\
\042\004\082\000\083\000\185\000\084\000\085\000\186\000\196\000\
\239\001\192\000\097\001\098\001\074\002\232\002\086\000\155\005\
\234\002\157\000\087\000\078\001\253\001\077\004\196\002\127\000\
\187\000\188\000\231\001\193\000\158\000\159\000\237\002\160\000\
\128\000\161\000\158\001\161\001\159\001\128\002\167\004\088\000\
\080\001\020\002\005\003\109\004\218\004\214\004\032\004\006\003\
\191\003\007\003\196\003\028\004\158\004\215\004\216\004\217\004\
\172\002\106\003\107\003\033\004\034\004\062\003\043\005\063\005\
\044\005\045\005\046\005\047\005\239\003\059\005\129\000\130\000\
\131\000\132\000\133\000\129\001\142\001\095\002\096\002\097\002\
\255\003\055\003\252\003\130\001\131\001\132\001\030\001\251\000\
\246\001\047\001"

let yysindex = "\180\007\
\119\061\200\008\016\047\124\064\160\067\000\000\076\004\241\002\
\244\009\076\004\000\000\236\254\076\004\076\004\000\000\000\000\
\076\004\076\004\076\004\076\004\076\004\000\000\076\004\044\067\
\174\002\205\061\037\062\122\057\122\057\068\003\000\000\232\054\
\122\057\076\004\000\000\000\000\036\004\076\004\106\000\000\000\
\000\000\244\009\119\061\000\000\000\000\076\004\076\004\000\000\
\000\000\076\004\076\004\000\000\254\000\102\000\157\000\000\000\
\225\072\000\000\222\005\236\255\000\000\000\000\241\000\000\000\
\000\000\000\000\017\001\000\000\000\000\024\002\000\000\102\000\
\000\000\000\000\000\000\089\001\000\000\034\069\015\002\244\009\
\244\009\124\064\124\064\000\000\000\000\000\000\000\000\000\000\
\076\004\076\004\036\004\200\008\076\004\000\000\140\003\000\000\
\000\000\241\000\000\000\000\000\024\002\102\000\000\000\200\008\
\000\000\000\000\000\000\000\000\113\002\000\000\000\000\145\007\
\220\002\050\255\122\009\044\003\165\016\016\047\054\003\241\002\
\021\003\000\000\000\000\000\000\038\000\000\000\023\003\000\000\
\000\000\115\001\232\000\000\000\061\002\000\000\216\004\236\255\
\076\004\076\004\035\003\163\066\226\066\000\000\088\059\018\004\
\129\004\086\003\000\000\000\000\067\000\251\003\000\000\000\000\
\160\067\160\067\000\000\000\000\000\000\039\004\000\000\107\004\
\000\000\122\057\122\057\033\004\244\009\000\000\000\000\000\000\
\000\000\000\000\000\000\122\062\076\004\041\002\097\005\160\067\
\040\066\220\002\124\064\019\002\244\009\000\000\188\004\113\001\
\212\002\117\255\000\000\127\004\000\000\000\000\246\004\165\002\
\224\004\000\000\073\073\248\004\000\000\248\004\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\032\061\080\005\032\061\076\004\076\004\106\000\022\005\
\000\000\000\000\000\000\244\009\000\000\036\005\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\083\005\000\000\
\000\000\000\000\165\000\000\000\000\000\000\000\000\000\000\000\
\244\009\000\000\000\000\000\000\184\255\130\255\032\061\124\064\
\076\004\160\255\070\005\000\000\076\004\000\000\000\000\124\064\
\069\005\097\005\124\064\000\000\122\057\222\005\102\000\225\004\
\124\064\124\064\124\064\124\064\124\064\124\064\124\064\124\064\
\124\064\124\064\124\064\124\064\124\064\124\064\124\064\124\064\
\124\064\124\064\124\064\124\064\124\064\207\062\124\064\000\000\
\076\004\000\000\173\005\033\004\124\064\000\000\033\004\000\000\
\033\004\000\000\033\004\000\000\000\000\124\064\104\003\099\005\
\244\009\244\009\150\005\157\005\244\009\150\005\119\002\041\069\
\000\000\000\000\124\064\119\002\119\002\000\000\000\000\041\002\
\219\003\168\004\000\000\069\005\000\000\000\000\000\000\033\004\
\000\000\174\004\000\000\017\255\000\000\138\005\235\005\000\000\
\174\004\000\000\174\004\000\000\000\000\000\000\233\005\163\005\
\231\005\043\017\043\017\000\000\016\047\076\004\033\004\183\000\
\198\005\004\006\000\000\000\000\255\005\000\000\000\000\000\000\
\090\008\094\003\170\005\194\005\016\047\021\003\000\000\000\000\
\160\067\168\068\000\000\010\006\034\006\203\255\224\005\037\004\
\236\005\000\000\236\005\000\000\018\004\000\000\165\000\129\004\
\000\000\000\000\076\001\000\000\000\000\000\000\000\000\000\000\
\053\002\152\013\239\059\044\060\000\000\000\000\144\003\000\000\
\000\000\160\067\076\003\032\061\033\004\000\000\033\004\119\002\
\189\004\102\005\000\000\205\001\227\005\000\000\251\005\158\000\
\000\000\000\000\009\002\006\070\077\006\128\003\168\068\011\058\
\104\002\136\005\205\005\188\065\000\000\000\000\000\000\160\067\
\241\005\033\004\141\001\033\004\115\005\072\006\000\000\000\000\
\119\002\143\005\035\003\070\006\214\007\000\000\078\006\000\000\
\000\000\035\003\124\064\000\000\000\000\157\005\000\000\124\064\
\118\255\051\003\200\073\160\067\000\000\020\006\122\057\023\006\
\041\002\009\006\076\004\000\000\229\050\000\000\022\006\028\006\
\029\006\000\000\019\002\000\000\000\000\038\006\000\000\000\000\
\041\006\027\006\241\002\037\006\178\002\160\067\232\002\000\000\
\043\006\032\006\000\000\029\005\122\006\123\006\032\061\000\000\
\000\000\044\067\116\003\036\063\124\063\087\055\000\000\000\000\
\166\073\166\073\134\073\247\007\073\073\134\073\239\009\239\009\
\239\009\239\009\089\002\104\006\104\006\239\009\089\002\089\002\
\134\073\104\006\089\002\089\002\089\002\122\057\000\000\104\006\
\229\050\000\000\029\005\044\006\227\005\073\073\124\064\124\064\
\124\064\170\004\092\006\124\064\124\064\124\064\119\002\119\002\
\000\000\000\000\000\000\218\004\000\000\000\000\134\073\027\001\
\033\004\219\003\048\006\033\004\000\000\211\002\000\000\000\000\
\000\000\123\002\055\006\186\002\029\005\057\006\000\000\199\255\
\000\000\155\006\000\000\000\000\174\004\091\001\211\255\062\048\
\000\000\000\000\000\000\000\000\096\006\219\003\016\047\159\002\
\016\047\016\047\119\003\000\000\071\006\000\000\000\000\021\001\
\241\002\097\006\000\000\000\000\000\000\121\003\016\047\148\006\
\000\000\000\000\053\003\160\067\029\000\108\005\067\006\000\000\
\097\011\000\000\000\000\000\000\000\000\179\002\000\000\162\006\
\000\000\173\000\031\067\178\059\000\000\173\000\000\000\094\006\
\000\000\000\000\124\064\124\064\235\004\000\000\124\064\124\064\
\124\064\000\000\000\000\000\000\132\006\000\000\095\006\000\000\
\019\015\074\002\019\015\033\004\000\000\188\006\000\000\016\047\
\124\064\000\000\126\006\000\000\160\067\000\000\000\000\000\000\
\127\006\000\000\127\006\000\000\090\008\122\058\124\064\188\065\
\000\000\108\000\184\006\000\000\124\064\130\006\033\004\073\001\
\119\061\155\001\000\000\000\000\000\000\087\006\000\000\000\000\
\000\000\161\000\000\000\033\004\124\064\000\000\073\073\000\000\
\073\073\000\000\000\000\000\000\000\000\000\000\033\004\243\000\
\000\000\000\000\000\000\157\006\027\001\178\002\043\006\102\000\
\100\065\068\005\190\006\000\000\187\006\146\006\149\006\153\006\
\021\002\000\000\000\000\220\002\191\006\178\002\219\003\019\002\
\078\003\178\002\102\000\007\002\000\000\000\000\169\001\201\003\
\091\005\103\004\000\000\000\000\176\003\000\000\244\254\016\047\
\124\064\125\006\221\255\000\000\255\002\000\000\248\004\000\000\
\248\004\128\006\165\000\000\000\165\255\124\064\102\000\156\006\
\178\002\132\006\073\073\038\005\063\000\190\255\162\005\124\064\
\085\070\117\070\195\070\130\006\094\255\145\006\200\008\219\003\
\129\002\000\000\000\000\186\003\212\006\219\003\043\006\214\004\
\102\000\176\003\214\006\174\004\000\000\000\000\016\047\057\000\
\224\006\000\000\000\000\241\002\057\255\033\004\000\000\016\047\
\180\001\137\006\033\004\021\003\000\000\097\006\159\006\000\000\
\090\008\124\006\000\000\000\000\000\000\033\004\160\067\142\006\
\000\000\037\004\000\000\000\000\000\000\000\000\149\000\000\000\
\223\255\000\000\000\000\000\000\208\001\000\000\098\000\245\255\
\181\005\227\070\049\071\081\071\103\004\174\006\000\000\164\006\
\000\000\172\006\071\006\158\006\169\000\225\006\033\004\000\000\
\102\000\144\000\182\255\126\006\154\006\125\005\226\006\226\006\
\237\006\166\006\179\006\126\006\000\000\000\000\210\063\124\064\
\160\067\041\073\000\000\044\005\124\064\000\000\219\003\000\000\
\030\003\000\000\016\047\073\073\124\064\124\064\033\004\216\006\
\060\255\000\000\028\009\124\064\233\058\234\006\000\000\161\065\
\059\002\105\060\166\060\227\060\124\064\000\000\016\047\160\067\
\000\000\000\000\000\000\015\000\000\000\160\067\219\003\102\000\
\102\000\175\001\226\005\000\000\000\000\000\000\248\006\000\000\
\000\000\016\047\000\000\033\004\033\004\106\000\106\000\102\000\
\000\000\000\000\000\000\000\000\160\067\000\000\217\000\236\006\
\180\006\241\002\000\000\000\000\234\005\244\006\000\000\000\000\
\000\000\000\000\000\000\110\000\122\005\000\000\019\002\000\000\
\000\000\000\000\000\000\236\006\102\000\203\006\000\000\000\000\
\206\006\000\000\210\006\124\064\124\064\124\064\073\073\000\000\
\211\006\000\000\217\006\000\000\223\006\199\005\000\000\000\000\
\033\004\120\004\180\001\043\006\029\005\015\007\000\000\000\000\
\000\000\219\003\180\001\201\003\061\001\008\007\000\000\200\006\
\219\003\000\000\000\000\087\001\000\000\000\000\074\255\000\000\
\016\047\241\002\193\006\097\006\000\000\000\000\016\047\000\000\
\037\004\000\000\000\000\219\003\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\124\064\124\064\124\064\000\000\000\000\
\000\000\228\255\201\006\000\000\007\007\000\000\157\005\208\006\
\000\000\164\006\090\008\184\000\102\000\000\000\204\006\000\000\
\000\000\124\064\000\000\188\065\016\047\124\064\209\006\215\006\
\016\047\000\000\124\064\218\006\000\000\000\000\219\006\000\000\
\124\064\019\002\000\000\174\069\097\255\000\000\000\000\033\004\
\000\000\000\000\000\000\124\064\124\064\126\006\046\001\000\000\
\126\006\124\064\019\007\000\000\000\000\000\000\000\000\000\000\
\179\002\000\000\162\006\000\000\173\000\000\000\088\003\173\000\
\000\000\227\006\184\006\180\001\000\000\000\000\019\002\219\003\
\255\254\016\047\124\064\033\004\102\000\033\004\102\000\000\000\
\184\006\103\004\000\000\162\011\000\000\229\006\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\108\002\000\000\000\000\
\036\007\124\064\124\064\168\071\200\071\022\072\124\064\124\064\
\124\064\219\003\019\002\000\000\000\000\202\005\035\003\129\002\
\211\002\000\000\000\000\219\003\229\006\211\002\016\047\000\000\
\000\000\000\000\000\000\000\000\033\004\097\006\001\000\054\072\
\132\072\164\072\103\004\000\000\241\002\000\000\131\005\053\007\
\000\000\000\000\000\000\055\007\000\000\204\006\102\000\048\007\
\000\000\033\004\000\000\000\000\000\000\033\004\000\000\188\065\
\124\064\073\073\226\005\000\000\094\000\082\001\000\000\000\000\
\000\000\000\000\000\000\049\007\016\047\239\006\000\000\124\064\
\124\064\000\000\226\005\161\003\000\000\125\003\102\000\102\000\
\174\255\000\000\187\003\000\000\000\000\041\002\000\000\249\006\
\222\069\229\045\000\000\222\003\021\007\070\007\000\000\000\000\
\027\001\054\255\000\000\252\000\015\003\054\255\131\005\073\073\
\073\073\000\000\018\007\000\000\022\007\000\000\024\007\073\073\
\073\073\073\073\180\001\226\005\170\005\170\005\046\005\000\000\
\000\000\105\004\048\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\016\047\001\007\000\000\
\033\004\000\000\234\005\000\000\254\002\062\048\000\000\000\000\
\124\064\000\000\000\000\000\000\202\000\000\000\250\006\016\047\
\238\003\161\065\000\000\000\000\000\000\016\047\000\000\000\000\
\233\006\229\006\157\005\235\006\164\006\157\005\027\001\000\000\
\033\004\070\007\229\006\164\006\000\000\033\004\016\047\000\000\
\041\002\030\002\193\001\000\000\000\000\000\000\000\000\000\000\
\254\006\000\000\234\005\124\064\124\064\124\064\007\003\007\003\
\016\047\005\007\016\047\061\001\041\002\027\001\008\002\000\000\
\000\000\099\000\106\000\029\007\000\000\000\000\194\003\033\004\
\079\007\219\003\000\000\000\000\065\004\124\064\000\000\033\004\
\157\005\157\005\013\066\157\005\157\005\110\005\033\004\093\255\
\010\007\000\000\090\004\000\000\106\002\074\002\033\004\000\000\
\000\000\000\000\000\000\000\000\073\073\073\073\073\073\000\000\
\000\000\000\000\000\000\027\001\000\000\000\000\213\003\033\004\
\016\047\135\004\000\000\000\000\009\007\000\000\011\007\124\064\
\000\000\092\007\093\007\060\017\000\000\094\007\097\007\124\064\
\085\007\000\000\000\000\164\006\070\007\000\000\016\047\074\002\
\033\004\033\004\000\000\096\007\000\000\043\006\083\001\000\000\
\000\000\037\002\033\004\000\000\000\000\062\048\062\048\126\006\
\033\004\086\007\075\001\016\047\016\047\000\000\124\064\025\007\
\033\004\033\004\000\000\000\000\039\005\000\000\033\004\033\004\
\033\004\033\004\102\000\000\000\000\000\000\000\000\000\000\000\
\095\007\124\064\016\047\033\004\033\004\000\000\000\000\000\000\
\131\005\016\047\131\005\139\001\009\003\000\000\016\047\000\000\
\033\004\033\004\102\000\234\005\006\007\032\007\157\005\227\005\
\164\006\107\007\102\000\091\004\000\000\000\000\000\000\000\000\
\109\007\157\005\157\005\016\047\000\000\124\064\062\048\110\007\
\111\007\033\004\000\000\102\000\016\047\016\047\000\000\033\004\
\033\004"

let yyrindex = "\000\000\
\126\008\127\008\000\000\000\000\000\000\000\000\106\069\000\000\
\000\000\039\064\000\000\000\000\214\002\242\005\000\000\000\000\
\221\067\101\066\099\067\209\064\139\003\000\000\106\069\000\000\
\000\000\000\000\000\000\000\000\000\000\248\067\193\017\000\000\
\000\000\209\064\000\000\000\000\200\004\096\000\042\004\000\000\
\000\000\000\000\060\000\000\000\000\000\209\064\225\007\000\000\
\000\000\242\005\209\064\000\000\000\000\021\043\103\016\000\000\
\136\044\000\000\060\000\120\043\000\000\000\000\067\044\000\000\
\000\000\000\000\081\053\000\000\000\000\102\053\000\000\021\043\
\000\000\000\000\000\000\000\000\000\000\035\025\221\027\058\024\
\174\024\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\214\002\099\004\200\004\062\000\225\007\000\000\000\000\000\000\
\000\000\218\012\000\000\000\000\111\053\146\053\000\000\062\000\
\000\000\000\000\000\000\000\000\167\053\000\000\000\000\000\000\
\113\005\113\005\000\000\188\012\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\240\016\000\000\
\000\000\000\000\151\015\000\000\163\014\000\000\000\000\000\000\
\221\067\229\068\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\014\049\000\000\000\000\
\255\001\098\003\000\000\000\000\000\000\050\005\000\000\125\049\
\000\000\000\000\000\000\117\054\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\221\001\000\000\000\000\000\000\
\000\000\053\068\000\000\000\000\000\000\135\255\016\002\000\000\
\214\255\000\000\000\000\076\000\000\000\000\000\069\255\000\000\
\040\004\000\000\215\255\131\000\000\000\245\005\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\038\007\004\054\038\007\214\002\026\007\042\004\080\068\
\000\000\000\000\000\000\012\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\028\056\114\056\139\003\000\000\000\000\200\056\030\057\000\000\
\014\000\000\000\000\000\000\000\000\000\000\000\038\007\000\000\
\217\003\000\000\008\003\000\000\026\007\000\000\000\000\000\000\
\084\006\000\000\000\000\000\000\000\000\060\000\132\050\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\057\034\000\000\000\000\
\248\067\000\000\120\043\141\068\000\000\000\000\041\005\000\000\
\031\007\000\000\055\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\221\022\151\025\
\000\000\000\000\000\000\011\026\128\026\000\000\000\000\000\000\
\000\000\000\000\000\000\084\006\000\000\000\000\000\000\031\007\
\000\000\000\000\000\000\125\001\000\000\120\007\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\147\255\000\000\098\007\
\000\000\102\007\116\007\000\000\000\000\099\004\180\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\045\000\000\000\194\000\090\000\
\131\000\000\000\245\005\000\000\066\000\000\000\026\007\101\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\038\007\117\054\000\000\155\048\244\026\
\000\000\000\000\000\000\000\000\164\005\000\000\000\000\000\000\
\000\000\000\000\068\017\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\066\007\000\000\198\055\021\043\207\002\000\000\000\000\
\104\027\000\000\000\000\000\000\000\000\000\000\085\255\000\000\
\000\000\196\000\000\000\000\000\000\000\069\004\000\000\162\000\
\000\000\000\000\041\007\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\026\007\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\001\003\000\000\000\000\038\007\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\096\037\205\037\053\038\174\034\208\039\157\038\034\035\150\035\
\011\036\127\036\127\031\081\028\197\028\243\036\244\031\104\032\
\005\039\058\029\220\032\081\033\197\033\000\000\000\000\174\029\
\000\000\000\000\111\003\000\000\164\005\051\040\000\000\000\000\
\000\000\000\000\082\018\000\000\000\000\000\000\081\023\198\023\
\000\000\000\000\000\000\105\022\000\000\000\000\109\039\025\053\
\066\007\000\000\000\000\005\004\030\006\146\053\000\000\000\000\
\000\000\000\000\000\000\000\000\001\003\000\000\000\000\000\000\
\000\000\193\049\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\246\044\
\000\000\000\000\000\000\000\000\205\045\000\000\000\000\000\000\
\000\000\048\046\000\000\000\000\000\000\000\000\000\000\102\255\
\000\000\000\000\222\000\162\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\202\006\000\000\093\005\
\000\000\225\003\000\000\000\000\000\000\165\005\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\090\007\000\000\000\000\000\000\
\000\000\000\000\000\000\238\039\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\034\030\000\000\000\000\000\000\038\065\000\000\
\169\004\000\000\000\000\000\000\000\000\000\000\025\001\000\000\
\000\000\084\255\000\000\169\255\000\000\000\000\185\255\000\000\
\097\000\000\000\000\000\000\000\000\000\000\000\064\007\065\007\
\000\000\000\000\000\000\000\000\136\003\000\000\000\000\213\005\
\182\004\000\000\074\006\000\000\191\002\105\000\139\000\143\000\
\000\000\000\000\000\000\053\068\185\040\000\000\000\000\000\000\
\000\000\000\000\021\043\000\000\000\000\000\000\234\004\021\043\
\053\068\228\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\131\000\000\000\
\245\005\000\000\139\003\000\000\000\000\000\000\213\005\000\000\
\000\000\090\007\000\000\198\006\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\018\005\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\146\053\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\047\002\000\000\000\000\
\087\255\000\000\210\000\000\000\000\000\147\046\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\197\000\000\000\229\000\
\000\000\125\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\068\007\000\000\000\000\099\007\
\012\050\000\000\074\050\000\000\000\000\040\011\238\039\000\000\
\021\043\000\000\000\000\174\001\000\000\049\255\073\007\073\007\
\068\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\089\045\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\136\255\000\000\000\000\122\007\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\021\043\
\028\041\000\000\127\010\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\050\038\065\139\004\225\002\136\004\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\163\051\
\000\000\000\000\000\000\000\000\021\043\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\016\052\028\041\000\000\000\000\000\000\
\198\018\000\000\058\019\000\000\000\000\000\000\155\040\000\000\
\175\019\000\000\035\020\000\000\151\020\000\000\000\000\000\000\
\235\003\000\000\162\050\000\000\001\003\240\047\000\000\119\007\
\000\000\000\000\191\047\146\053\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\125\001\000\000\000\000\000\000\190\057\
\000\000\000\000\128\007\248\046\000\000\000\000\000\000\000\000\
\186\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\048\004\000\000\000\000\021\043\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\220\255\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\012\005\000\000\125\004\000\000\203\004\000\000\000\000\062\005\
\000\000\000\000\151\030\231\041\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\120\003\136\004\058\003\136\004\000\000\
\011\031\228\001\000\000\115\007\000\000\063\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\069\007\000\000\000\000\000\000\063\001\069\007\000\000\000\000\
\000\000\000\000\000\000\000\000\229\015\091\047\000\000\000\000\
\000\000\000\000\068\007\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\074\042\021\043\000\000\
\000\000\103\001\000\000\000\000\000\000\148\001\000\000\000\000\
\000\000\254\040\175\008\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\026\012\000\000\000\000\000\000\136\004\136\004\
\108\007\000\000\099\007\000\000\000\000\000\000\000\000\000\000\
\000\000\118\007\199\049\069\052\000\000\122\052\000\000\000\000\
\249\050\028\041\000\000\000\000\000\000\028\041\000\000\097\041\
\201\041\000\000\012\021\000\000\128\021\000\000\244\021\044\042\
\143\042\247\042\049\051\042\048\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\044\001\000\000\028\041\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\112\007\108\007\000\000\114\007\099\007\000\000\249\050\000\000\
\178\052\208\052\056\006\099\007\000\000\219\051\000\000\000\000\
\000\000\092\052\021\043\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\028\041\000\000\000\000\000\000\106\010\238\013\
\000\000\156\050\000\000\000\000\000\000\028\015\146\053\000\000\
\000\000\000\000\115\003\193\002\000\000\000\000\000\000\249\004\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\111\002\
\000\000\000\000\000\000\000\000\000\000\000\000\219\051\000\000\
\000\000\000\000\000\000\000\000\092\052\000\000\139\039\000\000\
\000\000\000\000\000\000\000\000\090\043\189\043\037\044\000\000\
\000\000\000\000\000\000\028\015\000\000\000\000\000\000\031\007\
\000\000\000\000\000\000\000\000\082\007\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\099\007\008\053\000\000\000\000\000\000\
\139\039\139\039\000\000\241\015\000\000\000\000\000\000\000\000\
\000\000\019\005\161\004\000\000\000\000\000\000\000\000\000\000\
\168\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\181\047\139\039\000\000\000\000\000\000\000\000\000\050\021\006\
\120\003\058\003\243\004\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\032\002\071\003\000\000\000\000\000\000\
\000\000\000\000\000\000\117\007\000\000\000\000\000\000\000\000\
\182\002\105\051\243\004\243\004\125\007\126\007\000\000\130\007\
\099\007\000\000\243\004\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\196\003\000\000\243\004\000\000\000\000\000\000\212\003\
\237\004"

let yygindex = "\000\000\
\000\000\000\000\000\000\000\000\000\000\020\000\183\255\037\000\
\168\000\184\005\119\253\000\000\166\254\147\005\096\255\145\008\
\232\012\061\254\077\005\253\255\063\014\144\252\036\003\247\255\
\000\000\046\000\016\000\021\000\027\000\000\000\000\000\000\000\
\000\000\030\000\035\000\040\000\000\000\255\255\003\000\093\009\
\084\002\000\000\000\000\000\000\000\000\000\000\000\000\041\000\
\000\000\000\000\000\000\000\000\010\255\059\252\000\000\000\000\
\000\000\004\000\148\005\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\010\003\056\000\112\251\081\255\136\253\214\251\
\048\253\185\252\087\251\199\003\087\003\000\000\000\000\000\000\
\000\000\000\000\000\000\211\253\000\000\000\000\000\000\042\000\
\082\255\014\006\085\005\100\005\000\000\000\000\083\255\048\000\
\000\000\000\000\170\255\035\002\103\253\160\006\187\010\173\011\
\000\000\000\000\000\000\131\255\000\000\006\013\182\006\006\000\
\104\255\048\003\121\007\000\000\124\007\165\006\244\010\176\253\
\000\000\218\000\000\000\000\000\000\000\198\003\090\005\152\255\
\254\004\000\000\000\000\000\000\000\000\227\000\000\000\034\007\
\145\255\042\007\081\006\083\008\000\000\000\000\060\004\000\000\
\000\000\129\007\233\253\016\005\193\251\101\251\000\252\028\253\
\000\000\204\252\000\000\074\004\000\000\000\000\119\251\088\255\
\101\253\062\006\091\007\000\000\000\000\232\003\000\000\000\000\
\253\003\243\252\000\000\200\003\108\004\000\000\179\253\135\002\
\155\255\000\000\000\000\192\005\147\254\157\255\199\254\151\255\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\055\255\000\000"

let yytablesize = 19255
let yytable = "\126\000\
\102\000\151\000\212\001\213\001\103\000\203\001\119\001\117\001\
\251\001\230\001\128\001\168\000\118\001\157\001\086\002\026\003\
\137\001\096\000\107\001\221\001\053\000\151\001\097\000\061\003\
\151\003\203\002\063\003\123\001\098\000\190\003\111\001\099\000\
\198\000\162\004\176\001\024\003\100\000\143\001\126\003\125\000\
\123\002\101\000\106\000\241\001\043\004\242\001\060\000\139\004\
\027\004\074\001\248\001\090\004\052\004\051\005\034\005\222\004\
\169\000\120\001\030\005\034\000\131\003\071\000\039\001\102\002\
\162\000\103\002\181\001\220\004\084\001\050\003\252\000\184\000\
\039\005\143\003\031\001\171\000\037\005\194\003\001\004\008\000\
\191\000\206\002\162\000\087\001\080\001\009\002\023\002\173\000\
\060\000\038\001\102\000\216\001\197\004\231\003\103\000\098\002\
\184\004\195\003\243\004\069\004\206\004\161\001\102\000\023\002\
\075\001\084\001\103\000\096\000\126\000\006\002\087\001\126\000\
\097\000\126\000\126\000\131\005\232\001\218\002\098\000\096\000\
\045\001\099\000\198\001\139\001\097\000\095\001\100\000\100\001\
\101\001\007\002\098\000\101\000\106\000\099\000\113\002\079\001\
\151\000\151\000\100\000\151\000\085\005\122\001\171\000\101\000\
\106\000\132\005\002\004\199\001\113\002\151\000\151\000\113\002\
\037\005\135\001\131\003\151\004\064\002\200\001\027\005\162\000\
\052\002\113\002\162\000\084\001\208\003\145\004\040\003\245\001\
\089\001\040\003\127\001\135\000\151\000\151\000\087\001\080\001\
\224\001\087\001\087\001\080\001\023\002\064\002\115\002\004\002\
\083\001\160\001\245\001\232\003\133\005\218\003\185\004\080\002\
\161\001\245\001\245\001\089\001\161\001\228\001\201\001\029\001\
\229\001\202\001\129\002\188\001\189\001\040\004\052\003\233\001\
\041\003\219\002\115\002\041\003\192\001\093\001\085\001\245\001\
\245\001\067\002\052\003\088\001\200\003\083\001\014\004\008\002\
\085\001\113\002\079\001\245\001\225\001\113\002\079\001\064\002\
\064\002\251\003\245\001\245\001\125\002\245\001\076\001\082\005\
\093\001\115\002\152\002\115\002\218\003\155\004\088\001\037\003\
\088\005\064\002\059\004\037\005\012\002\044\001\188\004\115\002\
\247\004\190\004\209\003\089\001\203\002\025\005\089\001\089\001\
\133\002\117\001\134\002\082\002\013\002\069\002\089\004\194\005\
\117\001\196\005\117\001\077\001\160\001\005\002\245\001\083\001\
\160\001\128\001\128\001\219\003\083\003\026\005\041\004\109\002\
\162\000\178\002\053\003\089\005\024\002\130\002\213\001\060\000\
\116\002\060\000\140\005\056\003\163\001\203\002\059\003\122\002\
\093\001\081\002\085\001\169\000\093\001\085\001\088\001\201\003\
\211\005\088\001\088\001\034\000\015\004\071\000\216\003\156\004\
\052\003\085\002\071\004\158\002\013\005\015\005\177\001\163\001\
\038\001\028\000\178\001\076\001\060\000\010\003\166\000\082\002\
\229\002\179\001\019\004\196\001\180\001\034\000\023\002\071\000\
\083\002\154\001\217\001\075\001\059\004\012\005\248\004\216\002\
\086\001\216\003\241\002\154\001\083\002\087\002\027\004\162\000\
\079\002\082\002\086\001\069\002\049\005\114\004\126\000\177\001\
\036\001\084\002\216\002\178\001\111\002\126\000\107\005\126\000\
\084\003\216\002\179\001\085\002\155\001\180\001\126\000\126\000\
\081\002\126\000\150\002\160\005\162\000\205\004\155\001\163\001\
\071\002\072\002\077\002\163\001\076\002\126\000\075\002\095\001\
\216\002\126\000\169\004\075\002\253\003\151\000\151\000\034\000\
\028\000\071\000\217\003\216\002\170\003\166\000\082\002\085\002\
\216\002\151\002\012\004\216\002\002\002\216\002\076\001\083\002\
\045\001\222\002\039\004\151\002\167\002\162\000\151\000\151\000\
\151\000\139\003\048\001\147\004\127\003\154\001\151\000\006\001\
\154\001\127\001\127\001\179\001\086\001\018\004\111\005\086\001\
\084\002\156\001\083\002\078\001\162\001\038\002\079\002\010\002\
\111\002\115\004\085\002\151\000\151\000\235\003\216\002\018\002\
\151\000\162\000\022\002\243\003\151\000\135\004\006\004\224\001\
\155\001\119\005\074\005\155\001\128\003\157\001\150\002\162\001\
\126\000\126\000\162\000\039\002\150\002\065\005\162\000\203\002\
\077\002\060\000\106\004\148\001\075\002\055\002\162\000\126\000\
\151\000\102\000\013\004\079\001\058\002\103\000\177\001\163\000\
\164\004\151\000\178\001\168\002\117\001\151\002\122\001\224\001\
\069\003\179\001\096\000\041\005\180\001\157\001\026\001\097\000\
\210\002\212\002\151\000\070\003\071\003\098\000\245\002\038\002\
\099\000\038\002\213\001\081\001\112\002\100\000\010\005\223\002\
\114\002\198\001\101\000\106\000\156\001\097\005\078\001\162\001\
\226\002\015\003\017\003\162\001\031\002\191\000\114\002\075\005\
\169\002\114\002\074\003\214\002\061\004\039\002\064\002\039\002\
\149\001\110\005\199\001\114\002\162\000\151\000\107\004\061\005\
\157\001\150\003\152\003\213\001\200\001\038\005\214\002\150\002\
\105\003\245\004\116\002\189\004\060\000\214\002\135\002\064\002\
\134\003\184\000\046\003\136\002\092\004\198\001\087\002\177\001\
\177\005\014\005\191\000\178\001\123\003\147\001\135\003\171\003\
\143\004\137\002\179\001\214\002\135\002\180\001\168\000\022\003\
\179\005\126\000\052\003\141\003\126\000\201\001\199\001\214\002\
\202\001\171\002\087\002\126\000\214\002\126\000\126\000\214\002\
\200\001\214\002\075\003\114\002\081\002\135\002\204\003\114\002\
\205\003\064\002\064\002\126\000\076\003\048\003\057\003\135\002\
\151\000\172\000\125\005\087\005\214\002\126\000\193\001\002\004\
\146\001\202\002\162\000\064\002\028\000\162\000\095\005\151\000\
\151\000\166\000\082\002\067\003\162\000\193\003\086\001\137\004\
\162\000\201\001\214\002\083\002\202\001\166\003\142\004\194\001\
\214\002\168\000\095\005\078\003\002\004\126\000\136\003\126\000\
\135\002\138\002\189\003\135\002\126\000\089\003\169\000\218\001\
\166\005\151\000\203\002\147\001\084\002\061\003\058\003\011\004\
\063\003\126\000\151\000\180\003\151\000\218\001\085\002\100\004\
\102\004\137\005\248\003\046\001\172\000\021\003\224\001\028\000\
\041\005\095\004\250\003\117\001\162\002\219\001\012\000\016\004\
\137\005\092\001\093\001\177\001\114\003\028\000\235\002\178\001\
\214\002\181\003\004\004\219\001\137\003\234\003\179\001\236\002\
\008\004\180\001\197\005\227\001\029\000\151\000\163\002\029\003\
\030\003\152\003\213\001\104\005\033\000\106\005\182\003\203\002\
\162\000\169\000\220\001\087\002\224\001\162\000\060\000\040\003\
\138\003\048\000\198\005\199\002\040\003\184\003\122\001\203\002\
\220\001\185\003\122\001\045\001\126\000\196\004\122\001\048\000\
\122\001\199\002\177\001\046\001\122\001\122\001\178\001\061\005\
\122\001\162\000\235\002\216\002\178\003\179\001\169\002\183\003\
\180\001\122\001\083\001\236\002\216\002\175\005\176\005\116\000\
\099\001\041\003\164\003\170\002\087\002\102\000\041\003\235\004\
\203\002\103\000\087\002\169\002\197\003\017\004\118\004\241\003\
\126\000\242\004\116\000\126\000\139\002\218\001\096\000\167\005\
\094\005\116\000\078\004\097\000\126\000\194\001\106\002\000\004\
\122\001\098\000\095\003\096\003\099\000\126\000\198\001\122\001\
\162\000\100\000\045\001\151\000\216\002\028\000\101\000\106\000\
\116\000\194\001\214\002\219\001\168\005\202\002\162\000\171\002\
\115\003\122\001\122\001\116\000\122\001\122\001\220\005\199\001\
\029\000\123\001\116\000\116\000\179\003\116\000\125\003\015\000\
\033\000\200\001\169\005\085\001\171\002\214\002\147\000\122\001\
\106\002\106\002\165\003\112\001\142\000\204\001\214\002\169\002\
\220\001\221\004\142\000\204\001\115\001\151\000\213\001\048\000\
\108\003\147\000\106\002\087\002\136\005\060\001\061\001\126\000\
\147\000\110\001\109\003\109\001\193\001\214\002\116\000\126\000\
\044\003\151\000\201\001\170\005\151\000\202\001\151\000\151\000\
\151\000\179\004\210\005\126\000\151\000\150\001\147\000\147\000\
\087\002\150\004\151\000\087\002\236\001\194\001\214\002\180\002\
\181\002\122\000\147\000\066\001\202\002\162\000\126\000\064\004\
\198\003\147\000\147\000\045\000\147\000\246\001\048\000\210\002\
\171\002\151\000\163\004\147\001\071\001\210\003\195\004\247\002\
\134\000\179\001\106\001\087\004\180\001\111\004\106\001\046\003\
\246\001\237\001\236\003\224\001\248\002\106\001\012\000\246\001\
\246\001\012\000\189\000\134\000\047\003\182\002\097\004\092\001\
\093\001\106\001\134\000\012\000\012\000\147\000\115\001\012\000\
\149\001\228\001\236\004\120\001\229\001\246\001\246\001\253\002\
\012\000\012\000\012\000\012\000\237\003\190\000\087\002\090\002\
\134\000\246\001\249\002\216\002\162\000\087\002\012\000\012\000\
\246\001\246\001\048\003\246\001\134\000\126\000\202\003\068\003\
\106\001\254\002\213\001\126\000\134\000\148\004\134\000\107\000\
\087\002\239\004\012\000\122\000\216\002\012\000\048\005\012\000\
\012\000\012\000\012\000\071\005\162\000\045\001\216\002\012\000\
\012\000\120\002\107\000\040\003\074\003\062\004\012\000\126\000\
\146\002\107\000\146\002\203\003\246\001\031\005\054\004\055\004\
\151\000\126\000\012\000\146\002\012\000\126\000\012\000\134\000\
\166\000\081\002\220\002\042\005\065\004\066\004\224\001\063\004\
\107\000\133\001\012\000\072\004\221\002\012\000\147\001\216\002\
\185\001\012\000\216\002\107\000\086\004\041\003\117\000\147\001\
\190\000\028\000\062\005\107\000\112\005\107\000\166\000\082\002\
\146\002\170\004\025\002\200\005\140\001\174\004\160\004\011\000\
\083\002\117\000\194\001\224\001\087\002\167\000\126\000\253\000\
\117\000\123\001\155\001\152\003\213\001\123\001\119\001\117\001\
\126\000\123\001\016\000\123\001\118\001\185\001\194\001\123\001\
\123\001\084\002\193\004\123\001\155\001\138\001\107\000\117\000\
\201\005\214\002\145\001\085\002\123\001\022\000\087\002\224\001\
\093\005\048\000\117\000\177\001\214\002\162\000\198\004\178\001\
\087\002\117\000\117\000\126\000\117\000\254\000\179\001\048\000\
\212\004\180\001\144\000\255\000\108\005\115\001\163\000\022\005\
\012\003\162\000\177\002\002\005\063\002\118\002\064\002\145\000\
\253\004\048\000\080\003\123\001\152\003\213\001\129\005\155\001\
\065\002\214\002\123\001\172\003\151\000\216\002\185\001\209\001\
\044\000\087\002\087\002\190\000\146\002\117\000\072\003\214\002\
\077\003\126\000\173\003\174\003\123\001\123\001\162\000\123\001\
\123\001\162\000\122\000\145\000\139\000\216\002\147\002\141\000\
\194\001\209\001\119\002\216\002\126\000\126\000\126\000\214\002\
\148\002\168\004\123\001\144\000\048\000\171\004\145\000\152\001\
\090\002\087\002\175\004\002\005\194\001\145\000\206\002\146\002\
\149\001\017\005\162\000\031\002\149\001\031\002\144\000\214\002\
\149\001\040\003\149\001\186\004\187\004\144\000\149\001\192\003\
\216\002\191\004\149\001\145\000\090\002\135\001\033\005\216\002\
\035\005\166\000\126\000\149\001\031\002\081\002\021\005\145\000\
\205\002\116\005\126\000\144\000\214\002\028\005\145\000\145\000\
\078\005\145\000\200\004\045\001\126\000\214\002\151\000\144\000\
\183\001\214\002\126\000\041\003\000\005\028\000\144\000\144\000\
\216\002\144\000\166\000\082\002\122\000\216\002\214\002\162\000\
\214\002\214\002\135\001\126\000\083\002\214\002\240\003\150\002\
\177\001\149\001\029\005\214\002\178\001\214\002\119\002\162\000\
\172\001\096\001\145\000\179\001\077\005\126\000\180\001\126\000\
\186\001\144\003\080\005\149\001\149\001\084\002\149\001\149\001\
\214\002\122\000\144\000\173\001\151\002\216\002\087\002\085\002\
\214\002\169\003\013\003\091\005\150\002\176\003\214\002\151\000\
\214\002\149\001\083\005\164\000\214\002\086\005\164\000\214\002\
\011\005\164\000\164\000\120\005\097\001\164\000\164\000\164\000\
\164\000\164\000\162\000\164\000\214\002\162\000\162\000\019\005\
\020\005\151\002\164\000\146\002\213\003\126\000\164\000\137\002\
\214\002\164\000\164\000\214\002\135\005\214\005\163\000\132\004\
\126\000\043\003\164\000\164\000\146\002\090\002\164\000\164\000\
\107\001\187\001\162\000\126\000\107\001\216\002\144\005\212\002\
\122\005\123\005\216\001\126\005\127\005\162\000\107\001\033\001\
\171\005\133\004\126\000\126\000\172\005\143\005\146\002\107\001\
\126\000\126\000\212\002\162\000\162\000\216\002\163\000\174\001\
\145\005\212\002\216\002\216\002\148\001\164\000\164\000\164\000\
\034\000\164\000\162\000\161\005\216\002\003\003\090\002\126\000\
\073\005\040\003\175\001\008\000\090\002\002\005\126\000\002\005\
\212\002\117\001\004\003\126\000\149\000\117\001\107\001\126\002\
\180\005\181\005\034\000\212\002\117\001\216\002\060\005\117\001\
\091\004\144\001\146\002\212\002\146\002\212\002\152\001\216\002\
\126\000\226\001\152\001\126\000\212\002\164\000\164\000\193\005\
\031\003\126\000\126\000\041\003\152\001\234\001\198\004\105\004\
\214\002\182\001\146\002\204\005\112\000\152\001\113\000\114\000\
\028\000\104\000\115\000\214\002\143\000\115\001\117\000\193\001\
\191\001\063\002\212\002\155\002\202\005\121\005\212\002\117\001\
\218\005\164\000\146\002\214\002\155\001\156\002\209\005\143\000\
\126\002\224\005\225\005\104\000\091\002\212\002\143\000\120\000\
\194\001\216\005\217\005\146\003\212\002\090\002\121\000\109\001\
\235\001\071\000\132\000\109\001\092\002\026\002\027\002\028\002\
\029\002\097\003\122\000\123\000\143\000\062\002\177\003\149\005\
\142\000\030\002\212\002\187\003\216\002\215\003\109\001\158\005\
\143\000\048\000\090\002\071\000\132\000\090\002\212\002\143\000\
\143\000\096\001\143\000\245\003\216\002\096\001\212\002\099\001\
\212\002\096\001\211\003\096\001\206\002\057\005\238\001\096\001\
\096\001\151\001\246\003\160\001\160\001\151\001\182\005\153\003\
\058\005\164\000\164\000\154\003\096\001\031\002\185\005\151\001\
\184\001\185\001\155\003\214\002\247\003\156\003\240\001\214\002\
\151\001\192\005\188\003\143\000\097\001\002\003\157\003\164\000\
\097\001\212\002\120\001\003\003\097\001\247\001\097\001\206\001\
\214\002\214\002\097\001\085\003\249\002\164\000\097\001\214\002\
\004\003\164\000\252\001\096\001\058\004\086\003\148\002\097\001\
\090\002\116\004\096\001\228\001\214\002\219\005\229\001\090\002\
\177\001\254\001\214\002\117\004\178\001\162\000\014\002\255\001\
\128\005\000\002\045\004\179\001\096\001\096\001\180\001\096\001\
\096\001\019\002\090\002\001\002\038\004\164\000\214\002\068\002\
\191\001\069\002\159\002\191\001\160\002\191\001\097\001\191\001\
\142\000\204\001\096\001\070\002\148\001\097\001\161\002\148\002\
\148\001\148\002\148\002\148\002\148\001\148\002\148\001\076\001\
\148\002\148\002\148\001\202\002\162\000\045\001\148\001\097\001\
\097\001\254\004\097\001\097\001\191\001\028\000\162\000\148\001\
\191\001\255\004\000\005\026\002\027\002\028\002\029\002\184\002\
\185\002\099\001\148\002\093\004\094\004\097\001\207\002\030\002\
\001\005\148\002\164\000\144\001\212\002\073\002\220\003\212\002\
\221\003\237\004\139\002\104\004\190\000\148\002\148\002\206\002\
\208\002\212\002\222\003\139\002\238\004\100\002\090\002\214\002\
\112\004\020\004\012\000\021\004\182\001\148\001\212\002\122\000\
\212\002\212\002\101\002\164\000\150\002\022\004\104\002\182\001\
\120\004\013\000\014\000\031\002\212\002\212\002\150\002\148\001\
\148\001\105\002\148\001\148\001\182\001\182\001\021\000\249\002\
\090\002\191\001\106\002\191\001\184\002\187\002\113\002\130\004\
\212\002\114\002\090\002\212\002\115\002\148\001\122\000\138\004\
\212\002\029\000\182\001\121\002\073\001\062\002\212\002\126\002\
\062\002\033\000\202\002\162\000\212\002\005\005\191\001\037\000\
\191\001\204\002\062\002\162\000\045\001\039\000\062\002\127\002\
\212\002\216\002\216\002\119\002\212\002\186\002\188\002\062\002\
\062\002\062\002\062\002\090\002\090\002\043\000\131\002\135\002\
\212\002\107\002\108\002\212\002\212\002\209\002\062\002\164\000\
\165\004\047\000\132\002\214\002\050\000\118\001\135\002\214\002\
\124\002\118\001\164\002\214\002\214\002\135\002\166\002\197\002\
\118\001\062\002\176\002\118\001\062\002\206\002\119\002\062\002\
\062\002\062\002\214\002\090\002\118\001\005\005\062\002\062\002\
\213\002\142\002\144\002\146\002\135\002\062\002\135\002\225\002\
\238\002\150\002\227\002\055\005\056\005\230\002\062\002\239\002\
\135\002\062\002\240\002\062\002\112\000\062\002\113\000\114\000\
\028\000\214\002\115\000\242\002\243\002\116\000\117\000\008\003\
\202\004\062\002\204\004\118\001\062\002\244\002\009\003\194\002\
\062\002\246\002\001\003\131\002\131\002\061\001\118\000\048\000\
\025\003\032\003\131\002\038\003\054\003\191\001\119\000\120\000\
\191\001\135\002\042\003\045\003\135\002\051\003\121\000\131\002\
\064\003\149\001\073\003\224\002\241\004\131\002\079\003\087\003\
\179\001\244\004\122\000\123\000\001\000\002\000\003\000\004\000\
\005\000\094\003\101\003\002\002\103\003\116\003\184\002\129\003\
\131\002\131\002\249\002\031\002\142\003\252\002\185\000\185\000\
\182\001\099\001\008\005\159\003\160\003\099\001\185\000\161\003\
\090\002\099\001\162\003\099\001\185\000\185\000\163\003\099\001\
\199\003\167\003\182\001\212\003\182\001\206\003\182\001\233\003\
\185\000\242\003\182\001\249\003\099\001\008\000\005\004\007\004\
\119\002\185\000\023\005\024\005\010\004\029\004\030\004\185\000\
\185\000\185\000\185\000\185\000\035\004\005\005\036\004\044\004\
\191\001\194\000\049\004\051\004\046\004\040\005\008\000\068\004\
\114\001\050\005\185\000\050\004\074\004\096\004\108\004\185\000\
\113\004\110\004\121\004\122\004\185\000\185\000\182\001\123\004\
\127\004\136\004\099\001\191\001\204\002\140\004\128\004\185\000\
\185\000\185\000\185\000\185\000\129\004\141\004\144\001\149\004\
\144\001\159\004\157\004\177\004\099\001\099\001\070\005\099\001\
\099\001\185\000\161\004\144\001\182\001\192\004\172\004\112\000\
\166\004\113\000\114\000\028\000\173\004\115\000\158\003\176\004\
\115\001\117\000\099\001\082\003\219\004\204\002\223\004\005\005\
\194\004\005\005\006\005\009\005\212\002\018\003\016\005\212\002\
\182\001\036\005\160\001\093\003\018\005\206\004\096\005\052\005\
\067\005\212\002\120\000\053\005\166\002\054\005\100\005\076\005\
\081\005\121\000\084\005\099\005\105\005\113\005\212\002\164\000\
\212\002\212\002\109\005\118\005\134\005\122\000\123\000\147\005\
\148\005\150\005\151\005\156\005\118\003\212\002\157\005\159\005\
\178\005\042\003\039\005\183\005\191\005\207\005\062\002\208\005\
\212\005\062\002\215\005\221\005\222\005\034\000\071\000\026\002\
\212\002\034\000\214\002\062\002\071\000\047\002\216\002\062\002\
\212\002\044\002\191\001\214\002\120\002\042\003\212\002\144\001\
\062\002\062\002\062\002\062\002\212\002\150\000\008\000\046\002\
\114\001\102\000\144\001\223\002\224\002\194\001\182\001\062\002\
\212\002\214\002\137\002\049\002\212\002\144\001\166\000\135\002\
\183\000\182\001\136\002\135\002\218\001\214\003\015\000\136\002\
\212\002\138\002\062\002\212\002\141\002\062\002\230\003\120\002\
\062\002\062\002\062\002\191\001\142\002\143\002\144\001\062\002\
\062\002\139\002\182\001\195\005\066\005\141\005\062\002\112\000\
\122\003\113\000\114\000\028\000\048\004\115\000\190\005\011\003\
\115\001\117\000\062\002\081\003\062\002\211\002\062\002\079\005\
\078\002\077\002\056\004\191\001\151\002\023\003\028\003\163\001\
\149\002\007\005\062\002\119\004\252\004\062\002\205\005\206\005\
\112\003\062\002\120\000\117\002\093\002\072\005\213\005\064\005\
\000\000\121\000\098\005\240\004\000\000\000\000\042\003\204\002\
\000\000\000\000\000\000\000\000\000\000\122\000\123\000\223\005\
\191\001\191\001\000\000\000\000\000\000\052\001\009\004\000\000\
\000\000\141\001\000\000\000\000\112\000\000\000\113\000\114\000\
\028\000\144\001\115\000\000\000\000\000\116\000\117\000\000\000\
\000\000\000\000\000\000\156\001\150\000\150\000\000\000\150\000\
\216\002\216\002\059\001\060\001\061\001\000\000\118\000\216\002\
\000\000\150\000\150\000\000\000\000\000\216\002\119\000\120\000\
\000\000\000\000\000\000\000\000\216\002\191\001\121\000\042\003\
\194\002\000\000\216\002\000\000\000\000\063\001\064\001\042\003\
\150\000\150\000\122\000\123\000\222\001\000\000\000\000\000\000\
\191\001\066\001\067\001\068\001\069\001\216\002\216\002\000\000\
\000\000\081\004\083\004\085\004\000\000\182\001\000\000\088\004\
\000\000\000\000\071\001\000\000\000\000\194\002\000\000\000\000\
\000\000\000\000\000\000\165\000\000\000\000\000\172\000\000\000\
\000\000\174\000\175\000\000\000\000\000\176\000\177\000\178\000\
\179\000\180\000\000\000\181\000\194\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\032\001\000\000\
\000\000\034\001\035\001\000\000\000\000\000\000\000\000\000\000\
\000\000\042\003\040\001\041\001\144\001\000\000\042\001\043\001\
\112\000\000\000\113\000\114\000\028\000\000\000\115\000\000\000\
\000\000\115\001\117\000\000\000\000\000\182\001\000\000\182\001\
\000\000\182\001\000\000\144\001\182\001\000\000\000\000\000\000\
\042\003\000\000\000\000\000\000\000\000\144\001\015\000\000\000\
\191\001\015\000\191\001\120\000\000\000\104\001\105\001\106\001\
\000\000\108\001\121\000\015\000\015\000\000\000\000\000\015\000\
\000\000\000\000\204\002\000\000\000\000\000\000\122\000\123\000\
\015\000\015\000\015\000\015\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\012\000\042\003\015\000\015\000\
\000\000\000\000\042\003\000\000\000\000\000\000\000\000\000\000\
\000\000\191\001\000\000\089\000\014\000\153\001\154\001\066\002\
\000\000\000\000\015\000\000\000\000\000\015\000\000\000\000\000\
\090\000\015\000\015\000\000\000\000\000\000\000\144\001\015\000\
\015\000\000\000\144\001\000\000\000\000\000\000\015\000\204\002\
\000\000\000\000\000\000\029\000\000\000\000\000\000\000\000\000\
\000\000\197\001\015\000\033\000\015\000\000\000\015\000\204\002\
\042\003\091\000\144\001\000\000\000\000\000\000\000\000\039\000\
\000\000\000\000\015\000\209\002\000\000\015\000\000\000\000\000\
\144\001\015\000\000\000\000\000\000\000\000\000\141\001\092\000\
\000\000\150\000\150\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\093\000\000\000\000\000\050\000\042\003\
\204\002\000\000\000\000\000\000\000\000\000\000\042\003\000\000\
\000\000\000\000\150\000\150\000\150\000\000\000\000\000\000\000\
\000\000\000\000\150\000\000\000\000\000\191\001\000\000\069\005\
\000\000\157\002\112\000\000\000\113\000\114\000\028\000\000\000\
\115\000\249\001\250\001\116\000\117\000\144\001\000\000\150\000\
\150\000\000\000\000\000\000\000\150\000\000\000\000\000\000\000\
\150\000\240\001\000\000\222\001\118\000\144\001\000\000\003\002\
\000\000\000\000\191\001\156\001\119\000\060\003\000\000\000\000\
\000\000\000\000\156\001\000\000\121\000\011\002\052\000\069\005\
\000\000\017\002\000\000\000\000\150\000\000\000\000\000\070\004\
\122\000\123\000\000\000\000\000\000\000\150\000\000\000\000\000\
\124\001\000\000\000\000\222\001\191\001\000\000\000\000\000\000\
\000\000\144\001\000\000\000\000\144\001\125\001\150\000\000\000\
\000\000\000\003\000\000\191\001\000\000\000\000\000\000\144\001\
\000\000\000\000\183\000\191\001\000\000\000\000\000\000\000\000\
\112\000\000\000\113\000\114\000\028\000\000\000\115\000\000\000\
\000\000\126\001\117\000\000\000\191\001\000\000\000\000\153\000\
\000\000\000\000\000\000\170\000\000\000\000\000\000\000\000\000\
\000\000\150\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\170\000\120\000\000\000\191\001\191\001\000\000\
\000\000\000\000\121\000\144\001\000\000\000\000\000\000\191\001\
\000\000\000\000\110\002\000\000\170\000\144\001\122\000\123\000\
\000\000\000\000\000\000\000\000\000\000\144\001\191\001\000\000\
\000\000\000\000\000\000\191\001\191\001\191\001\191\001\000\000\
\156\000\008\000\009\000\000\000\000\000\052\001\010\000\011\000\
\144\001\144\001\000\000\135\002\000\000\000\000\000\000\000\000\
\170\000\000\000\170\000\170\000\000\000\144\001\069\005\000\000\
\069\005\015\000\016\000\156\001\150\000\000\000\000\000\000\000\
\144\001\058\001\059\001\060\001\061\001\000\000\000\000\000\000\
\000\000\000\000\000\000\150\000\150\000\022\000\144\001\106\002\
\024\000\025\000\026\000\027\000\144\001\144\001\028\000\000\000\
\162\000\000\000\000\000\142\000\032\000\063\001\064\001\000\000\
\000\000\000\000\110\003\000\000\000\000\000\000\000\000\000\000\
\000\000\066\001\067\001\068\001\069\001\150\000\153\000\153\000\
\000\000\153\000\042\000\000\000\000\000\000\000\150\000\000\000\
\150\000\000\000\071\001\153\000\153\000\000\000\000\000\231\002\
\044\000\000\000\222\001\000\000\000\000\045\000\000\000\170\000\
\048\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\240\001\153\000\214\001\240\001\000\000\000\000\170\000\
\000\000\000\000\000\000\000\000\000\000\000\000\240\001\145\003\
\000\000\150\000\240\001\000\000\000\000\000\000\052\000\156\000\
\156\000\052\000\156\000\240\001\240\001\240\001\240\001\000\000\
\222\001\000\000\000\000\052\000\156\000\156\000\000\000\000\000\
\000\000\000\000\240\001\000\000\000\000\000\000\000\000\000\000\
\052\000\000\000\052\000\052\000\000\000\000\000\000\000\000\000\
\000\000\000\000\205\001\156\000\156\000\240\001\052\000\052\000\
\240\001\000\000\000\000\240\001\240\001\240\001\000\000\000\000\
\000\000\154\000\240\001\240\001\000\000\171\000\000\000\000\000\
\000\000\240\001\052\000\000\000\000\000\052\000\170\000\244\003\
\000\000\052\000\052\000\000\000\171\000\240\001\000\000\240\001\
\052\000\240\001\000\000\000\000\000\000\000\000\052\000\000\000\
\000\000\000\000\000\000\170\000\141\001\240\001\171\000\000\000\
\240\001\000\000\052\000\000\000\240\001\000\000\052\000\150\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\052\000\000\000\000\000\052\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\171\000\000\000\171\000\171\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\150\000\000\000\170\000\170\000\000\000\000\000\170\000\
\000\000\053\000\170\000\000\000\116\001\021\002\000\000\000\000\
\000\000\000\000\000\000\032\002\000\000\150\000\000\000\106\002\
\150\000\000\000\150\000\150\000\150\000\000\000\000\000\106\002\
\150\000\000\000\000\000\000\000\106\002\000\000\150\000\000\000\
\154\000\154\000\000\000\154\000\000\000\000\000\000\000\000\000\
\000\000\106\002\000\000\106\002\106\002\154\000\154\000\000\000\
\000\000\000\000\000\000\000\000\000\000\150\000\000\000\000\000\
\106\002\171\000\000\000\153\000\214\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\154\000\215\001\000\000\222\001\
\088\003\171\000\000\000\106\002\000\000\000\000\106\002\000\000\
\000\000\106\002\106\002\106\002\153\000\153\000\153\000\207\003\
\000\000\106\002\000\000\000\000\153\000\000\000\000\000\106\002\
\000\000\000\000\000\000\000\000\134\004\000\000\000\000\000\000\
\000\000\000\000\000\000\106\002\000\000\000\000\000\000\106\002\
\000\000\214\001\153\000\000\000\156\000\156\000\214\001\000\000\
\000\000\000\000\153\000\106\002\000\000\000\000\106\002\112\000\
\000\000\113\000\114\000\028\000\000\000\115\000\000\000\000\000\
\116\000\117\000\000\000\000\000\140\002\156\000\156\000\156\000\
\000\000\206\004\000\000\000\000\000\000\156\000\153\000\000\000\
\171\000\118\000\000\000\000\000\000\000\000\000\000\000\153\000\
\207\004\119\000\120\000\115\002\150\000\000\000\000\000\198\001\
\000\000\121\000\156\000\156\000\000\000\171\000\000\000\156\000\
\153\000\000\000\222\001\156\000\000\000\122\000\123\000\000\000\
\000\000\000\000\000\000\000\000\170\000\032\002\000\000\000\000\
\208\004\076\000\113\000\114\000\028\000\000\000\115\000\000\000\
\000\000\116\000\209\004\000\000\000\000\000\000\000\000\156\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\222\001\
\233\002\000\000\118\000\153\000\000\000\000\000\000\000\000\000\
\000\000\210\004\119\000\120\000\000\000\000\000\000\000\000\000\
\000\000\156\000\121\000\000\000\000\000\171\000\171\000\000\000\
\000\000\171\000\155\000\201\001\171\000\000\000\211\004\123\000\
\000\000\000\000\000\000\222\001\000\000\000\000\000\000\156\001\
\000\000\053\000\000\000\000\000\053\000\000\000\116\001\000\000\
\000\000\000\000\000\000\000\000\000\000\116\001\053\000\116\001\
\000\000\000\000\000\000\000\000\233\002\000\000\000\000\000\000\
\000\000\000\000\000\000\053\000\000\000\053\000\053\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\153\000\000\000\
\150\000\053\000\053\000\000\000\000\000\154\000\215\001\000\000\
\000\000\000\000\000\000\000\000\000\000\153\000\153\000\000\000\
\000\000\000\000\000\000\000\000\000\000\053\000\000\000\000\000\
\053\000\000\000\000\000\000\000\053\000\053\000\154\000\154\000\
\154\000\000\000\000\000\053\000\111\003\000\000\154\000\000\000\
\000\000\053\000\000\000\000\000\000\000\000\000\000\000\153\000\
\000\000\000\000\000\000\000\000\000\000\053\000\000\000\156\000\
\153\000\053\000\214\001\215\001\154\000\000\000\000\000\000\000\
\215\001\000\000\000\000\000\000\154\000\053\000\156\000\156\000\
\053\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\155\000\155\000\000\000\155\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\155\000\155\000\
\154\000\000\000\150\000\214\001\000\000\000\000\000\000\000\000\
\156\000\154\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\156\000\000\000\156\000\000\000\155\000\155\000\000\000\
\000\000\000\000\154\000\115\002\000\000\115\002\115\002\115\002\
\000\000\000\000\000\000\115\002\000\000\000\000\171\000\000\000\
\115\002\000\000\000\000\000\000\115\002\115\002\115\002\000\000\
\000\000\000\000\000\000\000\000\000\000\115\002\115\002\115\002\
\115\002\076\000\000\000\000\000\156\000\000\000\000\000\115\002\
\000\000\000\000\000\000\150\000\115\002\154\000\076\000\000\000\
\000\000\000\000\000\000\115\002\115\002\239\001\110\003\000\000\
\000\000\000\000\000\000\076\000\000\000\076\000\076\000\115\002\
\000\000\000\000\115\002\115\002\000\000\115\002\115\002\115\002\
\000\000\115\002\076\000\000\000\115\002\115\002\000\000\000\000\
\000\000\153\000\000\000\115\002\000\000\000\000\000\000\000\000\
\000\000\116\001\000\000\000\000\000\000\076\000\115\002\115\002\
\110\003\115\002\115\002\115\002\115\002\076\000\165\005\115\002\
\000\000\000\000\000\000\076\000\000\000\000\000\000\000\115\002\
\115\002\076\000\115\002\000\000\000\000\000\000\115\002\000\000\
\154\000\000\000\000\000\057\002\000\000\076\000\059\002\000\000\
\060\002\076\000\061\002\153\000\000\000\000\000\000\000\154\000\
\154\000\000\000\156\000\000\000\000\000\076\000\000\000\000\000\
\076\000\000\000\000\000\000\000\000\000\000\000\000\000\153\000\
\000\000\000\000\214\001\000\000\153\000\153\000\153\000\094\002\
\195\000\195\000\153\000\099\002\000\000\000\000\000\000\000\000\
\153\000\154\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\154\000\000\000\215\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\156\000\000\000\000\000\153\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\156\000\000\000\000\000\156\000\079\004\156\000\156\000\156\000\
\102\001\103\001\000\000\156\000\000\000\215\001\000\000\141\002\
\000\000\156\000\000\000\000\000\000\000\008\000\155\000\155\000\
\000\000\000\000\002\002\011\000\153\002\000\000\154\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\156\000\000\000\000\000\137\000\000\000\015\000\016\000\155\000\
\155\000\155\000\000\000\000\000\000\000\000\000\000\000\155\000\
\155\000\198\002\000\000\201\002\000\000\000\000\000\000\000\000\
\000\000\022\000\000\000\138\000\139\000\000\000\140\000\141\000\
\000\000\000\000\028\000\000\000\155\000\155\000\000\000\142\000\
\143\000\155\000\000\000\000\000\000\000\155\000\144\000\000\000\
\116\001\000\000\000\000\000\000\000\000\254\003\214\001\000\000\
\000\000\000\000\000\000\145\000\000\000\239\001\000\000\000\000\
\239\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\146\000\155\000\239\001\154\000\044\000\000\000\239\001\000\000\
\000\000\045\000\155\000\000\000\048\000\147\000\000\000\239\001\
\239\001\239\001\239\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\155\000\000\000\000\000\239\001\000\000\
\000\000\000\000\000\000\209\001\000\000\000\000\000\000\156\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\239\001\000\000\000\000\239\001\154\000\000\000\239\001\
\239\001\239\001\000\000\000\000\000\000\000\000\239\001\239\001\
\036\003\000\000\000\000\039\003\000\000\239\001\155\000\000\000\
\000\000\154\000\000\000\000\000\215\001\000\000\154\000\154\000\
\154\000\239\001\000\000\239\001\154\000\239\001\000\000\000\000\
\000\000\000\000\154\000\000\000\000\000\000\000\000\000\000\000\
\000\000\239\001\000\000\000\000\239\001\000\000\000\000\000\000\
\239\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\154\000\214\001\000\000\000\000\000\000\000\000\033\002\
\034\002\035\002\036\002\037\002\038\002\039\002\040\002\041\002\
\042\002\043\002\044\002\045\002\046\002\047\002\048\002\049\002\
\050\002\051\002\052\002\053\002\000\000\056\002\000\000\000\000\
\000\000\155\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\113\003\062\002\000\000\251\001\000\000\
\155\000\155\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\079\002\002\002\156\000\002\002\002\002\002\002\000\000\
\000\000\000\000\002\002\146\004\000\000\000\000\133\003\002\002\
\000\000\000\000\000\000\002\002\002\002\002\002\000\000\000\000\
\000\000\000\000\155\000\000\000\002\002\002\002\002\002\002\002\
\000\000\000\000\000\000\155\000\000\000\155\000\002\002\000\000\
\000\000\000\000\002\002\002\002\214\001\000\000\000\000\000\000\
\000\000\000\000\002\002\002\002\000\000\000\000\000\000\000\000\
\215\001\000\000\000\000\000\000\000\000\000\000\002\002\000\000\
\000\000\002\002\000\000\000\000\002\002\002\002\002\002\000\000\
\002\002\000\000\000\000\002\002\002\002\000\000\155\000\000\000\
\237\001\000\000\002\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\002\002\002\002\000\000\
\002\002\002\002\002\002\000\000\000\000\156\000\002\002\000\000\
\000\000\000\000\000\000\000\000\000\000\214\001\002\002\000\000\
\000\000\002\002\000\000\000\000\000\000\002\002\000\000\000\000\
\138\005\000\000\000\000\209\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\209\001\000\000\003\004\000\000\000\000\
\209\001\215\002\000\000\000\000\000\000\000\000\217\002\000\000\
\000\000\000\000\000\000\000\000\000\000\209\001\000\000\209\001\
\209\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\162\005\000\000\209\001\000\000\156\000\104\003\
\000\000\112\000\000\000\113\000\114\000\028\000\000\000\115\000\
\000\000\000\000\115\001\117\000\155\000\000\000\037\004\209\001\
\000\000\000\000\195\000\195\000\215\001\209\001\209\001\209\001\
\000\000\000\000\000\000\000\000\000\000\209\001\106\002\000\000\
\000\000\000\000\000\000\209\001\120\000\000\000\000\000\000\000\
\000\000\000\000\000\000\121\000\000\000\000\000\067\004\209\001\
\000\000\000\000\000\000\209\001\116\001\027\003\000\000\122\000\
\123\000\000\000\033\003\034\003\035\003\000\000\155\000\209\001\
\000\000\000\000\209\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\251\001\000\000\
\251\001\251\001\155\000\098\004\099\004\155\000\251\001\155\000\
\155\000\155\000\000\000\251\001\000\000\155\000\000\000\251\001\
\251\001\251\001\000\000\155\000\000\000\000\000\000\000\000\000\
\251\001\251\001\251\001\251\001\000\000\000\000\000\000\000\000\
\000\000\000\000\251\001\000\000\000\000\000\000\215\001\251\001\
\000\000\000\000\155\000\000\000\000\000\000\000\251\001\251\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\131\004\000\000\251\001\000\000\000\000\251\001\000\000\000\000\
\251\001\251\001\251\001\000\000\251\001\098\003\099\003\100\003\
\251\001\000\000\000\000\144\004\000\000\000\000\251\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\036\002\
\237\001\251\001\251\001\237\001\251\001\251\001\251\001\000\000\
\000\000\000\000\000\000\214\002\000\000\237\001\000\000\215\001\
\000\000\237\001\251\001\130\003\000\000\251\001\000\000\000\000\
\214\002\251\001\237\001\237\001\237\001\237\001\000\000\000\000\
\000\000\000\000\000\000\140\003\000\000\000\000\000\000\000\000\
\000\000\237\001\000\000\214\002\000\000\214\002\214\002\214\002\
\000\000\214\002\000\000\000\000\214\002\214\002\000\000\000\000\
\000\000\000\000\000\000\000\000\237\001\000\000\000\000\237\001\
\000\000\155\000\237\001\237\001\237\001\000\000\000\000\000\000\
\000\000\237\001\237\001\000\000\000\000\000\000\214\002\000\000\
\237\001\000\000\000\000\209\001\000\000\214\002\000\000\000\000\
\000\000\000\000\000\000\201\004\237\001\203\004\237\001\000\000\
\237\001\214\002\214\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\237\001\000\000\223\003\237\001\
\000\000\000\000\000\000\237\001\000\000\000\000\106\002\106\002\
\106\002\106\002\000\000\000\000\106\002\106\002\106\002\106\002\
\106\002\106\002\106\002\106\002\106\002\106\002\106\002\106\002\
\106\002\106\002\106\002\106\002\246\004\000\000\106\002\106\002\
\106\002\106\002\106\002\106\002\106\002\106\002\000\000\000\000\
\000\000\000\000\106\002\106\002\000\000\000\000\106\002\106\002\
\106\002\106\002\106\002\106\002\106\002\106\002\000\000\106\002\
\106\002\106\002\000\000\106\002\106\002\106\002\106\002\000\000\
\000\000\106\002\106\002\106\002\000\000\106\002\106\002\106\002\
\106\002\106\002\106\002\000\000\106\002\106\002\106\002\106\002\
\106\002\000\000\000\000\000\000\000\000\155\000\106\002\106\002\
\106\002\106\002\106\002\106\002\106\002\106\002\000\000\106\002\
\064\002\106\002\106\002\060\004\106\002\106\002\106\002\106\002\
\106\002\000\000\106\002\106\002\000\000\106\002\106\002\106\002\
\106\002\000\000\106\002\106\002\000\000\106\002\000\000\000\000\
\000\000\106\002\000\000\112\000\000\000\113\000\114\000\028\000\
\000\000\115\000\000\000\000\000\116\000\117\000\000\000\000\000\
\068\005\000\000\000\000\000\000\000\000\000\000\134\001\036\002\
\000\000\036\002\036\002\036\002\000\000\118\000\000\000\036\002\
\000\000\000\000\000\000\000\000\036\002\119\000\120\000\000\000\
\036\002\036\002\036\002\000\000\000\000\121\000\000\000\000\000\
\000\000\036\002\036\002\036\002\036\002\090\005\000\000\000\000\
\000\000\122\000\123\000\036\002\000\000\000\000\000\000\155\000\
\036\002\000\000\124\004\125\004\126\004\000\000\000\000\036\002\
\036\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\036\002\000\000\000\000\036\002\117\005\
\000\000\036\002\036\002\036\002\000\000\036\002\000\000\000\000\
\036\002\036\002\000\000\000\000\000\000\000\000\130\005\036\002\
\000\000\124\001\000\000\209\001\000\000\000\000\139\005\000\000\
\000\000\000\000\036\002\036\002\000\000\036\002\036\002\036\002\
\209\001\241\000\152\004\153\004\154\004\000\000\000\000\142\005\
\155\000\000\000\000\000\036\002\000\000\209\001\036\002\209\001\
\209\001\112\000\036\002\113\000\114\000\028\000\000\000\115\000\
\000\000\000\000\126\001\117\000\209\001\000\000\000\000\000\000\
\163\005\164\005\112\000\000\000\113\000\114\000\028\000\178\004\
\115\000\000\000\174\005\116\000\117\000\000\000\000\000\209\001\
\000\000\000\000\209\001\000\000\120\000\209\001\209\001\209\001\
\000\000\184\005\000\000\121\000\118\000\209\001\186\005\187\005\
\188\005\189\005\000\000\209\001\119\000\060\003\000\000\122\000\
\123\000\000\000\000\000\000\000\121\000\000\000\000\000\209\001\
\000\000\000\000\000\000\209\001\000\000\000\000\000\000\152\005\
\122\000\123\000\000\000\000\000\000\000\000\000\000\000\209\001\
\000\000\000\000\209\001\000\000\000\000\000\000\000\000\000\000\
\224\004\225\004\000\000\000\000\000\000\232\004\233\004\234\004\
\064\002\064\002\064\002\064\002\000\000\247\000\064\002\064\002\
\064\002\064\002\064\002\064\002\064\002\064\002\064\002\064\002\
\064\002\064\002\064\002\064\002\064\002\064\002\064\002\000\000\
\064\002\064\002\064\002\064\002\064\002\064\002\064\002\064\002\
\000\000\000\000\000\000\000\000\064\002\064\002\000\000\000\000\
\064\002\064\002\064\002\064\002\064\002\064\002\064\002\064\002\
\000\000\064\002\064\002\064\002\000\000\064\002\064\002\064\002\
\064\002\000\000\000\000\064\002\064\002\064\002\052\002\064\002\
\064\002\064\002\064\002\064\002\064\002\000\000\064\002\064\002\
\064\002\064\002\064\002\000\000\000\000\000\000\000\000\000\000\
\064\002\064\002\064\002\064\002\064\002\064\002\064\002\064\002\
\000\000\064\002\000\000\064\002\064\002\000\000\064\002\064\002\
\064\002\064\002\064\002\000\000\064\002\064\002\000\000\064\002\
\064\002\064\002\064\002\000\000\064\002\064\002\000\000\064\002\
\000\000\000\000\000\000\064\002\000\000\000\000\000\000\000\000\
\000\000\245\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\241\000\241\000\241\000\241\000\000\000\000\000\241\000\
\241\000\241\000\241\000\241\000\241\000\241\000\241\000\241\000\
\241\000\241\000\241\000\241\000\241\000\241\000\241\000\241\000\
\000\000\241\000\241\000\241\000\241\000\241\000\241\000\241\000\
\241\000\000\000\101\005\102\005\103\005\241\000\241\000\000\000\
\000\000\241\000\241\000\241\000\241\000\241\000\241\000\241\000\
\241\000\000\000\241\000\241\000\241\000\000\000\241\000\241\000\
\241\000\241\000\000\000\000\000\241\000\241\000\241\000\000\000\
\241\000\241\000\241\000\241\000\241\000\241\000\000\000\241\000\
\241\000\241\000\241\000\241\000\000\000\000\000\000\000\000\000\
\000\000\241\000\241\000\241\000\241\000\241\000\241\000\241\000\
\241\000\000\000\241\000\000\000\241\000\241\000\253\000\241\000\
\241\000\241\000\241\000\241\000\000\000\241\000\241\000\000\000\
\241\000\241\000\241\000\241\000\000\000\241\000\241\000\000\000\
\241\000\000\000\000\000\000\000\241\000\247\000\247\000\247\000\
\247\000\000\000\000\000\247\000\247\000\247\000\247\000\247\000\
\247\000\247\000\247\000\247\000\247\000\247\000\247\000\247\000\
\247\000\247\000\247\000\247\000\000\000\247\000\247\000\247\000\
\247\000\247\000\247\000\247\000\247\000\000\000\000\000\000\000\
\000\000\247\000\247\000\000\000\000\000\247\000\247\000\247\000\
\247\000\247\000\247\000\247\000\247\000\000\000\247\000\247\000\
\247\000\000\000\247\000\247\000\247\000\247\000\000\000\000\000\
\247\000\247\000\247\000\000\000\247\000\247\000\247\000\247\000\
\247\000\247\000\000\000\247\000\247\000\247\000\247\000\247\000\
\000\000\000\000\000\000\000\000\000\000\247\000\247\000\247\000\
\247\000\247\000\247\000\247\000\247\000\000\000\247\000\000\000\
\247\000\247\000\249\000\247\000\247\000\247\000\247\000\247\000\
\000\000\247\000\247\000\000\000\247\000\247\000\247\000\247\000\
\000\000\247\000\247\000\000\000\247\000\000\000\000\000\000\000\
\247\000\245\000\245\000\245\000\245\000\000\000\000\000\245\000\
\245\000\245\000\245\000\245\000\245\000\245\000\245\000\245\000\
\245\000\245\000\245\000\245\000\245\000\245\000\245\000\245\000\
\000\000\245\000\245\000\245\000\245\000\245\000\245\000\245\000\
\245\000\000\000\000\000\000\000\000\000\245\000\245\000\000\000\
\000\000\245\000\245\000\245\000\245\000\245\000\245\000\245\000\
\245\000\000\000\245\000\245\000\245\000\000\000\245\000\245\000\
\245\000\245\000\000\000\000\000\245\000\245\000\245\000\000\000\
\245\000\245\000\245\000\245\000\245\000\245\000\000\000\245\000\
\245\000\245\000\245\000\245\000\000\000\000\000\000\000\000\000\
\000\000\245\000\245\000\245\000\245\000\245\000\245\000\245\000\
\245\000\000\000\245\000\000\000\245\000\245\000\251\000\245\000\
\245\000\245\000\245\000\245\000\000\000\245\000\245\000\000\000\
\245\000\245\000\245\000\245\000\000\000\245\000\245\000\000\000\
\245\000\000\000\000\000\000\000\245\000\000\000\253\000\253\000\
\253\000\253\000\000\000\000\000\253\000\253\000\253\000\253\000\
\253\000\253\000\253\000\253\000\253\000\253\000\253\000\253\000\
\253\000\253\000\253\000\253\000\253\000\000\000\253\000\253\000\
\253\000\253\000\253\000\253\000\253\000\253\000\000\000\000\000\
\000\000\000\000\253\000\253\000\000\000\000\000\253\000\253\000\
\253\000\253\000\253\000\253\000\253\000\253\000\000\000\253\000\
\253\000\253\000\000\000\253\000\253\000\253\000\253\000\000\000\
\000\000\253\000\253\000\253\000\000\000\253\000\253\000\253\000\
\253\000\253\000\253\000\000\000\253\000\253\000\253\000\253\000\
\253\000\000\000\000\000\000\000\000\000\000\000\253\000\253\000\
\253\000\253\000\253\000\253\000\253\000\253\000\000\000\253\000\
\000\000\253\000\253\000\003\001\253\000\253\000\253\000\253\000\
\253\000\000\000\253\000\253\000\000\000\253\000\253\000\253\000\
\253\000\000\000\253\000\253\000\000\000\253\000\000\000\000\000\
\000\000\253\000\249\000\249\000\249\000\249\000\000\000\000\000\
\249\000\249\000\249\000\249\000\249\000\249\000\249\000\249\000\
\249\000\249\000\249\000\249\000\249\000\249\000\249\000\249\000\
\249\000\000\000\249\000\249\000\249\000\249\000\249\000\249\000\
\249\000\249\000\000\000\000\000\000\000\000\000\249\000\249\000\
\000\000\000\000\249\000\249\000\249\000\249\000\249\000\249\000\
\249\000\249\000\000\000\249\000\249\000\249\000\000\000\249\000\
\249\000\249\000\249\000\000\000\000\000\249\000\249\000\249\000\
\000\000\249\000\249\000\249\000\249\000\249\000\249\000\000\000\
\249\000\249\000\249\000\249\000\249\000\000\000\000\000\000\000\
\000\000\000\000\249\000\249\000\249\000\249\000\249\000\249\000\
\249\000\249\000\000\000\249\000\000\000\249\000\249\000\255\000\
\249\000\249\000\249\000\249\000\249\000\000\000\249\000\249\000\
\000\000\249\000\249\000\249\000\249\000\000\000\249\000\249\000\
\000\000\249\000\000\000\000\000\000\000\249\000\251\000\251\000\
\251\000\251\000\000\000\000\000\251\000\251\000\251\000\251\000\
\251\000\251\000\251\000\251\000\251\000\251\000\251\000\251\000\
\251\000\251\000\251\000\251\000\251\000\000\000\251\000\251\000\
\251\000\251\000\251\000\251\000\251\000\251\000\000\000\000\000\
\000\000\000\000\251\000\251\000\000\000\000\000\251\000\251\000\
\251\000\251\000\251\000\251\000\251\000\251\000\000\000\251\000\
\251\000\251\000\000\000\251\000\251\000\251\000\251\000\000\000\
\000\000\251\000\251\000\251\000\000\000\251\000\251\000\251\000\
\251\000\251\000\251\000\000\000\251\000\251\000\251\000\251\000\
\251\000\000\000\000\000\000\000\000\000\000\000\251\000\251\000\
\251\000\251\000\251\000\251\000\251\000\251\000\000\000\251\000\
\000\000\251\000\251\000\001\001\251\000\251\000\251\000\251\000\
\251\000\000\000\251\000\251\000\000\000\251\000\251\000\251\000\
\251\000\000\000\251\000\251\000\000\000\251\000\000\000\000\000\
\000\000\251\000\000\000\003\001\003\001\003\001\003\001\000\000\
\000\000\003\001\003\001\003\001\003\001\003\001\003\001\003\001\
\003\001\003\001\003\001\003\001\003\001\003\001\003\001\003\001\
\003\001\003\001\000\000\003\001\003\001\003\001\003\001\003\001\
\003\001\003\001\003\001\000\000\000\000\000\000\000\000\003\001\
\003\001\000\000\000\000\003\001\003\001\003\001\003\001\003\001\
\003\001\003\001\003\001\000\000\003\001\003\001\003\001\000\000\
\003\001\003\001\003\001\003\001\000\000\000\000\003\001\003\001\
\003\001\000\000\003\001\003\001\003\001\003\001\003\001\003\001\
\000\000\003\001\003\001\003\001\003\001\003\001\000\000\000\000\
\000\000\000\000\000\000\003\001\003\001\003\001\003\001\003\001\
\003\001\003\001\003\001\000\000\003\001\000\000\003\001\003\001\
\030\001\003\001\003\001\003\001\003\001\003\001\000\000\003\001\
\003\001\000\000\003\001\003\001\003\001\003\001\000\000\003\001\
\003\001\000\000\003\001\000\000\000\000\000\000\003\001\255\000\
\255\000\255\000\255\000\000\000\000\000\255\000\255\000\255\000\
\255\000\255\000\255\000\255\000\255\000\255\000\255\000\255\000\
\255\000\255\000\255\000\255\000\255\000\255\000\000\000\255\000\
\255\000\255\000\255\000\255\000\255\000\255\000\255\000\000\000\
\000\000\000\000\000\000\255\000\255\000\000\000\000\000\255\000\
\255\000\255\000\255\000\255\000\255\000\255\000\255\000\000\000\
\255\000\255\000\255\000\000\000\255\000\255\000\255\000\255\000\
\000\000\000\000\255\000\255\000\255\000\000\000\255\000\255\000\
\255\000\255\000\255\000\255\000\000\000\255\000\255\000\255\000\
\255\000\255\000\000\000\000\000\000\000\000\000\000\000\255\000\
\255\000\255\000\255\000\255\000\255\000\255\000\255\000\000\000\
\255\000\000\000\255\000\255\000\039\001\255\000\255\000\255\000\
\255\000\255\000\000\000\255\000\255\000\000\000\255\000\255\000\
\255\000\255\000\000\000\255\000\255\000\000\000\255\000\000\000\
\000\000\000\000\255\000\001\001\001\001\001\001\001\001\000\000\
\000\000\001\001\001\001\001\001\001\001\001\001\001\001\001\001\
\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\001\
\001\001\001\001\000\000\001\001\001\001\001\001\001\001\001\001\
\001\001\001\001\001\001\000\000\000\000\000\000\000\000\001\001\
\001\001\000\000\000\000\001\001\001\001\001\001\001\001\001\001\
\001\001\001\001\001\001\000\000\001\001\001\001\001\001\000\000\
\001\001\001\001\001\001\001\001\000\000\000\000\001\001\001\001\
\001\001\000\000\001\001\001\001\001\001\001\001\001\001\001\001\
\000\000\001\001\001\001\001\001\001\001\001\001\000\000\000\000\
\000\000\000\000\000\000\001\001\001\001\001\001\001\001\001\001\
\001\001\001\001\001\001\000\000\001\001\000\000\001\001\001\001\
\041\001\001\001\001\001\001\001\001\001\001\001\000\000\001\001\
\001\001\000\000\001\001\001\001\001\001\001\001\000\000\001\001\
\001\001\000\000\001\001\000\000\000\000\000\000\001\001\000\000\
\030\001\030\001\030\001\030\001\000\000\000\000\030\001\030\001\
\030\001\030\001\030\001\030\001\030\001\030\001\030\001\030\001\
\030\001\030\001\030\001\030\001\030\001\030\001\000\000\000\000\
\030\001\030\001\030\001\030\001\030\001\030\001\030\001\030\001\
\000\000\000\000\000\000\000\000\030\001\030\001\000\000\000\000\
\030\001\030\001\030\001\030\001\030\001\030\001\030\001\000\000\
\000\000\030\001\030\001\030\001\000\000\030\001\030\001\030\001\
\030\001\000\000\000\000\030\001\030\001\030\001\000\000\030\001\
\030\001\030\001\030\001\030\001\030\001\000\000\030\001\030\001\
\030\001\030\001\030\001\000\000\000\000\000\000\000\000\000\000\
\030\001\030\001\030\001\030\001\030\001\030\001\030\001\030\001\
\000\000\030\001\000\000\030\001\030\001\044\001\030\001\030\001\
\030\001\030\001\030\001\000\000\030\001\030\001\000\000\030\001\
\030\001\030\001\030\001\000\000\030\001\030\001\000\000\030\001\
\000\000\000\000\000\000\030\001\039\001\039\001\039\001\039\001\
\000\000\000\000\039\001\039\001\039\001\039\001\039\001\039\001\
\039\001\039\001\039\001\039\001\039\001\039\001\039\001\039\001\
\039\001\039\001\000\000\000\000\039\001\039\001\039\001\039\001\
\039\001\039\001\039\001\039\001\000\000\000\000\000\000\000\000\
\039\001\039\001\000\000\000\000\039\001\039\001\039\001\039\001\
\039\001\039\001\039\001\000\000\000\000\039\001\039\001\039\001\
\000\000\039\001\039\001\039\001\039\001\000\000\000\000\039\001\
\039\001\039\001\000\000\039\001\039\001\039\001\039\001\039\001\
\039\001\000\000\039\001\039\001\039\001\039\001\039\001\000\000\
\000\000\000\000\000\000\000\000\039\001\039\001\039\001\039\001\
\039\001\039\001\039\001\039\001\000\000\039\001\000\000\039\001\
\039\001\233\000\039\001\039\001\039\001\000\000\000\000\000\000\
\039\001\039\001\000\000\039\001\039\001\039\001\039\001\000\000\
\039\001\039\001\000\000\039\001\000\000\000\000\000\000\039\001\
\041\001\041\001\041\001\041\001\000\000\000\000\041\001\041\001\
\041\001\041\001\041\001\041\001\041\001\041\001\041\001\041\001\
\041\001\041\001\041\001\041\001\041\001\041\001\000\000\000\000\
\041\001\041\001\041\001\041\001\041\001\041\001\041\001\041\001\
\000\000\000\000\000\000\000\000\041\001\041\001\000\000\000\000\
\041\001\041\001\041\001\041\001\041\001\041\001\041\001\000\000\
\000\000\041\001\041\001\041\001\000\000\041\001\041\001\041\001\
\041\001\000\000\000\000\041\001\041\001\041\001\000\000\041\001\
\041\001\041\001\041\001\041\001\041\001\000\000\041\001\041\001\
\041\001\041\001\041\001\000\000\000\000\000\000\000\000\000\000\
\041\001\041\001\041\001\041\001\041\001\041\001\041\001\041\001\
\000\000\041\001\000\000\041\001\041\001\234\000\041\001\041\001\
\041\001\000\000\000\000\000\000\041\001\041\001\000\000\041\001\
\041\001\041\001\041\001\000\000\041\001\041\001\000\000\041\001\
\000\000\000\000\000\000\041\001\000\000\044\001\044\001\044\001\
\044\001\000\000\000\000\044\001\044\001\044\001\044\001\044\001\
\044\001\044\001\044\001\044\001\044\001\044\001\044\001\044\001\
\044\001\044\001\044\001\000\000\000\000\044\001\044\001\044\001\
\044\001\044\001\044\001\044\001\044\001\000\000\000\000\000\000\
\000\000\044\001\044\001\000\000\000\000\044\001\044\001\044\001\
\044\001\044\001\044\001\044\001\000\000\000\000\044\001\044\001\
\044\001\000\000\044\001\044\001\044\001\044\001\000\000\000\000\
\044\001\044\001\044\001\000\000\044\001\044\001\044\001\044\001\
\044\001\044\001\000\000\044\001\044\001\044\001\044\001\044\001\
\000\000\000\000\000\000\000\000\000\000\044\001\044\001\044\001\
\044\001\044\001\044\001\044\001\044\001\000\000\044\001\000\000\
\044\001\044\001\173\000\044\001\044\001\044\001\000\000\000\000\
\000\000\044\001\044\001\000\000\044\001\044\001\044\001\044\001\
\000\000\044\001\044\001\000\000\044\001\000\000\000\000\000\000\
\044\001\233\000\233\000\233\000\233\000\000\000\000\000\000\000\
\000\000\233\000\233\000\233\000\000\000\000\000\233\000\233\000\
\233\000\233\000\233\000\233\000\233\000\233\000\233\000\233\000\
\000\000\233\000\233\000\233\000\233\000\233\000\233\000\000\000\
\000\000\000\000\000\000\000\000\000\000\233\000\233\000\000\000\
\000\000\233\000\233\000\233\000\233\000\233\000\233\000\233\000\
\233\000\000\000\233\000\000\000\233\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\233\000\233\000\000\000\
\233\000\000\000\000\000\233\000\233\000\233\000\000\000\233\000\
\233\000\233\000\233\000\233\000\000\000\000\000\000\000\000\000\
\000\000\233\000\233\000\233\000\233\000\233\000\233\000\233\000\
\000\000\000\000\233\000\000\000\233\000\233\000\174\000\233\000\
\233\000\233\000\233\000\233\000\000\000\233\000\000\000\000\000\
\233\000\233\000\233\000\000\000\000\000\233\000\000\000\000\000\
\233\000\000\000\000\000\000\000\233\000\234\000\234\000\234\000\
\234\000\000\000\000\000\000\000\000\000\234\000\234\000\234\000\
\000\000\000\000\234\000\234\000\234\000\234\000\234\000\234\000\
\234\000\234\000\234\000\234\000\000\000\234\000\234\000\234\000\
\234\000\234\000\234\000\000\000\000\000\000\000\000\000\000\000\
\000\000\234\000\234\000\000\000\000\000\234\000\234\000\234\000\
\234\000\234\000\234\000\234\000\234\000\000\000\234\000\000\000\
\234\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\234\000\234\000\000\000\234\000\000\000\000\000\234\000\
\234\000\234\000\000\000\234\000\234\000\234\000\234\000\234\000\
\000\000\000\000\000\000\000\000\000\000\234\000\234\000\234\000\
\234\000\234\000\234\000\234\000\000\000\000\000\234\000\000\000\
\234\000\234\000\186\000\234\000\234\000\234\000\234\000\234\000\
\000\000\234\000\000\000\000\000\234\000\234\000\234\000\000\000\
\000\000\234\000\000\000\000\000\234\000\000\000\000\000\000\000\
\234\000\000\000\173\000\173\000\173\000\173\000\000\000\000\000\
\000\000\000\000\173\000\173\000\173\000\000\000\000\000\173\000\
\173\000\173\000\173\000\173\000\173\000\173\000\173\000\173\000\
\000\000\000\000\173\000\173\000\173\000\173\000\173\000\173\000\
\000\000\000\000\000\000\000\000\000\000\000\000\173\000\173\000\
\000\000\000\000\173\000\173\000\173\000\173\000\173\000\173\000\
\173\000\000\000\000\000\173\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\173\000\173\000\
\000\000\173\000\000\000\000\000\173\000\173\000\173\000\000\000\
\173\000\173\000\173\000\173\000\173\000\000\000\000\000\000\000\
\000\000\000\000\173\000\000\000\173\000\173\000\173\000\173\000\
\173\000\000\000\000\000\000\000\000\000\173\000\173\000\187\000\
\173\000\173\000\173\000\000\000\000\000\000\000\173\000\000\000\
\000\000\173\000\000\000\173\000\000\000\000\000\173\000\000\000\
\000\000\173\000\000\000\000\000\000\000\173\000\174\000\174\000\
\174\000\174\000\000\000\000\000\000\000\000\000\174\000\174\000\
\174\000\000\000\000\000\174\000\174\000\174\000\174\000\174\000\
\174\000\174\000\174\000\174\000\000\000\000\000\174\000\174\000\
\174\000\174\000\174\000\174\000\000\000\000\000\000\000\000\000\
\000\000\000\000\174\000\174\000\000\000\000\000\174\000\174\000\
\174\000\174\000\174\000\174\000\174\000\000\000\000\000\174\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\174\000\174\000\000\000\174\000\000\000\000\000\
\174\000\174\000\174\000\000\000\174\000\174\000\174\000\174\000\
\174\000\000\000\000\000\000\000\000\000\000\000\174\000\000\000\
\174\000\174\000\174\000\174\000\174\000\000\000\000\000\000\000\
\000\000\174\000\174\000\225\000\174\000\174\000\174\000\000\000\
\000\000\000\000\174\000\000\000\000\000\174\000\000\000\174\000\
\000\000\000\000\174\000\000\000\000\000\174\000\000\000\000\000\
\000\000\174\000\186\000\186\000\186\000\186\000\000\000\000\000\
\000\000\000\000\186\000\186\000\186\000\000\000\000\000\186\000\
\186\000\186\000\186\000\186\000\186\000\186\000\186\000\186\000\
\000\000\000\000\186\000\186\000\186\000\186\000\186\000\186\000\
\000\000\000\000\000\000\000\000\000\000\000\000\186\000\186\000\
\000\000\000\000\186\000\186\000\186\000\186\000\186\000\186\000\
\186\000\000\000\000\000\186\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\186\000\186\000\
\000\000\186\000\000\000\000\000\186\000\186\000\186\000\000\000\
\186\000\186\000\186\000\186\000\186\000\000\000\000\000\000\000\
\000\000\000\000\186\000\000\000\186\000\186\000\186\000\186\000\
\186\000\000\000\000\000\000\000\000\000\186\000\186\000\226\000\
\186\000\186\000\186\000\000\000\000\000\000\000\186\000\000\000\
\000\000\186\000\000\000\186\000\000\000\000\000\186\000\000\000\
\000\000\186\000\000\000\000\000\000\000\186\000\000\000\187\000\
\187\000\187\000\187\000\000\000\000\000\000\000\000\000\187\000\
\187\000\187\000\000\000\000\000\187\000\187\000\187\000\187\000\
\187\000\187\000\187\000\187\000\187\000\000\000\000\000\187\000\
\187\000\187\000\187\000\187\000\187\000\000\000\000\000\000\000\
\000\000\000\000\000\000\187\000\187\000\000\000\000\000\187\000\
\187\000\187\000\187\000\187\000\187\000\187\000\000\000\000\000\
\187\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\187\000\187\000\000\000\187\000\000\000\
\000\000\187\000\187\000\187\000\000\000\187\000\187\000\187\000\
\187\000\187\000\000\000\000\000\000\000\000\000\000\000\187\000\
\000\000\187\000\187\000\187\000\187\000\187\000\000\000\000\000\
\000\000\000\000\187\000\187\000\185\000\187\000\187\000\187\000\
\000\000\000\000\000\000\187\000\000\000\000\000\187\000\000\000\
\187\000\000\000\000\000\187\000\000\000\000\000\187\000\000\000\
\000\000\000\000\187\000\225\000\225\000\225\000\225\000\000\000\
\000\000\000\000\000\000\225\000\225\000\225\000\000\000\000\000\
\225\000\225\000\225\000\225\000\225\000\225\000\225\000\225\000\
\225\000\000\000\000\000\225\000\225\000\225\000\225\000\225\000\
\225\000\000\000\000\000\000\000\000\000\000\000\000\000\225\000\
\225\000\000\000\000\000\225\000\225\000\225\000\225\000\225\000\
\225\000\225\000\000\000\000\000\225\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\225\000\
\225\000\000\000\225\000\000\000\000\000\225\000\225\000\225\000\
\000\000\225\000\225\000\225\000\225\000\225\000\000\000\000\000\
\000\000\000\000\000\000\225\000\000\000\225\000\225\000\225\000\
\225\000\225\000\000\000\000\000\000\000\000\000\225\000\225\000\
\196\000\225\000\225\000\225\000\000\000\000\000\000\000\225\000\
\000\000\000\000\225\000\000\000\225\000\000\000\000\000\225\000\
\000\000\000\000\225\000\000\000\000\000\000\000\225\000\226\000\
\226\000\226\000\226\000\000\000\000\000\000\000\000\000\226\000\
\226\000\226\000\000\000\000\000\226\000\226\000\226\000\226\000\
\226\000\226\000\226\000\226\000\226\000\000\000\000\000\226\000\
\226\000\226\000\226\000\226\000\226\000\000\000\000\000\000\000\
\000\000\000\000\000\000\226\000\226\000\000\000\000\000\226\000\
\226\000\226\000\226\000\226\000\226\000\226\000\000\000\000\000\
\226\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\226\000\226\000\000\000\226\000\000\000\
\000\000\226\000\226\000\226\000\000\000\226\000\226\000\226\000\
\226\000\226\000\000\000\000\000\000\000\000\000\000\000\226\000\
\000\000\226\000\226\000\226\000\226\000\226\000\000\000\000\000\
\000\000\000\000\226\000\226\000\197\000\226\000\226\000\226\000\
\000\000\000\000\000\000\226\000\000\000\000\000\226\000\000\000\
\226\000\000\000\000\000\226\000\000\000\000\000\226\000\000\000\
\000\000\000\000\226\000\000\000\185\000\185\000\185\000\185\000\
\000\000\000\000\000\000\000\000\185\000\185\000\185\000\000\000\
\000\000\185\000\185\000\185\000\185\000\185\000\000\000\185\000\
\185\000\185\000\000\000\000\000\185\000\185\000\185\000\185\000\
\185\000\185\000\000\000\000\000\000\000\000\000\000\000\000\000\
\185\000\185\000\000\000\000\000\185\000\185\000\185\000\185\000\
\185\000\185\000\185\000\000\000\000\000\185\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\185\000\185\000\000\000\185\000\000\000\000\000\185\000\185\000\
\185\000\000\000\185\000\185\000\185\000\185\000\185\000\000\000\
\000\000\000\000\000\000\000\000\185\000\000\000\185\000\185\000\
\185\000\185\000\185\000\000\000\000\000\000\000\000\000\185\000\
\185\000\204\000\185\000\185\000\185\000\000\000\000\000\000\000\
\185\000\000\000\000\000\185\000\000\000\185\000\000\000\000\000\
\185\000\000\000\000\000\185\000\000\000\000\000\000\000\185\000\
\196\000\196\000\196\000\196\000\000\000\000\000\000\000\000\000\
\196\000\196\000\196\000\000\000\000\000\196\000\196\000\196\000\
\196\000\196\000\196\000\196\000\196\000\196\000\000\000\000\000\
\196\000\196\000\196\000\196\000\196\000\196\000\000\000\000\000\
\000\000\000\000\000\000\000\000\196\000\196\000\000\000\000\000\
\196\000\196\000\196\000\196\000\196\000\196\000\000\000\000\000\
\000\000\196\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\196\000\196\000\000\000\196\000\
\000\000\000\000\196\000\196\000\196\000\000\000\196\000\196\000\
\196\000\196\000\196\000\000\000\000\000\000\000\000\000\000\000\
\196\000\000\000\196\000\196\000\196\000\196\000\196\000\000\000\
\000\000\000\000\000\000\196\000\196\000\203\000\196\000\196\000\
\196\000\000\000\000\000\000\000\196\000\000\000\000\000\196\000\
\000\000\196\000\000\000\000\000\196\000\000\000\000\000\196\000\
\000\000\000\000\000\000\196\000\197\000\197\000\197\000\197\000\
\000\000\000\000\000\000\000\000\197\000\197\000\197\000\000\000\
\000\000\197\000\197\000\197\000\197\000\197\000\197\000\197\000\
\197\000\197\000\000\000\000\000\197\000\197\000\197\000\197\000\
\197\000\197\000\000\000\000\000\000\000\000\000\000\000\000\000\
\197\000\197\000\000\000\000\000\197\000\197\000\197\000\197\000\
\197\000\197\000\000\000\000\000\000\000\197\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\197\000\197\000\000\000\197\000\000\000\000\000\197\000\197\000\
\197\000\000\000\197\000\197\000\197\000\197\000\197\000\000\000\
\000\000\000\000\000\000\000\000\197\000\000\000\197\000\197\000\
\197\000\197\000\197\000\000\000\000\000\000\000\000\000\197\000\
\197\000\179\000\197\000\197\000\197\000\000\000\000\000\000\000\
\197\000\000\000\000\000\197\000\000\000\197\000\000\000\000\000\
\197\000\000\000\000\000\197\000\000\000\000\000\000\000\197\000\
\000\000\204\000\204\000\204\000\204\000\000\000\000\000\000\000\
\000\000\204\000\204\000\204\000\000\000\000\000\204\000\204\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\000\000\
\000\000\204\000\204\000\204\000\204\000\204\000\204\000\000\000\
\000\000\000\000\000\000\000\000\000\000\204\000\204\000\000\000\
\000\000\204\000\204\000\204\000\204\000\204\000\204\000\000\000\
\000\000\000\000\204\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\204\000\204\000\000\000\
\204\000\000\000\000\000\204\000\204\000\204\000\000\000\204\000\
\204\000\204\000\204\000\204\000\000\000\000\000\000\000\000\000\
\000\000\204\000\000\000\204\000\204\000\204\000\204\000\204\000\
\000\000\000\000\000\000\000\000\204\000\204\000\182\000\204\000\
\204\000\204\000\000\000\000\000\000\000\204\000\000\000\000\000\
\204\000\000\000\204\000\000\000\000\000\204\000\000\000\000\000\
\204\000\000\000\000\000\000\000\204\000\203\000\203\000\203\000\
\203\000\000\000\000\000\000\000\000\000\203\000\203\000\203\000\
\000\000\000\000\203\000\203\000\203\000\203\000\203\000\203\000\
\203\000\203\000\203\000\000\000\000\000\203\000\203\000\203\000\
\203\000\203\000\203\000\000\000\000\000\000\000\000\000\000\000\
\000\000\203\000\203\000\000\000\000\000\203\000\203\000\203\000\
\203\000\203\000\203\000\000\000\000\000\000\000\203\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\203\000\203\000\000\000\203\000\000\000\000\000\203\000\
\203\000\203\000\000\000\203\000\203\000\203\000\203\000\203\000\
\000\000\000\000\000\000\000\000\000\000\203\000\000\000\203\000\
\203\000\203\000\203\000\203\000\000\000\000\000\000\000\000\000\
\203\000\203\000\183\000\203\000\203\000\203\000\000\000\000\000\
\000\000\203\000\000\000\000\000\203\000\000\000\203\000\000\000\
\000\000\203\000\000\000\000\000\203\000\000\000\000\000\000\000\
\203\000\179\000\179\000\179\000\179\000\000\000\000\000\000\000\
\000\000\000\000\179\000\179\000\000\000\000\000\179\000\179\000\
\179\000\179\000\179\000\179\000\179\000\179\000\179\000\000\000\
\000\000\179\000\179\000\179\000\179\000\179\000\179\000\000\000\
\000\000\000\000\000\000\000\000\000\000\179\000\179\000\000\000\
\000\000\179\000\179\000\179\000\179\000\179\000\179\000\179\000\
\000\000\000\000\179\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\179\000\179\000\000\000\
\179\000\000\000\000\000\179\000\179\000\179\000\000\000\179\000\
\179\000\179\000\179\000\179\000\000\000\000\000\000\000\000\000\
\000\000\179\000\000\000\179\000\179\000\179\000\179\000\179\000\
\000\000\000\000\000\000\000\000\179\000\179\000\195\000\179\000\
\179\000\179\000\000\000\000\000\000\000\179\000\000\000\000\000\
\179\000\000\000\179\000\000\000\000\000\179\000\000\000\000\000\
\179\000\000\000\000\000\000\000\179\000\000\000\182\000\182\000\
\182\000\182\000\000\000\000\000\000\000\000\000\000\000\182\000\
\182\000\000\000\000\000\182\000\182\000\182\000\182\000\182\000\
\182\000\182\000\182\000\182\000\000\000\000\000\182\000\182\000\
\182\000\182\000\182\000\182\000\000\000\000\000\000\000\000\000\
\000\000\000\000\182\000\182\000\000\000\000\000\182\000\182\000\
\182\000\182\000\182\000\182\000\182\000\000\000\000\000\182\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\182\000\182\000\000\000\182\000\000\000\000\000\
\182\000\182\000\182\000\000\000\182\000\182\000\182\000\182\000\
\182\000\000\000\000\000\000\000\000\000\000\000\182\000\000\000\
\182\000\182\000\182\000\182\000\182\000\000\000\000\000\000\000\
\000\000\182\000\182\000\201\000\182\000\182\000\182\000\000\000\
\000\000\000\000\182\000\000\000\000\000\182\000\000\000\182\000\
\000\000\000\000\182\000\000\000\000\000\182\000\000\000\000\000\
\000\000\182\000\183\000\183\000\183\000\183\000\000\000\000\000\
\000\000\000\000\000\000\183\000\183\000\000\000\000\000\183\000\
\183\000\183\000\183\000\183\000\183\000\183\000\183\000\183\000\
\000\000\000\000\183\000\183\000\183\000\183\000\183\000\183\000\
\000\000\000\000\000\000\000\000\000\000\000\000\183\000\183\000\
\000\000\000\000\183\000\183\000\183\000\183\000\183\000\183\000\
\183\000\000\000\000\000\183\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\183\000\183\000\
\000\000\183\000\000\000\000\000\183\000\183\000\183\000\000\000\
\183\000\183\000\183\000\183\000\183\000\000\000\000\000\000\000\
\000\000\000\000\183\000\000\000\183\000\183\000\183\000\183\000\
\183\000\000\000\000\000\000\000\000\000\183\000\183\000\202\000\
\183\000\183\000\183\000\000\000\000\000\000\000\183\000\000\000\
\000\000\183\000\000\000\183\000\000\000\000\000\183\000\000\000\
\000\000\183\000\000\000\000\000\000\000\183\000\195\000\195\000\
\195\000\195\000\000\000\000\000\000\000\000\000\195\000\195\000\
\195\000\000\000\000\000\195\000\195\000\195\000\195\000\195\000\
\195\000\195\000\195\000\195\000\000\000\000\000\195\000\195\000\
\195\000\195\000\195\000\195\000\000\000\000\000\000\000\000\000\
\000\000\000\000\195\000\195\000\000\000\000\000\195\000\195\000\
\195\000\195\000\195\000\000\000\000\000\000\000\000\000\195\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\195\000\195\000\000\000\195\000\000\000\000\000\
\195\000\195\000\195\000\000\000\195\000\195\000\195\000\195\000\
\195\000\000\000\000\000\000\000\000\000\000\000\195\000\000\000\
\195\000\000\000\195\000\195\000\195\000\000\000\000\000\000\000\
\000\000\195\000\195\000\198\000\195\000\195\000\195\000\000\000\
\000\000\000\000\000\000\000\000\000\000\195\000\000\000\195\000\
\000\000\000\000\195\000\000\000\000\000\195\000\000\000\000\000\
\000\000\195\000\000\000\201\000\201\000\201\000\201\000\000\000\
\000\000\000\000\000\000\201\000\201\000\201\000\000\000\000\000\
\201\000\201\000\201\000\201\000\201\000\201\000\201\000\201\000\
\201\000\000\000\000\000\201\000\201\000\201\000\201\000\201\000\
\201\000\000\000\000\000\000\000\000\000\000\000\000\000\201\000\
\201\000\000\000\000\000\201\000\201\000\201\000\201\000\201\000\
\000\000\000\000\000\000\000\000\201\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\201\000\
\201\000\000\000\201\000\000\000\000\000\201\000\201\000\201\000\
\000\000\201\000\201\000\201\000\201\000\201\000\000\000\000\000\
\000\000\000\000\000\000\201\000\000\000\201\000\000\000\201\000\
\201\000\201\000\000\000\000\000\000\000\000\000\201\000\201\000\
\199\000\201\000\201\000\201\000\000\000\000\000\000\000\000\000\
\000\000\000\000\201\000\000\000\201\000\000\000\000\000\201\000\
\000\000\000\000\201\000\000\000\000\000\000\000\201\000\202\000\
\202\000\202\000\202\000\000\000\000\000\000\000\000\000\202\000\
\202\000\202\000\000\000\000\000\202\000\202\000\202\000\202\000\
\202\000\202\000\202\000\202\000\202\000\000\000\000\000\202\000\
\202\000\202\000\202\000\202\000\202\000\000\000\000\000\000\000\
\000\000\000\000\000\000\202\000\202\000\000\000\000\000\202\000\
\202\000\202\000\202\000\202\000\000\000\000\000\000\000\000\000\
\202\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\202\000\202\000\000\000\202\000\000\000\
\000\000\202\000\202\000\202\000\000\000\202\000\202\000\202\000\
\202\000\202\000\000\000\000\000\000\000\000\000\000\000\202\000\
\000\000\202\000\000\000\202\000\202\000\202\000\000\000\000\000\
\000\000\000\000\202\000\202\000\200\000\202\000\202\000\202\000\
\000\000\000\000\000\000\000\000\000\000\000\000\202\000\000\000\
\202\000\000\000\000\000\202\000\000\000\000\000\202\000\000\000\
\000\000\000\000\202\000\198\000\198\000\198\000\198\000\000\000\
\000\000\000\000\000\000\198\000\198\000\198\000\000\000\000\000\
\198\000\198\000\198\000\198\000\198\000\198\000\198\000\198\000\
\198\000\000\000\000\000\198\000\198\000\198\000\198\000\198\000\
\198\000\000\000\000\000\000\000\000\000\000\000\000\000\198\000\
\198\000\000\000\000\000\198\000\198\000\198\000\198\000\198\000\
\000\000\000\000\000\000\000\000\198\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\198\000\
\198\000\000\000\198\000\000\000\000\000\198\000\198\000\198\000\
\000\000\198\000\198\000\198\000\198\000\198\000\000\000\000\000\
\000\000\000\000\000\000\198\000\000\000\198\000\000\000\198\000\
\198\000\198\000\000\000\000\000\000\000\000\000\198\000\198\000\
\153\000\198\000\198\000\198\000\000\000\000\000\000\000\000\000\
\000\000\000\000\198\000\000\000\198\000\000\000\000\000\198\000\
\000\000\000\000\198\000\000\000\000\000\000\000\198\000\000\000\
\199\000\199\000\199\000\199\000\000\000\000\000\000\000\000\000\
\199\000\199\000\199\000\000\000\000\000\199\000\199\000\199\000\
\199\000\199\000\199\000\199\000\199\000\199\000\000\000\000\000\
\199\000\199\000\199\000\199\000\199\000\199\000\000\000\000\000\
\000\000\000\000\000\000\000\000\199\000\199\000\000\000\000\000\
\199\000\199\000\199\000\199\000\199\000\000\000\000\000\000\000\
\000\000\199\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\199\000\199\000\000\000\199\000\
\000\000\000\000\199\000\199\000\199\000\000\000\199\000\199\000\
\199\000\199\000\199\000\000\000\000\000\000\000\000\000\000\000\
\199\000\000\000\199\000\000\000\199\000\199\000\199\000\000\000\
\000\000\000\000\000\000\199\000\199\000\192\000\199\000\199\000\
\199\000\000\000\000\000\000\000\000\000\000\000\000\000\199\000\
\000\000\199\000\000\000\000\000\199\000\000\000\000\000\199\000\
\000\000\000\000\000\000\199\000\200\000\200\000\200\000\200\000\
\000\000\000\000\000\000\000\000\200\000\200\000\200\000\000\000\
\000\000\200\000\200\000\200\000\200\000\200\000\200\000\200\000\
\200\000\200\000\000\000\000\000\200\000\200\000\200\000\200\000\
\200\000\200\000\000\000\000\000\000\000\000\000\000\000\000\000\
\200\000\200\000\000\000\000\000\200\000\200\000\200\000\200\000\
\200\000\000\000\000\000\000\000\000\000\200\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\200\000\200\000\000\000\200\000\000\000\000\000\200\000\200\000\
\200\000\000\000\200\000\200\000\200\000\200\000\200\000\000\000\
\000\000\000\000\000\000\000\000\200\000\000\000\200\000\000\000\
\200\000\200\000\200\000\000\000\000\000\000\000\000\000\200\000\
\200\000\205\000\200\000\200\000\200\000\000\000\000\000\000\000\
\000\000\000\000\000\000\200\000\000\000\200\000\000\000\000\000\
\200\000\000\000\000\000\200\000\000\000\000\000\000\000\200\000\
\153\000\153\000\153\000\153\000\000\000\000\000\000\000\000\000\
\153\000\153\000\153\000\000\000\000\000\153\000\153\000\153\000\
\153\000\153\000\153\000\153\000\153\000\153\000\000\000\000\000\
\153\000\153\000\153\000\153\000\153\000\153\000\000\000\000\000\
\000\000\000\000\000\000\000\000\153\000\153\000\000\000\000\000\
\153\000\153\000\153\000\153\000\153\000\153\000\153\000\000\000\
\000\000\153\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\153\000\153\000\000\000\000\000\
\000\000\000\000\153\000\153\000\153\000\000\000\153\000\000\000\
\000\000\153\000\153\000\000\000\000\000\000\000\000\000\000\000\
\153\000\000\000\153\000\000\000\000\000\000\000\153\000\000\000\
\000\000\000\000\000\000\153\000\153\000\207\000\153\000\153\000\
\153\000\000\000\000\000\000\000\153\000\000\000\000\000\153\000\
\000\000\153\000\000\000\000\000\153\000\000\000\000\000\153\000\
\000\000\000\000\000\000\153\000\000\000\192\000\192\000\192\000\
\192\000\000\000\000\000\000\000\000\000\192\000\192\000\192\000\
\000\000\000\000\192\000\192\000\000\000\192\000\192\000\192\000\
\192\000\192\000\192\000\000\000\000\000\192\000\192\000\192\000\
\192\000\192\000\192\000\000\000\000\000\000\000\000\000\000\000\
\000\000\192\000\192\000\000\000\000\000\192\000\192\000\192\000\
\192\000\000\000\000\000\000\000\000\000\000\000\192\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\192\000\192\000\000\000\192\000\000\000\000\000\192\000\
\192\000\192\000\000\000\192\000\000\000\000\000\192\000\192\000\
\000\000\000\000\000\000\000\000\000\000\192\000\000\000\192\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\192\000\192\000\193\000\192\000\192\000\192\000\000\000\000\000\
\000\000\000\000\000\000\000\000\192\000\000\000\192\000\000\000\
\000\000\192\000\000\000\000\000\192\000\000\000\000\000\000\000\
\192\000\205\000\205\000\205\000\205\000\000\000\000\000\000\000\
\000\000\205\000\205\000\205\000\000\000\000\000\205\000\205\000\
\000\000\205\000\205\000\205\000\205\000\205\000\205\000\000\000\
\000\000\205\000\205\000\205\000\205\000\205\000\205\000\000\000\
\000\000\000\000\000\000\000\000\000\000\205\000\205\000\000\000\
\000\000\205\000\205\000\205\000\000\000\000\000\000\000\000\000\
\000\000\000\000\205\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\205\000\205\000\000\000\
\205\000\000\000\000\000\000\000\205\000\205\000\000\000\205\000\
\000\000\000\000\205\000\205\000\000\000\000\000\000\000\000\000\
\000\000\205\000\000\000\205\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\205\000\205\000\194\000\205\000\
\205\000\205\000\000\000\000\000\000\000\000\000\000\000\000\000\
\205\000\000\000\205\000\000\000\000\000\205\000\000\000\000\000\
\205\000\000\000\000\000\000\000\205\000\207\000\207\000\207\000\
\207\000\000\000\000\000\000\000\000\000\207\000\207\000\207\000\
\000\000\000\000\207\000\207\000\000\000\207\000\207\000\207\000\
\207\000\207\000\207\000\000\000\000\000\207\000\207\000\207\000\
\207\000\207\000\207\000\000\000\000\000\000\000\000\000\000\000\
\000\000\207\000\207\000\000\000\000\000\207\000\207\000\207\000\
\000\000\000\000\000\000\000\000\000\000\000\000\207\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\207\000\207\000\000\000\207\000\000\000\000\000\000\000\
\207\000\207\000\000\000\207\000\000\000\000\000\207\000\207\000\
\000\000\000\000\000\000\000\000\000\000\207\000\000\000\207\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\207\000\207\000\206\000\207\000\207\000\207\000\000\000\000\000\
\000\000\000\000\000\000\000\000\207\000\000\000\207\000\000\000\
\000\000\207\000\000\000\000\000\207\000\000\000\000\000\000\000\
\207\000\000\000\193\000\193\000\193\000\193\000\000\000\000\000\
\000\000\000\000\193\000\193\000\193\000\000\000\000\000\193\000\
\193\000\000\000\193\000\193\000\193\000\193\000\193\000\193\000\
\000\000\000\000\193\000\193\000\193\000\193\000\193\000\193\000\
\000\000\000\000\000\000\000\000\000\000\000\000\193\000\193\000\
\000\000\000\000\193\000\193\000\193\000\000\000\000\000\000\000\
\000\000\000\000\000\000\193\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\193\000\193\000\
\000\000\193\000\000\000\000\000\000\000\193\000\193\000\000\000\
\193\000\000\000\000\000\193\000\193\000\000\000\000\000\000\000\
\000\000\000\000\193\000\000\000\193\000\000\000\000\000\211\000\
\000\000\000\000\000\000\000\000\000\000\193\000\193\000\000\000\
\193\000\193\000\193\000\000\000\000\000\000\000\000\000\000\000\
\000\000\193\000\000\000\193\000\000\000\000\000\193\000\000\000\
\000\000\193\000\000\000\000\000\000\000\193\000\194\000\194\000\
\194\000\194\000\000\000\000\000\000\000\000\000\194\000\194\000\
\194\000\000\000\000\000\194\000\194\000\000\000\194\000\194\000\
\194\000\194\000\194\000\194\000\000\000\000\000\194\000\194\000\
\194\000\194\000\194\000\194\000\000\000\000\000\000\000\000\000\
\000\000\000\000\194\000\194\000\000\000\000\000\194\000\194\000\
\194\000\000\000\000\000\000\000\000\000\000\000\000\000\194\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\194\000\194\000\000\000\194\000\000\000\000\000\
\000\000\194\000\194\000\000\000\194\000\000\000\000\000\194\000\
\194\000\000\000\000\000\000\000\210\000\000\000\194\000\000\000\
\194\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\194\000\194\000\000\000\194\000\194\000\194\000\000\000\
\000\000\000\000\000\000\000\000\000\000\194\000\000\000\194\000\
\000\000\000\000\194\000\000\000\000\000\194\000\000\000\000\000\
\000\000\194\000\206\000\206\000\206\000\206\000\000\000\000\000\
\000\000\000\000\206\000\206\000\206\000\000\000\000\000\206\000\
\206\000\000\000\206\000\206\000\206\000\206\000\206\000\206\000\
\000\000\000\000\206\000\206\000\206\000\206\000\206\000\206\000\
\000\000\000\000\000\000\000\000\000\000\000\000\206\000\206\000\
\000\000\000\000\206\000\206\000\206\000\000\000\000\000\000\000\
\000\000\000\000\000\000\206\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\206\000\206\000\
\000\000\206\000\000\000\000\000\209\000\206\000\206\000\000\000\
\206\000\000\000\000\000\206\000\206\000\000\000\000\000\000\000\
\000\000\000\000\206\000\000\000\206\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\206\000\206\000\000\000\
\206\000\206\000\206\000\000\000\000\000\000\000\000\000\000\000\
\000\000\206\000\000\000\206\000\000\000\000\000\206\000\211\000\
\000\000\206\000\211\000\000\000\000\000\206\000\000\000\211\000\
\211\000\211\000\000\000\000\000\211\000\211\000\000\000\211\000\
\211\000\211\000\211\000\211\000\211\000\000\000\000\000\211\000\
\211\000\211\000\000\000\211\000\211\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\211\000\000\000\000\000\211\000\
\211\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\211\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\211\000\073\001\000\000\211\000\000\000\
\000\000\000\000\211\000\211\000\000\000\211\000\000\000\000\000\
\211\000\211\000\000\000\000\000\000\000\000\000\000\000\211\000\
\000\000\211\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\211\000\211\000\000\000\211\000\211\000\211\000\
\000\000\000\000\000\000\000\000\000\000\000\000\211\000\000\000\
\211\000\000\000\000\000\211\000\210\000\000\000\211\000\210\000\
\000\000\000\000\211\000\000\000\210\000\210\000\210\000\000\000\
\000\000\210\000\210\000\000\000\210\000\210\000\210\000\210\000\
\210\000\210\000\000\000\000\000\210\000\210\000\210\000\000\000\
\210\000\210\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\210\000\000\000\000\000\210\000\210\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\210\000\000\000\000\000\
\000\000\000\000\000\000\000\000\208\000\000\000\000\000\000\000\
\210\000\000\000\000\000\210\000\000\000\000\000\000\000\210\000\
\210\000\000\000\210\000\000\000\000\000\210\000\210\000\000\000\
\000\000\000\000\000\000\000\000\210\000\000\000\210\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\210\000\
\210\000\000\000\210\000\210\000\210\000\000\000\000\000\000\000\
\000\000\000\000\000\000\210\000\209\000\210\000\000\000\209\000\
\210\000\000\000\000\000\210\000\209\000\000\000\209\000\210\000\
\000\000\209\000\209\000\000\000\209\000\209\000\209\000\209\000\
\209\000\209\000\000\000\000\000\209\000\209\000\209\000\000\000\
\209\000\209\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\209\000\000\000\000\000\209\000\209\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\209\000\000\000\000\000\
\000\000\000\000\000\000\000\000\072\001\000\000\000\000\000\000\
\209\000\000\000\000\000\209\000\000\000\000\000\000\000\209\000\
\209\000\000\000\209\000\000\000\000\000\209\000\209\000\000\000\
\000\000\000\000\000\000\000\000\209\000\000\000\000\000\000\000\
\000\000\000\000\214\002\000\000\000\000\000\000\000\000\209\000\
\209\000\000\000\209\000\209\000\209\000\000\000\000\000\000\000\
\000\000\000\000\000\000\209\000\073\001\209\000\000\000\073\001\
\209\000\000\000\000\000\209\000\073\001\000\000\073\001\209\000\
\000\000\073\001\073\001\000\000\073\001\073\001\073\001\073\001\
\073\001\073\001\000\000\000\000\073\001\073\001\073\001\000\000\
\073\001\073\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\073\001\000\000\000\000\073\001\073\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\073\001\000\000\212\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\073\001\000\000\000\000\073\001\000\000\000\000\000\000\073\001\
\073\001\000\000\073\001\000\000\000\000\073\001\073\001\000\000\
\000\000\000\000\000\000\000\000\073\001\214\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\073\001\
\073\001\000\000\073\001\073\001\073\001\000\000\000\000\000\000\
\000\000\000\000\000\000\073\001\208\000\073\001\000\000\208\000\
\073\001\000\000\000\000\073\001\208\000\000\000\208\000\073\001\
\000\000\208\000\208\000\000\000\208\000\208\000\208\000\208\000\
\208\000\208\000\000\000\000\000\208\000\208\000\208\000\000\000\
\208\000\208\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\208\000\000\000\000\000\208\000\208\000\000\000\000\000\
\000\000\000\000\224\000\000\000\000\000\208\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\208\000\000\000\000\000\208\000\000\000\000\000\000\000\208\000\
\208\000\000\000\208\000\000\000\000\000\208\000\208\000\000\000\
\000\000\000\000\000\000\000\000\208\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\208\000\
\208\000\000\000\208\000\208\000\208\000\000\000\000\000\000\000\
\000\000\000\000\000\000\208\000\072\001\208\000\000\000\072\001\
\208\000\000\000\000\000\208\000\072\001\000\000\072\001\208\000\
\000\000\072\001\072\001\000\000\072\001\072\001\072\001\072\001\
\072\001\072\001\000\000\000\000\072\001\072\001\072\001\000\000\
\072\001\072\001\214\002\000\000\000\000\000\000\000\000\000\000\
\000\000\072\001\214\002\000\000\072\001\072\001\000\000\214\002\
\000\000\000\000\215\000\000\000\000\000\072\001\000\000\000\000\
\000\000\000\000\000\000\000\000\214\002\000\000\214\002\214\002\
\072\001\000\000\000\000\072\001\000\000\000\000\000\000\072\001\
\072\001\000\000\072\001\214\002\000\000\072\001\072\001\000\000\
\099\000\000\000\000\000\000\000\072\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\214\002\072\001\
\072\001\214\002\072\001\072\001\072\001\214\002\214\002\212\000\
\000\000\000\000\212\000\072\001\214\002\072\001\000\000\212\000\
\072\001\212\000\214\002\072\001\212\000\212\000\000\000\072\001\
\212\000\000\000\212\000\212\000\212\000\000\000\214\002\212\000\
\212\000\212\000\214\002\212\000\212\000\214\002\000\000\000\000\
\000\000\000\000\000\000\000\000\212\000\000\000\214\002\212\000\
\212\000\214\002\214\002\000\000\000\000\188\000\000\000\000\000\
\212\000\000\000\000\000\000\000\000\000\000\000\000\000\214\002\
\000\000\214\002\214\002\212\000\000\000\000\000\212\000\000\000\
\000\000\000\000\212\000\212\000\000\000\212\000\214\002\000\000\
\212\000\212\000\000\000\212\002\000\000\000\000\000\000\212\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\214\002\212\000\212\000\214\002\212\000\212\000\212\000\
\214\002\214\002\224\000\000\000\000\000\224\000\212\000\214\002\
\212\000\000\000\224\000\212\000\224\000\214\002\212\000\224\000\
\224\000\000\000\212\000\224\000\000\000\224\000\224\000\224\000\
\000\000\214\002\224\000\224\000\224\000\214\002\224\000\224\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\224\000\
\000\000\214\002\224\000\224\000\214\002\000\000\000\000\000\000\
\217\000\000\000\000\000\224\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\224\000\000\000\
\000\000\224\000\000\000\000\000\000\000\224\000\224\000\000\000\
\224\000\000\000\000\000\224\000\224\000\000\000\000\000\000\000\
\000\000\000\000\224\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\224\000\224\000\000\000\
\224\000\224\000\224\000\000\000\000\000\000\000\000\000\000\000\
\000\000\224\000\215\000\224\000\000\000\215\000\224\000\000\000\
\000\000\224\000\215\000\000\000\215\000\224\000\000\000\215\000\
\215\000\000\000\000\000\215\000\000\000\215\000\215\000\215\000\
\000\000\000\000\215\000\215\000\215\000\000\000\215\000\215\000\
\099\000\000\000\000\000\000\000\000\000\000\000\000\000\215\000\
\000\000\000\000\215\000\215\000\000\000\099\000\000\000\000\000\
\216\000\000\000\000\000\215\000\000\000\000\000\000\000\000\000\
\000\000\000\000\099\000\000\000\099\000\099\000\215\000\000\000\
\000\000\215\000\000\000\000\000\000\000\215\000\215\000\000\000\
\215\000\099\000\000\000\215\000\215\000\000\000\100\000\000\000\
\000\000\000\000\215\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\099\000\215\000\215\000\099\000\
\215\000\215\000\215\000\099\000\099\000\188\000\000\000\000\000\
\188\000\215\000\099\000\215\000\000\000\188\000\215\000\188\000\
\099\000\215\000\188\000\188\000\000\000\215\000\188\000\000\000\
\188\000\188\000\188\000\000\000\099\000\188\000\188\000\188\000\
\099\000\188\000\188\000\212\002\000\000\000\000\212\002\000\000\
\000\000\000\000\188\000\000\000\099\000\188\000\188\000\099\000\
\212\002\000\000\000\000\220\000\000\000\000\000\188\000\000\000\
\000\000\000\000\000\000\000\000\000\000\212\002\000\000\212\002\
\212\002\188\000\000\000\000\000\188\000\000\000\000\000\000\000\
\188\000\188\000\000\000\188\000\212\002\000\000\188\000\188\000\
\000\000\165\001\000\000\000\000\000\000\188\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\212\002\
\188\000\188\000\212\002\188\000\188\000\188\000\000\000\212\002\
\217\000\000\000\000\000\217\000\188\000\212\002\188\000\000\000\
\217\000\188\000\217\000\212\002\188\000\217\000\217\000\000\000\
\188\000\217\000\000\000\217\000\217\000\217\000\000\000\212\002\
\217\000\217\000\217\000\212\002\217\000\217\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\217\000\000\000\212\002\
\217\000\217\000\212\002\000\000\000\000\000\000\218\000\000\000\
\000\000\217\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\217\000\000\000\000\000\217\000\
\000\000\000\000\000\000\217\000\217\000\000\000\217\000\000\000\
\000\000\217\000\217\000\000\000\000\000\000\000\000\000\000\000\
\217\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\217\000\217\000\000\000\217\000\217\000\
\217\000\000\000\000\000\000\000\000\000\000\000\000\000\217\000\
\216\000\217\000\000\000\216\000\217\000\000\000\000\000\217\000\
\216\000\000\000\216\000\217\000\000\000\216\000\216\000\000\000\
\000\000\216\000\000\000\216\000\216\000\216\000\000\000\000\000\
\216\000\216\000\216\000\000\000\216\000\216\000\100\000\000\000\
\000\000\000\000\000\000\000\000\000\000\216\000\000\000\000\000\
\216\000\216\000\000\000\100\000\000\000\000\000\219\000\000\000\
\000\000\216\000\000\000\000\000\000\000\000\000\000\000\000\000\
\100\000\000\000\100\000\100\000\216\000\000\000\000\000\216\000\
\000\000\000\000\000\000\216\000\216\000\000\000\216\000\100\000\
\000\000\216\000\216\000\000\000\212\002\000\000\000\000\000\000\
\216\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\100\000\216\000\216\000\100\000\216\000\216\000\
\216\000\100\000\100\000\220\000\000\000\000\000\220\000\216\000\
\100\000\216\000\000\000\220\000\216\000\220\000\100\000\216\000\
\220\000\220\000\000\000\216\000\220\000\000\000\220\000\220\000\
\220\000\000\000\100\000\220\000\220\000\220\000\100\000\220\000\
\220\000\165\001\000\000\000\000\000\000\000\000\000\000\000\000\
\220\000\000\000\100\000\220\000\220\000\100\000\165\001\000\000\
\000\000\223\000\000\000\000\000\220\000\000\000\000\000\000\000\
\000\000\000\000\000\000\165\001\000\000\165\001\165\001\220\000\
\000\000\000\000\220\000\000\000\000\000\000\000\220\000\220\000\
\000\000\220\000\165\001\000\000\220\000\220\000\000\000\037\000\
\000\000\000\000\000\000\220\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\165\001\220\000\220\000\
\165\001\220\000\220\000\220\000\165\001\165\001\218\000\000\000\
\000\000\218\000\220\000\165\001\220\000\000\000\218\000\220\000\
\218\000\165\001\220\000\218\000\218\000\000\000\220\000\218\000\
\000\000\218\000\218\000\218\000\000\000\165\001\218\000\218\000\
\218\000\165\001\218\000\218\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\218\000\000\000\165\001\218\000\218\000\
\165\001\000\000\000\000\000\000\221\000\000\000\000\000\218\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\218\000\000\000\000\000\218\000\000\000\000\000\
\000\000\218\000\218\000\000\000\218\000\000\000\000\000\218\000\
\218\000\000\000\000\000\000\000\000\000\000\000\218\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\218\000\218\000\000\000\218\000\218\000\218\000\000\000\
\000\000\000\000\000\000\000\000\000\000\218\000\219\000\218\000\
\000\000\219\000\218\000\000\000\000\000\218\000\219\000\000\000\
\219\000\218\000\000\000\219\000\219\000\000\000\000\000\219\000\
\000\000\219\000\219\000\219\000\000\000\000\000\219\000\219\000\
\219\000\000\000\219\000\219\000\212\002\000\000\000\000\000\000\
\000\000\000\000\000\000\219\000\000\000\000\000\219\000\219\000\
\000\000\212\002\000\000\000\000\222\000\000\000\000\000\219\000\
\000\000\000\000\000\000\000\000\000\000\000\000\212\002\000\000\
\212\002\212\002\219\000\000\000\000\000\219\000\000\000\000\000\
\000\000\219\000\219\000\000\000\219\000\212\002\000\000\219\000\
\219\000\000\000\040\000\000\000\000\000\000\000\219\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\212\002\219\000\219\000\212\002\219\000\219\000\219\000\000\000\
\212\002\223\000\000\000\000\000\223\000\219\000\212\002\219\000\
\000\000\223\000\219\000\223\000\212\002\219\000\223\000\223\000\
\000\000\219\000\223\000\000\000\223\000\223\000\223\000\000\000\
\212\002\223\000\223\000\223\000\212\002\223\000\223\000\037\000\
\000\000\000\000\000\000\000\000\000\000\000\000\223\000\000\000\
\212\002\223\000\223\000\212\002\037\000\000\000\000\000\152\000\
\000\000\000\000\223\000\000\000\000\000\000\000\000\000\000\000\
\000\000\037\000\000\000\037\000\037\000\223\000\000\000\000\000\
\223\000\000\000\000\000\000\000\223\000\223\000\000\000\223\000\
\037\000\000\000\223\000\223\000\000\000\000\000\000\000\000\000\
\000\000\223\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\037\000\223\000\223\000\037\000\223\000\
\223\000\223\000\000\000\037\000\221\000\000\000\000\000\221\000\
\223\000\037\000\223\000\000\000\221\000\223\000\221\000\037\000\
\223\000\221\000\221\000\000\000\223\000\221\000\000\000\221\000\
\221\000\221\000\000\000\037\000\221\000\221\000\221\000\037\000\
\221\000\221\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\221\000\000\000\037\000\221\000\221\000\037\000\000\000\
\000\000\000\000\000\000\000\000\000\000\221\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\003\002\000\000\000\000\
\221\000\000\000\000\000\221\000\000\000\000\000\000\000\221\000\
\221\000\000\000\221\000\000\000\000\000\221\000\221\000\000\000\
\000\000\000\000\000\000\000\000\221\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\221\000\
\221\000\000\000\221\000\221\000\221\000\000\000\000\000\000\000\
\000\000\000\000\000\000\221\000\222\000\221\000\000\000\222\000\
\221\000\000\000\000\000\221\000\222\000\000\000\222\000\221\000\
\000\000\222\000\222\000\000\000\000\000\222\000\000\000\222\000\
\222\000\222\000\000\000\000\000\222\000\222\000\222\000\000\000\
\222\000\222\000\040\000\000\000\000\000\000\000\000\000\000\000\
\000\000\222\000\000\000\000\000\222\000\222\000\000\000\040\000\
\000\000\000\000\000\000\000\000\000\000\222\000\000\000\000\000\
\189\000\000\000\000\000\000\000\040\000\000\000\040\000\040\000\
\222\000\000\000\000\000\222\000\000\000\000\000\000\000\222\000\
\222\000\000\000\222\000\040\000\000\000\222\000\222\000\000\000\
\000\000\000\000\000\000\000\000\222\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\040\000\222\000\
\222\000\040\000\222\000\222\000\222\000\000\000\040\000\152\000\
\000\000\000\000\152\000\222\000\040\000\222\000\000\000\152\000\
\222\000\152\000\040\000\222\000\152\000\152\000\000\000\222\000\
\152\000\000\000\152\000\152\000\152\000\000\000\040\000\152\000\
\152\000\152\000\040\000\152\000\152\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\152\000\000\000\040\000\152\000\
\152\000\040\000\000\000\000\000\000\000\000\000\000\000\000\000\
\152\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\152\000\000\000\000\000\152\000\000\000\
\000\000\000\000\152\000\152\000\037\002\152\000\000\000\000\000\
\152\000\152\000\000\000\000\000\000\000\000\000\000\000\152\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\152\000\152\000\000\000\152\000\000\000\152\000\
\000\000\000\000\000\000\000\000\000\000\000\000\152\000\000\000\
\152\000\000\000\000\000\152\000\000\000\003\002\152\000\003\002\
\003\002\003\002\152\000\000\000\000\000\003\002\000\000\000\000\
\000\000\000\000\003\002\000\000\000\000\000\000\003\002\003\002\
\003\002\000\000\000\000\000\000\000\000\000\000\000\000\003\002\
\003\002\003\002\003\002\000\000\000\000\000\000\000\000\000\000\
\000\000\003\002\000\000\000\000\000\000\003\002\003\002\000\000\
\000\000\000\000\000\000\000\000\000\000\003\002\003\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\002\
\000\000\003\002\000\000\000\000\003\002\000\000\000\000\003\002\
\003\002\003\002\000\000\003\002\000\000\000\000\003\002\003\002\
\000\000\000\000\000\000\000\000\000\000\003\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\003\002\003\002\000\000\003\002\003\002\003\002\000\000\000\000\
\189\000\003\002\000\000\189\000\000\000\000\000\000\000\000\000\
\189\000\003\002\189\000\000\000\003\002\189\000\189\000\000\000\
\003\002\189\000\000\000\189\000\189\000\189\000\000\000\000\000\
\189\000\000\000\189\000\000\000\189\000\189\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\189\000\000\000\000\000\
\189\000\189\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\189\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\255\001\000\000\189\000\000\000\000\000\189\000\
\000\000\000\000\000\000\189\000\189\000\000\000\189\000\000\000\
\000\000\189\000\189\000\000\000\000\000\000\000\000\000\000\000\
\189\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\189\000\189\000\000\000\189\000\189\000\
\189\000\000\000\000\000\000\000\000\000\000\000\000\000\189\000\
\000\000\189\000\000\000\000\000\189\000\000\000\000\000\189\000\
\000\000\000\000\000\000\189\000\037\002\000\000\037\002\037\002\
\037\002\000\000\000\000\000\000\037\002\000\000\000\000\000\000\
\000\000\037\002\000\000\000\000\000\000\037\002\037\002\037\002\
\000\000\000\000\000\000\000\000\000\000\000\000\037\002\037\002\
\037\002\037\002\000\000\000\000\206\004\000\000\000\000\000\000\
\037\002\000\000\000\000\000\000\000\000\037\002\000\000\000\002\
\000\000\000\000\000\000\032\005\037\002\037\002\000\000\000\000\
\000\000\000\000\198\001\000\000\000\000\000\000\000\000\000\000\
\037\002\000\000\000\000\037\002\000\000\000\000\037\002\037\002\
\037\002\000\000\037\002\000\000\000\000\037\002\037\002\000\000\
\000\000\000\000\000\000\208\004\037\002\113\000\114\000\028\000\
\000\000\115\000\000\000\000\000\116\000\209\004\000\000\037\002\
\037\002\000\000\037\002\037\002\037\002\000\000\000\000\001\002\
\000\000\001\002\001\002\001\002\000\000\118\000\000\000\001\002\
\037\002\000\000\000\000\037\002\001\002\119\000\120\000\037\002\
\001\002\001\002\001\002\000\000\000\000\121\000\000\000\000\000\
\000\000\001\002\001\002\001\002\001\002\000\000\201\001\000\000\
\000\000\211\004\123\000\001\002\000\000\000\000\000\000\000\000\
\001\002\000\000\254\001\000\000\000\000\000\000\000\000\001\002\
\001\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\001\002\000\000\000\000\001\002\000\000\
\000\000\001\002\001\002\001\002\000\000\001\002\000\000\000\000\
\000\000\001\002\000\000\000\000\000\000\000\000\000\000\001\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\001\002\001\002\000\000\001\002\001\002\001\002\
\000\000\000\000\255\001\000\000\255\001\255\001\255\001\000\000\
\000\000\000\000\255\001\001\002\000\000\000\000\001\002\255\001\
\000\000\000\000\001\002\255\001\255\001\255\001\000\000\000\000\
\000\000\000\000\000\000\000\000\255\001\255\001\255\001\255\001\
\000\000\000\000\000\000\000\000\146\000\000\000\255\001\000\000\
\000\000\000\000\000\000\255\001\000\000\000\000\090\000\000\000\
\000\000\000\000\255\001\255\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\255\001\000\000\
\000\000\255\001\000\000\000\000\255\001\255\001\255\001\000\000\
\255\001\000\000\000\000\000\000\255\001\000\000\000\000\000\000\
\000\000\000\000\255\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\255\001\255\001\065\000\
\255\001\255\001\255\001\000\000\000\000\000\000\000\000\000\002\
\000\000\000\002\000\002\000\002\000\000\000\000\255\001\000\002\
\000\000\255\001\000\000\000\000\000\002\255\001\000\000\000\000\
\000\002\000\002\000\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\002\000\002\000\002\000\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\
\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\002\
\000\002\066\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\002\000\000\000\000\000\002\000\000\
\000\000\000\002\000\002\000\002\000\000\000\002\000\000\000\000\
\000\000\000\002\000\000\000\000\000\000\000\000\112\000\000\002\
\113\000\114\000\028\000\000\000\115\000\000\000\000\000\116\000\
\117\000\000\000\000\002\000\002\000\000\000\002\000\002\000\002\
\000\000\000\000\254\001\000\000\254\001\254\001\254\001\000\000\
\118\000\000\000\254\001\000\002\000\000\000\000\000\002\254\001\
\119\000\120\000\000\002\254\001\254\001\254\001\000\000\000\000\
\121\000\000\000\000\000\000\000\254\001\254\001\254\001\254\001\
\000\000\000\000\000\000\000\000\122\000\123\000\254\001\000\000\
\000\000\000\000\000\000\254\001\000\000\000\000\000\000\000\000\
\000\000\000\000\254\001\254\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\254\001\000\000\
\000\000\254\001\214\002\000\000\254\001\254\001\254\001\000\000\
\254\001\000\000\000\000\000\000\254\001\000\000\000\000\000\000\
\000\000\000\000\254\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\146\000\254\001\254\001\146\000\
\254\001\254\001\254\001\000\000\000\000\000\000\090\000\000\000\
\000\000\146\000\000\000\000\000\000\000\146\000\254\001\146\000\
\000\000\254\001\000\000\090\000\000\000\254\001\146\000\146\000\
\146\000\146\000\000\000\000\000\000\000\000\000\000\000\000\000\
\090\000\000\000\090\000\090\000\000\000\146\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\090\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\065\000\
\146\000\000\000\000\000\146\000\000\000\000\000\000\000\146\000\
\146\000\000\000\090\000\000\000\065\000\146\000\146\000\000\000\
\065\000\090\000\090\000\000\000\146\000\000\000\000\000\000\000\
\090\000\065\000\065\000\065\000\065\000\106\002\090\000\000\000\
\146\000\000\000\146\000\000\000\146\000\000\000\000\000\000\000\
\065\000\000\000\090\000\000\000\000\000\000\000\090\000\000\000\
\146\000\000\000\000\000\146\000\000\000\000\000\000\000\146\000\
\000\000\066\000\090\000\065\000\066\000\090\000\065\000\000\000\
\000\000\065\000\065\000\065\000\000\000\000\000\066\000\000\000\
\065\000\065\000\066\000\000\000\000\000\000\000\000\000\065\000\
\000\000\000\000\000\000\066\000\066\000\066\000\066\000\000\000\
\000\000\000\000\000\000\065\000\000\000\065\000\000\000\065\000\
\000\000\000\000\066\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\065\000\000\000\000\000\065\000\000\000\
\000\000\000\000\065\000\000\000\000\000\066\000\000\000\000\000\
\066\000\000\000\000\000\000\000\066\000\066\000\000\000\000\000\
\000\000\000\000\066\000\066\000\112\000\000\000\113\000\114\000\
\028\000\066\000\115\000\000\000\120\001\116\000\117\000\000\000\
\000\000\000\000\000\000\000\000\000\000\066\000\000\000\066\000\
\000\000\066\000\000\000\000\000\000\000\000\000\118\000\000\000\
\000\000\000\000\000\000\000\000\000\000\066\000\119\000\060\003\
\066\000\000\000\214\002\000\000\066\000\214\002\121\000\214\002\
\214\002\214\002\214\002\000\000\000\000\214\002\214\002\214\002\
\000\000\000\000\122\000\123\000\000\000\214\002\000\000\000\000\
\000\000\214\002\000\000\000\000\214\002\000\000\214\002\214\002\
\214\002\214\002\214\002\214\002\214\002\214\002\214\002\000\000\
\000\000\214\002\214\002\214\002\000\000\000\000\098\002\000\000\
\000\000\000\000\214\002\214\002\214\002\214\002\214\002\214\002\
\214\002\214\002\214\002\214\002\214\002\214\002\214\002\214\002\
\000\000\214\002\214\002\214\002\000\000\214\002\214\002\214\002\
\214\002\214\002\214\002\000\000\214\002\214\002\000\000\214\002\
\214\002\000\000\214\002\214\002\000\000\000\000\214\002\214\002\
\000\000\214\002\214\002\214\002\214\002\214\002\214\002\214\002\
\000\000\214\002\214\002\214\002\000\000\214\002\000\000\214\002\
\214\002\000\000\214\002\000\000\214\002\214\002\214\002\214\002\
\214\002\214\002\214\002\212\001\214\002\106\002\000\000\000\000\
\000\000\106\002\000\000\106\002\000\000\106\002\000\000\106\002\
\000\000\106\002\000\000\106\002\106\002\000\000\106\002\106\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\106\002\106\002\000\000\106\002\106\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\106\002\
\106\002\106\002\106\002\000\000\106\002\106\002\000\000\000\000\
\106\002\213\001\000\000\000\000\000\000\106\002\106\002\106\002\
\000\000\000\000\000\000\000\000\106\002\000\000\106\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\106\002\000\000\
\000\000\106\002\000\000\000\000\000\000\000\000\106\002\000\000\
\106\002\106\002\000\000\106\002\106\002\000\000\106\002\000\000\
\000\000\000\000\106\002\000\000\000\000\106\002\000\000\106\002\
\000\000\000\000\106\002\106\002\120\001\000\000\106\002\000\000\
\120\001\000\000\120\001\212\002\120\001\000\000\120\001\000\000\
\120\001\000\000\120\001\120\001\000\000\120\001\120\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\120\001\
\000\000\000\000\120\001\120\001\000\000\000\000\000\000\000\000\
\000\000\064\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\120\001\120\001\
\000\000\120\001\000\000\120\001\120\001\000\000\000\000\120\001\
\000\000\000\000\000\000\000\000\120\001\120\001\120\001\000\000\
\000\000\000\000\000\000\120\001\000\000\120\001\098\002\000\000\
\000\000\098\002\000\000\000\000\000\000\120\001\098\002\000\000\
\120\001\000\000\000\000\098\002\098\002\120\001\000\000\120\001\
\120\001\098\002\120\001\120\001\119\002\120\001\000\000\000\000\
\098\002\120\001\098\002\098\002\120\001\000\000\120\001\000\000\
\000\000\120\001\120\001\000\000\000\000\120\001\000\000\098\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\031\002\
\209\001\031\002\031\002\031\002\000\000\031\002\000\000\000\000\
\031\002\031\002\098\002\000\000\000\000\098\002\000\000\119\002\
\098\002\098\002\098\002\212\001\000\000\000\000\212\001\000\000\
\098\002\031\002\000\000\212\001\000\000\098\002\098\002\000\000\
\212\001\031\002\031\002\000\000\000\000\000\000\212\001\000\000\
\000\000\031\002\098\002\000\000\000\000\212\001\098\002\212\001\
\212\001\000\000\000\000\000\000\000\000\031\002\031\002\000\000\
\063\000\000\000\098\002\212\001\212\001\098\002\214\002\000\000\
\214\002\214\002\214\002\000\000\214\002\000\000\000\000\214\002\
\214\002\000\000\000\000\000\000\000\000\000\000\000\000\212\001\
\000\000\213\001\212\001\000\000\213\001\212\001\212\001\212\001\
\214\002\213\001\000\000\000\000\040\002\212\001\213\001\000\000\
\214\002\214\002\000\000\212\001\213\001\000\000\000\000\000\000\
\214\002\000\000\000\000\213\001\000\000\213\001\213\001\212\001\
\131\000\000\000\000\000\212\001\214\002\214\002\000\000\040\002\
\000\000\213\001\213\001\000\000\000\000\000\000\000\000\212\001\
\000\000\000\000\212\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\212\002\000\000\213\001\212\002\000\000\
\213\001\000\000\000\000\213\001\213\001\213\001\000\000\000\000\
\212\002\000\000\213\001\213\001\000\000\000\000\212\002\000\000\
\000\000\213\001\000\000\000\000\000\000\212\002\000\000\212\002\
\212\002\064\000\174\001\000\000\064\000\213\001\000\000\000\000\
\000\000\213\001\000\000\212\002\212\002\000\000\064\000\000\000\
\000\000\000\000\064\000\212\002\212\002\213\001\000\000\000\000\
\213\001\000\000\000\000\064\000\064\000\064\000\064\000\212\002\
\000\000\000\000\212\002\000\000\000\000\000\000\000\000\212\002\
\000\000\212\002\064\000\000\000\000\000\212\002\000\000\000\000\
\000\000\000\000\241\001\212\002\241\001\241\001\241\001\000\000\
\241\001\000\000\214\002\241\001\241\001\064\000\000\000\212\002\
\064\000\000\000\000\000\212\002\064\000\064\000\000\000\000\000\
\000\000\000\000\008\000\064\000\241\001\000\000\000\000\212\002\
\011\000\064\000\212\002\000\000\241\001\241\001\000\000\000\000\
\209\001\000\000\000\000\209\001\241\001\064\000\000\000\064\000\
\209\001\064\000\015\000\016\000\000\000\209\001\000\000\000\000\
\241\001\241\001\000\000\209\001\000\000\064\000\000\000\174\001\
\064\000\000\000\209\001\000\000\209\001\209\001\022\000\000\000\
\138\000\139\000\000\000\140\000\141\000\000\000\000\000\028\000\
\000\000\209\001\000\000\000\000\142\000\143\000\000\000\000\000\
\000\000\000\000\000\000\144\000\000\000\000\000\000\000\000\000\
\063\000\000\000\000\000\063\000\209\001\000\000\000\000\209\001\
\145\000\000\000\209\001\209\001\209\001\063\000\000\000\000\000\
\000\000\063\000\209\001\000\000\175\001\146\000\000\000\000\000\
\209\001\044\000\063\000\063\000\063\000\063\000\045\000\000\000\
\000\000\048\000\147\000\000\000\209\001\000\000\000\000\000\000\
\209\001\063\000\000\000\209\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\209\001\000\000\000\000\209\001\
\131\000\000\000\000\000\131\000\063\000\000\000\000\000\063\000\
\000\000\000\000\000\000\063\000\063\000\131\000\000\000\000\000\
\000\000\177\001\063\000\131\000\000\000\000\000\000\000\000\000\
\063\000\000\000\131\000\000\000\131\000\131\000\000\000\000\000\
\000\000\000\000\000\000\000\000\063\000\000\000\063\000\000\000\
\063\000\131\000\000\000\000\000\000\000\000\000\000\000\000\000\
\131\000\000\000\000\000\000\000\063\000\000\000\000\000\063\000\
\000\000\000\000\174\001\000\000\131\000\174\001\000\000\131\000\
\000\000\000\000\000\000\131\000\131\000\000\000\131\000\174\001\
\000\000\176\001\131\000\000\000\000\000\174\001\000\000\000\000\
\131\000\000\000\000\000\000\000\174\001\000\000\174\001\174\001\
\000\000\000\000\000\000\000\000\131\000\000\000\000\000\000\000\
\131\000\000\000\000\000\174\001\000\000\000\000\000\000\178\001\
\000\000\000\000\000\000\000\000\131\000\000\000\000\000\131\000\
\000\000\000\000\214\002\000\000\000\000\214\002\174\001\000\000\
\000\000\174\001\214\002\000\000\000\000\174\001\174\001\214\002\
\000\000\000\000\000\000\000\000\174\001\214\002\000\000\000\000\
\000\000\000\000\174\001\000\000\214\002\000\000\214\002\214\002\
\115\002\000\000\000\000\000\000\000\000\000\000\174\001\000\000\
\000\000\000\000\174\001\214\002\000\000\000\000\000\000\182\001\
\000\000\000\000\000\000\000\000\000\000\000\000\174\001\174\001\
\000\000\174\001\174\001\000\000\000\000\000\000\214\002\000\000\
\209\001\214\002\000\000\000\000\174\001\214\002\214\002\000\000\
\000\000\000\000\174\001\000\000\214\002\000\000\000\000\000\000\
\000\000\174\001\214\002\174\001\174\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\214\002\000\000\
\174\001\000\000\214\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\175\001\000\000\214\002\175\001\
\000\000\214\002\000\000\174\001\000\000\000\000\174\001\000\000\
\044\000\175\001\174\001\174\001\000\000\000\000\000\000\175\001\
\000\000\174\001\000\000\209\001\000\000\000\000\175\001\174\001\
\175\001\175\001\000\000\209\001\000\000\047\000\000\000\000\000\
\209\001\000\000\000\000\174\001\000\000\175\001\085\000\174\001\
\000\000\000\000\000\000\000\000\000\000\209\001\000\000\209\001\
\209\001\177\001\000\000\174\001\177\001\000\000\174\001\000\000\
\175\001\000\000\000\000\175\001\209\001\000\000\177\001\175\001\
\175\001\000\000\000\000\000\000\177\001\000\000\175\001\000\000\
\000\000\212\002\000\000\177\001\175\001\177\001\177\001\209\001\
\000\000\000\000\209\001\000\000\000\000\209\001\209\001\209\001\
\175\001\000\000\177\001\000\000\175\001\209\001\081\000\000\000\
\000\000\000\000\000\000\209\001\000\000\000\000\000\000\000\000\
\175\001\176\001\000\000\175\001\176\001\177\001\000\000\209\001\
\177\001\000\000\000\000\209\001\177\001\177\001\176\001\000\000\
\000\000\000\000\000\000\177\001\176\001\000\000\000\000\209\001\
\000\000\177\001\209\001\176\001\000\000\176\001\176\001\178\001\
\000\000\000\000\178\001\000\000\000\000\177\001\000\000\000\000\
\000\000\177\001\176\001\000\000\178\001\000\000\000\000\000\000\
\000\000\000\000\178\001\000\000\000\000\177\001\000\000\000\000\
\177\001\178\001\000\000\178\001\178\001\176\001\000\000\000\000\
\176\001\000\000\000\000\000\000\176\001\176\001\000\000\000\000\
\178\001\000\000\000\000\176\001\000\000\000\000\000\000\000\000\
\000\000\176\001\000\000\000\000\000\000\000\000\000\000\182\001\
\000\000\000\000\182\001\178\001\000\000\176\001\178\001\000\000\
\000\000\176\001\178\001\178\001\182\001\000\000\000\000\000\000\
\209\001\178\001\182\001\000\000\000\000\176\001\000\000\178\001\
\176\001\182\001\000\000\182\001\182\001\209\001\000\000\000\000\
\000\000\000\000\000\000\178\001\000\000\000\000\000\000\178\001\
\182\001\000\000\209\001\000\000\209\001\209\001\000\000\000\000\
\000\000\000\000\000\000\178\001\000\000\000\000\178\001\000\000\
\000\000\209\001\000\000\182\001\000\000\000\000\182\001\000\000\
\000\000\000\000\182\001\182\001\000\000\000\000\000\000\000\000\
\044\000\182\001\000\000\000\000\209\001\000\000\000\000\182\001\
\000\000\000\000\209\001\209\001\209\001\044\000\000\000\000\000\
\000\000\000\000\209\001\182\001\000\000\047\000\000\000\182\001\
\209\001\000\000\044\000\000\000\044\000\044\000\085\000\000\000\
\000\000\000\000\047\000\182\001\209\001\000\000\182\001\000\000\
\209\001\044\000\000\000\085\000\000\000\000\000\000\000\047\000\
\000\000\047\000\047\000\000\000\209\001\000\000\000\000\209\001\
\085\000\000\000\085\000\085\000\044\000\000\000\047\000\044\000\
\000\000\212\002\000\000\000\000\044\000\000\000\000\000\085\000\
\000\000\000\000\044\000\000\000\000\000\000\000\212\002\000\000\
\044\000\047\000\000\000\000\000\047\000\000\000\081\000\000\000\
\000\000\047\000\085\000\212\002\044\000\212\002\212\002\047\000\
\044\000\000\000\085\000\081\000\000\000\047\000\000\000\000\000\
\085\000\000\000\212\002\000\000\044\000\000\000\085\000\044\000\
\081\000\047\000\081\000\081\000\000\000\047\000\000\000\000\000\
\000\000\000\000\085\000\000\000\000\000\212\002\085\000\081\000\
\000\000\047\000\000\000\000\000\047\000\212\002\000\000\000\000\
\000\000\000\000\085\000\212\002\000\000\085\000\000\000\000\000\
\000\000\212\002\081\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\081\000\000\000\000\000\212\002\000\000\000\000\
\081\000\212\002\000\000\000\000\000\000\000\000\081\000\000\000\
\000\000\000\000\000\000\000\000\000\000\212\002\000\000\000\000\
\212\002\000\000\081\000\207\002\000\000\000\000\081\000\000\000\
\207\002\207\002\207\002\207\002\000\000\000\000\207\002\207\002\
\207\002\207\002\081\000\000\000\000\000\081\000\207\002\000\000\
\000\000\000\000\000\000\000\000\000\000\207\002\000\000\207\002\
\207\002\207\002\207\002\207\002\207\002\207\002\207\002\000\000\
\000\000\000\000\207\002\000\000\207\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\207\002\207\002\207\002\207\002\
\207\002\207\002\207\002\207\002\000\000\000\000\207\002\207\002\
\000\000\000\000\207\002\207\002\207\002\207\002\000\000\207\002\
\207\002\207\002\207\002\207\002\000\000\207\002\000\000\000\000\
\207\002\207\002\000\000\207\002\207\002\000\000\000\000\207\002\
\207\002\000\000\207\002\000\000\207\002\207\002\000\000\207\002\
\207\002\000\000\000\000\207\002\207\002\000\000\207\002\000\000\
\207\002\207\002\000\000\207\002\000\000\207\002\207\002\207\002\
\207\002\207\002\207\002\207\002\214\002\207\002\000\000\000\000\
\000\000\214\002\214\002\214\002\214\002\000\000\000\000\214\002\
\214\002\000\000\000\000\000\000\000\000\000\000\000\000\214\002\
\000\000\000\000\000\000\000\000\000\000\000\000\214\002\000\000\
\214\002\000\000\214\002\214\002\214\002\214\002\214\002\214\002\
\000\000\000\000\000\000\214\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\214\002\214\002\214\002\
\214\002\214\002\214\002\214\002\214\002\000\000\000\000\214\002\
\214\002\000\000\000\000\214\002\214\002\214\002\000\000\000\000\
\214\002\214\002\214\002\214\002\214\002\000\000\214\002\000\000\
\000\000\214\002\214\002\000\000\000\000\214\002\000\000\000\000\
\214\002\214\002\000\000\214\002\000\000\214\002\214\002\000\000\
\000\000\214\002\000\000\000\000\000\000\214\002\000\000\214\002\
\000\000\214\002\214\002\000\000\214\002\000\000\214\002\214\002\
\000\000\214\002\214\002\214\002\214\002\000\000\214\002\001\001\
\002\001\003\001\000\000\000\000\007\000\008\000\004\001\000\000\
\005\001\000\000\010\000\011\000\000\000\000\000\006\001\007\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\008\001\000\000\000\000\015\000\016\000\017\000\
\018\000\019\000\000\000\009\001\000\000\000\000\020\000\000\000\
\000\000\010\001\011\001\012\001\013\001\014\001\015\001\000\000\
\000\000\022\000\000\000\023\000\024\000\025\000\026\000\027\000\
\000\000\000\000\028\000\000\000\016\001\000\000\030\000\031\000\
\032\000\000\000\000\000\000\000\034\000\000\000\017\001\018\001\
\000\000\019\001\000\000\000\000\000\000\038\000\000\000\000\000\
\000\000\020\001\021\001\022\001\023\001\024\001\025\001\000\000\
\000\000\000\000\000\000\000\000\000\000\026\001\000\000\000\000\
\000\000\027\001\000\000\028\001\044\000\000\000\000\000\000\000\
\000\000\045\000\046\000\000\000\048\000\049\000\001\001\002\001\
\003\001\051\000\000\000\007\000\008\000\004\001\000\000\005\001\
\000\000\010\000\011\000\000\000\000\000\018\003\007\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\008\001\000\000\000\000\015\000\016\000\017\000\018\000\
\019\000\000\000\009\001\000\000\000\000\020\000\000\000\000\000\
\010\001\011\001\012\001\013\001\014\001\015\001\000\000\000\000\
\022\000\000\000\023\000\024\000\025\000\026\000\027\000\000\000\
\000\000\028\000\000\000\016\001\000\000\030\000\031\000\032\000\
\000\000\000\000\000\000\034\000\000\000\017\001\018\001\000\000\
\019\003\000\000\000\000\000\000\038\000\000\000\000\000\000\000\
\020\001\021\001\022\001\023\001\024\001\025\001\000\000\000\000\
\000\000\000\000\000\000\000\000\020\003\000\000\000\000\000\000\
\027\001\000\000\028\001\044\000\000\000\000\000\000\000\000\000\
\045\000\046\000\000\000\048\000\049\000\214\002\000\000\000\000\
\051\000\000\000\214\002\214\002\214\002\000\000\000\000\000\000\
\214\002\214\002\214\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\214\002\
\000\000\214\002\214\002\214\002\214\002\214\002\214\002\214\002\
\000\000\000\000\000\000\000\000\214\002\000\000\214\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\214\002\
\000\000\214\002\214\002\214\002\214\002\214\002\000\000\000\000\
\214\002\214\002\000\000\000\000\214\002\214\002\214\002\000\000\
\000\000\214\002\214\002\000\000\214\002\214\002\000\000\214\002\
\000\000\000\000\000\000\214\002\000\000\214\002\000\000\000\000\
\000\000\214\002\214\002\085\002\214\002\000\000\000\000\000\000\
\152\002\152\002\152\002\000\000\000\000\214\002\152\002\152\002\
\000\000\000\000\214\002\000\000\000\000\000\000\000\000\214\002\
\214\002\214\002\214\002\214\002\214\002\000\000\000\000\214\002\
\000\000\152\002\152\002\152\002\152\002\152\002\000\000\000\000\
\000\000\000\000\152\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\152\002\000\000\152\002\
\152\002\152\002\152\002\152\002\000\000\000\000\152\002\000\000\
\000\000\000\000\152\002\152\002\152\002\000\000\000\000\000\000\
\152\002\000\000\152\002\152\002\000\000\000\000\000\000\000\000\
\000\000\152\002\000\000\000\000\000\000\000\000\000\000\152\002\
\152\002\086\002\152\002\000\000\000\000\000\000\153\002\153\002\
\153\002\085\002\000\000\000\000\153\002\153\002\000\000\000\000\
\152\002\000\000\000\000\000\000\000\000\152\002\152\002\000\000\
\152\002\152\002\000\000\000\000\000\000\152\002\000\000\153\002\
\153\002\153\002\153\002\153\002\000\000\000\000\000\000\000\000\
\153\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\153\002\000\000\153\002\153\002\153\002\
\153\002\153\002\000\000\000\000\153\002\000\000\000\000\000\000\
\153\002\153\002\153\002\000\000\000\000\000\000\153\002\000\000\
\153\002\153\002\000\000\000\000\000\000\000\000\000\000\153\002\
\000\000\000\000\000\000\000\000\000\000\153\002\153\002\083\002\
\153\002\000\000\000\000\000\000\154\002\154\002\154\002\086\002\
\000\000\000\000\154\002\154\002\000\000\000\000\153\002\000\000\
\000\000\000\000\000\000\153\002\153\002\000\000\153\002\153\002\
\000\000\000\000\000\000\153\002\000\000\154\002\154\002\154\002\
\154\002\154\002\000\000\000\000\000\000\000\000\154\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\154\002\000\000\154\002\154\002\154\002\154\002\154\002\
\000\000\000\000\154\002\000\000\000\000\000\000\154\002\154\002\
\154\002\000\000\000\000\000\000\154\002\000\000\154\002\154\002\
\000\000\000\000\000\000\000\000\000\000\154\002\000\000\000\000\
\000\000\000\000\000\000\154\002\154\002\084\002\154\002\000\000\
\000\000\000\000\155\002\155\002\155\002\083\002\000\000\000\000\
\155\002\155\002\000\000\000\000\154\002\000\000\000\000\000\000\
\000\000\154\002\154\002\000\000\154\002\154\002\000\000\000\000\
\000\000\154\002\000\000\155\002\155\002\155\002\155\002\155\002\
\000\000\000\000\000\000\000\000\155\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\155\002\
\000\000\155\002\155\002\155\002\155\002\155\002\000\000\000\000\
\155\002\000\000\000\000\000\000\155\002\155\002\155\002\000\000\
\000\000\000\000\155\002\000\000\155\002\155\002\000\000\000\000\
\000\000\000\000\000\000\155\002\000\000\000\000\000\000\000\000\
\000\000\155\002\155\002\000\000\155\002\000\000\000\000\000\000\
\000\000\000\000\000\000\084\002\199\000\200\000\201\000\000\000\
\000\000\000\000\155\002\000\000\202\000\000\000\203\000\155\002\
\155\002\000\000\155\002\155\002\204\000\205\000\206\000\155\002\
\000\000\207\000\208\000\209\000\000\000\210\000\211\000\212\000\
\000\000\213\000\214\000\215\000\216\000\000\000\000\000\000\000\
\217\000\218\000\219\000\000\000\000\000\000\000\000\000\000\000\
\000\000\220\000\221\000\000\000\000\000\222\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\223\000\224\000\000\000\000\000\000\000\004\002\225\000\226\000\
\000\000\004\002\000\000\227\000\228\000\229\000\230\000\231\000\
\232\000\233\000\000\000\234\000\000\000\000\000\004\002\000\000\
\004\002\235\000\000\000\243\001\000\000\000\000\236\000\004\002\
\004\002\000\000\000\000\000\000\237\000\000\000\000\000\238\000\
\239\000\004\002\240\000\241\000\242\000\243\000\244\000\000\000\
\245\000\246\000\247\000\248\000\249\000\004\002\004\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\004\002\000\000\000\000\000\000\004\002\000\000\004\002\
\004\002\004\002\000\000\004\002\000\000\000\000\004\002\000\000\
\000\000\000\000\001\001\002\001\003\001\000\000\000\000\000\000\
\008\000\164\001\000\000\005\001\000\000\000\000\011\000\243\001\
\004\002\006\001\007\001\000\000\004\002\000\000\004\002\000\000\
\000\000\004\002\000\000\000\000\000\000\008\001\137\000\000\000\
\015\000\016\000\004\002\000\000\004\002\000\000\009\001\000\000\
\000\000\000\000\000\000\000\000\010\001\011\001\012\001\013\001\
\014\001\015\001\000\000\000\000\022\000\000\000\138\000\139\000\
\000\000\140\000\141\000\000\000\000\000\028\000\000\000\016\001\
\000\000\000\000\142\000\143\000\000\000\000\000\000\000\000\000\
\000\000\165\001\166\001\000\000\167\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\020\001\021\001\168\001\169\001\
\024\001\170\001\000\000\000\000\000\000\000\000\000\000\000\000\
\026\001\000\000\000\000\146\000\027\001\000\000\028\001\044\000\
\000\000\000\000\000\000\000\000\045\000\000\000\179\002\048\000\
\147\000\001\001\002\001\003\001\000\000\000\000\000\000\008\000\
\164\001\000\000\005\001\000\000\000\000\011\000\000\000\000\000\
\006\001\007\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\008\001\137\000\000\000\015\000\
\016\000\000\000\000\000\000\000\000\000\009\001\000\000\000\000\
\000\000\000\000\000\000\010\001\011\001\012\001\013\001\014\001\
\015\001\000\000\000\000\022\000\000\000\138\000\139\000\000\000\
\140\000\141\000\000\000\000\000\028\000\000\000\016\001\000\000\
\000\000\142\000\143\000\000\000\000\000\000\000\000\000\000\000\
\165\001\166\001\000\000\167\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\020\001\021\001\168\001\169\001\024\001\
\170\001\000\000\000\000\000\000\000\000\000\000\000\000\026\001\
\000\000\000\000\146\000\027\001\000\000\028\001\044\000\000\000\
\000\000\000\000\000\000\045\000\000\000\124\003\048\000\147\000\
\001\001\002\001\003\001\000\000\000\000\000\000\008\000\164\001\
\000\000\005\001\000\000\000\000\011\000\000\000\000\000\006\001\
\007\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\008\001\137\000\000\000\015\000\016\000\
\000\000\000\000\000\000\000\000\009\001\000\000\000\000\000\000\
\000\000\000\000\010\001\011\001\012\001\013\001\014\001\015\001\
\000\000\000\000\022\000\000\000\138\000\139\000\000\000\140\000\
\141\000\000\000\000\000\028\000\000\000\016\001\000\000\000\000\
\142\000\143\000\000\000\000\000\000\000\000\000\000\000\165\001\
\166\001\000\000\167\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\020\001\021\001\168\001\169\001\024\001\170\001\
\000\000\000\000\000\000\000\000\000\000\000\000\026\001\000\000\
\000\000\146\000\027\001\000\000\028\001\044\000\000\000\000\000\
\000\000\000\000\045\000\000\000\073\004\048\000\147\000\001\001\
\002\001\003\001\000\000\000\000\000\000\008\000\164\001\000\000\
\005\001\000\000\000\000\011\000\000\000\000\000\006\001\007\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\008\001\137\000\000\000\015\000\016\000\000\000\
\000\000\000\000\000\000\009\001\000\000\000\000\000\000\000\000\
\000\000\010\001\011\001\012\001\013\001\014\001\015\001\000\000\
\000\000\022\000\000\000\138\000\139\000\000\000\140\000\141\000\
\000\000\000\000\028\000\000\000\016\001\000\000\000\000\142\000\
\143\000\000\000\000\000\000\000\000\000\000\000\165\001\166\001\
\000\000\167\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\020\001\021\001\168\001\169\001\024\001\170\001\000\000\
\000\000\091\003\000\000\000\000\000\000\026\001\000\000\008\000\
\146\000\027\001\000\000\028\001\044\000\011\000\000\000\000\000\
\018\003\045\000\000\000\000\000\048\000\147\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\137\000\000\000\015\000\
\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\022\000\000\000\138\000\139\000\000\000\
\140\000\141\000\000\000\000\000\028\000\000\000\143\002\000\000\
\000\000\142\000\143\000\000\000\008\000\000\000\000\000\000\000\
\144\000\000\000\011\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\145\000\000\000\000\000\
\000\000\000\000\137\000\000\000\015\000\016\000\000\000\092\003\
\000\000\000\000\146\000\000\000\000\000\000\000\044\000\000\000\
\000\000\000\000\000\000\045\000\000\000\000\000\048\000\147\000\
\022\000\000\000\138\000\139\000\000\000\140\000\141\000\000\000\
\000\000\028\000\000\000\145\002\000\000\000\000\142\000\143\000\
\000\000\008\000\000\000\000\000\000\000\144\000\000\000\011\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\145\000\000\000\000\000\000\000\000\000\137\000\
\000\000\015\000\016\000\000\000\000\000\000\000\000\000\146\000\
\000\000\000\000\000\000\044\000\000\000\000\000\000\000\000\000\
\045\000\000\000\000\000\048\000\147\000\022\000\000\000\138\000\
\139\000\000\000\140\000\141\000\000\000\000\000\028\000\000\000\
\080\004\000\000\000\000\142\000\143\000\000\000\008\000\000\000\
\000\000\000\000\144\000\000\000\011\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\145\000\
\000\000\000\000\000\000\000\000\137\000\000\000\015\000\016\000\
\000\000\000\000\000\000\000\000\146\000\000\000\000\000\000\000\
\044\000\000\000\000\000\000\000\000\000\045\000\000\000\000\000\
\048\000\147\000\022\000\000\000\138\000\139\000\000\000\140\000\
\141\000\000\000\000\000\028\000\000\000\082\004\000\000\000\000\
\142\000\143\000\000\000\008\000\000\000\000\000\000\000\144\000\
\000\000\011\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\145\000\000\000\000\000\000\000\
\000\000\137\000\000\000\015\000\016\000\000\000\000\000\000\000\
\000\000\146\000\000\000\000\000\000\000\044\000\000\000\000\000\
\000\000\000\000\045\000\000\000\000\000\048\000\147\000\022\000\
\000\000\138\000\139\000\000\000\140\000\141\000\000\000\000\000\
\028\000\000\000\084\004\000\000\000\000\142\000\143\000\000\000\
\008\000\000\000\000\000\000\000\144\000\000\000\011\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\145\000\000\000\000\000\000\000\000\000\137\000\000\000\
\015\000\016\000\000\000\000\000\000\000\000\000\146\000\000\000\
\000\000\000\000\044\000\000\000\000\000\000\000\000\000\045\000\
\000\000\000\000\048\000\147\000\022\000\000\000\138\000\139\000\
\000\000\140\000\141\000\000\000\000\000\028\000\000\000\000\000\
\000\000\000\000\142\000\143\000\007\000\008\000\009\000\000\000\
\000\000\144\000\010\000\011\000\012\000\243\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\145\000\000\000\
\000\000\000\000\000\000\013\000\014\000\015\000\016\000\017\000\
\018\000\019\000\000\000\146\000\000\000\000\000\020\000\044\000\
\021\000\000\000\000\000\000\000\045\000\000\000\000\000\048\000\
\147\000\022\000\000\000\023\000\024\000\025\000\026\000\027\000\
\000\000\000\000\028\000\029\000\000\000\000\000\030\000\031\000\
\032\000\000\000\000\000\033\000\034\000\000\000\035\000\036\000\
\000\000\037\000\000\000\000\000\000\000\038\000\000\000\039\000\
\000\000\000\000\000\000\040\000\041\000\000\000\042\000\000\000\
\244\001\000\000\000\000\007\000\008\000\009\000\000\000\043\000\
\000\000\010\000\011\000\012\000\044\000\000\000\000\000\000\000\
\000\000\045\000\046\000\047\000\048\000\049\000\050\000\000\000\
\000\000\051\000\013\000\014\000\015\000\016\000\017\000\018\000\
\019\000\000\000\000\000\000\000\000\000\020\000\000\000\021\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\022\000\000\000\023\000\024\000\025\000\026\000\027\000\000\000\
\000\000\028\000\029\000\000\000\000\000\030\000\031\000\032\000\
\000\000\000\000\033\000\034\000\000\000\035\000\036\000\000\000\
\037\000\000\000\000\000\000\000\038\000\000\000\039\000\000\000\
\000\000\000\000\040\000\041\000\000\000\042\000\000\000\000\000\
\000\000\007\000\008\000\009\000\000\000\000\000\043\000\010\000\
\011\000\000\000\000\000\044\000\000\000\000\000\000\000\000\000\
\045\000\046\000\047\000\048\000\049\000\050\000\000\000\000\000\
\051\000\000\000\015\000\016\000\017\000\018\000\019\000\000\000\
\000\000\000\000\000\000\020\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\022\000\000\000\
\023\000\024\000\025\000\026\000\027\000\000\000\000\000\028\000\
\000\000\000\000\000\000\030\000\031\000\032\000\000\000\000\000\
\000\000\034\000\000\000\035\000\036\000\000\000\000\000\000\000\
\000\000\000\000\038\000\000\000\000\000\000\000\000\000\000\000\
\040\000\041\000\000\000\042\000\000\000\000\000\000\000\000\000\
\194\000\007\000\008\000\009\000\000\000\000\000\197\000\010\000\
\011\000\044\000\000\000\000\000\000\000\000\000\045\000\046\000\
\000\000\048\000\049\000\000\000\000\000\000\000\051\000\000\000\
\000\000\000\000\015\000\016\000\017\000\018\000\019\000\000\000\
\000\000\000\000\000\000\020\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\022\000\000\000\
\023\000\024\000\025\000\026\000\027\000\000\000\000\000\028\000\
\000\000\000\000\000\000\030\000\031\000\032\000\000\000\000\000\
\000\000\034\000\000\000\035\000\036\000\000\000\000\000\000\000\
\000\000\000\000\038\000\000\000\000\000\000\000\000\000\000\000\
\040\000\041\000\000\000\042\000\000\000\000\000\007\000\008\000\
\009\000\000\000\000\000\000\000\010\000\011\000\000\000\000\000\
\000\000\044\000\000\000\000\000\000\000\000\000\045\000\046\000\
\000\000\048\000\049\000\195\001\000\000\000\000\051\000\015\000\
\016\000\017\000\018\000\019\000\000\000\000\000\000\000\000\000\
\020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\022\000\000\000\023\000\024\000\025\000\
\026\000\027\000\000\000\000\000\028\000\000\000\000\000\000\000\
\030\000\031\000\032\000\000\000\000\000\000\000\034\000\000\000\
\035\000\036\000\000\000\000\000\000\000\000\000\000\000\038\000\
\000\000\000\000\000\000\000\000\000\000\040\000\041\000\000\000\
\042\000\000\000\000\000\007\000\008\000\009\000\000\000\000\000\
\000\000\010\000\011\000\000\000\000\000\000\000\044\000\000\000\
\000\000\000\000\000\000\045\000\046\000\000\000\048\000\049\000\
\000\000\000\000\000\000\051\000\015\000\016\000\017\000\018\000\
\019\000\000\000\000\000\000\000\000\000\020\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\022\000\000\000\023\000\024\000\025\000\026\000\027\000\000\000\
\000\000\028\000\000\000\000\000\000\000\030\000\031\000\032\000\
\000\000\000\000\000\000\034\000\000\000\035\000\036\000\000\000\
\000\000\000\000\000\000\000\000\038\000\000\000\000\000\000\000\
\000\000\054\002\040\000\041\000\000\000\042\000\000\000\000\000\
\007\000\008\000\009\000\000\000\000\000\000\000\010\000\011\000\
\000\000\000\000\000\000\044\000\000\000\000\000\000\000\000\000\
\045\000\046\000\000\000\048\000\049\000\000\000\000\000\000\000\
\051\000\015\000\016\000\017\000\018\000\019\000\000\000\000\000\
\000\000\000\000\020\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\022\000\000\000\023\000\
\024\000\025\000\026\000\027\000\000\000\000\000\028\000\000\000\
\000\000\000\000\030\000\031\000\032\000\000\000\000\000\000\000\
\034\000\000\000\035\000\036\000\000\000\000\000\000\000\000\000\
\000\000\038\000\000\000\000\000\000\000\000\000\000\000\040\000\
\041\000\000\000\042\000\000\000\000\000\000\000\000\000\014\003\
\007\000\008\000\009\000\000\000\000\000\016\003\010\000\011\000\
\044\000\000\000\000\000\000\000\000\000\045\000\046\000\000\000\
\048\000\049\000\000\000\000\000\000\000\051\000\000\000\000\000\
\000\000\015\000\016\000\017\000\018\000\019\000\000\000\000\000\
\000\000\000\000\020\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\022\000\000\000\023\000\
\024\000\025\000\026\000\027\000\000\000\000\000\028\000\000\000\
\000\000\000\000\030\000\031\000\032\000\000\000\000\000\000\000\
\034\000\000\000\035\000\036\000\000\000\000\000\000\000\000\000\
\000\000\038\000\000\000\000\000\000\000\000\000\000\000\040\000\
\041\000\000\000\042\000\000\000\000\000\000\000\007\000\008\000\
\009\000\000\000\000\000\000\000\010\000\011\000\000\000\000\000\
\044\000\000\000\000\000\000\000\000\000\045\000\046\000\053\004\
\048\000\049\000\000\000\000\000\000\000\051\000\000\000\015\000\
\016\000\017\000\018\000\019\000\000\000\000\000\000\000\000\000\
\020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\022\000\000\000\023\000\024\000\025\000\
\026\000\027\000\000\000\000\000\028\000\000\000\000\000\000\000\
\030\000\031\000\032\000\000\000\000\000\000\000\034\000\000\000\
\035\000\036\000\000\000\000\000\000\000\000\000\000\000\038\000\
\000\000\000\000\000\000\000\000\000\000\040\000\041\000\000\000\
\042\000\000\000\000\000\216\002\216\002\216\002\000\000\000\000\
\000\000\216\002\216\002\000\000\000\000\000\000\044\000\000\000\
\000\000\000\000\000\000\045\000\046\000\000\000\048\000\049\000\
\216\002\000\000\000\000\051\000\216\002\216\002\216\002\216\002\
\216\002\000\000\000\000\000\000\000\000\216\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\216\002\000\000\216\002\216\002\216\002\216\002\216\002\000\000\
\000\000\216\002\000\000\000\000\000\000\216\002\216\002\216\002\
\000\000\000\000\000\000\216\002\000\000\216\002\216\002\000\000\
\000\000\000\000\000\000\000\000\216\002\000\000\000\000\000\000\
\000\000\000\000\216\002\216\002\000\000\216\002\000\000\000\000\
\007\000\008\000\009\000\000\000\000\000\000\000\010\000\011\000\
\000\000\000\000\000\000\216\002\000\000\000\000\000\000\000\000\
\216\002\216\002\000\000\216\002\216\002\000\000\000\000\000\000\
\216\002\015\000\016\000\017\000\018\000\019\000\000\000\000\000\
\000\000\000\000\020\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\022\000\000\000\023\000\
\024\000\025\000\026\000\027\000\000\000\000\000\028\000\000\000\
\000\000\000\000\030\000\031\000\032\000\000\000\000\000\000\000\
\034\000\000\000\035\000\036\000\000\000\000\000\000\000\000\000\
\000\000\038\000\000\000\000\000\000\000\000\000\000\000\040\000\
\041\000\000\000\042\000\000\000\000\000\216\002\216\002\216\002\
\000\000\000\000\000\000\216\002\216\002\000\000\000\000\000\000\
\044\000\000\000\000\000\000\000\000\000\045\000\046\000\000\000\
\048\000\049\000\000\000\000\000\000\000\051\000\216\002\216\002\
\216\002\216\002\216\002\000\000\000\000\000\000\000\000\216\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\216\002\000\000\216\002\216\002\216\002\216\002\
\216\002\000\000\000\000\216\002\000\000\000\000\000\000\216\002\
\216\002\216\002\000\000\000\000\000\000\216\002\000\000\216\002\
\216\002\000\000\000\000\000\000\000\000\000\000\216\002\000\000\
\000\000\000\000\000\000\000\000\216\002\216\002\000\000\216\002\
\000\000\000\000\214\002\214\002\214\002\000\000\000\000\000\000\
\214\002\214\002\000\000\000\000\000\000\216\002\000\000\000\000\
\000\000\000\000\216\002\216\002\000\000\216\002\216\002\000\000\
\000\000\000\000\216\002\214\002\214\002\214\002\214\002\214\002\
\000\000\000\000\000\000\000\000\214\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\214\002\
\000\000\214\002\214\002\214\002\214\002\214\002\000\000\000\000\
\214\002\000\000\000\000\000\000\214\002\214\002\214\002\000\000\
\000\000\008\000\214\002\000\000\214\002\214\002\000\000\011\000\
\000\000\147\003\000\000\214\002\229\001\000\000\000\000\000\000\
\000\000\214\002\214\002\000\000\214\002\000\000\148\003\000\000\
\000\000\015\000\016\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\214\002\000\000\000\000\000\000\000\000\214\002\
\214\002\000\000\214\002\214\002\000\000\022\000\207\001\214\002\
\139\000\000\000\140\000\141\000\000\000\000\000\028\000\000\000\
\000\000\000\000\000\000\142\000\149\003\000\000\008\000\000\000\
\000\000\000\000\144\000\000\000\011\000\000\000\228\001\000\000\
\000\000\229\001\000\000\000\000\209\001\000\000\000\000\145\000\
\000\000\000\000\000\000\148\003\210\001\000\000\015\000\016\000\
\000\000\008\000\000\000\000\000\146\000\000\000\000\000\011\000\
\044\000\189\002\000\000\211\001\000\000\045\000\000\000\000\000\
\048\000\147\000\022\000\207\001\000\000\139\000\000\000\140\000\
\141\000\015\000\016\000\028\000\000\000\000\000\000\000\000\000\
\142\000\149\003\000\000\000\000\000\000\000\000\000\000\144\000\
\000\000\000\000\000\000\000\000\000\000\022\000\207\001\000\000\
\139\000\209\001\140\000\141\000\145\000\000\000\028\000\000\000\
\000\000\210\001\000\000\142\000\190\002\000\000\000\000\000\000\
\000\000\146\000\144\000\000\000\191\002\044\000\000\000\000\000\
\211\001\000\000\045\000\000\000\209\001\048\000\147\000\145\000\
\000\000\000\000\008\000\000\000\210\001\000\000\000\000\000\000\
\011\000\000\000\124\005\000\000\146\000\000\000\000\000\000\000\
\044\000\000\000\000\000\211\001\000\000\045\000\000\000\148\003\
\048\000\147\000\015\000\016\000\000\000\008\000\000\000\000\000\
\000\000\000\000\000\000\011\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\022\000\207\001\
\000\000\139\000\000\000\140\000\141\000\015\000\016\000\028\000\
\000\000\000\000\000\000\000\000\142\000\149\003\000\000\000\000\
\000\000\000\000\000\000\144\000\000\000\000\000\000\000\000\000\
\000\000\022\000\207\001\000\000\139\000\209\001\140\000\141\000\
\145\000\000\000\028\000\000\000\000\000\210\001\000\000\142\000\
\208\001\000\000\216\002\000\000\000\000\146\000\144\000\000\000\
\216\002\044\000\000\000\000\000\211\001\000\000\045\000\000\000\
\209\001\048\000\147\000\145\000\000\000\000\000\000\000\000\000\
\210\001\000\000\216\002\216\002\000\000\000\000\000\000\000\000\
\146\000\000\000\000\000\000\000\044\000\000\000\000\000\211\001\
\000\000\045\000\000\000\000\000\048\000\147\000\216\002\216\002\
\000\000\216\002\000\000\216\002\216\002\000\000\000\000\216\002\
\000\000\000\000\000\000\000\000\216\002\216\002\000\000\000\000\
\008\000\000\000\000\000\216\002\000\000\000\000\011\000\000\000\
\000\000\000\000\000\000\000\000\000\000\216\002\000\000\000\000\
\216\002\000\000\000\000\000\000\000\000\216\002\137\000\000\000\
\015\000\016\000\000\000\000\000\000\000\216\002\000\000\000\000\
\000\000\216\002\000\000\000\000\216\002\000\000\216\002\000\000\
\000\000\216\002\216\002\000\000\022\000\000\000\138\000\139\000\
\000\000\140\000\141\000\000\000\000\000\028\000\000\000\000\000\
\000\000\000\000\142\000\143\000\000\000\000\000\000\000\008\000\
\000\000\144\000\000\000\162\001\000\000\011\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\145\000\000\000\
\000\000\000\000\000\000\000\000\000\000\137\000\194\000\015\000\
\016\000\000\000\000\000\146\000\000\000\000\000\000\000\044\000\
\000\000\000\000\000\000\000\000\045\000\000\000\000\000\048\000\
\147\000\000\000\000\000\022\000\000\000\138\000\139\000\000\000\
\140\000\141\000\000\000\000\000\028\000\000\000\000\000\000\000\
\000\000\142\000\143\000\000\000\008\000\000\000\000\000\000\000\
\144\000\000\000\011\000\000\000\000\000\000\000\000\000\000\000\
\000\000\008\000\009\000\000\000\000\000\145\000\010\000\011\000\
\000\000\000\000\137\000\000\000\015\000\016\000\000\000\000\000\
\000\000\000\000\146\000\000\000\000\000\000\000\044\000\000\000\
\000\000\015\000\016\000\045\000\000\000\000\000\048\000\147\000\
\022\000\000\000\138\000\139\000\000\000\140\000\141\000\000\000\
\000\000\028\000\000\000\000\000\000\000\022\000\142\000\143\000\
\024\000\025\000\026\000\027\000\000\000\144\000\028\000\000\000\
\216\002\000\000\216\002\182\000\032\000\000\000\216\002\000\000\
\000\000\000\000\145\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\090\003\000\000\000\000\000\000\216\002\146\000\
\216\002\216\002\042\000\044\000\000\000\000\000\000\000\000\000\
\045\000\000\000\000\000\048\000\147\000\000\000\000\000\000\000\
\044\000\000\000\000\000\000\000\216\002\045\000\216\002\216\002\
\048\000\216\002\216\002\000\000\000\000\216\002\000\000\000\000\
\000\000\000\000\216\002\216\002\000\000\008\000\000\000\000\000\
\000\000\216\002\000\000\011\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\216\002\000\000\
\000\000\000\000\000\000\137\000\000\000\015\000\016\000\000\000\
\000\000\000\000\000\000\216\002\000\000\000\000\000\000\216\002\
\000\000\000\000\000\000\000\000\216\002\000\000\000\000\216\002\
\216\002\022\000\000\000\138\000\139\000\000\000\140\000\141\000\
\000\000\000\000\028\000\000\000\000\000\000\000\000\000\142\000\
\143\000\000\000\216\002\000\000\000\000\000\000\144\000\000\000\
\216\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\145\000\000\000\000\000\000\000\000\000\
\216\002\000\000\216\002\216\002\000\000\216\002\000\000\000\000\
\146\000\000\000\000\000\216\002\044\000\000\000\000\000\000\000\
\000\000\045\000\000\000\000\000\048\000\147\000\216\002\000\000\
\216\002\216\002\000\000\216\002\216\002\216\002\216\002\216\002\
\000\000\000\000\000\000\000\000\216\002\216\002\000\000\000\000\
\000\000\000\000\000\000\216\002\000\000\000\000\000\000\000\000\
\000\000\216\002\000\000\216\002\216\002\000\000\216\002\216\002\
\216\002\000\000\216\002\000\000\000\000\000\000\000\000\216\002\
\216\002\000\000\148\002\000\000\000\000\216\002\216\002\000\000\
\148\002\216\002\000\000\000\000\000\000\000\000\216\002\000\000\
\000\000\216\002\216\002\216\002\000\000\000\000\000\000\000\000\
\148\002\000\000\148\002\148\002\216\002\129\002\000\000\000\000\
\216\002\000\000\000\000\129\002\216\002\000\000\000\000\000\000\
\000\000\216\002\000\000\000\000\216\002\216\002\148\002\000\000\
\148\002\148\002\000\000\148\002\148\002\129\002\129\002\148\002\
\000\000\000\000\000\000\000\000\148\002\148\002\000\000\000\000\
\000\000\000\000\000\000\148\002\000\000\000\000\000\000\000\000\
\000\000\129\002\000\000\129\002\129\002\000\000\129\002\129\002\
\148\002\000\000\129\002\000\000\000\000\000\000\000\000\129\002\
\129\002\000\000\214\002\000\000\000\000\148\002\129\002\000\000\
\214\002\148\002\000\000\000\000\000\000\000\000\148\002\000\000\
\000\000\148\002\148\002\129\002\000\000\000\000\000\000\000\000\
\000\000\000\000\214\002\214\002\000\000\008\000\000\000\000\000\
\129\002\000\000\000\000\011\000\129\002\000\000\000\000\000\000\
\000\000\129\002\000\000\000\000\129\002\129\002\214\002\000\000\
\214\002\214\002\000\000\214\002\214\002\015\000\016\000\214\002\
\000\000\000\000\000\000\000\000\214\002\214\002\000\000\000\000\
\000\000\000\000\000\000\214\002\000\000\000\000\000\000\000\000\
\000\000\022\000\000\000\000\000\139\000\000\000\140\000\141\000\
\214\002\000\000\028\000\000\000\000\000\000\000\000\000\142\000\
\143\000\000\000\216\002\000\000\000\000\214\002\144\000\000\000\
\216\002\214\002\000\000\000\000\000\000\000\000\214\002\000\000\
\000\000\214\002\214\002\145\000\000\000\000\000\000\000\000\000\
\000\000\000\000\216\002\216\002\000\000\000\000\000\000\000\000\
\146\000\000\000\000\000\000\000\044\000\000\000\000\000\000\000\
\000\000\045\000\000\000\000\000\048\000\147\000\216\002\000\000\
\000\000\216\002\000\000\216\002\216\002\000\000\000\000\216\002\
\000\000\000\000\000\000\000\000\216\002\216\002\000\000\008\000\
\009\000\000\000\000\000\216\002\010\000\011\000\008\000\009\000\
\000\000\000\000\000\000\010\000\011\000\000\000\000\000\087\001\
\216\002\000\000\000\000\000\000\000\000\000\000\000\000\015\000\
\016\000\000\000\000\000\000\000\000\000\216\002\015\000\016\000\
\000\000\216\002\000\000\000\000\000\000\000\000\216\002\000\000\
\088\001\216\002\216\002\022\000\089\001\000\000\024\000\025\000\
\026\000\027\000\022\000\089\001\028\000\024\000\025\000\026\000\
\027\000\142\000\032\000\028\000\000\000\000\000\000\000\000\000\
\142\000\032\000\000\000\000\000\000\000\000\000\000\000\216\002\
\216\002\000\000\090\001\000\000\216\002\216\002\000\000\000\000\
\042\000\090\001\091\001\000\000\000\000\000\000\000\000\042\000\
\000\000\091\001\092\001\093\001\000\000\000\000\044\000\216\002\
\216\002\094\001\000\000\045\000\000\000\044\000\048\000\000\000\
\094\001\000\000\045\000\000\000\000\000\048\000\000\000\000\000\
\000\000\000\000\000\000\216\002\000\000\000\000\216\002\216\002\
\216\002\216\002\000\000\000\000\216\002\000\000\000\000\000\000\
\000\000\216\002\216\002\000\000\000\000\180\004\049\001\050\001\
\000\000\000\000\000\000\000\000\000\000\000\000\051\001\000\000\
\000\000\000\000\000\000\181\004\052\001\053\001\182\004\054\001\
\216\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\055\001\000\000\000\000\000\000\000\000\000\000\216\002\000\000\
\000\000\056\001\000\000\216\002\000\000\000\000\216\002\057\001\
\058\001\059\001\060\001\061\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\062\001\000\000\167\002\000\000\000\000\162\000\
\000\000\000\000\000\000\000\000\063\001\064\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\065\001\
\066\001\067\001\068\001\069\001\000\000\001\001\002\001\003\001\
\000\000\000\000\000\000\183\004\164\001\000\000\005\001\000\000\
\000\000\071\001\000\000\000\000\112\000\007\001\113\000\114\000\
\028\000\000\000\115\000\000\000\000\000\116\000\117\000\000\000\
\008\001\000\000\000\000\000\000\000\000\000\000\000\000\134\001\
\000\000\009\001\000\000\000\000\000\000\000\000\118\000\010\001\
\011\001\012\001\013\001\014\001\015\001\000\000\119\000\120\000\
\000\000\000\000\000\000\168\002\000\000\000\000\121\000\000\000\
\000\000\000\000\016\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\122\000\123\000\173\002\166\001\000\000\174\002\
\000\000\000\000\000\000\000\000\224\003\049\001\050\001\020\001\
\021\001\175\002\169\001\024\001\170\001\051\001\000\000\000\000\
\000\000\000\000\000\000\052\001\053\001\000\000\054\001\027\001\
\000\000\028\001\000\000\000\000\000\000\000\000\000\000\055\001\
\000\000\000\000\000\000\000\000\226\003\049\001\050\001\000\000\
\056\001\000\000\000\000\000\000\000\000\051\001\057\001\058\001\
\059\001\060\001\061\001\052\001\053\001\000\000\054\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\055\001\
\000\000\062\001\000\000\000\000\000\000\000\000\162\000\000\000\
\056\001\000\000\000\000\063\001\064\001\000\000\057\001\058\001\
\059\001\060\001\061\001\000\000\000\000\000\000\065\001\066\001\
\067\001\068\001\069\001\000\000\000\000\000\000\000\000\225\003\
\000\000\062\001\000\000\000\000\000\000\000\000\162\000\000\000\
\071\001\000\000\000\000\063\001\064\001\000\000\000\000\000\000\
\000\000\000\000\228\003\049\001\050\001\000\000\065\001\066\001\
\067\001\068\001\069\001\051\001\000\000\000\000\000\000\000\000\
\227\003\052\001\053\001\000\000\054\001\000\000\000\000\000\000\
\071\001\000\000\000\000\000\000\000\000\055\001\000\000\000\000\
\000\000\000\000\224\003\049\001\050\001\000\000\056\001\000\000\
\000\000\000\000\000\000\051\001\057\001\058\001\059\001\060\001\
\061\001\052\001\053\001\000\000\054\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\055\001\000\000\062\001\
\000\000\000\000\000\000\000\000\162\000\000\000\056\001\000\000\
\000\000\063\001\064\001\000\000\057\001\058\001\059\001\060\001\
\061\001\000\000\000\000\000\000\065\001\066\001\067\001\068\001\
\069\001\000\000\000\000\000\000\000\000\000\000\000\000\062\001\
\229\003\000\000\000\000\000\000\162\000\000\000\071\001\000\000\
\000\000\063\001\064\001\000\000\000\000\000\000\000\000\000\000\
\226\003\049\001\050\001\000\000\065\001\066\001\067\001\068\001\
\069\001\051\001\000\000\000\000\000\000\023\004\000\000\052\001\
\053\001\000\000\054\001\000\000\000\000\000\000\071\001\000\000\
\000\000\000\000\000\000\055\001\000\000\000\000\000\000\000\000\
\228\003\049\001\050\001\000\000\056\001\000\000\000\000\000\000\
\000\000\051\001\057\001\058\001\059\001\060\001\061\001\052\001\
\053\001\000\000\054\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\055\001\000\000\062\001\000\000\000\000\
\000\000\000\000\162\000\000\000\056\001\000\000\000\000\063\001\
\064\001\000\000\057\001\058\001\059\001\060\001\061\001\000\000\
\000\000\000\000\065\001\066\001\067\001\068\001\069\001\000\000\
\000\000\000\000\000\000\000\000\024\004\062\001\000\000\000\000\
\000\000\000\000\162\000\000\000\071\001\000\000\000\000\063\001\
\064\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\065\001\066\001\067\001\068\001\069\001\226\004\
\049\001\050\001\000\000\000\000\000\000\000\000\025\004\000\000\
\051\001\000\000\000\000\000\000\071\001\000\000\052\001\053\001\
\000\000\054\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\055\001\000\000\000\000\000\000\000\000\228\004\
\049\001\050\001\000\000\056\001\000\000\000\000\000\000\000\000\
\051\001\057\001\058\001\059\001\060\001\061\001\052\001\053\001\
\000\000\054\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\055\001\000\000\062\001\000\000\000\000\000\000\
\000\000\162\000\000\000\056\001\000\000\000\000\063\001\064\001\
\000\000\057\001\058\001\059\001\060\001\061\001\000\000\000\000\
\000\000\065\001\066\001\067\001\068\001\069\001\000\000\000\000\
\000\000\000\000\227\004\000\000\062\001\000\000\000\000\000\000\
\000\000\162\000\000\000\071\001\000\000\000\000\063\001\064\001\
\000\000\000\000\000\000\000\000\000\000\230\004\049\001\050\001\
\000\000\065\001\066\001\067\001\068\001\069\001\051\001\000\000\
\000\000\000\000\000\000\229\004\052\001\053\001\000\000\054\001\
\000\000\000\000\000\000\071\001\000\000\000\000\000\000\000\000\
\055\001\000\000\000\000\000\000\000\000\226\004\049\001\050\001\
\000\000\056\001\000\000\000\000\000\000\000\000\051\001\057\001\
\058\001\059\001\060\001\061\001\052\001\053\001\000\000\054\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\055\001\000\000\062\001\000\000\000\000\000\000\000\000\162\000\
\000\000\056\001\000\000\000\000\063\001\064\001\000\000\057\001\
\058\001\059\001\060\001\061\001\000\000\000\000\000\000\065\001\
\066\001\067\001\068\001\069\001\000\000\000\000\000\000\000\000\
\000\000\000\000\062\001\231\004\000\000\000\000\000\000\162\000\
\000\000\071\001\000\000\000\000\063\001\064\001\000\000\000\000\
\000\000\000\000\000\000\228\004\049\001\050\001\000\000\065\001\
\066\001\067\001\068\001\069\001\051\001\000\000\000\000\000\000\
\249\004\000\000\052\001\053\001\000\000\054\001\000\000\000\000\
\000\000\071\001\000\000\000\000\000\000\000\000\055\001\000\000\
\000\000\000\000\000\000\230\004\049\001\050\001\000\000\056\001\
\000\000\000\000\000\000\000\000\051\001\057\001\058\001\059\001\
\060\001\061\001\052\001\053\001\000\000\054\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\055\001\000\000\
\062\001\000\000\000\000\000\000\000\000\162\000\000\000\056\001\
\000\000\000\000\063\001\064\001\000\000\057\001\058\001\059\001\
\060\001\061\001\000\000\000\000\000\000\065\001\066\001\067\001\
\068\001\069\001\000\000\000\000\000\000\000\000\000\000\250\004\
\062\001\049\001\050\001\000\000\000\000\162\000\000\000\071\001\
\000\000\051\001\063\001\064\001\000\000\000\000\000\000\052\001\
\053\001\000\000\054\001\000\000\000\000\065\001\066\001\067\001\
\068\001\069\001\000\000\055\001\000\000\000\000\000\000\000\000\
\000\000\251\004\000\000\000\000\056\001\000\000\000\000\071\001\
\000\000\000\000\057\001\058\001\059\001\060\001\061\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\062\001\000\000\000\000\
\000\000\000\000\162\000\000\000\000\000\000\000\000\000\063\001\
\064\001\049\001\050\001\000\000\000\000\000\000\000\000\000\000\
\000\000\051\001\065\001\066\001\067\001\068\001\069\001\052\001\
\053\001\000\000\054\001\000\000\000\000\000\000\000\000\070\001\
\000\000\057\004\000\000\055\001\071\001\000\000\000\000\000\000\
\000\000\049\001\050\001\000\000\056\001\000\000\000\000\000\000\
\000\000\051\001\057\001\058\001\059\001\060\001\061\001\052\001\
\053\001\000\000\054\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\055\001\000\000\062\001\000\000\000\000\
\000\000\000\000\162\000\000\000\056\001\000\000\000\000\063\001\
\064\001\000\000\057\001\058\001\059\001\060\001\061\001\000\000\
\000\000\000\000\065\001\066\001\067\001\068\001\069\001\000\000\
\000\000\000\000\000\000\000\000\000\000\062\001\049\001\050\001\
\000\000\000\000\162\000\000\000\071\001\000\000\051\001\063\001\
\064\001\000\000\000\000\000\000\052\001\000\000\000\000\000\000\
\000\000\000\000\065\001\066\001\067\001\068\001\069\001\000\000\
\055\001\000\000\000\000\000\000\000\000\000\000\049\001\050\001\
\000\000\056\001\000\000\000\000\071\001\000\000\000\000\057\001\
\058\001\059\001\060\001\061\001\052\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\055\001\000\000\062\001\000\000\000\000\000\000\000\000\162\000\
\000\000\056\001\000\000\000\000\063\001\064\001\000\000\057\001\
\058\001\059\001\060\001\061\001\012\000\000\000\000\000\065\001\
\066\001\067\001\068\001\069\001\000\000\000\000\000\000\000\000\
\000\000\000\000\062\001\089\000\014\000\000\000\000\000\162\000\
\000\000\071\001\000\000\000\000\063\001\064\001\000\000\000\000\
\090\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\066\001\067\001\068\001\069\001\000\000\000\000\112\000\000\000\
\113\000\114\000\028\000\029\000\115\000\000\000\000\000\116\000\
\117\000\071\001\000\000\033\000\000\000\000\000\000\000\000\000\
\000\000\091\000\000\000\000\000\000\000\000\000\000\000\039\000\
\118\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\119\000\120\000\000\000\000\000\000\000\000\000\000\000\092\000\
\121\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\093\000\122\000\123\000\050\000"

let yycheck = "\003\000\
\002\000\005\000\177\000\177\000\002\000\174\000\112\000\112\000\
\255\000\185\000\115\000\008\000\112\000\139\000\105\001\061\002\
\118\000\002\000\092\000\180\000\001\000\133\000\002\000\104\002\
\233\002\221\001\104\002\114\000\002\000\002\003\104\000\002\000\
\027\000\034\004\146\000\059\002\002\000\000\000\192\002\003\000\
\150\001\002\000\002\000\196\000\116\003\198\000\001\000\245\003\
\101\003\059\000\252\000\164\003\124\003\223\004\210\004\119\004\
\009\000\008\001\203\004\000\000\198\002\000\000\043\000\121\001\
\066\001\123\001\000\000\110\004\000\001\093\002\029\000\024\000\
\019\001\229\002\033\000\027\001\214\004\090\001\022\001\006\001\
\025\000\022\001\066\001\000\001\000\001\031\001\000\001\108\001\
\043\000\042\000\092\000\178\000\094\001\000\001\092\000\079\001\
\000\001\110\001\141\004\040\001\008\001\000\001\104\000\017\001\
\059\000\037\001\104\000\092\000\112\000\029\001\027\001\115\000\
\092\000\117\000\118\000\023\001\000\001\000\001\092\000\104\000\
\067\001\092\000\030\001\120\000\104\000\078\000\092\000\080\000\
\081\000\000\001\104\000\092\000\092\000\104\000\000\001\000\001\
\140\000\141\000\104\000\143\000\029\005\092\001\094\001\104\000\
\104\000\053\001\090\001\055\001\014\001\153\000\154\000\017\001\
\034\005\117\000\036\003\012\004\022\001\065\001\201\004\066\001\
\014\001\027\001\066\001\095\001\000\001\092\001\073\001\000\001\
\000\001\073\001\115\000\004\000\176\000\177\000\091\001\091\001\
\180\000\094\001\095\001\095\001\094\001\047\001\036\001\000\001\
\000\001\000\001\019\001\094\001\088\005\000\001\094\001\104\001\
\091\001\026\001\027\001\027\001\095\001\014\001\106\001\032\000\
\017\001\109\001\000\001\162\000\163\000\024\001\008\001\091\001\
\115\001\092\001\064\001\115\001\165\000\000\001\000\001\048\001\
\049\001\087\001\008\001\000\001\000\001\037\001\000\001\094\001\
\010\001\091\001\091\001\060\001\181\000\095\001\095\001\097\001\
\098\001\055\003\067\001\068\001\154\001\070\001\003\001\026\005\
\027\001\095\001\188\001\097\001\000\001\018\001\027\001\082\002\
\035\005\115\001\132\003\133\005\093\001\000\000\070\004\109\001\
\000\001\073\004\094\001\091\001\200\002\088\001\094\001\095\001\
\161\001\114\001\163\001\000\001\109\001\000\001\000\001\185\005\
\121\001\187\005\123\001\040\001\091\001\094\001\111\001\095\001\
\095\001\130\001\131\001\094\001\000\001\112\001\105\001\133\001\
\066\001\207\001\092\001\036\005\046\001\091\001\212\001\250\000\
\145\001\252\000\106\005\101\002\000\001\241\002\092\001\149\001\
\091\001\035\001\092\001\004\001\095\001\095\001\091\001\091\001\
\201\005\094\001\095\001\000\001\094\001\000\001\000\001\092\001\
\008\001\000\001\147\003\193\001\181\004\182\004\004\001\027\001\
\025\001\059\001\008\001\000\001\031\001\023\002\064\001\065\001\
\249\001\015\001\094\001\172\000\018\001\026\001\045\001\026\001\
\074\001\000\001\179\000\046\001\230\003\000\001\094\001\000\001\
\000\001\000\001\003\002\010\001\000\001\105\001\155\004\066\001\
\000\001\094\001\010\001\094\001\221\004\000\001\114\001\004\001\
\007\001\099\001\019\001\008\001\018\001\121\001\060\005\123\001\
\092\001\026\001\015\001\109\001\000\001\018\001\130\001\131\001\
\035\001\133\001\000\001\132\005\066\001\106\004\010\001\091\001\
\089\001\090\001\000\001\095\001\093\001\145\001\000\001\096\001\
\049\001\149\001\044\004\092\001\092\001\153\001\154\001\092\001\
\059\001\092\001\092\001\060\001\247\002\064\001\065\001\094\001\
\065\001\000\001\014\001\068\001\000\001\070\001\091\001\074\001\
\067\001\243\001\027\001\010\001\015\001\066\001\178\001\179\001\
\180\001\017\001\022\001\001\004\073\001\092\001\186\001\015\001\
\095\001\130\001\131\001\015\001\092\001\092\001\092\001\095\001\
\099\001\000\001\094\001\000\001\000\001\018\001\094\001\032\001\
\018\001\092\001\109\001\207\001\208\001\040\003\111\001\040\001\
\212\001\066\001\043\001\046\003\216\001\237\003\068\003\219\001\
\092\001\074\005\017\001\095\001\113\001\000\001\092\001\027\001\
\228\001\229\001\066\001\018\001\000\001\243\004\066\001\171\003\
\094\001\188\001\018\001\004\001\094\001\070\001\066\001\243\001\
\244\001\243\001\094\001\003\001\077\001\243\001\004\001\083\001\
\065\001\253\001\008\001\094\001\101\002\092\001\000\000\003\002\
\112\002\015\001\243\001\008\001\018\001\131\002\094\001\243\001\
\228\001\229\001\014\002\113\002\114\002\243\001\011\002\092\001\
\243\001\094\001\192\002\003\001\094\001\243\001\176\004\243\001\
\000\001\030\001\243\001\243\001\091\001\043\005\091\001\091\001\
\247\001\028\002\029\002\095\001\109\001\238\001\014\001\094\001\
\014\001\017\001\022\001\000\001\135\003\092\001\022\001\094\001\
\073\001\063\005\055\001\027\001\066\001\057\002\094\001\008\001\
\091\001\233\002\233\002\233\002\065\001\217\004\019\001\091\001\
\169\002\143\004\171\002\022\001\023\002\026\001\008\001\047\001\
\000\001\026\002\014\001\000\001\167\003\030\001\082\002\004\001\
\152\005\000\001\027\002\008\001\189\002\065\001\014\001\248\002\
\002\001\014\001\015\001\048\001\030\001\018\001\027\001\054\002\
\022\001\101\002\008\001\113\001\104\002\106\001\055\001\060\001\
\109\001\079\001\110\002\111\002\065\001\113\002\114\002\068\001\
\065\001\070\001\094\001\091\001\035\001\055\001\015\003\095\001\
\017\003\097\001\098\001\127\002\121\002\065\001\036\001\065\001\
\132\002\027\001\083\005\031\005\008\001\137\002\022\001\090\001\
\022\001\065\001\066\001\115\001\059\001\066\001\042\005\147\002\
\148\002\064\001\065\001\111\002\066\001\005\003\062\001\242\003\
\066\001\106\001\111\001\074\001\109\001\244\002\249\003\047\001\
\036\001\094\001\062\005\127\002\090\001\169\002\094\001\171\002\
\106\001\094\001\001\003\109\001\176\002\137\002\027\001\035\001\
\094\001\181\002\118\004\065\001\099\001\006\005\092\001\080\003\
\006\005\189\002\190\002\019\001\192\002\035\001\109\001\182\003\
\183\003\093\005\050\003\022\001\094\001\030\002\202\002\059\001\
\008\001\027\001\052\003\052\003\000\001\065\001\000\000\000\001\
\108\005\097\001\098\001\004\001\176\002\059\001\253\001\008\001\
\092\001\049\001\064\003\065\001\201\002\039\003\015\001\253\001\
\073\003\018\001\088\001\115\001\060\001\233\002\026\001\064\002\
\065\002\152\003\152\003\057\005\068\001\059\005\070\001\179\004\
\066\001\094\001\102\001\247\002\248\002\066\001\201\002\073\001\
\094\001\109\001\112\001\111\001\073\001\255\002\000\001\195\004\
\102\001\255\002\004\001\067\001\008\003\096\004\008\001\109\001\
\010\001\111\001\004\001\094\001\014\001\015\001\008\001\008\001\
\018\001\066\001\057\002\055\001\014\001\015\001\014\001\111\001\
\018\001\027\001\003\001\057\002\064\001\150\005\151\005\000\001\
\018\001\115\001\014\001\027\001\040\003\039\003\115\001\130\004\
\236\004\039\003\046\003\014\001\008\003\094\001\207\003\044\003\
\052\003\140\004\019\001\055\003\000\001\035\001\039\003\019\001\
\027\001\026\001\000\001\039\003\064\003\090\001\047\001\060\003\
\066\001\039\003\155\002\156\002\039\003\073\003\030\001\073\001\
\066\001\039\003\067\001\079\003\112\001\059\001\039\003\039\003\
\049\001\110\001\036\001\065\001\048\001\065\001\066\001\079\001\
\177\002\091\001\092\001\060\001\094\001\095\001\215\005\055\001\
\060\001\000\000\067\001\068\001\094\001\070\001\191\002\030\001\
\068\001\065\001\070\001\072\000\079\001\055\001\000\001\113\001\
\097\001\098\001\094\001\003\001\064\001\065\001\064\001\014\001\
\102\001\014\001\064\001\065\001\064\001\129\003\044\004\109\001\
\055\001\019\001\115\001\135\003\027\001\045\001\046\001\139\003\
\026\001\102\000\065\001\000\000\022\001\095\001\111\001\147\003\
\022\001\149\003\106\001\111\001\152\003\109\001\154\003\155\003\
\156\003\058\004\200\005\159\003\160\003\097\001\048\001\049\001\
\164\003\007\004\166\003\167\003\000\001\047\001\112\001\064\001\
\065\001\109\001\060\001\083\001\065\001\066\001\178\003\139\003\
\009\003\067\001\068\001\106\001\070\001\000\001\109\001\147\003\
\079\001\189\003\035\004\065\001\100\001\022\003\095\004\014\001\
\000\001\015\001\004\001\159\003\018\001\194\003\008\001\014\001\
\019\001\037\001\074\001\207\003\027\001\015\001\000\001\026\001\
\027\001\003\001\037\001\019\001\027\001\110\001\178\003\097\001\
\098\001\027\001\026\001\013\001\014\001\111\001\064\001\017\001\
\000\000\014\001\131\004\008\001\017\001\048\001\049\001\000\001\
\026\001\027\001\028\001\029\001\108\001\064\001\242\003\105\001\
\048\001\060\001\065\001\030\001\066\001\249\003\040\001\041\001\
\067\001\068\001\065\001\070\001\060\001\001\004\000\001\097\001\
\066\001\026\001\176\004\007\004\068\001\002\004\070\001\000\001\
\012\004\135\004\060\001\109\001\055\001\063\001\000\001\065\001\
\066\001\067\001\068\001\022\001\066\001\067\001\065\001\073\001\
\074\001\147\001\019\001\073\001\022\001\000\001\080\001\035\004\
\064\001\026\001\066\001\037\001\111\001\206\004\127\003\128\003\
\044\004\045\004\092\001\075\001\094\001\049\004\096\001\111\001\
\064\001\035\001\000\001\220\004\141\003\142\003\058\004\026\001\
\049\001\014\001\108\001\148\003\010\001\111\001\065\001\106\001\
\064\001\115\001\109\001\060\001\157\003\115\001\000\001\065\001\
\064\001\059\001\243\004\068\001\067\005\070\001\064\001\065\001\
\112\001\045\004\047\001\075\001\064\001\049\004\031\004\012\001\
\074\001\019\001\090\001\095\004\096\004\109\001\098\004\028\001\
\026\001\000\001\064\001\018\005\018\005\004\001\208\004\208\004\
\108\004\008\001\031\001\010\001\208\004\109\001\110\001\014\001\
\015\001\099\001\027\001\018\001\064\001\064\001\111\001\049\001\
\112\001\064\001\100\001\109\001\027\001\050\001\130\004\131\004\
\041\005\109\001\060\001\004\001\075\001\066\001\098\004\008\001\
\140\004\067\001\068\001\143\004\070\001\074\001\015\001\109\001\
\108\004\018\001\071\001\080\001\061\005\064\001\083\001\027\001\
\037\001\066\001\027\001\159\004\053\001\064\001\055\001\084\001\
\157\004\109\001\110\001\066\001\083\005\083\005\086\005\064\001\
\065\001\112\001\073\001\094\001\176\004\035\001\064\001\040\001\
\101\001\181\004\182\004\064\001\066\001\111\001\064\001\064\001\
\064\001\189\004\109\001\110\001\091\001\092\001\066\001\094\001\
\095\001\066\001\109\001\000\001\053\001\059\001\055\001\056\001\
\090\001\066\001\109\001\065\001\208\004\209\004\210\004\088\001\
\065\001\042\004\113\001\000\001\109\001\046\004\019\001\000\000\
\082\002\221\004\051\004\223\004\110\001\026\001\022\001\109\001\
\000\001\189\004\066\001\109\001\004\001\109\001\019\001\112\001\
\008\001\073\001\010\001\068\004\069\004\026\001\014\001\064\001\
\102\001\074\004\018\001\048\001\110\002\209\004\210\004\109\001\
\027\001\064\001\254\004\027\001\109\001\035\001\094\001\060\001\
\221\001\064\001\006\005\048\001\000\001\075\001\067\001\068\001\
\027\001\070\001\099\004\067\001\016\005\035\001\018\005\060\001\
\022\001\013\001\022\005\115\001\064\001\059\001\067\001\068\001\
\064\001\070\001\064\001\065\001\109\001\238\001\026\001\066\001\
\028\001\029\001\254\004\039\005\074\001\059\001\109\001\000\001\
\004\001\073\001\112\001\065\001\008\001\041\001\109\001\066\001\
\031\001\000\000\111\001\015\001\016\005\057\005\018\001\059\005\
\018\001\230\002\022\005\091\001\092\001\099\001\094\001\095\001\
\060\001\109\001\111\001\050\001\000\001\109\001\074\005\109\001\
\068\001\246\002\027\002\039\005\037\001\250\002\074\001\083\005\
\102\001\113\001\027\005\007\000\080\001\030\005\010\000\109\001\
\177\004\013\000\014\000\027\001\000\000\017\000\018\000\019\000\
\020\000\021\000\066\001\023\000\096\001\066\001\066\001\192\004\
\193\004\037\001\030\000\066\001\025\003\113\005\034\000\064\001\
\108\001\037\000\038\000\111\001\027\001\027\001\083\001\000\001\
\124\005\086\002\046\000\047\000\083\001\247\002\050\000\051\000\
\004\001\023\001\066\001\135\005\008\001\035\001\000\001\000\001\
\081\005\082\005\091\001\084\005\085\005\066\001\018\001\108\001\
\146\005\026\001\150\005\151\005\146\005\113\005\109\001\027\001\
\156\005\157\005\019\001\066\001\066\001\059\001\083\001\031\001\
\026\001\026\001\064\001\065\001\000\000\089\000\090\000\091\000\
\000\001\093\000\066\001\135\005\074\001\071\001\040\003\179\005\
\009\005\073\001\050\001\006\001\046\003\185\005\186\005\187\005\
\049\001\004\001\084\001\191\005\005\000\008\001\066\001\022\001\
\156\005\157\005\026\001\060\001\015\001\099\001\094\001\018\001\
\166\003\125\000\064\001\068\001\066\001\070\001\004\001\109\001\
\212\005\022\001\008\001\215\005\000\000\137\000\138\000\179\005\
\047\001\221\005\222\005\115\001\018\001\095\001\186\005\189\003\
\064\001\149\000\088\001\191\005\055\001\027\001\057\001\058\001\
\059\001\000\001\061\001\075\001\000\001\064\001\065\001\022\001\
\164\000\053\001\000\001\055\001\189\005\078\005\111\001\066\001\
\212\005\173\000\112\001\091\001\064\001\065\001\199\005\019\001\
\022\001\221\005\222\005\026\001\093\001\019\001\026\001\090\001\
\047\001\210\005\211\005\232\002\026\001\135\003\097\001\004\001\
\027\001\000\001\000\001\008\001\109\001\053\001\054\001\055\001\
\056\001\047\001\109\001\110\001\048\001\000\000\251\002\120\005\
\064\001\065\001\048\001\000\003\093\001\000\001\027\001\128\005\
\060\001\109\001\164\003\026\001\026\001\167\003\060\001\067\001\
\068\001\000\001\070\001\094\001\109\001\004\001\068\001\018\001\
\070\001\008\001\023\003\010\001\022\001\016\001\095\001\014\001\
\015\001\004\001\109\001\140\000\141\000\008\001\159\005\004\001\
\027\001\253\000\254\000\008\001\027\001\109\001\040\001\018\001\
\153\000\154\000\015\001\091\001\049\003\018\001\095\001\095\001\
\027\001\178\005\000\001\111\001\000\001\065\001\027\001\019\001\
\004\001\111\001\008\001\071\001\008\001\022\001\010\001\176\000\
\064\001\065\001\014\001\000\001\065\001\033\001\018\001\071\001\
\084\001\037\001\093\001\066\001\073\001\010\001\006\001\027\001\
\242\003\000\001\073\001\014\001\084\001\214\005\017\001\249\003\
\004\001\094\001\090\001\010\001\008\001\066\001\065\001\053\001\
\027\001\055\001\014\001\015\001\091\001\092\001\018\001\094\001\
\095\001\077\001\012\004\065\001\113\003\073\001\110\001\053\001\
\076\001\055\001\053\001\079\001\055\001\081\001\066\001\083\001\
\064\001\065\001\113\001\065\001\000\001\073\001\065\001\055\001\
\004\001\057\001\058\001\059\001\008\001\061\001\010\001\003\001\
\064\001\065\001\014\001\065\001\066\001\067\001\018\001\091\001\
\092\001\055\001\094\001\095\001\112\001\059\001\066\001\027\001\
\116\001\063\001\064\001\053\001\054\001\055\001\056\001\064\001\
\065\001\000\000\090\001\168\003\169\003\113\001\064\001\065\001\
\078\001\097\001\134\001\135\001\000\001\064\001\053\001\003\001\
\055\001\016\001\055\001\184\003\064\001\109\001\110\001\022\001\
\227\001\013\001\065\001\064\001\027\001\092\001\096\004\234\001\
\197\003\053\001\013\001\055\001\160\001\073\001\026\001\109\001\
\028\001\029\001\008\001\167\001\000\001\065\001\014\001\171\001\
\213\003\028\001\029\001\109\001\040\001\041\001\010\001\091\001\
\092\001\095\001\094\001\095\001\184\001\185\001\041\001\065\001\
\130\004\189\001\036\001\191\001\064\001\065\001\073\001\073\001\
\060\001\014\001\140\004\063\001\022\001\113\001\109\001\244\003\
\068\001\060\001\206\001\090\001\063\001\000\001\074\001\022\001\
\003\001\068\001\065\001\066\001\080\001\159\004\218\001\074\001\
\220\001\221\001\013\001\066\001\067\001\080\001\017\001\014\001\
\092\001\064\001\065\001\022\001\096\001\210\001\211\001\026\001\
\027\001\028\001\029\001\181\004\182\004\096\001\095\001\008\001\
\108\001\130\001\131\001\111\001\000\000\000\001\041\001\251\001\
\037\004\108\001\095\001\055\001\111\001\004\001\023\001\059\001\
\153\001\008\001\112\001\063\001\064\001\030\001\092\001\103\001\
\015\001\060\001\014\001\018\001\063\001\022\001\065\001\066\001\
\067\001\068\001\078\001\221\004\027\001\223\004\073\001\074\001\
\027\001\178\001\179\001\180\001\053\001\080\001\055\001\092\001\
\091\001\186\001\092\001\237\004\238\004\109\001\000\000\092\001\
\065\001\092\001\094\001\094\001\055\001\096\001\057\001\058\001\
\059\001\109\001\061\001\094\001\092\001\064\001\065\001\014\001\
\101\004\108\001\103\004\066\001\111\001\115\001\020\001\216\001\
\115\001\109\001\115\001\064\001\065\001\046\001\081\001\109\001\
\109\001\062\001\071\001\108\001\002\001\081\002\089\001\090\001\
\084\002\106\001\086\002\109\001\109\001\109\001\097\001\084\001\
\073\001\073\001\100\001\244\001\137\004\090\001\027\001\109\001\
\015\001\142\004\109\001\110\001\001\000\002\000\003\000\004\000\
\005\000\092\001\055\001\000\001\094\001\064\001\064\001\008\001\
\109\001\110\001\065\001\109\001\040\001\014\002\001\001\002\001\
\124\002\000\001\167\004\014\001\018\001\004\001\009\001\062\001\
\074\005\008\001\062\001\010\001\015\001\016\001\062\001\014\001\
\092\001\027\001\142\002\064\001\144\002\094\001\146\002\079\001\
\027\001\014\001\150\002\014\001\027\001\006\001\094\001\073\001\
\109\001\036\001\199\004\200\004\095\001\064\001\075\001\042\001\
\043\001\044\001\045\001\046\001\073\001\111\005\022\001\094\001\
\172\002\092\001\014\001\073\001\027\001\218\004\006\001\040\001\
\008\001\222\004\061\001\094\001\027\001\014\001\027\001\066\001\
\021\001\086\001\064\001\062\001\071\001\072\001\194\002\062\001\
\062\001\003\001\073\001\199\002\200\002\014\001\062\001\082\001\
\083\001\084\001\085\001\086\001\062\001\086\001\210\002\095\001\
\212\002\027\001\090\001\073\001\091\001\092\001\003\005\094\001\
\095\001\100\001\091\001\223\002\224\002\027\001\094\001\055\001\
\101\001\057\001\058\001\059\001\094\001\061\001\234\002\094\001\
\064\001\065\001\113\001\132\002\088\001\241\002\027\001\185\005\
\094\001\187\005\014\001\020\001\000\001\015\001\022\001\003\001\
\252\002\053\001\147\002\148\002\094\001\008\001\043\005\062\001\
\080\001\013\001\090\001\062\001\092\001\062\001\051\005\094\001\
\112\001\097\001\112\001\094\001\088\001\065\001\026\001\019\003\
\028\001\029\001\063\005\021\001\091\001\109\001\110\001\095\001\
\094\001\014\001\014\001\014\001\181\002\041\001\014\001\027\001\
\027\001\037\003\019\001\091\001\022\001\112\001\000\001\088\001\
\014\001\003\001\014\001\014\001\014\001\000\000\000\000\008\001\
\060\001\092\001\065\001\013\001\092\001\036\001\109\001\017\001\
\068\001\036\001\062\003\109\001\022\001\065\003\074\001\067\003\
\026\001\027\001\028\001\029\001\080\001\005\000\006\001\036\001\
\008\001\064\001\078\003\092\001\092\001\090\001\082\003\041\001\
\092\001\040\001\064\001\036\001\096\001\089\003\094\001\053\001\
\024\000\093\003\053\001\064\001\091\001\026\003\000\000\064\001\
\108\001\064\001\060\001\111\001\064\001\063\001\036\003\065\001\
\066\001\067\001\068\001\111\003\064\001\064\001\114\003\073\001\
\074\001\064\001\118\003\186\005\254\004\111\005\080\001\055\001\
\187\002\057\001\058\001\059\001\120\003\061\001\171\005\026\002\
\064\001\065\001\092\001\131\002\094\001\000\001\096\001\018\005\
\096\001\094\001\129\003\143\003\187\001\057\002\063\002\141\000\
\183\001\166\004\108\001\212\003\155\004\111\001\195\005\196\005\
\171\002\115\001\090\001\145\001\108\001\006\005\203\005\243\004\
\255\255\097\001\043\005\136\004\255\255\255\255\170\003\171\003\
\255\255\255\255\255\255\255\255\255\255\109\001\110\001\220\005\
\180\003\181\003\255\255\255\255\255\255\015\001\079\003\255\255\
\255\255\121\000\255\255\255\255\055\001\255\255\057\001\058\001\
\059\001\197\003\061\001\255\255\255\255\064\001\065\001\255\255\
\255\255\255\255\255\255\139\000\140\000\141\000\255\255\143\000\
\064\001\065\001\044\001\045\001\046\001\255\255\081\001\071\001\
\255\255\153\000\154\000\255\255\255\255\077\001\089\001\090\001\
\255\255\255\255\255\255\255\255\084\001\233\003\097\001\235\003\
\129\003\255\255\090\001\255\255\255\255\071\001\072\001\243\003\
\176\000\177\000\109\001\110\001\180\000\255\255\255\255\255\255\
\252\003\083\001\084\001\085\001\086\001\109\001\110\001\255\255\
\255\255\154\003\155\003\156\003\255\255\009\004\255\255\160\003\
\255\255\255\255\100\001\255\255\255\255\166\003\255\255\255\255\
\255\255\255\255\255\255\007\000\255\255\255\255\010\000\255\255\
\255\255\013\000\014\000\255\255\255\255\017\000\018\000\019\000\
\020\000\021\000\255\255\023\000\189\003\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\034\000\255\255\
\255\255\037\000\038\000\255\255\255\255\255\255\255\255\255\255\
\255\255\061\004\046\000\047\000\064\004\255\255\050\000\051\000\
\055\001\255\255\057\001\058\001\059\001\255\255\061\001\255\255\
\255\255\064\001\065\001\255\255\255\255\081\004\255\255\083\004\
\255\255\085\004\255\255\087\004\088\004\255\255\255\255\255\255\
\092\004\255\255\255\255\255\255\255\255\097\004\000\001\255\255\
\100\004\003\001\102\004\090\001\255\255\089\000\090\000\091\000\
\255\255\093\000\097\001\013\001\014\001\255\255\255\255\017\001\
\255\255\255\255\118\004\255\255\255\255\255\255\109\001\110\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\013\001\137\004\040\001\041\001\
\255\255\255\255\142\004\255\255\255\255\255\255\255\255\255\255\
\255\255\149\004\255\255\028\001\029\001\137\000\138\000\087\001\
\255\255\255\255\060\001\255\255\255\255\063\001\255\255\255\255\
\041\001\067\001\068\001\255\255\255\255\255\255\170\004\073\001\
\074\001\255\255\174\004\255\255\255\255\255\255\080\001\179\004\
\255\255\255\255\255\255\060\001\255\255\255\255\255\255\255\255\
\255\255\173\000\092\001\068\001\094\001\255\255\096\001\195\004\
\196\004\074\001\198\004\255\255\255\255\255\255\255\255\080\001\
\255\255\255\255\108\001\000\001\255\255\111\001\255\255\255\255\
\212\004\115\001\255\255\255\255\255\255\255\255\150\001\096\001\
\255\255\153\001\154\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\108\001\255\255\255\255\111\001\235\004\
\236\004\255\255\255\255\255\255\255\255\255\255\242\004\255\255\
\255\255\255\255\178\001\179\001\180\001\255\255\255\255\255\255\
\255\255\255\255\186\001\255\255\255\255\001\005\255\255\003\005\
\255\255\193\001\055\001\255\255\057\001\058\001\059\001\255\255\
\061\001\253\000\254\000\064\001\065\001\017\005\255\255\207\001\
\208\001\255\255\255\255\255\255\212\001\255\255\255\255\255\255\
\216\001\000\000\255\255\219\001\081\001\033\005\255\255\019\001\
\255\255\255\255\038\005\227\001\089\001\090\001\255\255\255\255\
\255\255\255\255\234\001\255\255\097\001\033\001\000\000\051\005\
\255\255\037\001\255\255\255\255\244\001\255\255\255\255\108\001\
\109\001\110\001\255\255\255\255\255\255\253\001\255\255\255\255\
\023\001\255\255\255\255\003\002\072\005\255\255\255\255\255\255\
\255\255\077\005\255\255\255\255\080\005\036\001\014\002\255\255\
\255\255\017\002\255\255\087\005\255\255\255\255\255\255\091\005\
\255\255\255\255\026\002\095\005\255\255\255\255\255\255\255\255\
\055\001\255\255\057\001\058\001\059\001\255\255\061\001\255\255\
\255\255\064\001\065\001\255\255\112\005\255\255\255\255\005\000\
\255\255\255\255\255\255\009\000\255\255\255\255\255\255\255\255\
\255\255\057\002\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\024\000\090\001\255\255\137\005\138\005\255\255\
\255\255\255\255\097\001\143\005\255\255\255\255\255\255\147\005\
\255\255\255\255\134\001\255\255\042\000\153\005\109\001\110\001\
\255\255\255\255\255\255\255\255\255\255\161\005\162\005\255\255\
\255\255\255\255\255\255\167\005\168\005\169\005\170\005\255\255\
\005\000\006\001\007\001\255\255\255\255\015\001\011\001\012\001\
\180\005\181\005\255\255\167\001\255\255\255\255\255\255\255\255\
\078\000\255\255\080\000\081\000\255\255\193\005\194\005\255\255\
\196\005\030\001\031\001\131\002\132\002\255\255\255\255\255\255\
\204\005\043\001\044\001\045\001\046\001\255\255\255\255\255\255\
\255\255\255\255\255\255\147\002\148\002\050\001\218\005\000\000\
\053\001\054\001\055\001\056\001\224\005\225\005\059\001\255\255\
\066\001\255\255\255\255\064\001\065\001\071\001\072\001\255\255\
\255\255\255\255\170\002\255\255\255\255\255\255\255\255\255\255\
\255\255\083\001\084\001\085\001\086\001\181\002\140\000\141\000\
\255\255\143\000\087\001\255\255\255\255\255\255\190\002\255\255\
\192\002\255\255\100\001\153\000\154\000\255\255\255\255\251\001\
\101\001\255\255\202\002\255\255\255\255\106\001\255\255\165\000\
\109\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\000\001\176\000\177\000\003\001\255\255\255\255\181\000\
\255\255\255\255\255\255\255\255\255\255\255\255\013\001\231\002\
\255\255\233\002\017\001\255\255\255\255\255\255\000\001\140\000\
\141\000\003\001\143\000\026\001\027\001\028\001\029\001\255\255\
\248\002\255\255\255\255\013\001\153\000\154\000\255\255\255\255\
\255\255\255\255\041\001\255\255\255\255\255\255\255\255\255\255\
\026\001\255\255\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\175\000\176\000\177\000\060\001\040\001\041\001\
\063\001\255\255\255\255\066\001\067\001\068\001\255\255\255\255\
\255\255\005\000\073\001\074\001\255\255\009\000\255\255\255\255\
\255\255\080\001\060\001\255\255\255\255\063\001\004\001\047\003\
\255\255\067\001\068\001\255\255\024\000\092\001\255\255\094\001\
\074\001\096\001\255\255\255\255\255\255\255\255\080\001\255\255\
\255\255\255\255\255\255\025\001\068\003\108\001\042\000\255\255\
\111\001\255\255\092\001\255\255\115\001\255\255\096\001\079\003\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\108\001\255\255\255\255\111\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\078\000\255\255\080\000\081\000\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\129\003\255\255\089\001\090\001\255\255\255\255\093\001\
\255\255\000\000\096\001\255\255\112\000\042\001\255\255\255\255\
\255\255\255\255\255\255\048\001\255\255\149\003\255\255\000\001\
\152\003\255\255\154\003\155\003\156\003\255\255\255\255\008\001\
\160\003\255\255\255\255\255\255\013\001\255\255\166\003\255\255\
\140\000\141\000\255\255\143\000\255\255\255\255\255\255\255\255\
\255\255\026\001\255\255\028\001\029\001\153\000\154\000\255\255\
\255\255\255\255\255\255\255\255\255\255\189\003\255\255\255\255\
\041\001\165\000\255\255\153\001\154\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\176\000\177\000\255\255\207\003\
\000\001\181\000\255\255\060\001\255\255\255\255\063\001\255\255\
\255\255\066\001\067\001\068\001\178\001\179\001\180\001\019\003\
\255\255\074\001\255\255\255\255\186\001\255\255\255\255\080\001\
\255\255\255\255\255\255\255\255\236\003\255\255\255\255\255\255\
\255\255\255\255\255\255\092\001\255\255\255\255\255\255\096\001\
\255\255\207\001\208\001\255\255\153\001\154\001\212\001\255\255\
\255\255\255\255\216\001\108\001\255\255\255\255\111\001\055\001\
\255\255\057\001\058\001\059\001\255\255\061\001\255\255\255\255\
\064\001\065\001\255\255\255\255\177\001\178\001\179\001\180\001\
\255\255\008\001\255\255\255\255\255\255\186\001\244\001\255\255\
\004\001\081\001\255\255\255\255\255\255\255\255\255\255\253\001\
\023\001\089\001\090\001\000\000\044\004\255\255\255\255\030\001\
\255\255\097\001\207\001\208\001\255\255\025\001\255\255\212\001\
\014\002\255\255\058\004\216\001\255\255\109\001\110\001\255\255\
\255\255\255\255\255\255\255\255\026\002\226\001\255\255\255\255\
\055\001\000\000\057\001\058\001\059\001\255\255\061\001\255\255\
\255\255\064\001\065\001\255\255\255\255\255\255\255\255\244\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\095\004\
\253\001\255\255\081\001\057\002\255\255\255\255\255\255\255\255\
\255\255\088\001\089\001\090\001\255\255\255\255\255\255\255\255\
\255\255\014\002\097\001\255\255\255\255\089\001\090\001\255\255\
\255\255\093\001\005\000\106\001\096\001\255\255\109\001\110\001\
\255\255\255\255\255\255\131\004\255\255\255\255\255\255\135\004\
\255\255\000\001\255\255\255\255\003\001\255\255\114\001\255\255\
\255\255\255\255\255\255\255\255\255\255\121\001\013\001\123\001\
\255\255\255\255\255\255\255\255\057\002\255\255\255\255\255\255\
\255\255\255\255\255\255\026\001\255\255\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\132\002\255\255\
\176\004\040\001\041\001\255\255\255\255\153\001\154\001\255\255\
\255\255\255\255\255\255\255\255\255\255\147\002\148\002\255\255\
\255\255\255\255\255\255\255\255\255\255\060\001\255\255\255\255\
\063\001\255\255\255\255\255\255\067\001\068\001\178\001\179\001\
\180\001\255\255\255\255\074\001\170\002\255\255\186\001\255\255\
\255\255\080\001\255\255\255\255\255\255\255\255\255\255\181\002\
\255\255\255\255\255\255\255\255\255\255\092\001\255\255\132\002\
\190\002\096\001\192\002\207\001\208\001\255\255\255\255\255\255\
\212\001\255\255\255\255\255\255\216\001\108\001\147\002\148\002\
\111\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\140\000\141\000\255\255\143\000\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\153\000\154\000\
\244\001\255\255\018\005\233\002\255\255\255\255\255\255\255\255\
\181\002\253\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\190\002\255\255\192\002\255\255\176\000\177\000\255\255\
\255\255\255\255\014\002\000\001\255\255\002\001\003\001\004\001\
\255\255\255\255\255\255\008\001\255\255\255\255\026\002\255\255\
\013\001\255\255\255\255\255\255\017\001\018\001\019\001\255\255\
\255\255\255\255\255\255\255\255\255\255\026\001\027\001\028\001\
\029\001\000\001\255\255\255\255\233\002\255\255\255\255\036\001\
\255\255\255\255\255\255\083\005\041\001\057\002\013\001\255\255\
\255\255\255\255\255\255\048\001\049\001\000\000\094\005\255\255\
\255\255\255\255\255\255\026\001\255\255\028\001\029\001\060\001\
\255\255\255\255\063\001\064\001\255\255\066\001\067\001\068\001\
\255\255\070\001\041\001\255\255\073\001\074\001\255\255\255\255\
\255\255\079\003\255\255\080\001\255\255\255\255\255\255\255\255\
\255\255\101\002\255\255\255\255\255\255\060\001\091\001\092\001\
\136\005\094\001\095\001\096\001\097\001\068\001\142\005\100\001\
\255\255\255\255\255\255\074\001\255\255\255\255\255\255\108\001\
\109\001\080\001\111\001\255\255\255\255\255\255\115\001\255\255\
\132\002\255\255\255\255\076\001\255\255\092\001\079\001\255\255\
\081\001\096\001\083\001\129\003\255\255\255\255\255\255\147\002\
\148\002\255\255\079\003\255\255\255\255\108\001\255\255\255\255\
\111\001\255\255\255\255\255\255\255\255\255\255\255\255\149\003\
\255\255\255\255\152\003\255\255\154\003\155\003\156\003\112\001\
\026\000\027\000\160\003\116\001\255\255\255\255\255\255\255\255\
\166\003\181\002\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\190\002\255\255\192\002\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\129\003\255\255\255\255\189\003\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\149\003\255\255\255\255\152\003\153\003\154\003\155\003\156\003\
\082\000\083\000\255\255\160\003\255\255\233\002\255\255\000\001\
\255\255\166\003\255\255\255\255\255\255\006\001\153\001\154\001\
\255\255\255\255\000\000\012\001\189\001\255\255\191\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\189\003\255\255\255\255\028\001\255\255\030\001\031\001\178\001\
\179\001\180\001\255\255\255\255\255\255\255\255\255\255\186\001\
\187\001\218\001\255\255\220\001\255\255\255\255\255\255\255\255\
\255\255\050\001\255\255\052\001\053\001\255\255\055\001\056\001\
\255\255\255\255\059\001\255\255\207\001\208\001\255\255\064\001\
\065\001\212\001\255\255\255\255\255\255\216\001\071\001\255\255\
\052\003\255\255\255\255\255\255\255\255\057\003\044\004\255\255\
\255\255\255\255\255\255\084\001\255\255\000\001\255\255\255\255\
\003\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\097\001\244\001\013\001\079\003\101\001\255\255\017\001\255\255\
\255\255\106\001\253\001\255\255\109\001\110\001\255\255\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\014\002\255\255\255\255\041\001\255\255\
\255\255\255\255\255\255\000\000\255\255\255\255\255\255\044\004\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\060\001\255\255\255\255\063\001\129\003\255\255\066\001\
\067\001\068\001\255\255\255\255\255\255\255\255\073\001\074\001\
\081\002\255\255\255\255\084\002\255\255\080\001\057\002\255\255\
\255\255\149\003\255\255\255\255\152\003\255\255\154\003\155\003\
\156\003\092\001\255\255\094\001\160\003\096\001\255\255\255\255\
\255\255\255\255\166\003\255\255\255\255\255\255\255\255\255\255\
\255\255\108\001\255\255\255\255\111\001\255\255\255\255\255\255\
\115\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\189\003\176\004\255\255\255\255\255\255\255\255\049\001\
\050\001\051\001\052\001\053\001\054\001\055\001\056\001\057\001\
\058\001\059\001\060\001\061\001\062\001\063\001\064\001\065\001\
\066\001\067\001\068\001\069\001\255\255\071\001\255\255\255\255\
\255\255\132\002\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\172\002\086\001\255\255\000\000\255\255\
\147\002\148\002\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\099\001\000\001\176\004\002\001\003\001\004\001\255\255\
\255\255\255\255\008\001\255\003\255\255\255\255\199\002\013\001\
\255\255\255\255\255\255\017\001\018\001\019\001\255\255\255\255\
\255\255\255\255\181\002\255\255\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\190\002\255\255\192\002\036\001\255\255\
\255\255\255\255\040\001\041\001\018\005\255\255\255\255\255\255\
\255\255\255\255\048\001\049\001\255\255\255\255\255\255\255\255\
\044\004\255\255\255\255\255\255\255\255\255\255\060\001\255\255\
\255\255\063\001\255\255\255\255\066\001\067\001\068\001\255\255\
\070\001\255\255\255\255\073\001\074\001\255\255\233\002\255\255\
\000\000\255\255\080\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\091\001\092\001\255\255\
\094\001\095\001\096\001\255\255\255\255\018\005\100\001\255\255\
\255\255\255\255\255\255\255\255\255\255\083\005\108\001\255\255\
\255\255\111\001\255\255\255\255\255\255\115\001\255\255\255\255\
\094\005\255\255\255\255\000\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\008\001\255\255\062\003\255\255\255\255\
\013\001\235\001\255\255\255\255\255\255\255\255\240\001\255\255\
\255\255\255\255\255\255\255\255\255\255\026\001\255\255\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\136\005\255\255\041\001\255\255\083\005\053\001\
\255\255\055\001\255\255\057\001\058\001\059\001\255\255\061\001\
\255\255\255\255\064\001\065\001\079\003\255\255\111\003\060\001\
\255\255\255\255\028\002\029\002\176\004\066\001\067\001\068\001\
\255\255\255\255\255\255\255\255\255\255\074\001\000\000\255\255\
\255\255\255\255\255\255\080\001\090\001\255\255\255\255\255\255\
\255\255\255\255\255\255\097\001\255\255\255\255\143\003\092\001\
\255\255\255\255\255\255\096\001\208\004\063\002\255\255\109\001\
\110\001\255\255\068\002\069\002\070\002\255\255\129\003\108\001\
\255\255\255\255\111\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\000\001\255\255\
\002\001\003\001\149\003\180\003\181\003\152\003\008\001\154\003\
\155\003\156\003\255\255\013\001\255\255\160\003\255\255\017\001\
\018\001\019\001\255\255\166\003\255\255\255\255\255\255\255\255\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\255\255\255\255\255\255\018\005\041\001\
\255\255\255\255\189\003\255\255\255\255\255\255\048\001\049\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\233\003\255\255\060\001\255\255\255\255\063\001\255\255\255\255\
\066\001\067\001\068\001\255\255\070\001\159\002\160\002\161\002\
\074\001\255\255\255\255\252\003\255\255\255\255\080\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
\000\001\091\001\092\001\003\001\094\001\095\001\096\001\255\255\
\255\255\255\255\255\255\023\001\255\255\013\001\255\255\083\005\
\255\255\017\001\108\001\197\002\255\255\111\001\255\255\255\255\
\036\001\115\001\026\001\027\001\028\001\029\001\255\255\255\255\
\255\255\255\255\255\255\213\002\255\255\255\255\255\255\255\255\
\255\255\041\001\255\255\055\001\255\255\057\001\058\001\059\001\
\255\255\061\001\255\255\255\255\064\001\065\001\255\255\255\255\
\255\255\255\255\255\255\255\255\060\001\255\255\255\255\063\001\
\255\255\044\004\066\001\067\001\068\001\255\255\255\255\255\255\
\255\255\073\001\074\001\255\255\255\255\255\255\090\001\255\255\
\080\001\255\255\255\255\000\000\255\255\097\001\255\255\255\255\
\255\255\255\255\255\255\100\004\092\001\102\004\094\001\255\255\
\096\001\109\001\110\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\108\001\255\255\032\003\111\001\
\255\255\255\255\255\255\115\001\255\255\255\255\000\001\001\001\
\002\001\003\001\255\255\255\255\006\001\007\001\008\001\009\001\
\010\001\011\001\012\001\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\149\004\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\030\001\031\001\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\045\001\046\001\047\001\255\255\049\001\
\050\001\051\001\255\255\053\001\054\001\055\001\056\001\255\255\
\255\255\059\001\060\001\061\001\255\255\063\001\064\001\065\001\
\066\001\067\001\068\001\255\255\070\001\071\001\072\001\073\001\
\074\001\255\255\255\255\255\255\255\255\176\004\080\001\081\001\
\082\001\083\001\084\001\085\001\086\001\087\001\255\255\089\001\
\000\000\091\001\092\001\133\003\094\001\095\001\096\001\097\001\
\098\001\255\255\100\001\101\001\255\255\103\001\104\001\105\001\
\106\001\255\255\108\001\109\001\255\255\111\001\255\255\255\255\
\255\255\115\001\255\255\055\001\255\255\057\001\058\001\059\001\
\255\255\061\001\255\255\255\255\064\001\065\001\255\255\255\255\
\001\005\255\255\255\255\255\255\255\255\255\255\074\001\000\001\
\255\255\002\001\003\001\004\001\255\255\081\001\255\255\008\001\
\255\255\255\255\255\255\255\255\013\001\089\001\090\001\255\255\
\017\001\018\001\019\001\255\255\255\255\097\001\255\255\255\255\
\255\255\026\001\027\001\028\001\029\001\038\005\255\255\255\255\
\255\255\109\001\110\001\036\001\255\255\255\255\255\255\018\005\
\041\001\255\255\220\003\221\003\222\003\255\255\255\255\048\001\
\049\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\060\001\255\255\255\255\063\001\072\005\
\255\255\066\001\067\001\068\001\255\255\070\001\255\255\255\255\
\073\001\074\001\255\255\255\255\255\255\255\255\087\005\080\001\
\255\255\023\001\255\255\000\001\255\255\255\255\095\005\255\255\
\255\255\255\255\091\001\092\001\255\255\094\001\095\001\096\001\
\013\001\000\000\020\004\021\004\022\004\255\255\255\255\112\005\
\083\005\255\255\255\255\108\001\255\255\026\001\111\001\028\001\
\029\001\055\001\115\001\057\001\058\001\059\001\255\255\061\001\
\255\255\255\255\064\001\065\001\041\001\255\255\255\255\255\255\
\137\005\138\005\055\001\255\255\057\001\058\001\059\001\057\004\
\061\001\255\255\147\005\064\001\065\001\255\255\255\255\060\001\
\255\255\255\255\063\001\255\255\090\001\066\001\067\001\068\001\
\255\255\162\005\255\255\097\001\081\001\074\001\167\005\168\005\
\169\005\170\005\255\255\080\001\089\001\090\001\255\255\109\001\
\110\001\255\255\255\255\255\255\097\001\255\255\255\255\092\001\
\255\255\255\255\255\255\096\001\255\255\255\255\255\255\108\001\
\109\001\110\001\255\255\255\255\255\255\255\255\255\255\108\001\
\255\255\255\255\111\001\255\255\255\255\255\255\255\255\255\255\
\122\004\123\004\255\255\255\255\255\255\127\004\128\004\129\004\
\000\001\001\001\002\001\003\001\255\255\000\000\006\001\007\001\
\008\001\009\001\010\001\011\001\012\001\013\001\014\001\015\001\
\016\001\017\001\018\001\019\001\020\001\021\001\022\001\255\255\
\024\001\025\001\026\001\027\001\028\001\029\001\030\001\031\001\
\255\255\255\255\255\255\255\255\036\001\037\001\255\255\255\255\
\040\001\041\001\042\001\043\001\044\001\045\001\046\001\047\001\
\255\255\049\001\050\001\051\001\255\255\053\001\054\001\055\001\
\056\001\255\255\255\255\059\001\060\001\061\001\062\001\063\001\
\064\001\065\001\066\001\067\001\068\001\255\255\070\001\071\001\
\072\001\073\001\074\001\255\255\255\255\255\255\255\255\255\255\
\080\001\081\001\082\001\083\001\084\001\085\001\086\001\087\001\
\255\255\089\001\255\255\091\001\092\001\255\255\094\001\095\001\
\096\001\097\001\098\001\255\255\100\001\101\001\255\255\103\001\
\104\001\105\001\106\001\255\255\108\001\109\001\255\255\111\001\
\255\255\255\255\255\255\115\001\255\255\255\255\255\255\255\255\
\255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\000\001\001\001\002\001\003\001\255\255\255\255\006\001\
\007\001\008\001\009\001\010\001\011\001\012\001\013\001\014\001\
\015\001\016\001\017\001\018\001\019\001\020\001\021\001\022\001\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\030\001\
\031\001\255\255\052\005\053\005\054\005\036\001\037\001\255\255\
\255\255\040\001\041\001\042\001\043\001\044\001\045\001\046\001\
\047\001\255\255\049\001\050\001\051\001\255\255\053\001\054\001\
\055\001\056\001\255\255\255\255\059\001\060\001\061\001\255\255\
\063\001\064\001\065\001\066\001\067\001\068\001\255\255\070\001\
\071\001\072\001\073\001\074\001\255\255\255\255\255\255\255\255\
\255\255\080\001\081\001\082\001\083\001\084\001\085\001\086\001\
\087\001\255\255\089\001\255\255\091\001\092\001\000\000\094\001\
\095\001\096\001\097\001\098\001\255\255\100\001\101\001\255\255\
\103\001\104\001\105\001\106\001\255\255\108\001\109\001\255\255\
\111\001\255\255\255\255\255\255\115\001\000\001\001\001\002\001\
\003\001\255\255\255\255\006\001\007\001\008\001\009\001\010\001\
\011\001\012\001\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\022\001\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\030\001\031\001\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\045\001\046\001\047\001\255\255\049\001\050\001\
\051\001\255\255\053\001\054\001\055\001\056\001\255\255\255\255\
\059\001\060\001\061\001\255\255\063\001\064\001\065\001\066\001\
\067\001\068\001\255\255\070\001\071\001\072\001\073\001\074\001\
\255\255\255\255\255\255\255\255\255\255\080\001\081\001\082\001\
\083\001\084\001\085\001\086\001\087\001\255\255\089\001\255\255\
\091\001\092\001\000\000\094\001\095\001\096\001\097\001\098\001\
\255\255\100\001\101\001\255\255\103\001\104\001\105\001\106\001\
\255\255\108\001\109\001\255\255\111\001\255\255\255\255\255\255\
\115\001\000\001\001\001\002\001\003\001\255\255\255\255\006\001\
\007\001\008\001\009\001\010\001\011\001\012\001\013\001\014\001\
\015\001\016\001\017\001\018\001\019\001\020\001\021\001\022\001\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\030\001\
\031\001\255\255\255\255\255\255\255\255\036\001\037\001\255\255\
\255\255\040\001\041\001\042\001\043\001\044\001\045\001\046\001\
\047\001\255\255\049\001\050\001\051\001\255\255\053\001\054\001\
\055\001\056\001\255\255\255\255\059\001\060\001\061\001\255\255\
\063\001\064\001\065\001\066\001\067\001\068\001\255\255\070\001\
\071\001\072\001\073\001\074\001\255\255\255\255\255\255\255\255\
\255\255\080\001\081\001\082\001\083\001\084\001\085\001\086\001\
\087\001\255\255\089\001\255\255\091\001\092\001\000\000\094\001\
\095\001\096\001\097\001\098\001\255\255\100\001\101\001\255\255\
\103\001\104\001\105\001\106\001\255\255\108\001\109\001\255\255\
\111\001\255\255\255\255\255\255\115\001\255\255\000\001\001\001\
\002\001\003\001\255\255\255\255\006\001\007\001\008\001\009\001\
\010\001\011\001\012\001\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\022\001\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\030\001\031\001\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\045\001\046\001\047\001\255\255\049\001\
\050\001\051\001\255\255\053\001\054\001\055\001\056\001\255\255\
\255\255\059\001\060\001\061\001\255\255\063\001\064\001\065\001\
\066\001\067\001\068\001\255\255\070\001\071\001\072\001\073\001\
\074\001\255\255\255\255\255\255\255\255\255\255\080\001\081\001\
\082\001\083\001\084\001\085\001\086\001\087\001\255\255\089\001\
\255\255\091\001\092\001\000\000\094\001\095\001\096\001\097\001\
\098\001\255\255\100\001\101\001\255\255\103\001\104\001\105\001\
\106\001\255\255\108\001\109\001\255\255\111\001\255\255\255\255\
\255\255\115\001\000\001\001\001\002\001\003\001\255\255\255\255\
\006\001\007\001\008\001\009\001\010\001\011\001\012\001\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\022\001\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\030\001\031\001\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\046\001\047\001\255\255\049\001\050\001\051\001\255\255\053\001\
\054\001\055\001\056\001\255\255\255\255\059\001\060\001\061\001\
\255\255\063\001\064\001\065\001\066\001\067\001\068\001\255\255\
\070\001\071\001\072\001\073\001\074\001\255\255\255\255\255\255\
\255\255\255\255\080\001\081\001\082\001\083\001\084\001\085\001\
\086\001\087\001\255\255\089\001\255\255\091\001\092\001\000\000\
\094\001\095\001\096\001\097\001\098\001\255\255\100\001\101\001\
\255\255\103\001\104\001\105\001\106\001\255\255\108\001\109\001\
\255\255\111\001\255\255\255\255\255\255\115\001\000\001\001\001\
\002\001\003\001\255\255\255\255\006\001\007\001\008\001\009\001\
\010\001\011\001\012\001\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\022\001\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\030\001\031\001\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\045\001\046\001\047\001\255\255\049\001\
\050\001\051\001\255\255\053\001\054\001\055\001\056\001\255\255\
\255\255\059\001\060\001\061\001\255\255\063\001\064\001\065\001\
\066\001\067\001\068\001\255\255\070\001\071\001\072\001\073\001\
\074\001\255\255\255\255\255\255\255\255\255\255\080\001\081\001\
\082\001\083\001\084\001\085\001\086\001\087\001\255\255\089\001\
\255\255\091\001\092\001\000\000\094\001\095\001\096\001\097\001\
\098\001\255\255\100\001\101\001\255\255\103\001\104\001\105\001\
\106\001\255\255\108\001\109\001\255\255\111\001\255\255\255\255\
\255\255\115\001\255\255\000\001\001\001\002\001\003\001\255\255\
\255\255\006\001\007\001\008\001\009\001\010\001\011\001\012\001\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\022\001\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\030\001\031\001\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\045\001\046\001\047\001\255\255\049\001\050\001\051\001\255\255\
\053\001\054\001\055\001\056\001\255\255\255\255\059\001\060\001\
\061\001\255\255\063\001\064\001\065\001\066\001\067\001\068\001\
\255\255\070\001\071\001\072\001\073\001\074\001\255\255\255\255\
\255\255\255\255\255\255\080\001\081\001\082\001\083\001\084\001\
\085\001\086\001\087\001\255\255\089\001\255\255\091\001\092\001\
\000\000\094\001\095\001\096\001\097\001\098\001\255\255\100\001\
\101\001\255\255\103\001\104\001\105\001\106\001\255\255\108\001\
\109\001\255\255\111\001\255\255\255\255\255\255\115\001\000\001\
\001\001\002\001\003\001\255\255\255\255\006\001\007\001\008\001\
\009\001\010\001\011\001\012\001\013\001\014\001\015\001\016\001\
\017\001\018\001\019\001\020\001\021\001\022\001\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\030\001\031\001\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\043\001\044\001\045\001\046\001\047\001\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\055\001\056\001\
\255\255\255\255\059\001\060\001\061\001\255\255\063\001\064\001\
\065\001\066\001\067\001\068\001\255\255\070\001\071\001\072\001\
\073\001\074\001\255\255\255\255\255\255\255\255\255\255\080\001\
\081\001\082\001\083\001\084\001\085\001\086\001\087\001\255\255\
\089\001\255\255\091\001\092\001\000\000\094\001\095\001\096\001\
\097\001\098\001\255\255\100\001\101\001\255\255\103\001\104\001\
\105\001\106\001\255\255\108\001\109\001\255\255\111\001\255\255\
\255\255\255\255\115\001\000\001\001\001\002\001\003\001\255\255\
\255\255\006\001\007\001\008\001\009\001\010\001\011\001\012\001\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\022\001\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\030\001\031\001\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\045\001\046\001\047\001\255\255\049\001\050\001\051\001\255\255\
\053\001\054\001\055\001\056\001\255\255\255\255\059\001\060\001\
\061\001\255\255\063\001\064\001\065\001\066\001\067\001\068\001\
\255\255\070\001\071\001\072\001\073\001\074\001\255\255\255\255\
\255\255\255\255\255\255\080\001\081\001\082\001\083\001\084\001\
\085\001\086\001\087\001\255\255\089\001\255\255\091\001\092\001\
\000\000\094\001\095\001\096\001\097\001\098\001\255\255\100\001\
\101\001\255\255\103\001\104\001\105\001\106\001\255\255\108\001\
\109\001\255\255\111\001\255\255\255\255\255\255\115\001\255\255\
\000\001\001\001\002\001\003\001\255\255\255\255\006\001\007\001\
\008\001\009\001\010\001\011\001\012\001\013\001\014\001\015\001\
\016\001\017\001\018\001\019\001\020\001\021\001\255\255\255\255\
\024\001\025\001\026\001\027\001\028\001\029\001\030\001\031\001\
\255\255\255\255\255\255\255\255\036\001\037\001\255\255\255\255\
\040\001\041\001\042\001\043\001\044\001\045\001\046\001\255\255\
\255\255\049\001\050\001\051\001\255\255\053\001\054\001\055\001\
\056\001\255\255\255\255\059\001\060\001\061\001\255\255\063\001\
\064\001\065\001\066\001\067\001\068\001\255\255\070\001\071\001\
\072\001\073\001\074\001\255\255\255\255\255\255\255\255\255\255\
\080\001\081\001\082\001\083\001\084\001\085\001\086\001\087\001\
\255\255\089\001\255\255\091\001\092\001\000\000\094\001\095\001\
\096\001\097\001\098\001\255\255\100\001\101\001\255\255\103\001\
\104\001\105\001\106\001\255\255\108\001\109\001\255\255\111\001\
\255\255\255\255\255\255\115\001\000\001\001\001\002\001\003\001\
\255\255\255\255\006\001\007\001\008\001\009\001\010\001\011\001\
\012\001\013\001\014\001\015\001\016\001\017\001\018\001\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\027\001\
\028\001\029\001\030\001\031\001\255\255\255\255\255\255\255\255\
\036\001\037\001\255\255\255\255\040\001\041\001\042\001\043\001\
\044\001\045\001\046\001\255\255\255\255\049\001\050\001\051\001\
\255\255\053\001\054\001\055\001\056\001\255\255\255\255\059\001\
\060\001\061\001\255\255\063\001\064\001\065\001\066\001\067\001\
\068\001\255\255\070\001\071\001\072\001\073\001\074\001\255\255\
\255\255\255\255\255\255\255\255\080\001\081\001\082\001\083\001\
\084\001\085\001\086\001\087\001\255\255\089\001\255\255\091\001\
\092\001\000\000\094\001\095\001\096\001\255\255\255\255\255\255\
\100\001\101\001\255\255\103\001\104\001\105\001\106\001\255\255\
\108\001\109\001\255\255\111\001\255\255\255\255\255\255\115\001\
\000\001\001\001\002\001\003\001\255\255\255\255\006\001\007\001\
\008\001\009\001\010\001\011\001\012\001\013\001\014\001\015\001\
\016\001\017\001\018\001\019\001\020\001\021\001\255\255\255\255\
\024\001\025\001\026\001\027\001\028\001\029\001\030\001\031\001\
\255\255\255\255\255\255\255\255\036\001\037\001\255\255\255\255\
\040\001\041\001\042\001\043\001\044\001\045\001\046\001\255\255\
\255\255\049\001\050\001\051\001\255\255\053\001\054\001\055\001\
\056\001\255\255\255\255\059\001\060\001\061\001\255\255\063\001\
\064\001\065\001\066\001\067\001\068\001\255\255\070\001\071\001\
\072\001\073\001\074\001\255\255\255\255\255\255\255\255\255\255\
\080\001\081\001\082\001\083\001\084\001\085\001\086\001\087\001\
\255\255\089\001\255\255\091\001\092\001\000\000\094\001\095\001\
\096\001\255\255\255\255\255\255\100\001\101\001\255\255\103\001\
\104\001\105\001\106\001\255\255\108\001\109\001\255\255\111\001\
\255\255\255\255\255\255\115\001\255\255\000\001\001\001\002\001\
\003\001\255\255\255\255\006\001\007\001\008\001\009\001\010\001\
\011\001\012\001\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\030\001\031\001\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\045\001\046\001\255\255\255\255\049\001\050\001\
\051\001\255\255\053\001\054\001\055\001\056\001\255\255\255\255\
\059\001\060\001\061\001\255\255\063\001\064\001\065\001\066\001\
\067\001\068\001\255\255\070\001\071\001\072\001\073\001\074\001\
\255\255\255\255\255\255\255\255\255\255\080\001\081\001\082\001\
\083\001\084\001\085\001\086\001\087\001\255\255\089\001\255\255\
\091\001\092\001\000\000\094\001\095\001\096\001\255\255\255\255\
\255\255\100\001\101\001\255\255\103\001\104\001\105\001\106\001\
\255\255\108\001\109\001\255\255\111\001\255\255\255\255\255\255\
\115\001\000\001\001\001\002\001\003\001\255\255\255\255\255\255\
\255\255\008\001\009\001\010\001\255\255\255\255\013\001\014\001\
\015\001\016\001\017\001\018\001\019\001\020\001\021\001\022\001\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\036\001\037\001\255\255\
\255\255\040\001\041\001\042\001\043\001\044\001\045\001\046\001\
\047\001\255\255\049\001\255\255\051\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\060\001\061\001\255\255\
\063\001\255\255\255\255\066\001\067\001\068\001\255\255\070\001\
\071\001\072\001\073\001\074\001\255\255\255\255\255\255\255\255\
\255\255\080\001\081\001\082\001\083\001\084\001\085\001\086\001\
\255\255\255\255\089\001\255\255\091\001\092\001\000\000\094\001\
\095\001\096\001\097\001\098\001\255\255\100\001\255\255\255\255\
\103\001\104\001\105\001\255\255\255\255\108\001\255\255\255\255\
\111\001\255\255\255\255\255\255\115\001\000\001\001\001\002\001\
\003\001\255\255\255\255\255\255\255\255\008\001\009\001\010\001\
\255\255\255\255\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\022\001\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\045\001\046\001\047\001\255\255\049\001\255\255\
\051\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\060\001\061\001\255\255\063\001\255\255\255\255\066\001\
\067\001\068\001\255\255\070\001\071\001\072\001\073\001\074\001\
\255\255\255\255\255\255\255\255\255\255\080\001\081\001\082\001\
\083\001\084\001\085\001\086\001\255\255\255\255\089\001\255\255\
\091\001\092\001\000\000\094\001\095\001\096\001\097\001\098\001\
\255\255\100\001\255\255\255\255\103\001\104\001\105\001\255\255\
\255\255\108\001\255\255\255\255\111\001\255\255\255\255\255\255\
\115\001\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\046\001\255\255\255\255\049\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\060\001\061\001\
\255\255\063\001\255\255\255\255\066\001\067\001\068\001\255\255\
\070\001\071\001\072\001\073\001\074\001\255\255\255\255\255\255\
\255\255\255\255\080\001\255\255\082\001\083\001\084\001\085\001\
\086\001\255\255\255\255\255\255\255\255\091\001\092\001\000\000\
\094\001\095\001\096\001\255\255\255\255\255\255\100\001\255\255\
\255\255\103\001\255\255\105\001\255\255\255\255\108\001\255\255\
\255\255\111\001\255\255\255\255\255\255\115\001\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\008\001\009\001\
\010\001\255\255\255\255\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\045\001\046\001\255\255\255\255\049\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\060\001\061\001\255\255\063\001\255\255\255\255\
\066\001\067\001\068\001\255\255\070\001\071\001\072\001\073\001\
\074\001\255\255\255\255\255\255\255\255\255\255\080\001\255\255\
\082\001\083\001\084\001\085\001\086\001\255\255\255\255\255\255\
\255\255\091\001\092\001\000\000\094\001\095\001\096\001\255\255\
\255\255\255\255\100\001\255\255\255\255\103\001\255\255\105\001\
\255\255\255\255\108\001\255\255\255\255\111\001\255\255\255\255\
\255\255\115\001\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\046\001\255\255\255\255\049\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\060\001\061\001\
\255\255\063\001\255\255\255\255\066\001\067\001\068\001\255\255\
\070\001\071\001\072\001\073\001\074\001\255\255\255\255\255\255\
\255\255\255\255\080\001\255\255\082\001\083\001\084\001\085\001\
\086\001\255\255\255\255\255\255\255\255\091\001\092\001\000\000\
\094\001\095\001\096\001\255\255\255\255\255\255\100\001\255\255\
\255\255\103\001\255\255\105\001\255\255\255\255\108\001\255\255\
\255\255\111\001\255\255\255\255\255\255\115\001\255\255\000\001\
\001\001\002\001\003\001\255\255\255\255\255\255\255\255\008\001\
\009\001\010\001\255\255\255\255\013\001\014\001\015\001\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\043\001\044\001\045\001\046\001\255\255\255\255\
\049\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\060\001\061\001\255\255\063\001\255\255\
\255\255\066\001\067\001\068\001\255\255\070\001\071\001\072\001\
\073\001\074\001\255\255\255\255\255\255\255\255\255\255\080\001\
\255\255\082\001\083\001\084\001\085\001\086\001\255\255\255\255\
\255\255\255\255\091\001\092\001\000\000\094\001\095\001\096\001\
\255\255\255\255\255\255\100\001\255\255\255\255\103\001\255\255\
\105\001\255\255\255\255\108\001\255\255\255\255\111\001\255\255\
\255\255\255\255\115\001\000\001\001\001\002\001\003\001\255\255\
\255\255\255\255\255\255\008\001\009\001\010\001\255\255\255\255\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\255\255\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\045\001\046\001\255\255\255\255\049\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\060\001\
\061\001\255\255\063\001\255\255\255\255\066\001\067\001\068\001\
\255\255\070\001\071\001\072\001\073\001\074\001\255\255\255\255\
\255\255\255\255\255\255\080\001\255\255\082\001\083\001\084\001\
\085\001\086\001\255\255\255\255\255\255\255\255\091\001\092\001\
\000\000\094\001\095\001\096\001\255\255\255\255\255\255\100\001\
\255\255\255\255\103\001\255\255\105\001\255\255\255\255\108\001\
\255\255\255\255\111\001\255\255\255\255\255\255\115\001\000\001\
\001\001\002\001\003\001\255\255\255\255\255\255\255\255\008\001\
\009\001\010\001\255\255\255\255\013\001\014\001\015\001\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\043\001\044\001\045\001\046\001\255\255\255\255\
\049\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\060\001\061\001\255\255\063\001\255\255\
\255\255\066\001\067\001\068\001\255\255\070\001\071\001\072\001\
\073\001\074\001\255\255\255\255\255\255\255\255\255\255\080\001\
\255\255\082\001\083\001\084\001\085\001\086\001\255\255\255\255\
\255\255\255\255\091\001\092\001\000\000\094\001\095\001\096\001\
\255\255\255\255\255\255\100\001\255\255\255\255\103\001\255\255\
\105\001\255\255\255\255\108\001\255\255\255\255\111\001\255\255\
\255\255\255\255\115\001\255\255\000\001\001\001\002\001\003\001\
\255\255\255\255\255\255\255\255\008\001\009\001\010\001\255\255\
\255\255\013\001\014\001\015\001\016\001\017\001\255\255\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\027\001\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\036\001\037\001\255\255\255\255\040\001\041\001\042\001\043\001\
\044\001\045\001\046\001\255\255\255\255\049\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\060\001\061\001\255\255\063\001\255\255\255\255\066\001\067\001\
\068\001\255\255\070\001\071\001\072\001\073\001\074\001\255\255\
\255\255\255\255\255\255\255\255\080\001\255\255\082\001\083\001\
\084\001\085\001\086\001\255\255\255\255\255\255\255\255\091\001\
\092\001\000\000\094\001\095\001\096\001\255\255\255\255\255\255\
\100\001\255\255\255\255\103\001\255\255\105\001\255\255\255\255\
\108\001\255\255\255\255\111\001\255\255\255\255\255\255\115\001\
\000\001\001\001\002\001\003\001\255\255\255\255\255\255\255\255\
\008\001\009\001\010\001\255\255\255\255\013\001\014\001\015\001\
\016\001\017\001\018\001\019\001\020\001\021\001\255\255\255\255\
\024\001\025\001\026\001\027\001\028\001\029\001\255\255\255\255\
\255\255\255\255\255\255\255\255\036\001\037\001\255\255\255\255\
\040\001\041\001\042\001\043\001\044\001\045\001\255\255\255\255\
\255\255\049\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\060\001\061\001\255\255\063\001\
\255\255\255\255\066\001\067\001\068\001\255\255\070\001\071\001\
\072\001\073\001\074\001\255\255\255\255\255\255\255\255\255\255\
\080\001\255\255\082\001\083\001\084\001\085\001\086\001\255\255\
\255\255\255\255\255\255\091\001\092\001\000\000\094\001\095\001\
\096\001\255\255\255\255\255\255\100\001\255\255\255\255\103\001\
\255\255\105\001\255\255\255\255\108\001\255\255\255\255\111\001\
\255\255\255\255\255\255\115\001\000\001\001\001\002\001\003\001\
\255\255\255\255\255\255\255\255\008\001\009\001\010\001\255\255\
\255\255\013\001\014\001\015\001\016\001\017\001\018\001\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\027\001\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\036\001\037\001\255\255\255\255\040\001\041\001\042\001\043\001\
\044\001\045\001\255\255\255\255\255\255\049\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\060\001\061\001\255\255\063\001\255\255\255\255\066\001\067\001\
\068\001\255\255\070\001\071\001\072\001\073\001\074\001\255\255\
\255\255\255\255\255\255\255\255\080\001\255\255\082\001\083\001\
\084\001\085\001\086\001\255\255\255\255\255\255\255\255\091\001\
\092\001\000\000\094\001\095\001\096\001\255\255\255\255\255\255\
\100\001\255\255\255\255\103\001\255\255\105\001\255\255\255\255\
\108\001\255\255\255\255\111\001\255\255\255\255\255\255\115\001\
\255\255\000\001\001\001\002\001\003\001\255\255\255\255\255\255\
\255\255\008\001\009\001\010\001\255\255\255\255\013\001\014\001\
\015\001\016\001\017\001\018\001\019\001\020\001\021\001\255\255\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\036\001\037\001\255\255\
\255\255\040\001\041\001\042\001\043\001\044\001\045\001\255\255\
\255\255\255\255\049\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\060\001\061\001\255\255\
\063\001\255\255\255\255\066\001\067\001\068\001\255\255\070\001\
\071\001\072\001\073\001\074\001\255\255\255\255\255\255\255\255\
\255\255\080\001\255\255\082\001\083\001\084\001\085\001\086\001\
\255\255\255\255\255\255\255\255\091\001\092\001\000\000\094\001\
\095\001\096\001\255\255\255\255\255\255\100\001\255\255\255\255\
\103\001\255\255\105\001\255\255\255\255\108\001\255\255\255\255\
\111\001\255\255\255\255\255\255\115\001\000\001\001\001\002\001\
\003\001\255\255\255\255\255\255\255\255\008\001\009\001\010\001\
\255\255\255\255\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\045\001\255\255\255\255\255\255\049\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\060\001\061\001\255\255\063\001\255\255\255\255\066\001\
\067\001\068\001\255\255\070\001\071\001\072\001\073\001\074\001\
\255\255\255\255\255\255\255\255\255\255\080\001\255\255\082\001\
\083\001\084\001\085\001\086\001\255\255\255\255\255\255\255\255\
\091\001\092\001\000\000\094\001\095\001\096\001\255\255\255\255\
\255\255\100\001\255\255\255\255\103\001\255\255\105\001\255\255\
\255\255\108\001\255\255\255\255\111\001\255\255\255\255\255\255\
\115\001\000\001\001\001\002\001\003\001\255\255\255\255\255\255\
\255\255\255\255\009\001\010\001\255\255\255\255\013\001\014\001\
\015\001\016\001\017\001\018\001\019\001\020\001\021\001\255\255\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\036\001\037\001\255\255\
\255\255\040\001\041\001\042\001\043\001\044\001\045\001\046\001\
\255\255\255\255\049\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\060\001\061\001\255\255\
\063\001\255\255\255\255\066\001\067\001\068\001\255\255\070\001\
\071\001\072\001\073\001\074\001\255\255\255\255\255\255\255\255\
\255\255\080\001\255\255\082\001\083\001\084\001\085\001\086\001\
\255\255\255\255\255\255\255\255\091\001\092\001\000\000\094\001\
\095\001\096\001\255\255\255\255\255\255\100\001\255\255\255\255\
\103\001\255\255\105\001\255\255\255\255\108\001\255\255\255\255\
\111\001\255\255\255\255\255\255\115\001\255\255\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\255\255\009\001\
\010\001\255\255\255\255\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\045\001\046\001\255\255\255\255\049\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\060\001\061\001\255\255\063\001\255\255\255\255\
\066\001\067\001\068\001\255\255\070\001\071\001\072\001\073\001\
\074\001\255\255\255\255\255\255\255\255\255\255\080\001\255\255\
\082\001\083\001\084\001\085\001\086\001\255\255\255\255\255\255\
\255\255\091\001\092\001\000\000\094\001\095\001\096\001\255\255\
\255\255\255\255\100\001\255\255\255\255\103\001\255\255\105\001\
\255\255\255\255\108\001\255\255\255\255\111\001\255\255\255\255\
\255\255\115\001\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\255\255\009\001\010\001\255\255\255\255\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\046\001\255\255\255\255\049\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\060\001\061\001\
\255\255\063\001\255\255\255\255\066\001\067\001\068\001\255\255\
\070\001\071\001\072\001\073\001\074\001\255\255\255\255\255\255\
\255\255\255\255\080\001\255\255\082\001\083\001\084\001\085\001\
\086\001\255\255\255\255\255\255\255\255\091\001\092\001\000\000\
\094\001\095\001\096\001\255\255\255\255\255\255\100\001\255\255\
\255\255\103\001\255\255\105\001\255\255\255\255\108\001\255\255\
\255\255\111\001\255\255\255\255\255\255\115\001\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\008\001\009\001\
\010\001\255\255\255\255\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\255\255\255\255\255\255\255\255\049\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\060\001\061\001\255\255\063\001\255\255\255\255\
\066\001\067\001\068\001\255\255\070\001\071\001\072\001\073\001\
\074\001\255\255\255\255\255\255\255\255\255\255\080\001\255\255\
\082\001\255\255\084\001\085\001\086\001\255\255\255\255\255\255\
\255\255\091\001\092\001\000\000\094\001\095\001\096\001\255\255\
\255\255\255\255\255\255\255\255\255\255\103\001\255\255\105\001\
\255\255\255\255\108\001\255\255\255\255\111\001\255\255\255\255\
\255\255\115\001\255\255\000\001\001\001\002\001\003\001\255\255\
\255\255\255\255\255\255\008\001\009\001\010\001\255\255\255\255\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\255\255\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\255\255\255\255\255\255\255\255\049\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\060\001\
\061\001\255\255\063\001\255\255\255\255\066\001\067\001\068\001\
\255\255\070\001\071\001\072\001\073\001\074\001\255\255\255\255\
\255\255\255\255\255\255\080\001\255\255\082\001\255\255\084\001\
\085\001\086\001\255\255\255\255\255\255\255\255\091\001\092\001\
\000\000\094\001\095\001\096\001\255\255\255\255\255\255\255\255\
\255\255\255\255\103\001\255\255\105\001\255\255\255\255\108\001\
\255\255\255\255\111\001\255\255\255\255\255\255\115\001\000\001\
\001\001\002\001\003\001\255\255\255\255\255\255\255\255\008\001\
\009\001\010\001\255\255\255\255\013\001\014\001\015\001\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\043\001\044\001\255\255\255\255\255\255\255\255\
\049\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\060\001\061\001\255\255\063\001\255\255\
\255\255\066\001\067\001\068\001\255\255\070\001\071\001\072\001\
\073\001\074\001\255\255\255\255\255\255\255\255\255\255\080\001\
\255\255\082\001\255\255\084\001\085\001\086\001\255\255\255\255\
\255\255\255\255\091\001\092\001\000\000\094\001\095\001\096\001\
\255\255\255\255\255\255\255\255\255\255\255\255\103\001\255\255\
\105\001\255\255\255\255\108\001\255\255\255\255\111\001\255\255\
\255\255\255\255\115\001\000\001\001\001\002\001\003\001\255\255\
\255\255\255\255\255\255\008\001\009\001\010\001\255\255\255\255\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\255\255\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\255\255\255\255\255\255\255\255\049\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\060\001\
\061\001\255\255\063\001\255\255\255\255\066\001\067\001\068\001\
\255\255\070\001\071\001\072\001\073\001\074\001\255\255\255\255\
\255\255\255\255\255\255\080\001\255\255\082\001\255\255\084\001\
\085\001\086\001\255\255\255\255\255\255\255\255\091\001\092\001\
\000\000\094\001\095\001\096\001\255\255\255\255\255\255\255\255\
\255\255\255\255\103\001\255\255\105\001\255\255\255\255\108\001\
\255\255\255\255\111\001\255\255\255\255\255\255\115\001\255\255\
\000\001\001\001\002\001\003\001\255\255\255\255\255\255\255\255\
\008\001\009\001\010\001\255\255\255\255\013\001\014\001\015\001\
\016\001\017\001\018\001\019\001\020\001\021\001\255\255\255\255\
\024\001\025\001\026\001\027\001\028\001\029\001\255\255\255\255\
\255\255\255\255\255\255\255\255\036\001\037\001\255\255\255\255\
\040\001\041\001\042\001\043\001\044\001\255\255\255\255\255\255\
\255\255\049\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\060\001\061\001\255\255\063\001\
\255\255\255\255\066\001\067\001\068\001\255\255\070\001\071\001\
\072\001\073\001\074\001\255\255\255\255\255\255\255\255\255\255\
\080\001\255\255\082\001\255\255\084\001\085\001\086\001\255\255\
\255\255\255\255\255\255\091\001\092\001\000\000\094\001\095\001\
\096\001\255\255\255\255\255\255\255\255\255\255\255\255\103\001\
\255\255\105\001\255\255\255\255\108\001\255\255\255\255\111\001\
\255\255\255\255\255\255\115\001\000\001\001\001\002\001\003\001\
\255\255\255\255\255\255\255\255\008\001\009\001\010\001\255\255\
\255\255\013\001\014\001\015\001\016\001\017\001\018\001\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\027\001\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\036\001\037\001\255\255\255\255\040\001\041\001\042\001\043\001\
\044\001\255\255\255\255\255\255\255\255\049\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\060\001\061\001\255\255\063\001\255\255\255\255\066\001\067\001\
\068\001\255\255\070\001\071\001\072\001\073\001\074\001\255\255\
\255\255\255\255\255\255\255\255\080\001\255\255\082\001\255\255\
\084\001\085\001\086\001\255\255\255\255\255\255\255\255\091\001\
\092\001\000\000\094\001\095\001\096\001\255\255\255\255\255\255\
\255\255\255\255\255\255\103\001\255\255\105\001\255\255\255\255\
\108\001\255\255\255\255\111\001\255\255\255\255\255\255\115\001\
\000\001\001\001\002\001\003\001\255\255\255\255\255\255\255\255\
\008\001\009\001\010\001\255\255\255\255\013\001\014\001\015\001\
\016\001\017\001\018\001\019\001\020\001\021\001\255\255\255\255\
\024\001\025\001\026\001\027\001\028\001\029\001\255\255\255\255\
\255\255\255\255\255\255\255\255\036\001\037\001\255\255\255\255\
\040\001\041\001\042\001\043\001\044\001\045\001\046\001\255\255\
\255\255\049\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\060\001\061\001\255\255\255\255\
\255\255\255\255\066\001\067\001\068\001\255\255\070\001\255\255\
\255\255\073\001\074\001\255\255\255\255\255\255\255\255\255\255\
\080\001\255\255\082\001\255\255\255\255\255\255\086\001\255\255\
\255\255\255\255\255\255\091\001\092\001\000\000\094\001\095\001\
\096\001\255\255\255\255\255\255\100\001\255\255\255\255\103\001\
\255\255\105\001\255\255\255\255\108\001\255\255\255\255\111\001\
\255\255\255\255\255\255\115\001\255\255\000\001\001\001\002\001\
\003\001\255\255\255\255\255\255\255\255\008\001\009\001\010\001\
\255\255\255\255\013\001\014\001\255\255\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\255\255\255\255\255\255\255\255\255\255\049\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\060\001\061\001\255\255\063\001\255\255\255\255\066\001\
\067\001\068\001\255\255\070\001\255\255\255\255\073\001\074\001\
\255\255\255\255\255\255\255\255\255\255\080\001\255\255\082\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\091\001\092\001\000\000\094\001\095\001\096\001\255\255\255\255\
\255\255\255\255\255\255\255\255\103\001\255\255\105\001\255\255\
\255\255\108\001\255\255\255\255\111\001\255\255\255\255\255\255\
\115\001\000\001\001\001\002\001\003\001\255\255\255\255\255\255\
\255\255\008\001\009\001\010\001\255\255\255\255\013\001\014\001\
\255\255\016\001\017\001\018\001\019\001\020\001\021\001\255\255\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\036\001\037\001\255\255\
\255\255\040\001\041\001\042\001\255\255\255\255\255\255\255\255\
\255\255\255\255\049\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\060\001\061\001\255\255\
\063\001\255\255\255\255\255\255\067\001\068\001\255\255\070\001\
\255\255\255\255\073\001\074\001\255\255\255\255\255\255\255\255\
\255\255\080\001\255\255\082\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\091\001\092\001\000\000\094\001\
\095\001\096\001\255\255\255\255\255\255\255\255\255\255\255\255\
\103\001\255\255\105\001\255\255\255\255\108\001\255\255\255\255\
\111\001\255\255\255\255\255\255\115\001\000\001\001\001\002\001\
\003\001\255\255\255\255\255\255\255\255\008\001\009\001\010\001\
\255\255\255\255\013\001\014\001\255\255\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\255\255\255\255\255\255\255\255\255\255\255\255\049\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\060\001\061\001\255\255\063\001\255\255\255\255\255\255\
\067\001\068\001\255\255\070\001\255\255\255\255\073\001\074\001\
\255\255\255\255\255\255\255\255\255\255\080\001\255\255\082\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\091\001\092\001\000\000\094\001\095\001\096\001\255\255\255\255\
\255\255\255\255\255\255\255\255\103\001\255\255\105\001\255\255\
\255\255\108\001\255\255\255\255\111\001\255\255\255\255\255\255\
\115\001\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\255\255\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\255\255\255\255\255\255\
\255\255\255\255\255\255\049\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\060\001\061\001\
\255\255\063\001\255\255\255\255\255\255\067\001\068\001\255\255\
\070\001\255\255\255\255\073\001\074\001\255\255\255\255\255\255\
\255\255\255\255\080\001\255\255\082\001\255\255\255\255\000\000\
\255\255\255\255\255\255\255\255\255\255\091\001\092\001\255\255\
\094\001\095\001\096\001\255\255\255\255\255\255\255\255\255\255\
\255\255\103\001\255\255\105\001\255\255\255\255\108\001\255\255\
\255\255\111\001\255\255\255\255\255\255\115\001\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\008\001\009\001\
\010\001\255\255\255\255\013\001\014\001\255\255\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\255\255\255\255\255\255\255\255\255\255\255\255\049\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\060\001\061\001\255\255\063\001\255\255\255\255\
\255\255\067\001\068\001\255\255\070\001\255\255\255\255\073\001\
\074\001\255\255\255\255\255\255\000\000\255\255\080\001\255\255\
\082\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\091\001\092\001\255\255\094\001\095\001\096\001\255\255\
\255\255\255\255\255\255\255\255\255\255\103\001\255\255\105\001\
\255\255\255\255\108\001\255\255\255\255\111\001\255\255\255\255\
\255\255\115\001\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\255\255\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\255\255\255\255\255\255\
\255\255\255\255\255\255\049\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\060\001\061\001\
\255\255\063\001\255\255\255\255\000\000\067\001\068\001\255\255\
\070\001\255\255\255\255\073\001\074\001\255\255\255\255\255\255\
\255\255\255\255\080\001\255\255\082\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\091\001\092\001\255\255\
\094\001\095\001\096\001\255\255\255\255\255\255\255\255\255\255\
\255\255\103\001\255\255\105\001\255\255\255\255\108\001\000\001\
\255\255\111\001\003\001\255\255\255\255\115\001\255\255\008\001\
\009\001\010\001\255\255\255\255\013\001\014\001\255\255\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\255\255\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\037\001\255\255\255\255\040\001\
\041\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\049\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\060\001\000\000\255\255\063\001\255\255\
\255\255\255\255\067\001\068\001\255\255\070\001\255\255\255\255\
\073\001\074\001\255\255\255\255\255\255\255\255\255\255\080\001\
\255\255\082\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\091\001\092\001\255\255\094\001\095\001\096\001\
\255\255\255\255\255\255\255\255\255\255\255\255\103\001\255\255\
\105\001\255\255\255\255\108\001\000\001\255\255\111\001\003\001\
\255\255\255\255\115\001\255\255\008\001\009\001\010\001\255\255\
\255\255\013\001\014\001\255\255\016\001\017\001\018\001\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\255\255\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\037\001\255\255\255\255\040\001\041\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\255\255\255\255\
\255\255\255\255\255\255\255\255\000\000\255\255\255\255\255\255\
\060\001\255\255\255\255\063\001\255\255\255\255\255\255\067\001\
\068\001\255\255\070\001\255\255\255\255\073\001\074\001\255\255\
\255\255\255\255\255\255\255\255\080\001\255\255\082\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\091\001\
\092\001\255\255\094\001\095\001\096\001\255\255\255\255\255\255\
\255\255\255\255\255\255\103\001\000\001\105\001\255\255\003\001\
\108\001\255\255\255\255\111\001\008\001\255\255\010\001\115\001\
\255\255\013\001\014\001\255\255\016\001\017\001\018\001\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\255\255\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\037\001\255\255\255\255\040\001\041\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\255\255\255\255\
\255\255\255\255\255\255\255\255\000\000\255\255\255\255\255\255\
\060\001\255\255\255\255\063\001\255\255\255\255\255\255\067\001\
\068\001\255\255\070\001\255\255\255\255\073\001\074\001\255\255\
\255\255\255\255\255\255\255\255\080\001\255\255\255\255\255\255\
\255\255\255\255\000\000\255\255\255\255\255\255\255\255\091\001\
\092\001\255\255\094\001\095\001\096\001\255\255\255\255\255\255\
\255\255\255\255\255\255\103\001\000\001\105\001\255\255\003\001\
\108\001\255\255\255\255\111\001\008\001\255\255\010\001\115\001\
\255\255\013\001\014\001\255\255\016\001\017\001\018\001\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\255\255\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\037\001\255\255\255\255\040\001\041\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\255\255\000\000\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\060\001\255\255\255\255\063\001\255\255\255\255\255\255\067\001\
\068\001\255\255\070\001\255\255\255\255\073\001\074\001\255\255\
\255\255\255\255\255\255\255\255\080\001\000\000\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\091\001\
\092\001\255\255\094\001\095\001\096\001\255\255\255\255\255\255\
\255\255\255\255\255\255\103\001\000\001\105\001\255\255\003\001\
\108\001\255\255\255\255\111\001\008\001\255\255\010\001\115\001\
\255\255\013\001\014\001\255\255\016\001\017\001\018\001\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\255\255\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\037\001\255\255\255\255\040\001\041\001\255\255\255\255\
\255\255\255\255\000\000\255\255\255\255\049\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\060\001\255\255\255\255\063\001\255\255\255\255\255\255\067\001\
\068\001\255\255\070\001\255\255\255\255\073\001\074\001\255\255\
\255\255\255\255\255\255\255\255\080\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\091\001\
\092\001\255\255\094\001\095\001\096\001\255\255\255\255\255\255\
\255\255\255\255\255\255\103\001\000\001\105\001\255\255\003\001\
\108\001\255\255\255\255\111\001\008\001\255\255\010\001\115\001\
\255\255\013\001\014\001\255\255\016\001\017\001\018\001\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\255\255\
\028\001\029\001\000\001\255\255\255\255\255\255\255\255\255\255\
\255\255\037\001\008\001\255\255\040\001\041\001\255\255\013\001\
\255\255\255\255\000\000\255\255\255\255\049\001\255\255\255\255\
\255\255\255\255\255\255\255\255\026\001\255\255\028\001\029\001\
\060\001\255\255\255\255\063\001\255\255\255\255\255\255\067\001\
\068\001\255\255\070\001\041\001\255\255\073\001\074\001\255\255\
\000\000\255\255\255\255\255\255\080\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\060\001\091\001\
\092\001\063\001\094\001\095\001\096\001\067\001\068\001\000\001\
\255\255\255\255\003\001\103\001\074\001\105\001\255\255\008\001\
\108\001\010\001\080\001\111\001\013\001\014\001\255\255\115\001\
\017\001\255\255\019\001\020\001\021\001\255\255\092\001\024\001\
\025\001\026\001\096\001\028\001\029\001\000\001\255\255\255\255\
\255\255\255\255\255\255\255\255\037\001\255\255\108\001\040\001\
\041\001\111\001\013\001\255\255\255\255\000\000\255\255\255\255\
\049\001\255\255\255\255\255\255\255\255\255\255\255\255\026\001\
\255\255\028\001\029\001\060\001\255\255\255\255\063\001\255\255\
\255\255\255\255\067\001\068\001\255\255\070\001\041\001\255\255\
\073\001\074\001\255\255\000\000\255\255\255\255\255\255\080\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\060\001\091\001\092\001\063\001\094\001\095\001\096\001\
\067\001\068\001\000\001\255\255\255\255\003\001\103\001\074\001\
\105\001\255\255\008\001\108\001\010\001\080\001\111\001\013\001\
\014\001\255\255\115\001\017\001\255\255\019\001\020\001\021\001\
\255\255\092\001\024\001\025\001\026\001\096\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\037\001\
\255\255\108\001\040\001\041\001\111\001\255\255\255\255\255\255\
\000\000\255\255\255\255\049\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\060\001\255\255\
\255\255\063\001\255\255\255\255\255\255\067\001\068\001\255\255\
\070\001\255\255\255\255\073\001\074\001\255\255\255\255\255\255\
\255\255\255\255\080\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\091\001\092\001\255\255\
\094\001\095\001\096\001\255\255\255\255\255\255\255\255\255\255\
\255\255\103\001\000\001\105\001\255\255\003\001\108\001\255\255\
\255\255\111\001\008\001\255\255\010\001\115\001\255\255\013\001\
\014\001\255\255\255\255\017\001\255\255\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\255\255\028\001\029\001\
\000\001\255\255\255\255\255\255\255\255\255\255\255\255\037\001\
\255\255\255\255\040\001\041\001\255\255\013\001\255\255\255\255\
\000\000\255\255\255\255\049\001\255\255\255\255\255\255\255\255\
\255\255\255\255\026\001\255\255\028\001\029\001\060\001\255\255\
\255\255\063\001\255\255\255\255\255\255\067\001\068\001\255\255\
\070\001\041\001\255\255\073\001\074\001\255\255\000\000\255\255\
\255\255\255\255\080\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\060\001\091\001\092\001\063\001\
\094\001\095\001\096\001\067\001\068\001\000\001\255\255\255\255\
\003\001\103\001\074\001\105\001\255\255\008\001\108\001\010\001\
\080\001\111\001\013\001\014\001\255\255\115\001\017\001\255\255\
\019\001\020\001\021\001\255\255\092\001\024\001\025\001\026\001\
\096\001\028\001\029\001\000\001\255\255\255\255\003\001\255\255\
\255\255\255\255\037\001\255\255\108\001\040\001\041\001\111\001\
\013\001\255\255\255\255\000\000\255\255\255\255\049\001\255\255\
\255\255\255\255\255\255\255\255\255\255\026\001\255\255\028\001\
\029\001\060\001\255\255\255\255\063\001\255\255\255\255\255\255\
\067\001\068\001\255\255\070\001\041\001\255\255\073\001\074\001\
\255\255\000\000\255\255\255\255\255\255\080\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\060\001\
\091\001\092\001\063\001\094\001\095\001\096\001\255\255\068\001\
\000\001\255\255\255\255\003\001\103\001\074\001\105\001\255\255\
\008\001\108\001\010\001\080\001\111\001\013\001\014\001\255\255\
\115\001\017\001\255\255\019\001\020\001\021\001\255\255\092\001\
\024\001\025\001\026\001\096\001\028\001\029\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\037\001\255\255\108\001\
\040\001\041\001\111\001\255\255\255\255\255\255\000\000\255\255\
\255\255\049\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\060\001\255\255\255\255\063\001\
\255\255\255\255\255\255\067\001\068\001\255\255\070\001\255\255\
\255\255\073\001\074\001\255\255\255\255\255\255\255\255\255\255\
\080\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\091\001\092\001\255\255\094\001\095\001\
\096\001\255\255\255\255\255\255\255\255\255\255\255\255\103\001\
\000\001\105\001\255\255\003\001\108\001\255\255\255\255\111\001\
\008\001\255\255\010\001\115\001\255\255\013\001\014\001\255\255\
\255\255\017\001\255\255\019\001\020\001\021\001\255\255\255\255\
\024\001\025\001\026\001\255\255\028\001\029\001\000\001\255\255\
\255\255\255\255\255\255\255\255\255\255\037\001\255\255\255\255\
\040\001\041\001\255\255\013\001\255\255\255\255\000\000\255\255\
\255\255\049\001\255\255\255\255\255\255\255\255\255\255\255\255\
\026\001\255\255\028\001\029\001\060\001\255\255\255\255\063\001\
\255\255\255\255\255\255\067\001\068\001\255\255\070\001\041\001\
\255\255\073\001\074\001\255\255\000\000\255\255\255\255\255\255\
\080\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\060\001\091\001\092\001\063\001\094\001\095\001\
\096\001\067\001\068\001\000\001\255\255\255\255\003\001\103\001\
\074\001\105\001\255\255\008\001\108\001\010\001\080\001\111\001\
\013\001\014\001\255\255\115\001\017\001\255\255\019\001\020\001\
\021\001\255\255\092\001\024\001\025\001\026\001\096\001\028\001\
\029\001\000\001\255\255\255\255\255\255\255\255\255\255\255\255\
\037\001\255\255\108\001\040\001\041\001\111\001\013\001\255\255\
\255\255\000\000\255\255\255\255\049\001\255\255\255\255\255\255\
\255\255\255\255\255\255\026\001\255\255\028\001\029\001\060\001\
\255\255\255\255\063\001\255\255\255\255\255\255\067\001\068\001\
\255\255\070\001\041\001\255\255\073\001\074\001\255\255\000\000\
\255\255\255\255\255\255\080\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\060\001\091\001\092\001\
\063\001\094\001\095\001\096\001\067\001\068\001\000\001\255\255\
\255\255\003\001\103\001\074\001\105\001\255\255\008\001\108\001\
\010\001\080\001\111\001\013\001\014\001\255\255\115\001\017\001\
\255\255\019\001\020\001\021\001\255\255\092\001\024\001\025\001\
\026\001\096\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\037\001\255\255\108\001\040\001\041\001\
\111\001\255\255\255\255\255\255\000\000\255\255\255\255\049\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\060\001\255\255\255\255\063\001\255\255\255\255\
\255\255\067\001\068\001\255\255\070\001\255\255\255\255\073\001\
\074\001\255\255\255\255\255\255\255\255\255\255\080\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\091\001\092\001\255\255\094\001\095\001\096\001\255\255\
\255\255\255\255\255\255\255\255\255\255\103\001\000\001\105\001\
\255\255\003\001\108\001\255\255\255\255\111\001\008\001\255\255\
\010\001\115\001\255\255\013\001\014\001\255\255\255\255\017\001\
\255\255\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\255\255\028\001\029\001\000\001\255\255\255\255\255\255\
\255\255\255\255\255\255\037\001\255\255\255\255\040\001\041\001\
\255\255\013\001\255\255\255\255\000\000\255\255\255\255\049\001\
\255\255\255\255\255\255\255\255\255\255\255\255\026\001\255\255\
\028\001\029\001\060\001\255\255\255\255\063\001\255\255\255\255\
\255\255\067\001\068\001\255\255\070\001\041\001\255\255\073\001\
\074\001\255\255\000\000\255\255\255\255\255\255\080\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\060\001\091\001\092\001\063\001\094\001\095\001\096\001\255\255\
\068\001\000\001\255\255\255\255\003\001\103\001\074\001\105\001\
\255\255\008\001\108\001\010\001\080\001\111\001\013\001\014\001\
\255\255\115\001\017\001\255\255\019\001\020\001\021\001\255\255\
\092\001\024\001\025\001\026\001\096\001\028\001\029\001\000\001\
\255\255\255\255\255\255\255\255\255\255\255\255\037\001\255\255\
\108\001\040\001\041\001\111\001\013\001\255\255\255\255\000\000\
\255\255\255\255\049\001\255\255\255\255\255\255\255\255\255\255\
\255\255\026\001\255\255\028\001\029\001\060\001\255\255\255\255\
\063\001\255\255\255\255\255\255\067\001\068\001\255\255\070\001\
\041\001\255\255\073\001\074\001\255\255\255\255\255\255\255\255\
\255\255\080\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\060\001\091\001\092\001\063\001\094\001\
\095\001\096\001\255\255\068\001\000\001\255\255\255\255\003\001\
\103\001\074\001\105\001\255\255\008\001\108\001\010\001\080\001\
\111\001\013\001\014\001\255\255\115\001\017\001\255\255\019\001\
\020\001\021\001\255\255\092\001\024\001\025\001\026\001\096\001\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\037\001\255\255\108\001\040\001\041\001\111\001\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\000\000\255\255\255\255\
\060\001\255\255\255\255\063\001\255\255\255\255\255\255\067\001\
\068\001\255\255\070\001\255\255\255\255\073\001\074\001\255\255\
\255\255\255\255\255\255\255\255\080\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\091\001\
\092\001\255\255\094\001\095\001\096\001\255\255\255\255\255\255\
\255\255\255\255\255\255\103\001\000\001\105\001\255\255\003\001\
\108\001\255\255\255\255\111\001\008\001\255\255\010\001\115\001\
\255\255\013\001\014\001\255\255\255\255\017\001\255\255\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\255\255\
\028\001\029\001\000\001\255\255\255\255\255\255\255\255\255\255\
\255\255\037\001\255\255\255\255\040\001\041\001\255\255\013\001\
\255\255\255\255\255\255\255\255\255\255\049\001\255\255\255\255\
\000\000\255\255\255\255\255\255\026\001\255\255\028\001\029\001\
\060\001\255\255\255\255\063\001\255\255\255\255\255\255\067\001\
\068\001\255\255\070\001\041\001\255\255\073\001\074\001\255\255\
\255\255\255\255\255\255\255\255\080\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\060\001\091\001\
\092\001\063\001\094\001\095\001\096\001\255\255\068\001\000\001\
\255\255\255\255\003\001\103\001\074\001\105\001\255\255\008\001\
\108\001\010\001\080\001\111\001\013\001\014\001\255\255\115\001\
\017\001\255\255\019\001\020\001\021\001\255\255\092\001\024\001\
\025\001\026\001\096\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\037\001\255\255\108\001\040\001\
\041\001\111\001\255\255\255\255\255\255\255\255\255\255\255\255\
\049\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\060\001\255\255\255\255\063\001\255\255\
\255\255\255\255\067\001\068\001\000\000\070\001\255\255\255\255\
\073\001\074\001\255\255\255\255\255\255\255\255\255\255\080\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\091\001\092\001\255\255\094\001\255\255\096\001\
\255\255\255\255\255\255\255\255\255\255\255\255\103\001\255\255\
\105\001\255\255\255\255\108\001\255\255\000\001\111\001\002\001\
\003\001\004\001\115\001\255\255\255\255\008\001\255\255\255\255\
\255\255\255\255\013\001\255\255\255\255\255\255\017\001\018\001\
\019\001\255\255\255\255\255\255\255\255\255\255\255\255\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\255\255\255\255\255\255\040\001\041\001\255\255\
\255\255\255\255\255\255\255\255\255\255\048\001\049\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
\255\255\060\001\255\255\255\255\063\001\255\255\255\255\066\001\
\067\001\068\001\255\255\070\001\255\255\255\255\073\001\074\001\
\255\255\255\255\255\255\255\255\255\255\080\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\091\001\092\001\255\255\094\001\095\001\096\001\255\255\255\255\
\000\001\100\001\255\255\003\001\255\255\255\255\255\255\255\255\
\008\001\108\001\010\001\255\255\111\001\013\001\014\001\255\255\
\115\001\017\001\255\255\019\001\020\001\021\001\255\255\255\255\
\024\001\255\255\026\001\255\255\028\001\029\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\037\001\255\255\255\255\
\040\001\041\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\049\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\000\000\255\255\060\001\255\255\255\255\063\001\
\255\255\255\255\255\255\067\001\068\001\255\255\070\001\255\255\
\255\255\073\001\074\001\255\255\255\255\255\255\255\255\255\255\
\080\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\091\001\092\001\255\255\094\001\095\001\
\096\001\255\255\255\255\255\255\255\255\255\255\255\255\103\001\
\255\255\105\001\255\255\255\255\108\001\255\255\255\255\111\001\
\255\255\255\255\255\255\115\001\000\001\255\255\002\001\003\001\
\004\001\255\255\255\255\255\255\008\001\255\255\255\255\255\255\
\255\255\013\001\255\255\255\255\255\255\017\001\018\001\019\001\
\255\255\255\255\255\255\255\255\255\255\255\255\026\001\027\001\
\028\001\029\001\255\255\255\255\008\001\255\255\255\255\255\255\
\036\001\255\255\255\255\255\255\255\255\041\001\255\255\000\000\
\255\255\255\255\255\255\023\001\048\001\049\001\255\255\255\255\
\255\255\255\255\030\001\255\255\255\255\255\255\255\255\255\255\
\060\001\255\255\255\255\063\001\255\255\255\255\066\001\067\001\
\068\001\255\255\070\001\255\255\255\255\073\001\074\001\255\255\
\255\255\255\255\255\255\055\001\080\001\057\001\058\001\059\001\
\255\255\061\001\255\255\255\255\064\001\065\001\255\255\091\001\
\092\001\255\255\094\001\095\001\096\001\255\255\255\255\000\001\
\255\255\002\001\003\001\004\001\255\255\081\001\255\255\008\001\
\108\001\255\255\255\255\111\001\013\001\089\001\090\001\115\001\
\017\001\018\001\019\001\255\255\255\255\097\001\255\255\255\255\
\255\255\026\001\027\001\028\001\029\001\255\255\106\001\255\255\
\255\255\109\001\110\001\036\001\255\255\255\255\255\255\255\255\
\041\001\255\255\000\000\255\255\255\255\255\255\255\255\048\001\
\049\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\060\001\255\255\255\255\063\001\255\255\
\255\255\066\001\067\001\068\001\255\255\070\001\255\255\255\255\
\255\255\074\001\255\255\255\255\255\255\255\255\255\255\080\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\091\001\092\001\255\255\094\001\095\001\096\001\
\255\255\255\255\000\001\255\255\002\001\003\001\004\001\255\255\
\255\255\255\255\008\001\108\001\255\255\255\255\111\001\013\001\
\255\255\255\255\115\001\017\001\018\001\019\001\255\255\255\255\
\255\255\255\255\255\255\255\255\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\000\000\255\255\036\001\255\255\
\255\255\255\255\255\255\041\001\255\255\255\255\000\000\255\255\
\255\255\255\255\048\001\049\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\060\001\255\255\
\255\255\063\001\255\255\255\255\066\001\067\001\068\001\255\255\
\070\001\255\255\255\255\255\255\074\001\255\255\255\255\255\255\
\255\255\255\255\080\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\091\001\092\001\000\000\
\094\001\095\001\096\001\255\255\255\255\255\255\255\255\000\001\
\255\255\002\001\003\001\004\001\255\255\255\255\108\001\008\001\
\255\255\111\001\255\255\255\255\013\001\115\001\255\255\255\255\
\017\001\018\001\019\001\255\255\255\255\255\255\255\255\255\255\
\255\255\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\255\255\255\255\255\255\255\255\
\041\001\255\255\255\255\255\255\255\255\255\255\255\255\048\001\
\049\001\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\060\001\255\255\255\255\063\001\255\255\
\255\255\066\001\067\001\068\001\255\255\070\001\255\255\255\255\
\255\255\074\001\255\255\255\255\255\255\255\255\055\001\080\001\
\057\001\058\001\059\001\255\255\061\001\255\255\255\255\064\001\
\065\001\255\255\091\001\092\001\255\255\094\001\095\001\096\001\
\255\255\255\255\000\001\255\255\002\001\003\001\004\001\255\255\
\081\001\255\255\008\001\108\001\255\255\255\255\111\001\013\001\
\089\001\090\001\115\001\017\001\018\001\019\001\255\255\255\255\
\097\001\255\255\255\255\255\255\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\109\001\110\001\036\001\255\255\
\255\255\255\255\255\255\041\001\255\255\255\255\255\255\255\255\
\255\255\255\255\048\001\049\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\060\001\255\255\
\255\255\063\001\000\000\255\255\066\001\067\001\068\001\255\255\
\070\001\255\255\255\255\255\255\074\001\255\255\255\255\255\255\
\255\255\255\255\080\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\000\001\091\001\092\001\003\001\
\094\001\095\001\096\001\255\255\255\255\255\255\000\001\255\255\
\255\255\013\001\255\255\255\255\255\255\017\001\108\001\019\001\
\255\255\111\001\255\255\013\001\255\255\115\001\026\001\027\001\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\026\001\255\255\028\001\029\001\255\255\041\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\041\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\001\
\060\001\255\255\255\255\063\001\255\255\255\255\255\255\067\001\
\068\001\255\255\060\001\255\255\013\001\073\001\074\001\255\255\
\017\001\067\001\068\001\255\255\080\001\255\255\255\255\255\255\
\074\001\026\001\027\001\028\001\029\001\000\000\080\001\255\255\
\092\001\255\255\094\001\255\255\096\001\255\255\255\255\255\255\
\041\001\255\255\092\001\255\255\255\255\255\255\096\001\255\255\
\108\001\255\255\255\255\111\001\255\255\255\255\255\255\115\001\
\255\255\000\001\108\001\060\001\003\001\111\001\063\001\255\255\
\255\255\066\001\067\001\068\001\255\255\255\255\013\001\255\255\
\073\001\074\001\017\001\255\255\255\255\255\255\255\255\080\001\
\255\255\255\255\255\255\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\092\001\255\255\094\001\255\255\096\001\
\255\255\255\255\041\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\108\001\255\255\255\255\111\001\255\255\
\255\255\255\255\115\001\255\255\255\255\060\001\255\255\255\255\
\063\001\255\255\255\255\255\255\067\001\068\001\255\255\255\255\
\255\255\255\255\073\001\074\001\055\001\255\255\057\001\058\001\
\059\001\080\001\061\001\255\255\000\000\064\001\065\001\255\255\
\255\255\255\255\255\255\255\255\255\255\092\001\255\255\094\001\
\255\255\096\001\255\255\255\255\255\255\255\255\081\001\255\255\
\255\255\255\255\255\255\255\255\255\255\108\001\089\001\090\001\
\111\001\255\255\000\001\255\255\115\001\003\001\097\001\005\001\
\006\001\007\001\008\001\255\255\255\255\011\001\012\001\013\001\
\255\255\255\255\109\001\110\001\255\255\019\001\255\255\255\255\
\255\255\023\001\255\255\255\255\026\001\255\255\028\001\029\001\
\030\001\031\001\032\001\033\001\034\001\035\001\036\001\255\255\
\255\255\039\001\040\001\041\001\255\255\255\255\000\000\255\255\
\255\255\255\255\048\001\049\001\050\001\051\001\052\001\053\001\
\054\001\055\001\056\001\057\001\058\001\059\001\060\001\061\001\
\255\255\063\001\064\001\065\001\255\255\067\001\068\001\069\001\
\070\001\071\001\072\001\255\255\074\001\075\001\255\255\077\001\
\078\001\255\255\080\001\081\001\255\255\255\255\084\001\085\001\
\255\255\087\001\088\001\089\001\090\001\091\001\092\001\093\001\
\255\255\095\001\096\001\097\001\255\255\099\001\255\255\101\001\
\102\001\255\255\104\001\255\255\106\001\107\001\108\001\109\001\
\110\001\111\001\112\001\000\000\114\001\000\001\255\255\255\255\
\255\255\004\001\255\255\006\001\255\255\008\001\255\255\010\001\
\255\255\012\001\255\255\014\001\015\001\255\255\017\001\018\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\027\001\028\001\255\255\030\001\031\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\050\001\
\051\001\052\001\053\001\255\255\055\001\056\001\255\255\255\255\
\059\001\000\000\255\255\255\255\255\255\064\001\065\001\066\001\
\255\255\255\255\255\255\255\255\071\001\255\255\073\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\081\001\255\255\
\255\255\084\001\255\255\255\255\255\255\255\255\089\001\255\255\
\091\001\092\001\255\255\094\001\095\001\255\255\097\001\255\255\
\255\255\255\255\101\001\255\255\255\255\104\001\255\255\106\001\
\255\255\255\255\109\001\110\001\000\001\255\255\113\001\255\255\
\004\001\255\255\006\001\000\000\008\001\255\255\010\001\255\255\
\012\001\255\255\014\001\015\001\255\255\017\001\018\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\027\001\
\255\255\255\255\030\001\031\001\255\255\255\255\255\255\255\255\
\255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\050\001\051\001\
\255\255\053\001\255\255\055\001\056\001\255\255\255\255\059\001\
\255\255\255\255\255\255\255\255\064\001\065\001\066\001\255\255\
\255\255\255\255\255\255\071\001\255\255\073\001\000\001\255\255\
\255\255\003\001\255\255\255\255\255\255\081\001\008\001\255\255\
\084\001\255\255\255\255\013\001\014\001\089\001\255\255\091\001\
\092\001\019\001\094\001\095\001\022\001\097\001\255\255\255\255\
\026\001\101\001\028\001\029\001\104\001\255\255\106\001\255\255\
\255\255\109\001\110\001\255\255\255\255\113\001\255\255\041\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\055\001\
\000\000\057\001\058\001\059\001\255\255\061\001\255\255\255\255\
\064\001\065\001\060\001\255\255\255\255\063\001\255\255\065\001\
\066\001\067\001\068\001\000\001\255\255\255\255\003\001\255\255\
\074\001\081\001\255\255\008\001\255\255\079\001\080\001\255\255\
\013\001\089\001\090\001\255\255\255\255\255\255\019\001\255\255\
\255\255\097\001\092\001\255\255\255\255\026\001\096\001\028\001\
\029\001\255\255\255\255\255\255\255\255\109\001\110\001\255\255\
\000\000\255\255\108\001\040\001\041\001\111\001\055\001\255\255\
\057\001\058\001\059\001\255\255\061\001\255\255\255\255\064\001\
\065\001\255\255\255\255\255\255\255\255\255\255\255\255\060\001\
\255\255\000\001\063\001\255\255\003\001\066\001\067\001\068\001\
\081\001\008\001\255\255\255\255\073\001\074\001\013\001\255\255\
\089\001\090\001\255\255\080\001\019\001\255\255\255\255\255\255\
\097\001\255\255\255\255\026\001\255\255\028\001\029\001\092\001\
\000\000\255\255\255\255\096\001\109\001\110\001\255\255\100\001\
\255\255\040\001\041\001\255\255\255\255\255\255\255\255\108\001\
\255\255\255\255\111\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\000\001\255\255\060\001\003\001\255\255\
\063\001\255\255\255\255\066\001\067\001\068\001\255\255\255\255\
\013\001\255\255\073\001\074\001\255\255\255\255\019\001\255\255\
\255\255\080\001\255\255\255\255\255\255\026\001\255\255\028\001\
\029\001\000\001\000\000\255\255\003\001\092\001\255\255\255\255\
\255\255\096\001\255\255\040\001\041\001\255\255\013\001\255\255\
\255\255\255\255\017\001\048\001\049\001\108\001\255\255\255\255\
\111\001\255\255\255\255\026\001\027\001\028\001\029\001\060\001\
\255\255\255\255\063\001\255\255\255\255\255\255\255\255\068\001\
\255\255\070\001\041\001\255\255\255\255\074\001\255\255\255\255\
\255\255\255\255\055\001\080\001\057\001\058\001\059\001\255\255\
\061\001\255\255\000\000\064\001\065\001\060\001\255\255\092\001\
\063\001\255\255\255\255\096\001\067\001\068\001\255\255\255\255\
\255\255\255\255\006\001\074\001\081\001\255\255\255\255\108\001\
\012\001\080\001\111\001\255\255\089\001\090\001\255\255\255\255\
\000\001\255\255\255\255\003\001\097\001\092\001\255\255\094\001\
\008\001\096\001\030\001\031\001\255\255\013\001\255\255\255\255\
\109\001\110\001\255\255\019\001\255\255\108\001\255\255\000\000\
\111\001\255\255\026\001\255\255\028\001\029\001\050\001\255\255\
\052\001\053\001\255\255\055\001\056\001\255\255\255\255\059\001\
\255\255\041\001\255\255\255\255\064\001\065\001\255\255\255\255\
\255\255\255\255\255\255\071\001\255\255\255\255\255\255\255\255\
\000\001\255\255\255\255\003\001\060\001\255\255\255\255\063\001\
\084\001\255\255\066\001\067\001\068\001\013\001\255\255\255\255\
\255\255\017\001\074\001\255\255\000\000\097\001\255\255\255\255\
\080\001\101\001\026\001\027\001\028\001\029\001\106\001\255\255\
\255\255\109\001\110\001\255\255\092\001\255\255\255\255\255\255\
\096\001\041\001\255\255\000\000\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\108\001\255\255\255\255\111\001\
\000\001\255\255\255\255\003\001\060\001\255\255\255\255\063\001\
\255\255\255\255\255\255\067\001\068\001\013\001\255\255\255\255\
\255\255\000\000\074\001\019\001\255\255\255\255\255\255\255\255\
\080\001\255\255\026\001\255\255\028\001\029\001\255\255\255\255\
\255\255\255\255\255\255\255\255\092\001\255\255\094\001\255\255\
\096\001\041\001\255\255\255\255\255\255\255\255\255\255\255\255\
\048\001\255\255\255\255\255\255\108\001\255\255\255\255\111\001\
\255\255\255\255\000\001\255\255\060\001\003\001\255\255\063\001\
\255\255\255\255\255\255\067\001\068\001\255\255\070\001\013\001\
\255\255\000\000\074\001\255\255\255\255\019\001\255\255\255\255\
\080\001\255\255\255\255\255\255\026\001\255\255\028\001\029\001\
\255\255\255\255\255\255\255\255\092\001\255\255\255\255\255\255\
\096\001\255\255\255\255\041\001\255\255\255\255\255\255\000\000\
\255\255\255\255\255\255\255\255\108\001\255\255\255\255\111\001\
\255\255\255\255\000\001\255\255\255\255\003\001\060\001\255\255\
\255\255\063\001\008\001\255\255\255\255\067\001\068\001\013\001\
\255\255\255\255\255\255\255\255\074\001\019\001\255\255\255\255\
\255\255\255\255\080\001\255\255\026\001\255\255\028\001\029\001\
\086\001\255\255\255\255\255\255\255\255\255\255\092\001\255\255\
\255\255\255\255\096\001\041\001\255\255\255\255\255\255\000\000\
\255\255\255\255\255\255\255\255\255\255\255\255\108\001\000\001\
\255\255\111\001\003\001\255\255\255\255\255\255\060\001\255\255\
\000\000\063\001\255\255\255\255\013\001\067\001\068\001\255\255\
\255\255\255\255\019\001\255\255\074\001\255\255\255\255\255\255\
\255\255\026\001\080\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\092\001\255\255\
\041\001\255\255\096\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\000\001\255\255\108\001\003\001\
\255\255\111\001\255\255\060\001\255\255\255\255\063\001\255\255\
\000\000\013\001\067\001\068\001\255\255\255\255\255\255\019\001\
\255\255\074\001\255\255\000\001\255\255\255\255\026\001\080\001\
\028\001\029\001\255\255\008\001\255\255\000\000\255\255\255\255\
\013\001\255\255\255\255\092\001\255\255\041\001\000\000\096\001\
\255\255\255\255\255\255\255\255\255\255\026\001\255\255\028\001\
\029\001\000\001\255\255\108\001\003\001\255\255\111\001\255\255\
\060\001\255\255\255\255\063\001\041\001\255\255\013\001\067\001\
\068\001\255\255\255\255\255\255\019\001\255\255\074\001\255\255\
\255\255\000\000\255\255\026\001\080\001\028\001\029\001\060\001\
\255\255\255\255\063\001\255\255\255\255\066\001\067\001\068\001\
\092\001\255\255\041\001\255\255\096\001\074\001\000\000\255\255\
\255\255\255\255\255\255\080\001\255\255\255\255\255\255\255\255\
\108\001\000\001\255\255\111\001\003\001\060\001\255\255\092\001\
\063\001\255\255\255\255\096\001\067\001\068\001\013\001\255\255\
\255\255\255\255\255\255\074\001\019\001\255\255\255\255\108\001\
\255\255\080\001\111\001\026\001\255\255\028\001\029\001\000\001\
\255\255\255\255\003\001\255\255\255\255\092\001\255\255\255\255\
\255\255\096\001\041\001\255\255\013\001\255\255\255\255\255\255\
\255\255\255\255\019\001\255\255\255\255\108\001\255\255\255\255\
\111\001\026\001\255\255\028\001\029\001\060\001\255\255\255\255\
\063\001\255\255\255\255\255\255\067\001\068\001\255\255\255\255\
\041\001\255\255\255\255\074\001\255\255\255\255\255\255\255\255\
\255\255\080\001\255\255\255\255\255\255\255\255\255\255\000\001\
\255\255\255\255\003\001\060\001\255\255\092\001\063\001\255\255\
\255\255\096\001\067\001\068\001\013\001\255\255\255\255\255\255\
\000\001\074\001\019\001\255\255\255\255\108\001\255\255\080\001\
\111\001\026\001\255\255\028\001\029\001\013\001\255\255\255\255\
\255\255\255\255\255\255\092\001\255\255\255\255\255\255\096\001\
\041\001\255\255\026\001\255\255\028\001\029\001\255\255\255\255\
\255\255\255\255\255\255\108\001\255\255\255\255\111\001\255\255\
\255\255\041\001\255\255\060\001\255\255\255\255\063\001\255\255\
\255\255\255\255\067\001\068\001\255\255\255\255\255\255\255\255\
\000\001\074\001\255\255\255\255\060\001\255\255\255\255\080\001\
\255\255\255\255\066\001\067\001\068\001\013\001\255\255\255\255\
\255\255\255\255\074\001\092\001\255\255\000\001\255\255\096\001\
\080\001\255\255\026\001\255\255\028\001\029\001\000\001\255\255\
\255\255\255\255\013\001\108\001\092\001\255\255\111\001\255\255\
\096\001\041\001\255\255\013\001\255\255\255\255\255\255\026\001\
\255\255\028\001\029\001\255\255\108\001\255\255\255\255\111\001\
\026\001\255\255\028\001\029\001\060\001\255\255\041\001\063\001\
\255\255\000\001\255\255\255\255\068\001\255\255\255\255\041\001\
\255\255\255\255\074\001\255\255\255\255\255\255\013\001\255\255\
\080\001\060\001\255\255\255\255\063\001\255\255\000\001\255\255\
\255\255\068\001\060\001\026\001\092\001\028\001\029\001\074\001\
\096\001\255\255\068\001\013\001\255\255\080\001\255\255\255\255\
\074\001\255\255\041\001\255\255\108\001\255\255\080\001\111\001\
\026\001\092\001\028\001\029\001\255\255\096\001\255\255\255\255\
\255\255\255\255\092\001\255\255\255\255\060\001\096\001\041\001\
\255\255\108\001\255\255\255\255\111\001\068\001\255\255\255\255\
\255\255\255\255\108\001\074\001\255\255\111\001\255\255\255\255\
\255\255\080\001\060\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\068\001\255\255\255\255\092\001\255\255\255\255\
\074\001\096\001\255\255\255\255\255\255\255\255\080\001\255\255\
\255\255\255\255\255\255\255\255\255\255\108\001\255\255\255\255\
\111\001\255\255\092\001\000\001\255\255\255\255\096\001\255\255\
\005\001\006\001\007\001\008\001\255\255\255\255\011\001\012\001\
\013\001\014\001\108\001\255\255\255\255\111\001\019\001\255\255\
\255\255\255\255\255\255\255\255\255\255\026\001\255\255\028\001\
\029\001\030\001\031\001\032\001\033\001\034\001\035\001\255\255\
\255\255\255\255\039\001\255\255\041\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\049\001\050\001\051\001\052\001\
\053\001\054\001\055\001\056\001\255\255\255\255\059\001\060\001\
\255\255\255\255\063\001\064\001\065\001\066\001\255\255\068\001\
\069\001\070\001\071\001\072\001\255\255\074\001\255\255\255\255\
\077\001\078\001\255\255\080\001\081\001\255\255\255\255\084\001\
\085\001\255\255\087\001\255\255\089\001\090\001\255\255\092\001\
\093\001\255\255\255\255\096\001\097\001\255\255\099\001\255\255\
\101\001\102\001\255\255\104\001\255\255\106\001\107\001\108\001\
\109\001\110\001\111\001\112\001\000\001\114\001\255\255\255\255\
\255\255\005\001\006\001\007\001\008\001\255\255\255\255\011\001\
\012\001\255\255\255\255\255\255\255\255\255\255\255\255\019\001\
\255\255\255\255\255\255\255\255\255\255\255\255\026\001\255\255\
\028\001\255\255\030\001\031\001\032\001\033\001\034\001\035\001\
\255\255\255\255\255\255\039\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\050\001\051\001\
\052\001\053\001\054\001\055\001\056\001\255\255\255\255\059\001\
\060\001\255\255\255\255\063\001\064\001\065\001\255\255\255\255\
\068\001\069\001\070\001\071\001\072\001\255\255\074\001\255\255\
\255\255\077\001\078\001\255\255\255\255\081\001\255\255\255\255\
\084\001\085\001\255\255\087\001\255\255\089\001\090\001\255\255\
\255\255\093\001\255\255\255\255\255\255\097\001\255\255\099\001\
\255\255\101\001\102\001\255\255\104\001\255\255\106\001\107\001\
\255\255\109\001\110\001\111\001\112\001\255\255\114\001\000\001\
\001\001\002\001\255\255\255\255\005\001\006\001\007\001\255\255\
\009\001\255\255\011\001\012\001\255\255\255\255\015\001\016\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\255\255\030\001\031\001\032\001\
\033\001\034\001\255\255\036\001\255\255\255\255\039\001\255\255\
\255\255\042\001\043\001\044\001\045\001\046\001\047\001\255\255\
\255\255\050\001\255\255\052\001\053\001\054\001\055\001\056\001\
\255\255\255\255\059\001\255\255\061\001\255\255\063\001\064\001\
\065\001\255\255\255\255\255\255\069\001\255\255\071\001\072\001\
\255\255\074\001\255\255\255\255\255\255\078\001\255\255\255\255\
\255\255\082\001\083\001\084\001\085\001\086\001\087\001\255\255\
\255\255\255\255\255\255\255\255\255\255\094\001\255\255\255\255\
\255\255\098\001\255\255\100\001\101\001\255\255\255\255\255\255\
\255\255\106\001\107\001\255\255\109\001\110\001\000\001\001\001\
\002\001\114\001\255\255\005\001\006\001\007\001\255\255\009\001\
\255\255\011\001\012\001\255\255\255\255\015\001\016\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\027\001\255\255\255\255\030\001\031\001\032\001\033\001\
\034\001\255\255\036\001\255\255\255\255\039\001\255\255\255\255\
\042\001\043\001\044\001\045\001\046\001\047\001\255\255\255\255\
\050\001\255\255\052\001\053\001\054\001\055\001\056\001\255\255\
\255\255\059\001\255\255\061\001\255\255\063\001\064\001\065\001\
\255\255\255\255\255\255\069\001\255\255\071\001\072\001\255\255\
\074\001\255\255\255\255\255\255\078\001\255\255\255\255\255\255\
\082\001\083\001\084\001\085\001\086\001\087\001\255\255\255\255\
\255\255\255\255\255\255\255\255\094\001\255\255\255\255\255\255\
\098\001\255\255\100\001\101\001\255\255\255\255\255\255\255\255\
\106\001\107\001\255\255\109\001\110\001\000\001\255\255\255\255\
\114\001\255\255\005\001\006\001\007\001\255\255\255\255\255\255\
\011\001\012\001\013\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\026\001\
\255\255\028\001\029\001\030\001\031\001\032\001\033\001\034\001\
\255\255\255\255\255\255\255\255\039\001\255\255\041\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\050\001\
\255\255\052\001\053\001\054\001\055\001\056\001\255\255\255\255\
\059\001\060\001\255\255\255\255\063\001\064\001\065\001\255\255\
\255\255\068\001\069\001\255\255\071\001\072\001\255\255\074\001\
\255\255\255\255\255\255\078\001\255\255\080\001\255\255\255\255\
\255\255\084\001\085\001\000\001\087\001\255\255\255\255\255\255\
\005\001\006\001\007\001\255\255\255\255\096\001\011\001\012\001\
\255\255\255\255\101\001\255\255\255\255\255\255\255\255\106\001\
\107\001\108\001\109\001\110\001\111\001\255\255\255\255\114\001\
\255\255\030\001\031\001\032\001\033\001\034\001\255\255\255\255\
\255\255\255\255\039\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\050\001\255\255\052\001\
\053\001\054\001\055\001\056\001\255\255\255\255\059\001\255\255\
\255\255\255\255\063\001\064\001\065\001\255\255\255\255\255\255\
\069\001\255\255\071\001\072\001\255\255\255\255\255\255\255\255\
\255\255\078\001\255\255\255\255\255\255\255\255\255\255\084\001\
\085\001\000\001\087\001\255\255\255\255\255\255\005\001\006\001\
\007\001\094\001\255\255\255\255\011\001\012\001\255\255\255\255\
\101\001\255\255\255\255\255\255\255\255\106\001\107\001\255\255\
\109\001\110\001\255\255\255\255\255\255\114\001\255\255\030\001\
\031\001\032\001\033\001\034\001\255\255\255\255\255\255\255\255\
\039\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\050\001\255\255\052\001\053\001\054\001\
\055\001\056\001\255\255\255\255\059\001\255\255\255\255\255\255\
\063\001\064\001\065\001\255\255\255\255\255\255\069\001\255\255\
\071\001\072\001\255\255\255\255\255\255\255\255\255\255\078\001\
\255\255\255\255\255\255\255\255\255\255\084\001\085\001\000\001\
\087\001\255\255\255\255\255\255\005\001\006\001\007\001\094\001\
\255\255\255\255\011\001\012\001\255\255\255\255\101\001\255\255\
\255\255\255\255\255\255\106\001\107\001\255\255\109\001\110\001\
\255\255\255\255\255\255\114\001\255\255\030\001\031\001\032\001\
\033\001\034\001\255\255\255\255\255\255\255\255\039\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\050\001\255\255\052\001\053\001\054\001\055\001\056\001\
\255\255\255\255\059\001\255\255\255\255\255\255\063\001\064\001\
\065\001\255\255\255\255\255\255\069\001\255\255\071\001\072\001\
\255\255\255\255\255\255\255\255\255\255\078\001\255\255\255\255\
\255\255\255\255\255\255\084\001\085\001\000\001\087\001\255\255\
\255\255\255\255\005\001\006\001\007\001\094\001\255\255\255\255\
\011\001\012\001\255\255\255\255\101\001\255\255\255\255\255\255\
\255\255\106\001\107\001\255\255\109\001\110\001\255\255\255\255\
\255\255\114\001\255\255\030\001\031\001\032\001\033\001\034\001\
\255\255\255\255\255\255\255\255\039\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\050\001\
\255\255\052\001\053\001\054\001\055\001\056\001\255\255\255\255\
\059\001\255\255\255\255\255\255\063\001\064\001\065\001\255\255\
\255\255\255\255\069\001\255\255\071\001\072\001\255\255\255\255\
\255\255\255\255\255\255\078\001\255\255\255\255\255\255\255\255\
\255\255\084\001\085\001\255\255\087\001\255\255\255\255\255\255\
\255\255\255\255\255\255\094\001\003\001\004\001\005\001\255\255\
\255\255\255\255\101\001\255\255\011\001\255\255\013\001\106\001\
\107\001\255\255\109\001\110\001\019\001\020\001\021\001\114\001\
\255\255\024\001\025\001\026\001\255\255\028\001\029\001\030\001\
\255\255\032\001\033\001\034\001\035\001\255\255\255\255\255\255\
\039\001\040\001\041\001\255\255\255\255\255\255\255\255\255\255\
\255\255\048\001\049\001\255\255\255\255\052\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\063\001\064\001\255\255\255\255\255\255\000\001\069\001\070\001\
\255\255\004\001\255\255\074\001\075\001\076\001\077\001\078\001\
\079\001\080\001\255\255\082\001\255\255\255\255\017\001\255\255\
\019\001\088\001\255\255\022\001\255\255\255\255\093\001\026\001\
\027\001\255\255\255\255\255\255\099\001\255\255\255\255\102\001\
\103\001\036\001\105\001\106\001\107\001\108\001\109\001\255\255\
\111\001\112\001\113\001\114\001\115\001\048\001\049\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\060\001\255\255\255\255\255\255\064\001\255\255\066\001\
\067\001\068\001\255\255\070\001\255\255\255\255\073\001\255\255\
\255\255\255\255\000\001\001\001\002\001\255\255\255\255\255\255\
\006\001\007\001\255\255\009\001\255\255\255\255\012\001\090\001\
\091\001\015\001\016\001\255\255\095\001\255\255\097\001\255\255\
\255\255\100\001\255\255\255\255\255\255\027\001\028\001\255\255\
\030\001\031\001\109\001\255\255\111\001\255\255\036\001\255\255\
\255\255\255\255\255\255\255\255\042\001\043\001\044\001\045\001\
\046\001\047\001\255\255\255\255\050\001\255\255\052\001\053\001\
\255\255\055\001\056\001\255\255\255\255\059\001\255\255\061\001\
\255\255\255\255\064\001\065\001\255\255\255\255\255\255\255\255\
\255\255\071\001\072\001\255\255\074\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\083\001\084\001\085\001\
\086\001\087\001\255\255\255\255\255\255\255\255\255\255\255\255\
\094\001\255\255\255\255\097\001\098\001\255\255\100\001\101\001\
\255\255\255\255\255\255\255\255\106\001\255\255\108\001\109\001\
\110\001\000\001\001\001\002\001\255\255\255\255\255\255\006\001\
\007\001\255\255\009\001\255\255\255\255\012\001\255\255\255\255\
\015\001\016\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\027\001\028\001\255\255\030\001\
\031\001\255\255\255\255\255\255\255\255\036\001\255\255\255\255\
\255\255\255\255\255\255\042\001\043\001\044\001\045\001\046\001\
\047\001\255\255\255\255\050\001\255\255\052\001\053\001\255\255\
\055\001\056\001\255\255\255\255\059\001\255\255\061\001\255\255\
\255\255\064\001\065\001\255\255\255\255\255\255\255\255\255\255\
\071\001\072\001\255\255\074\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\083\001\084\001\085\001\086\001\
\087\001\255\255\255\255\255\255\255\255\255\255\255\255\094\001\
\255\255\255\255\097\001\098\001\255\255\100\001\101\001\255\255\
\255\255\255\255\255\255\106\001\255\255\108\001\109\001\110\001\
\000\001\001\001\002\001\255\255\255\255\255\255\006\001\007\001\
\255\255\009\001\255\255\255\255\012\001\255\255\255\255\015\001\
\016\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\027\001\028\001\255\255\030\001\031\001\
\255\255\255\255\255\255\255\255\036\001\255\255\255\255\255\255\
\255\255\255\255\042\001\043\001\044\001\045\001\046\001\047\001\
\255\255\255\255\050\001\255\255\052\001\053\001\255\255\055\001\
\056\001\255\255\255\255\059\001\255\255\061\001\255\255\255\255\
\064\001\065\001\255\255\255\255\255\255\255\255\255\255\071\001\
\072\001\255\255\074\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\082\001\083\001\084\001\085\001\086\001\087\001\
\255\255\255\255\255\255\255\255\255\255\255\255\094\001\255\255\
\255\255\097\001\098\001\255\255\100\001\101\001\255\255\255\255\
\255\255\255\255\106\001\255\255\108\001\109\001\110\001\000\001\
\001\001\002\001\255\255\255\255\255\255\006\001\007\001\255\255\
\009\001\255\255\255\255\012\001\255\255\255\255\015\001\016\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\028\001\255\255\030\001\031\001\255\255\
\255\255\255\255\255\255\036\001\255\255\255\255\255\255\255\255\
\255\255\042\001\043\001\044\001\045\001\046\001\047\001\255\255\
\255\255\050\001\255\255\052\001\053\001\255\255\055\001\056\001\
\255\255\255\255\059\001\255\255\061\001\255\255\255\255\064\001\
\065\001\255\255\255\255\255\255\255\255\255\255\071\001\072\001\
\255\255\074\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\083\001\084\001\085\001\086\001\087\001\255\255\
\255\255\000\001\255\255\255\255\255\255\094\001\255\255\006\001\
\097\001\098\001\255\255\100\001\101\001\012\001\255\255\255\255\
\015\001\106\001\255\255\255\255\109\001\110\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\028\001\255\255\030\001\
\031\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\050\001\255\255\052\001\053\001\255\255\
\055\001\056\001\255\255\255\255\059\001\255\255\000\001\255\255\
\255\255\064\001\065\001\255\255\006\001\255\255\255\255\255\255\
\071\001\255\255\012\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\084\001\255\255\255\255\
\255\255\255\255\028\001\255\255\030\001\031\001\255\255\094\001\
\255\255\255\255\097\001\255\255\255\255\255\255\101\001\255\255\
\255\255\255\255\255\255\106\001\255\255\255\255\109\001\110\001\
\050\001\255\255\052\001\053\001\255\255\055\001\056\001\255\255\
\255\255\059\001\255\255\000\001\255\255\255\255\064\001\065\001\
\255\255\006\001\255\255\255\255\255\255\071\001\255\255\012\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\084\001\255\255\255\255\255\255\255\255\028\001\
\255\255\030\001\031\001\255\255\255\255\255\255\255\255\097\001\
\255\255\255\255\255\255\101\001\255\255\255\255\255\255\255\255\
\106\001\255\255\255\255\109\001\110\001\050\001\255\255\052\001\
\053\001\255\255\055\001\056\001\255\255\255\255\059\001\255\255\
\000\001\255\255\255\255\064\001\065\001\255\255\006\001\255\255\
\255\255\255\255\071\001\255\255\012\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\084\001\
\255\255\255\255\255\255\255\255\028\001\255\255\030\001\031\001\
\255\255\255\255\255\255\255\255\097\001\255\255\255\255\255\255\
\101\001\255\255\255\255\255\255\255\255\106\001\255\255\255\255\
\109\001\110\001\050\001\255\255\052\001\053\001\255\255\055\001\
\056\001\255\255\255\255\059\001\255\255\000\001\255\255\255\255\
\064\001\065\001\255\255\006\001\255\255\255\255\255\255\071\001\
\255\255\012\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\084\001\255\255\255\255\255\255\
\255\255\028\001\255\255\030\001\031\001\255\255\255\255\255\255\
\255\255\097\001\255\255\255\255\255\255\101\001\255\255\255\255\
\255\255\255\255\106\001\255\255\255\255\109\001\110\001\050\001\
\255\255\052\001\053\001\255\255\055\001\056\001\255\255\255\255\
\059\001\255\255\000\001\255\255\255\255\064\001\065\001\255\255\
\006\001\255\255\255\255\255\255\071\001\255\255\012\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\084\001\255\255\255\255\255\255\255\255\028\001\255\255\
\030\001\031\001\255\255\255\255\255\255\255\255\097\001\255\255\
\255\255\255\255\101\001\255\255\255\255\255\255\255\255\106\001\
\255\255\255\255\109\001\110\001\050\001\255\255\052\001\053\001\
\255\255\055\001\056\001\255\255\255\255\059\001\255\255\255\255\
\255\255\255\255\064\001\065\001\005\001\006\001\007\001\255\255\
\255\255\071\001\011\001\012\001\013\001\014\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\084\001\255\255\
\255\255\255\255\255\255\028\001\029\001\030\001\031\001\032\001\
\033\001\034\001\255\255\097\001\255\255\255\255\039\001\101\001\
\041\001\255\255\255\255\255\255\106\001\255\255\255\255\109\001\
\110\001\050\001\255\255\052\001\053\001\054\001\055\001\056\001\
\255\255\255\255\059\001\060\001\255\255\255\255\063\001\064\001\
\065\001\255\255\255\255\068\001\069\001\255\255\071\001\072\001\
\255\255\074\001\255\255\255\255\255\255\078\001\255\255\080\001\
\255\255\255\255\255\255\084\001\085\001\255\255\087\001\255\255\
\089\001\255\255\255\255\005\001\006\001\007\001\255\255\096\001\
\255\255\011\001\012\001\013\001\101\001\255\255\255\255\255\255\
\255\255\106\001\107\001\108\001\109\001\110\001\111\001\255\255\
\255\255\114\001\028\001\029\001\030\001\031\001\032\001\033\001\
\034\001\255\255\255\255\255\255\255\255\039\001\255\255\041\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\050\001\255\255\052\001\053\001\054\001\055\001\056\001\255\255\
\255\255\059\001\060\001\255\255\255\255\063\001\064\001\065\001\
\255\255\255\255\068\001\069\001\255\255\071\001\072\001\255\255\
\074\001\255\255\255\255\255\255\078\001\255\255\080\001\255\255\
\255\255\255\255\084\001\085\001\255\255\087\001\255\255\255\255\
\255\255\005\001\006\001\007\001\255\255\255\255\096\001\011\001\
\012\001\255\255\255\255\101\001\255\255\255\255\255\255\255\255\
\106\001\107\001\108\001\109\001\110\001\111\001\255\255\255\255\
\114\001\255\255\030\001\031\001\032\001\033\001\034\001\255\255\
\255\255\255\255\255\255\039\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\050\001\255\255\
\052\001\053\001\054\001\055\001\056\001\255\255\255\255\059\001\
\255\255\255\255\255\255\063\001\064\001\065\001\255\255\255\255\
\255\255\069\001\255\255\071\001\072\001\255\255\255\255\255\255\
\255\255\255\255\078\001\255\255\255\255\255\255\255\255\255\255\
\084\001\085\001\255\255\087\001\255\255\255\255\255\255\255\255\
\092\001\005\001\006\001\007\001\255\255\255\255\010\001\011\001\
\012\001\101\001\255\255\255\255\255\255\255\255\106\001\107\001\
\255\255\109\001\110\001\255\255\255\255\255\255\114\001\255\255\
\255\255\255\255\030\001\031\001\032\001\033\001\034\001\255\255\
\255\255\255\255\255\255\039\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\050\001\255\255\
\052\001\053\001\054\001\055\001\056\001\255\255\255\255\059\001\
\255\255\255\255\255\255\063\001\064\001\065\001\255\255\255\255\
\255\255\069\001\255\255\071\001\072\001\255\255\255\255\255\255\
\255\255\255\255\078\001\255\255\255\255\255\255\255\255\255\255\
\084\001\085\001\255\255\087\001\255\255\255\255\005\001\006\001\
\007\001\255\255\255\255\255\255\011\001\012\001\255\255\255\255\
\255\255\101\001\255\255\255\255\255\255\255\255\106\001\107\001\
\255\255\109\001\110\001\026\001\255\255\255\255\114\001\030\001\
\031\001\032\001\033\001\034\001\255\255\255\255\255\255\255\255\
\039\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\050\001\255\255\052\001\053\001\054\001\
\055\001\056\001\255\255\255\255\059\001\255\255\255\255\255\255\
\063\001\064\001\065\001\255\255\255\255\255\255\069\001\255\255\
\071\001\072\001\255\255\255\255\255\255\255\255\255\255\078\001\
\255\255\255\255\255\255\255\255\255\255\084\001\085\001\255\255\
\087\001\255\255\255\255\005\001\006\001\007\001\255\255\255\255\
\255\255\011\001\012\001\255\255\255\255\255\255\101\001\255\255\
\255\255\255\255\255\255\106\001\107\001\255\255\109\001\110\001\
\255\255\255\255\255\255\114\001\030\001\031\001\032\001\033\001\
\034\001\255\255\255\255\255\255\255\255\039\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\050\001\255\255\052\001\053\001\054\001\055\001\056\001\255\255\
\255\255\059\001\255\255\255\255\255\255\063\001\064\001\065\001\
\255\255\255\255\255\255\069\001\255\255\071\001\072\001\255\255\
\255\255\255\255\255\255\255\255\078\001\255\255\255\255\255\255\
\255\255\083\001\084\001\085\001\255\255\087\001\255\255\255\255\
\005\001\006\001\007\001\255\255\255\255\255\255\011\001\012\001\
\255\255\255\255\255\255\101\001\255\255\255\255\255\255\255\255\
\106\001\107\001\255\255\109\001\110\001\255\255\255\255\255\255\
\114\001\030\001\031\001\032\001\033\001\034\001\255\255\255\255\
\255\255\255\255\039\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\050\001\255\255\052\001\
\053\001\054\001\055\001\056\001\255\255\255\255\059\001\255\255\
\255\255\255\255\063\001\064\001\065\001\255\255\255\255\255\255\
\069\001\255\255\071\001\072\001\255\255\255\255\255\255\255\255\
\255\255\078\001\255\255\255\255\255\255\255\255\255\255\084\001\
\085\001\255\255\087\001\255\255\255\255\255\255\255\255\092\001\
\005\001\006\001\007\001\255\255\255\255\010\001\011\001\012\001\
\101\001\255\255\255\255\255\255\255\255\106\001\107\001\255\255\
\109\001\110\001\255\255\255\255\255\255\114\001\255\255\255\255\
\255\255\030\001\031\001\032\001\033\001\034\001\255\255\255\255\
\255\255\255\255\039\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\050\001\255\255\052\001\
\053\001\054\001\055\001\056\001\255\255\255\255\059\001\255\255\
\255\255\255\255\063\001\064\001\065\001\255\255\255\255\255\255\
\069\001\255\255\071\001\072\001\255\255\255\255\255\255\255\255\
\255\255\078\001\255\255\255\255\255\255\255\255\255\255\084\001\
\085\001\255\255\087\001\255\255\255\255\255\255\005\001\006\001\
\007\001\255\255\255\255\255\255\011\001\012\001\255\255\255\255\
\101\001\255\255\255\255\255\255\255\255\106\001\107\001\022\001\
\109\001\110\001\255\255\255\255\255\255\114\001\255\255\030\001\
\031\001\032\001\033\001\034\001\255\255\255\255\255\255\255\255\
\039\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\050\001\255\255\052\001\053\001\054\001\
\055\001\056\001\255\255\255\255\059\001\255\255\255\255\255\255\
\063\001\064\001\065\001\255\255\255\255\255\255\069\001\255\255\
\071\001\072\001\255\255\255\255\255\255\255\255\255\255\078\001\
\255\255\255\255\255\255\255\255\255\255\084\001\085\001\255\255\
\087\001\255\255\255\255\005\001\006\001\007\001\255\255\255\255\
\255\255\011\001\012\001\255\255\255\255\255\255\101\001\255\255\
\255\255\255\255\255\255\106\001\107\001\255\255\109\001\110\001\
\026\001\255\255\255\255\114\001\030\001\031\001\032\001\033\001\
\034\001\255\255\255\255\255\255\255\255\039\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\050\001\255\255\052\001\053\001\054\001\055\001\056\001\255\255\
\255\255\059\001\255\255\255\255\255\255\063\001\064\001\065\001\
\255\255\255\255\255\255\069\001\255\255\071\001\072\001\255\255\
\255\255\255\255\255\255\255\255\078\001\255\255\255\255\255\255\
\255\255\255\255\084\001\085\001\255\255\087\001\255\255\255\255\
\005\001\006\001\007\001\255\255\255\255\255\255\011\001\012\001\
\255\255\255\255\255\255\101\001\255\255\255\255\255\255\255\255\
\106\001\107\001\255\255\109\001\110\001\255\255\255\255\255\255\
\114\001\030\001\031\001\032\001\033\001\034\001\255\255\255\255\
\255\255\255\255\039\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\050\001\255\255\052\001\
\053\001\054\001\055\001\056\001\255\255\255\255\059\001\255\255\
\255\255\255\255\063\001\064\001\065\001\255\255\255\255\255\255\
\069\001\255\255\071\001\072\001\255\255\255\255\255\255\255\255\
\255\255\078\001\255\255\255\255\255\255\255\255\255\255\084\001\
\085\001\255\255\087\001\255\255\255\255\005\001\006\001\007\001\
\255\255\255\255\255\255\011\001\012\001\255\255\255\255\255\255\
\101\001\255\255\255\255\255\255\255\255\106\001\107\001\255\255\
\109\001\110\001\255\255\255\255\255\255\114\001\030\001\031\001\
\032\001\033\001\034\001\255\255\255\255\255\255\255\255\039\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\050\001\255\255\052\001\053\001\054\001\055\001\
\056\001\255\255\255\255\059\001\255\255\255\255\255\255\063\001\
\064\001\065\001\255\255\255\255\255\255\069\001\255\255\071\001\
\072\001\255\255\255\255\255\255\255\255\255\255\078\001\255\255\
\255\255\255\255\255\255\255\255\084\001\085\001\255\255\087\001\
\255\255\255\255\005\001\006\001\007\001\255\255\255\255\255\255\
\011\001\012\001\255\255\255\255\255\255\101\001\255\255\255\255\
\255\255\255\255\106\001\107\001\255\255\109\001\110\001\255\255\
\255\255\255\255\114\001\030\001\031\001\032\001\033\001\034\001\
\255\255\255\255\255\255\255\255\039\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\050\001\
\255\255\052\001\053\001\054\001\055\001\056\001\255\255\255\255\
\059\001\255\255\255\255\255\255\063\001\064\001\065\001\255\255\
\255\255\006\001\069\001\255\255\071\001\072\001\255\255\012\001\
\255\255\014\001\255\255\078\001\017\001\255\255\255\255\255\255\
\255\255\084\001\085\001\255\255\087\001\255\255\027\001\255\255\
\255\255\030\001\031\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\101\001\255\255\255\255\255\255\255\255\106\001\
\107\001\255\255\109\001\110\001\255\255\050\001\051\001\114\001\
\053\001\255\255\055\001\056\001\255\255\255\255\059\001\255\255\
\255\255\255\255\255\255\064\001\065\001\255\255\006\001\255\255\
\255\255\255\255\071\001\255\255\012\001\255\255\014\001\255\255\
\255\255\017\001\255\255\255\255\081\001\255\255\255\255\084\001\
\255\255\255\255\255\255\027\001\089\001\255\255\030\001\031\001\
\255\255\006\001\255\255\255\255\097\001\255\255\255\255\012\001\
\101\001\014\001\255\255\104\001\255\255\106\001\255\255\255\255\
\109\001\110\001\050\001\051\001\255\255\053\001\255\255\055\001\
\056\001\030\001\031\001\059\001\255\255\255\255\255\255\255\255\
\064\001\065\001\255\255\255\255\255\255\255\255\255\255\071\001\
\255\255\255\255\255\255\255\255\255\255\050\001\051\001\255\255\
\053\001\081\001\055\001\056\001\084\001\255\255\059\001\255\255\
\255\255\089\001\255\255\064\001\065\001\255\255\255\255\255\255\
\255\255\097\001\071\001\255\255\073\001\101\001\255\255\255\255\
\104\001\255\255\106\001\255\255\081\001\109\001\110\001\084\001\
\255\255\255\255\006\001\255\255\089\001\255\255\255\255\255\255\
\012\001\255\255\014\001\255\255\097\001\255\255\255\255\255\255\
\101\001\255\255\255\255\104\001\255\255\106\001\255\255\027\001\
\109\001\110\001\030\001\031\001\255\255\006\001\255\255\255\255\
\255\255\255\255\255\255\012\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\050\001\051\001\
\255\255\053\001\255\255\055\001\056\001\030\001\031\001\059\001\
\255\255\255\255\255\255\255\255\064\001\065\001\255\255\255\255\
\255\255\255\255\255\255\071\001\255\255\255\255\255\255\255\255\
\255\255\050\001\051\001\255\255\053\001\081\001\055\001\056\001\
\084\001\255\255\059\001\255\255\255\255\089\001\255\255\064\001\
\065\001\255\255\006\001\255\255\255\255\097\001\071\001\255\255\
\012\001\101\001\255\255\255\255\104\001\255\255\106\001\255\255\
\081\001\109\001\110\001\084\001\255\255\255\255\255\255\255\255\
\089\001\255\255\030\001\031\001\255\255\255\255\255\255\255\255\
\097\001\255\255\255\255\255\255\101\001\255\255\255\255\104\001\
\255\255\106\001\255\255\255\255\109\001\110\001\050\001\051\001\
\255\255\053\001\255\255\055\001\056\001\255\255\255\255\059\001\
\255\255\255\255\255\255\255\255\064\001\065\001\255\255\255\255\
\006\001\255\255\255\255\071\001\255\255\255\255\012\001\255\255\
\255\255\255\255\255\255\255\255\255\255\081\001\255\255\255\255\
\084\001\255\255\255\255\255\255\255\255\089\001\028\001\255\255\
\030\001\031\001\255\255\255\255\255\255\097\001\255\255\255\255\
\255\255\101\001\255\255\255\255\104\001\255\255\106\001\255\255\
\255\255\109\001\110\001\255\255\050\001\255\255\052\001\053\001\
\255\255\055\001\056\001\255\255\255\255\059\001\255\255\255\255\
\255\255\255\255\064\001\065\001\255\255\255\255\255\255\006\001\
\255\255\071\001\255\255\010\001\255\255\012\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\084\001\255\255\
\255\255\255\255\255\255\255\255\255\255\028\001\092\001\030\001\
\031\001\255\255\255\255\097\001\255\255\255\255\255\255\101\001\
\255\255\255\255\255\255\255\255\106\001\255\255\255\255\109\001\
\110\001\255\255\255\255\050\001\255\255\052\001\053\001\255\255\
\055\001\056\001\255\255\255\255\059\001\255\255\255\255\255\255\
\255\255\064\001\065\001\255\255\006\001\255\255\255\255\255\255\
\071\001\255\255\012\001\255\255\255\255\255\255\255\255\255\255\
\255\255\006\001\007\001\255\255\255\255\084\001\011\001\012\001\
\255\255\255\255\028\001\255\255\030\001\031\001\255\255\255\255\
\255\255\255\255\097\001\255\255\255\255\255\255\101\001\255\255\
\255\255\030\001\031\001\106\001\255\255\255\255\109\001\110\001\
\050\001\255\255\052\001\053\001\255\255\055\001\056\001\255\255\
\255\255\059\001\255\255\255\255\255\255\050\001\064\001\065\001\
\053\001\054\001\055\001\056\001\255\255\071\001\059\001\255\255\
\006\001\255\255\008\001\064\001\065\001\255\255\012\001\255\255\
\255\255\255\255\084\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\092\001\255\255\255\255\255\255\028\001\097\001\
\030\001\031\001\087\001\101\001\255\255\255\255\255\255\255\255\
\106\001\255\255\255\255\109\001\110\001\255\255\255\255\255\255\
\101\001\255\255\255\255\255\255\050\001\106\001\052\001\053\001\
\109\001\055\001\056\001\255\255\255\255\059\001\255\255\255\255\
\255\255\255\255\064\001\065\001\255\255\006\001\255\255\255\255\
\255\255\071\001\255\255\012\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\084\001\255\255\
\255\255\255\255\255\255\028\001\255\255\030\001\031\001\255\255\
\255\255\255\255\255\255\097\001\255\255\255\255\255\255\101\001\
\255\255\255\255\255\255\255\255\106\001\255\255\255\255\109\001\
\110\001\050\001\255\255\052\001\053\001\255\255\055\001\056\001\
\255\255\255\255\059\001\255\255\255\255\255\255\255\255\064\001\
\065\001\255\255\006\001\255\255\255\255\255\255\071\001\255\255\
\012\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\084\001\255\255\255\255\255\255\255\255\
\028\001\255\255\030\001\031\001\255\255\006\001\255\255\255\255\
\097\001\255\255\255\255\012\001\101\001\255\255\255\255\255\255\
\255\255\106\001\255\255\255\255\109\001\110\001\050\001\255\255\
\052\001\053\001\255\255\055\001\056\001\030\001\031\001\059\001\
\255\255\255\255\255\255\255\255\064\001\065\001\255\255\255\255\
\255\255\255\255\255\255\071\001\255\255\255\255\255\255\255\255\
\255\255\050\001\255\255\052\001\053\001\255\255\055\001\056\001\
\084\001\255\255\059\001\255\255\255\255\255\255\255\255\064\001\
\065\001\255\255\006\001\255\255\255\255\097\001\071\001\255\255\
\012\001\101\001\255\255\255\255\255\255\255\255\106\001\255\255\
\255\255\109\001\110\001\084\001\255\255\255\255\255\255\255\255\
\028\001\255\255\030\001\031\001\093\001\006\001\255\255\255\255\
\097\001\255\255\255\255\012\001\101\001\255\255\255\255\255\255\
\255\255\106\001\255\255\255\255\109\001\110\001\050\001\255\255\
\052\001\053\001\255\255\055\001\056\001\030\001\031\001\059\001\
\255\255\255\255\255\255\255\255\064\001\065\001\255\255\255\255\
\255\255\255\255\255\255\071\001\255\255\255\255\255\255\255\255\
\255\255\050\001\255\255\052\001\053\001\255\255\055\001\056\001\
\084\001\255\255\059\001\255\255\255\255\255\255\255\255\064\001\
\065\001\255\255\006\001\255\255\255\255\097\001\071\001\255\255\
\012\001\101\001\255\255\255\255\255\255\255\255\106\001\255\255\
\255\255\109\001\110\001\084\001\255\255\255\255\255\255\255\255\
\255\255\255\255\030\001\031\001\255\255\006\001\255\255\255\255\
\097\001\255\255\255\255\012\001\101\001\255\255\255\255\255\255\
\255\255\106\001\255\255\255\255\109\001\110\001\050\001\255\255\
\052\001\053\001\255\255\055\001\056\001\030\001\031\001\059\001\
\255\255\255\255\255\255\255\255\064\001\065\001\255\255\255\255\
\255\255\255\255\255\255\071\001\255\255\255\255\255\255\255\255\
\255\255\050\001\255\255\255\255\053\001\255\255\055\001\056\001\
\084\001\255\255\059\001\255\255\255\255\255\255\255\255\064\001\
\065\001\255\255\006\001\255\255\255\255\097\001\071\001\255\255\
\012\001\101\001\255\255\255\255\255\255\255\255\106\001\255\255\
\255\255\109\001\110\001\084\001\255\255\255\255\255\255\255\255\
\255\255\255\255\030\001\031\001\255\255\255\255\255\255\255\255\
\097\001\255\255\255\255\255\255\101\001\255\255\255\255\255\255\
\255\255\106\001\255\255\255\255\109\001\110\001\050\001\255\255\
\255\255\053\001\255\255\055\001\056\001\255\255\255\255\059\001\
\255\255\255\255\255\255\255\255\064\001\065\001\255\255\006\001\
\007\001\255\255\255\255\071\001\011\001\012\001\006\001\007\001\
\255\255\255\255\255\255\011\001\012\001\255\255\255\255\022\001\
\084\001\255\255\255\255\255\255\255\255\255\255\255\255\030\001\
\031\001\255\255\255\255\255\255\255\255\097\001\030\001\031\001\
\255\255\101\001\255\255\255\255\255\255\255\255\106\001\255\255\
\047\001\109\001\110\001\050\001\051\001\255\255\053\001\054\001\
\055\001\056\001\050\001\051\001\059\001\053\001\054\001\055\001\
\056\001\064\001\065\001\059\001\255\255\255\255\255\255\255\255\
\064\001\065\001\255\255\255\255\255\255\255\255\255\255\006\001\
\007\001\255\255\081\001\255\255\011\001\012\001\255\255\255\255\
\087\001\081\001\089\001\255\255\255\255\255\255\255\255\087\001\
\255\255\089\001\097\001\098\001\255\255\255\255\101\001\030\001\
\031\001\104\001\255\255\106\001\255\255\101\001\109\001\255\255\
\104\001\255\255\106\001\255\255\255\255\109\001\255\255\255\255\
\255\255\255\255\255\255\050\001\255\255\255\255\053\001\054\001\
\055\001\056\001\255\255\255\255\059\001\255\255\255\255\255\255\
\255\255\064\001\065\001\255\255\255\255\000\001\001\001\002\001\
\255\255\255\255\255\255\255\255\255\255\255\255\009\001\255\255\
\255\255\255\255\255\255\014\001\015\001\016\001\017\001\018\001\
\087\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\027\001\255\255\255\255\255\255\255\255\255\255\101\001\255\255\
\255\255\036\001\255\255\106\001\255\255\255\255\109\001\042\001\
\043\001\044\001\045\001\046\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\255\255\015\001\255\255\255\255\066\001\
\255\255\255\255\255\255\255\255\071\001\072\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\083\001\084\001\085\001\086\001\255\255\000\001\001\001\002\001\
\255\255\255\255\255\255\094\001\007\001\255\255\009\001\255\255\
\255\255\100\001\255\255\255\255\055\001\016\001\057\001\058\001\
\059\001\255\255\061\001\255\255\255\255\064\001\065\001\255\255\
\027\001\255\255\255\255\255\255\255\255\255\255\255\255\074\001\
\255\255\036\001\255\255\255\255\255\255\255\255\081\001\042\001\
\043\001\044\001\045\001\046\001\047\001\255\255\089\001\090\001\
\255\255\255\255\255\255\094\001\255\255\255\255\097\001\255\255\
\255\255\255\255\061\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\109\001\110\001\071\001\072\001\255\255\074\001\
\255\255\255\255\255\255\255\255\000\001\001\001\002\001\082\001\
\083\001\084\001\085\001\086\001\087\001\009\001\255\255\255\255\
\255\255\255\255\255\255\015\001\016\001\255\255\018\001\098\001\
\255\255\100\001\255\255\255\255\255\255\255\255\255\255\027\001\
\255\255\255\255\255\255\255\255\000\001\001\001\002\001\255\255\
\036\001\255\255\255\255\255\255\255\255\009\001\042\001\043\001\
\044\001\045\001\046\001\015\001\016\001\255\255\018\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\027\001\
\255\255\061\001\255\255\255\255\255\255\255\255\066\001\255\255\
\036\001\255\255\255\255\071\001\072\001\255\255\042\001\043\001\
\044\001\045\001\046\001\255\255\255\255\255\255\082\001\083\001\
\084\001\085\001\086\001\255\255\255\255\255\255\255\255\091\001\
\255\255\061\001\255\255\255\255\255\255\255\255\066\001\255\255\
\100\001\255\255\255\255\071\001\072\001\255\255\255\255\255\255\
\255\255\255\255\000\001\001\001\002\001\255\255\082\001\083\001\
\084\001\085\001\086\001\009\001\255\255\255\255\255\255\255\255\
\092\001\015\001\016\001\255\255\018\001\255\255\255\255\255\255\
\100\001\255\255\255\255\255\255\255\255\027\001\255\255\255\255\
\255\255\255\255\000\001\001\001\002\001\255\255\036\001\255\255\
\255\255\255\255\255\255\009\001\042\001\043\001\044\001\045\001\
\046\001\015\001\016\001\255\255\018\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\027\001\255\255\061\001\
\255\255\255\255\255\255\255\255\066\001\255\255\036\001\255\255\
\255\255\071\001\072\001\255\255\042\001\043\001\044\001\045\001\
\046\001\255\255\255\255\255\255\082\001\083\001\084\001\085\001\
\086\001\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\094\001\255\255\255\255\255\255\066\001\255\255\100\001\255\255\
\255\255\071\001\072\001\255\255\255\255\255\255\255\255\255\255\
\000\001\001\001\002\001\255\255\082\001\083\001\084\001\085\001\
\086\001\009\001\255\255\255\255\255\255\091\001\255\255\015\001\
\016\001\255\255\018\001\255\255\255\255\255\255\100\001\255\255\
\255\255\255\255\255\255\027\001\255\255\255\255\255\255\255\255\
\000\001\001\001\002\001\255\255\036\001\255\255\255\255\255\255\
\255\255\009\001\042\001\043\001\044\001\045\001\046\001\015\001\
\016\001\255\255\018\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\027\001\255\255\061\001\255\255\255\255\
\255\255\255\255\066\001\255\255\036\001\255\255\255\255\071\001\
\072\001\255\255\042\001\043\001\044\001\045\001\046\001\255\255\
\255\255\255\255\082\001\083\001\084\001\085\001\086\001\255\255\
\255\255\255\255\255\255\255\255\092\001\061\001\255\255\255\255\
\255\255\255\255\066\001\255\255\100\001\255\255\255\255\071\001\
\072\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\082\001\083\001\084\001\085\001\086\001\000\001\
\001\001\002\001\255\255\255\255\255\255\255\255\094\001\255\255\
\009\001\255\255\255\255\255\255\100\001\255\255\015\001\016\001\
\255\255\018\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\255\255\255\255\255\255\000\001\
\001\001\002\001\255\255\036\001\255\255\255\255\255\255\255\255\
\009\001\042\001\043\001\044\001\045\001\046\001\015\001\016\001\
\255\255\018\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\061\001\255\255\255\255\255\255\
\255\255\066\001\255\255\036\001\255\255\255\255\071\001\072\001\
\255\255\042\001\043\001\044\001\045\001\046\001\255\255\255\255\
\255\255\082\001\083\001\084\001\085\001\086\001\255\255\255\255\
\255\255\255\255\091\001\255\255\061\001\255\255\255\255\255\255\
\255\255\066\001\255\255\100\001\255\255\255\255\071\001\072\001\
\255\255\255\255\255\255\255\255\255\255\000\001\001\001\002\001\
\255\255\082\001\083\001\084\001\085\001\086\001\009\001\255\255\
\255\255\255\255\255\255\092\001\015\001\016\001\255\255\018\001\
\255\255\255\255\255\255\100\001\255\255\255\255\255\255\255\255\
\027\001\255\255\255\255\255\255\255\255\000\001\001\001\002\001\
\255\255\036\001\255\255\255\255\255\255\255\255\009\001\042\001\
\043\001\044\001\045\001\046\001\015\001\016\001\255\255\018\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\027\001\255\255\061\001\255\255\255\255\255\255\255\255\066\001\
\255\255\036\001\255\255\255\255\071\001\072\001\255\255\042\001\
\043\001\044\001\045\001\046\001\255\255\255\255\255\255\082\001\
\083\001\084\001\085\001\086\001\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\094\001\255\255\255\255\255\255\066\001\
\255\255\100\001\255\255\255\255\071\001\072\001\255\255\255\255\
\255\255\255\255\255\255\000\001\001\001\002\001\255\255\082\001\
\083\001\084\001\085\001\086\001\009\001\255\255\255\255\255\255\
\091\001\255\255\015\001\016\001\255\255\018\001\255\255\255\255\
\255\255\100\001\255\255\255\255\255\255\255\255\027\001\255\255\
\255\255\255\255\255\255\000\001\001\001\002\001\255\255\036\001\
\255\255\255\255\255\255\255\255\009\001\042\001\043\001\044\001\
\045\001\046\001\015\001\016\001\255\255\018\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\027\001\255\255\
\061\001\255\255\255\255\255\255\255\255\066\001\255\255\036\001\
\255\255\255\255\071\001\072\001\255\255\042\001\043\001\044\001\
\045\001\046\001\255\255\255\255\255\255\082\001\083\001\084\001\
\085\001\086\001\255\255\255\255\255\255\255\255\255\255\092\001\
\061\001\001\001\002\001\255\255\255\255\066\001\255\255\100\001\
\255\255\009\001\071\001\072\001\255\255\255\255\255\255\015\001\
\016\001\255\255\018\001\255\255\255\255\082\001\083\001\084\001\
\085\001\086\001\255\255\027\001\255\255\255\255\255\255\255\255\
\255\255\094\001\255\255\255\255\036\001\255\255\255\255\100\001\
\255\255\255\255\042\001\043\001\044\001\045\001\046\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\061\001\255\255\255\255\
\255\255\255\255\066\001\255\255\255\255\255\255\255\255\071\001\
\072\001\001\001\002\001\255\255\255\255\255\255\255\255\255\255\
\255\255\009\001\082\001\083\001\084\001\085\001\086\001\015\001\
\016\001\255\255\018\001\255\255\255\255\255\255\255\255\095\001\
\255\255\025\001\255\255\027\001\100\001\255\255\255\255\255\255\
\255\255\001\001\002\001\255\255\036\001\255\255\255\255\255\255\
\255\255\009\001\042\001\043\001\044\001\045\001\046\001\015\001\
\016\001\255\255\018\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\027\001\255\255\061\001\255\255\255\255\
\255\255\255\255\066\001\255\255\036\001\255\255\255\255\071\001\
\072\001\255\255\042\001\043\001\044\001\045\001\046\001\255\255\
\255\255\255\255\082\001\083\001\084\001\085\001\086\001\255\255\
\255\255\255\255\255\255\255\255\255\255\061\001\001\001\002\001\
\255\255\255\255\066\001\255\255\100\001\255\255\009\001\071\001\
\072\001\255\255\255\255\255\255\015\001\255\255\255\255\255\255\
\255\255\255\255\082\001\083\001\084\001\085\001\086\001\255\255\
\027\001\255\255\255\255\255\255\255\255\255\255\001\001\002\001\
\255\255\036\001\255\255\255\255\100\001\255\255\255\255\042\001\
\043\001\044\001\045\001\046\001\015\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\027\001\255\255\061\001\255\255\255\255\255\255\255\255\066\001\
\255\255\036\001\255\255\255\255\071\001\072\001\255\255\042\001\
\043\001\044\001\045\001\046\001\013\001\255\255\255\255\082\001\
\083\001\084\001\085\001\086\001\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\028\001\029\001\255\255\255\255\066\001\
\255\255\100\001\255\255\255\255\071\001\072\001\255\255\255\255\
\041\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\083\001\084\001\085\001\086\001\255\255\255\255\055\001\255\255\
\057\001\058\001\059\001\060\001\061\001\255\255\255\255\064\001\
\065\001\100\001\255\255\068\001\255\255\255\255\255\255\255\255\
\255\255\074\001\255\255\255\255\255\255\255\255\255\255\080\001\
\081\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\089\001\090\001\255\255\255\255\255\255\255\255\255\255\096\001\
\097\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\108\001\109\001\110\001\111\001"

let yynames_const = "\
  AMPERAMPER\000\
  AMPERSAND\000\
  AND\000\
  AS\000\
  ASSERT\000\
  BACKQUOTE\000\
  BANG\000\
  BAR\000\
  BARBAR\000\
  BARRBRACKET\000\
  BEGIN\000\
  CLASS\000\
  COLON\000\
  COLONCOLON\000\
  COLONEQUAL\000\
  COLONGREATER\000\
  COMMA\000\
  CONSTRAINT\000\
  DO\000\
  DONE\000\
  DOT\000\
  DOTDOT\000\
  DOWNTO\000\
  ELSE\000\
  END\000\
  EOF\000\
  EQUAL\000\
  EXCEPTION\000\
  EXTERNAL\000\
  FALSE\000\
  FOR\000\
  FUN\000\
  FUNCTION\000\
  FUNCTOR\000\
  GREATER\000\
  GREATERRBRACE\000\
  GREATERRBRACKET\000\
  IF\000\
  IN\000\
  INCLUDE\000\
  INHERIT\000\
  INITIALIZER\000\
  LAZY\000\
  LBRACE\000\
  LBRACELESS\000\
  LBRACKET\000\
  LBRACKETBAR\000\
  LBRACKETLESS\000\
  LBRACKETGREATER\000\
  LBRACKETPERCENT\000\
  LBRACKETPERCENTPERCENT\000\
  LESS\000\
  LESSMINUS\000\
  LET\000\
  LPAREN\000\
  LBRACKETAT\000\
  LBRACKETATAT\000\
  LBRACKETATATAT\000\
  MATCH\000\
  METHOD\000\
  MINUS\000\
  MINUSDOT\000\
  MINUSGREATER\000\
  MODULE\000\
  MUTABLE\000\
  NEW\000\
  NONREC\000\
  OBJECT\000\
  OF\000\
  OPEN\000\
  OR\000\
  PERCENT\000\
  PLUS\000\
  PLUSDOT\000\
  PLUSEQ\000\
  PRIVATE\000\
  QUESTION\000\
  QUOTE\000\
  RBRACE\000\
  RBRACKET\000\
  REC\000\
  RPAREN\000\
  SEMI\000\
  SEMISEMI\000\
  HASH\000\
  SIG\000\
  STAR\000\
  STRUCT\000\
  THEN\000\
  TILDE\000\
  TO\000\
  TRUE\000\
  TRY\000\
  TYPE\000\
  UNDERSCORE\000\
  VAL\000\
  VIRTUAL\000\
  WHEN\000\
  WHILE\000\
  WITH\000\
  EOL\000\
  "

let yynames_block = "\
  CHAR\000\
  FLOAT\000\
  INFIXOP0\000\
  INFIXOP1\000\
  INFIXOP2\000\
  INFIXOP3\000\
  INFIXOP4\000\
  DOTOP\000\
  INT\000\
  LABEL\000\
  LIDENT\000\
  OPTLABEL\000\
  PREFIXOP\000\
  HASHOP\000\
  STRING\000\
  UIDENT\000\
  COMMENT\000\
  DOCSTRING\000\
  "

let yyact = [|
  (fun _ -> failwith "parser")
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'structure) in
    Obj.repr(
# 568 "ml/parser.mly"
                                         ( extra_str 1 _1 )
# 6360 "ml/parser.ml"
               : Parsetree.structure))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'signature) in
    Obj.repr(
# 571 "ml/parser.mly"
                                         ( extra_sig 1 _1 )
# 6367 "ml/parser.ml"
               : Parsetree.signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
# 576 "ml/parser.mly"
                  ( _1 )
# 6374 "ml/parser.ml"
               : Parsetree.core_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 579 "ml/parser.mly"
                 ( _1 )
# 6381 "ml/parser.ml"
               : Parsetree.expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
# 582 "ml/parser.mly"
                ( _1 )
# 6388 "ml/parser.ml"
               : Parsetree.pattern))
; (fun __caml_parser_env ->
    Obj.repr(
# 589 "ml/parser.mly"
      ( mkrhs "*" 2, None )
# 6394 "ml/parser.ml"
               : 'functor_arg))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'functor_arg_name) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
# 591 "ml/parser.mly"
      ( mkrhs _2 2, Some _4 )
# 6402 "ml/parser.ml"
               : 'functor_arg))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 595 "ml/parser.mly"
               ( _1 )
# 6409 "ml/parser.ml"
               : 'functor_arg_name))
; (fun __caml_parser_env ->
    Obj.repr(
# 596 "ml/parser.mly"
               ( "_" )
# 6415 "ml/parser.ml"
               : 'functor_arg_name))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'functor_args) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'functor_arg) in
    Obj.repr(
# 601 "ml/parser.mly"
      ( _2 :: _1 )
# 6423 "ml/parser.ml"
               : 'functor_args))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'functor_arg) in
    Obj.repr(
# 603 "ml/parser.mly"
      ( [ _1 ] )
# 6430 "ml/parser.ml"
               : 'functor_args))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'mod_longident) in
    Obj.repr(
# 608 "ml/parser.mly"
      ( mkmod(Pmod_ident (mkrhs _1 1)) )
# 6437 "ml/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'structure) in
    Obj.repr(
# 610 "ml/parser.mly"
      ( mkmod ~attrs:_2 (Pmod_structure(extra_str 3 _3)) )
# 6445 "ml/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'structure) in
    Obj.repr(
# 612 "ml/parser.mly"
      ( unclosed "struct" 1 "end" 4 )
# 6453 "ml/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'functor_args) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'module_expr) in
    Obj.repr(
# 614 "ml/parser.mly"
      ( let modexp =
          List.fold_left
            (fun acc (n, t) -> mkmod(Pmod_functor(n, t, acc)))
            _5 _3
        in wrap_mod_attrs modexp _2 )
# 6466 "ml/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'paren_module_expr) in
    Obj.repr(
# 620 "ml/parser.mly"
      ( mkmod(Pmod_apply(_1, _2)) )
# 6474 "ml/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'module_expr) in
    Obj.repr(
# 622 "ml/parser.mly"
      ( mkmod(Pmod_apply(_1, mkmod (Pmod_structure []))) )
# 6481 "ml/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'paren_module_expr) in
    Obj.repr(
# 624 "ml/parser.mly"
      ( _1 )
# 6488 "ml/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 626 "ml/parser.mly"
      ( Mod.attr _1 _2 )
# 6496 "ml/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
# 628 "ml/parser.mly"
      ( mkmod(Pmod_extension _1) )
# 6503 "ml/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
# 633 "ml/parser.mly"
      ( mkmod(Pmod_constraint(_2, _4)) )
# 6511 "ml/parser.ml"
               : 'paren_module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
# 635 "ml/parser.mly"
      ( unclosed "(" 1 ")" 5 )
# 6519 "ml/parser.ml"
               : 'paren_module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    Obj.repr(
# 637 "ml/parser.mly"
      ( _2 )
# 6526 "ml/parser.ml"
               : 'paren_module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    Obj.repr(
# 639 "ml/parser.mly"
      ( unclosed "(" 1 ")" 3 )
# 6533 "ml/parser.ml"
               : 'paren_module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 641 "ml/parser.mly"
      ( mkmod ~attrs:_3 (Pmod_unpack _4))
# 6541 "ml/parser.ml"
               : 'paren_module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 643 "ml/parser.mly"
      ( mkmod ~attrs:_3
          (Pmod_unpack(
               ghexp(Pexp_constraint(_4, ghtyp(Ptyp_package _6))))) )
# 6552 "ml/parser.ml"
               : 'paren_module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 6 : 'attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 5 : 'expr) in
    let _6 = (Parsing.peek_val __caml_parser_env 3 : 'package_type) in
    let _8 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 648 "ml/parser.mly"
      ( mkmod ~attrs:_3
          (Pmod_unpack(
               ghexp(Pexp_coerce(_4, Some(ghtyp(Ptyp_package _6)),
                                 ghtyp(Ptyp_package _8))))) )
# 6565 "ml/parser.ml"
               : 'paren_module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 653 "ml/parser.mly"
      ( mkmod ~attrs:_3
          (Pmod_unpack(
               ghexp(Pexp_coerce(_4, None, ghtyp(Ptyp_package _6))))) )
# 6576 "ml/parser.ml"
               : 'paren_module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    Obj.repr(
# 657 "ml/parser.mly"
      ( unclosed "(" 1 ")" 6 )
# 6584 "ml/parser.ml"
               : 'paren_module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    Obj.repr(
# 659 "ml/parser.mly"
      ( unclosed "(" 1 ")" 6 )
# 6592 "ml/parser.ml"
               : 'paren_module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 661 "ml/parser.mly"
      ( unclosed "(" 1 ")" 5 )
# 6600 "ml/parser.ml"
               : 'paren_module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'post_item_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'structure_tail) in
    Obj.repr(
# 666 "ml/parser.mly"
      ( mark_rhs_docs 1 2;
        (text_str 1) @ mkstrexp _1 _2 :: _3 )
# 6610 "ml/parser.ml"
               : 'structure))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'structure_tail) in
    Obj.repr(
# 668 "ml/parser.mly"
                   ( _1 )
# 6617 "ml/parser.ml"
               : 'structure))
; (fun __caml_parser_env ->
    Obj.repr(
# 671 "ml/parser.mly"
                         ( [] )
# 6623 "ml/parser.ml"
               : 'structure_tail))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'structure) in
    Obj.repr(
# 672 "ml/parser.mly"
                         ( (text_str 1) @ _2 )
# 6630 "ml/parser.ml"
               : 'structure_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'structure_item) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'structure_tail) in
    Obj.repr(
# 673 "ml/parser.mly"
                                  ( (text_str 1) @ _1 :: _2 )
# 6638 "ml/parser.ml"
               : 'structure_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'let_bindings) in
    Obj.repr(
# 677 "ml/parser.mly"
      ( val_of_let_bindings _1 )
# 6645 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'primitive_declaration) in
    Obj.repr(
# 679 "ml/parser.mly"
      ( let (body, ext) = _1 in mkstr_ext (Pstr_primitive body) ext )
# 6652 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'value_description) in
    Obj.repr(
# 681 "ml/parser.mly"
      ( let (body, ext) = _1 in mkstr_ext (Pstr_primitive body) ext )
# 6659 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_declarations) in
    Obj.repr(
# 683 "ml/parser.mly"
      ( let (nr, l, ext ) = _1 in mkstr_ext (Pstr_type (nr, List.rev l)) ext )
# 6666 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'str_type_extension) in
    Obj.repr(
# 685 "ml/parser.mly"
      ( let (l, ext) = _1 in mkstr_ext (Pstr_typext l) ext )
# 6673 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'str_exception_declaration) in
    Obj.repr(
# 687 "ml/parser.mly"
      ( let (l, ext) = _1 in mkstr_ext (Pstr_exception l) ext )
# 6680 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_binding) in
    Obj.repr(
# 689 "ml/parser.mly"
      ( let (body, ext) = _1 in mkstr_ext (Pstr_module body) ext )
# 6687 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'rec_module_bindings) in
    Obj.repr(
# 691 "ml/parser.mly"
      ( let (l, ext) = _1 in mkstr_ext (Pstr_recmodule(List.rev l)) ext )
# 6694 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_type_declaration) in
    Obj.repr(
# 693 "ml/parser.mly"
      ( let (body, ext) = _1 in mkstr_ext (Pstr_modtype body) ext )
# 6701 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'open_statement) in
    Obj.repr(
# 695 "ml/parser.mly"
      ( let (body, ext) = _1 in mkstr_ext (Pstr_open body) ext )
# 6708 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_type_declarations) in
    Obj.repr(
# 697 "ml/parser.mly"
      ( let (l, ext) = _1 in mkstr_ext (Pstr_class_type (List.rev l)) ext )
# 6715 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'str_include_statement) in
    Obj.repr(
# 699 "ml/parser.mly"
      ( let (body, ext) = _1 in mkstr_ext (Pstr_include body) ext )
# 6722 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'item_extension) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 701 "ml/parser.mly"
      ( mkstr(Pstr_extension (_1, (add_docs_attrs (symbol_docs ()) _2))) )
# 6730 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'floating_attribute) in
    Obj.repr(
# 703 "ml/parser.mly"
      ( mark_symbol_docs ();
        mkstr(Pstr_attribute _1) )
# 6738 "ml/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 708 "ml/parser.mly"
      ( let (ext, attrs) = _2 in
        Incl.mk _3 ~attrs:(attrs@_4)
            ~loc:(symbol_rloc()) ~docs:(symbol_docs ())
      , ext )
# 6750 "ml/parser.ml"
               : 'str_include_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'module_expr) in
    Obj.repr(
# 715 "ml/parser.mly"
      ( _2 )
# 6757 "ml/parser.ml"
               : 'module_binding_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'module_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'module_expr) in
    Obj.repr(
# 717 "ml/parser.mly"
      ( mkmod(Pmod_constraint(_4, _2)) )
# 6765 "ml/parser.ml"
               : 'module_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'functor_arg) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'module_binding_body) in
    Obj.repr(
# 719 "ml/parser.mly"
      ( mkmod(Pmod_functor(fst _1, snd _1, _2)) )
# 6773 "ml/parser.ml"
               : 'module_binding_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_binding_body) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 723 "ml/parser.mly"
      ( let (ext, attrs) = _2 in
        Mb.mk (mkrhs _3 3) _4 ~attrs:(attrs@_5)
            ~loc:(symbol_rloc ()) ~docs:(symbol_docs ())
      , ext )
# 6786 "ml/parser.ml"
               : 'module_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'rec_module_binding) in
    Obj.repr(
# 729 "ml/parser.mly"
                                           ( let (b, ext) = _1 in ([b], ext) )
# 6793 "ml/parser.ml"
               : 'rec_module_bindings))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'rec_module_bindings) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_module_binding) in
    Obj.repr(
# 731 "ml/parser.mly"
      ( let (l, ext) = _1 in (_2 :: l, ext) )
# 6801 "ml/parser.ml"
               : 'rec_module_bindings))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'module_binding_body) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 735 "ml/parser.mly"
      ( let (ext, attrs) = _2 in
        Mb.mk (mkrhs _4 4) _5 ~attrs:(attrs@_6)
            ~loc:(symbol_rloc ()) ~docs:(symbol_docs ())
      , ext )
# 6814 "ml/parser.ml"
               : 'rec_module_binding))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_binding_body) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 742 "ml/parser.mly"
      ( Mb.mk (mkrhs _3 3) _4 ~attrs:(_2@_5) ~loc:(symbol_rloc ())
               ~text:(symbol_text ()) ~docs:(symbol_docs ()) )
# 6825 "ml/parser.ml"
               : 'and_module_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'mty_longident) in
    Obj.repr(
# 750 "ml/parser.mly"
      ( mkmty(Pmty_ident (mkrhs _1 1)) )
# 6832 "ml/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'signature) in
    Obj.repr(
# 752 "ml/parser.mly"
      ( mkmty ~attrs:_2 (Pmty_signature (extra_sig 3 _3)) )
# 6840 "ml/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'signature) in
    Obj.repr(
# 754 "ml/parser.mly"
      ( unclosed "sig" 1 "end" 4 )
# 6848 "ml/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'functor_args) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'module_type) in
    Obj.repr(
# 757 "ml/parser.mly"
      ( let mty =
          List.fold_left
            (fun acc (n, t) -> mkmty(Pmty_functor(n, t, acc)))
            _5 _3
        in wrap_mty_attrs mty _2 )
# 6861 "ml/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'module_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'module_type) in
    Obj.repr(
# 764 "ml/parser.mly"
      ( mkmty(Pmty_functor(mknoloc "_", Some _1, _3)) )
# 6869 "ml/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'module_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'with_constraints) in
    Obj.repr(
# 766 "ml/parser.mly"
      ( mkmty(Pmty_with(_1, List.rev _3)) )
# 6877 "ml/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'attributes) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'module_expr) in
    Obj.repr(
# 768 "ml/parser.mly"
      ( mkmty ~attrs:_4 (Pmty_typeof _5) )
# 6885 "ml/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
# 772 "ml/parser.mly"
      ( _2 )
# 6892 "ml/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
# 774 "ml/parser.mly"
      ( unclosed "(" 1 ")" 3 )
# 6899 "ml/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
# 776 "ml/parser.mly"
      ( mkmty(Pmty_extension _1) )
# 6906 "ml/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 778 "ml/parser.mly"
      ( Mty.attr _1 _2 )
# 6914 "ml/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    Obj.repr(
# 781 "ml/parser.mly"
                         ( [] )
# 6920 "ml/parser.ml"
               : 'signature))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'signature) in
    Obj.repr(
# 782 "ml/parser.mly"
                         ( (text_sig 1) @ _2 )
# 6927 "ml/parser.ml"
               : 'signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'signature_item) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'signature) in
    Obj.repr(
# 783 "ml/parser.mly"
                             ( (text_sig 1) @ _1 :: _2 )
# 6935 "ml/parser.ml"
               : 'signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'value_description) in
    Obj.repr(
# 787 "ml/parser.mly"
      ( let (body, ext) = _1 in mksig_ext (Psig_value body) ext )
# 6942 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'primitive_declaration) in
    Obj.repr(
# 789 "ml/parser.mly"
      ( let (body, ext) = _1 in mksig_ext (Psig_value body) ext)
# 6949 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_declarations) in
    Obj.repr(
# 791 "ml/parser.mly"
      ( let (nr, l, ext) = _1 in mksig_ext (Psig_type (nr, List.rev l)) ext )
# 6956 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sig_type_extension) in
    Obj.repr(
# 793 "ml/parser.mly"
      ( let (l, ext) = _1 in mksig_ext (Psig_typext l) ext )
# 6963 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sig_exception_declaration) in
    Obj.repr(
# 795 "ml/parser.mly"
      ( let (l, ext) = _1 in mksig_ext (Psig_exception l) ext )
# 6970 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_declaration) in
    Obj.repr(
# 797 "ml/parser.mly"
      ( let (body, ext) = _1 in mksig_ext (Psig_module body) ext )
# 6977 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_alias) in
    Obj.repr(
# 799 "ml/parser.mly"
      ( let (body, ext) = _1 in mksig_ext (Psig_module body) ext )
# 6984 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'rec_module_declarations) in
    Obj.repr(
# 801 "ml/parser.mly"
      ( let (l, ext) = _1 in mksig_ext (Psig_recmodule (List.rev l)) ext )
# 6991 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_type_declaration) in
    Obj.repr(
# 803 "ml/parser.mly"
      ( let (body, ext) = _1 in mksig_ext (Psig_modtype body) ext )
# 6998 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'open_statement) in
    Obj.repr(
# 805 "ml/parser.mly"
      ( let (body, ext) = _1 in mksig_ext (Psig_open body) ext )
# 7005 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sig_include_statement) in
    Obj.repr(
# 807 "ml/parser.mly"
      ( let (body, ext) = _1 in mksig_ext (Psig_include body) ext )
# 7012 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_type_declarations) in
    Obj.repr(
# 809 "ml/parser.mly"
      ( let (l, ext) = _1 in mksig_ext (Psig_class_type (List.rev l)) ext )
# 7019 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'item_extension) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 811 "ml/parser.mly"
      ( mksig(Psig_extension (_1, (add_docs_attrs (symbol_docs ()) _2))) )
# 7027 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'floating_attribute) in
    Obj.repr(
# 813 "ml/parser.mly"
      ( mark_symbol_docs ();
        mksig(Psig_attribute _1) )
# 7035 "ml/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'override_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'mod_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 818 "ml/parser.mly"
      ( let (ext, attrs) = _3 in
        Opn.mk (mkrhs _4 4) ~override:_2 ~attrs:(attrs@_5)
          ~loc:(symbol_rloc()) ~docs:(symbol_docs ())
      , ext)
# 7048 "ml/parser.ml"
               : 'open_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 825 "ml/parser.mly"
      ( let (ext, attrs) = _2 in
        Incl.mk _3 ~attrs:(attrs@_4)
            ~loc:(symbol_rloc()) ~docs:(symbol_docs ())
      , ext)
# 7060 "ml/parser.ml"
               : 'sig_include_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'module_type) in
    Obj.repr(
# 832 "ml/parser.mly"
      ( _2 )
# 7067 "ml/parser.ml"
               : 'module_declaration_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'module_type) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'module_declaration_body) in
    Obj.repr(
# 834 "ml/parser.mly"
      ( mkmty(Pmty_functor(mkrhs _2 2, Some _4, _6)) )
# 7076 "ml/parser.ml"
               : 'module_declaration_body))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'module_declaration_body) in
    Obj.repr(
# 836 "ml/parser.mly"
      ( mkmty(Pmty_functor(mkrhs "*" 1, None, _3)) )
# 7083 "ml/parser.ml"
               : 'module_declaration_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_declaration_body) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 840 "ml/parser.mly"
      ( let (ext, attrs) = _2 in
        Md.mk (mkrhs _3 3) _4 ~attrs:(attrs@_5)
          ~loc:(symbol_rloc()) ~docs:(symbol_docs ())
      , ext )
# 7096 "ml/parser.ml"
               : 'module_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'mod_longident) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 847 "ml/parser.mly"
      ( let (ext, attrs) = _2 in
        Md.mk (mkrhs _3 3)
          (Mty.alias ~loc:(rhs_loc 5) (mkrhs _5 5)) ~attrs:(attrs@_6)
             ~loc:(symbol_rloc()) ~docs:(symbol_docs ())
      , ext )
# 7110 "ml/parser.ml"
               : 'module_alias))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'rec_module_declaration) in
    Obj.repr(
# 855 "ml/parser.mly"
      ( let (body, ext) = _1 in ([body], ext) )
# 7117 "ml/parser.ml"
               : 'rec_module_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'rec_module_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_module_declaration) in
    Obj.repr(
# 857 "ml/parser.mly"
      ( let (l, ext) = _1 in (_2 :: l, ext) )
# 7125 "ml/parser.ml"
               : 'rec_module_declarations))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 861 "ml/parser.mly"
      ( let (ext, attrs) = _2 in
        Md.mk (mkrhs _4 4) _6 ~attrs:(attrs@_7)
            ~loc:(symbol_rloc()) ~docs:(symbol_docs ())
      , ext)
# 7138 "ml/parser.ml"
               : 'rec_module_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 868 "ml/parser.mly"
      ( Md.mk (mkrhs _3 3) _5 ~attrs:(_2@_6) ~loc:(symbol_rloc())
              ~text:(symbol_text()) ~docs:(symbol_docs()) )
# 7149 "ml/parser.ml"
               : 'and_module_declaration))
; (fun __caml_parser_env ->
    Obj.repr(
# 872 "ml/parser.mly"
                              ( None )
# 7155 "ml/parser.ml"
               : 'module_type_declaration_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'module_type) in
    Obj.repr(
# 873 "ml/parser.mly"
                              ( Some _2 )
# 7162 "ml/parser.ml"
               : 'module_type_declaration_body))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'ident) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'module_type_declaration_body) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 878 "ml/parser.mly"
      ( let (ext, attrs) = _3 in
        Mtd.mk (mkrhs _4 4) ?typ:_5 ~attrs:(attrs@_6)
          ~loc:(symbol_rloc()) ~docs:(symbol_docs ())
      , ext )
# 7175 "ml/parser.ml"
               : 'module_type_declaration))
; (fun __caml_parser_env ->
    Obj.repr(
# 886 "ml/parser.mly"
                                                ( [] )
# 7181 "ml/parser.ml"
               : 'class_type_parameters))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'type_parameter_list) in
    Obj.repr(
# 887 "ml/parser.mly"
                                                ( List.rev _2 )
# 7188 "ml/parser.ml"
               : 'class_type_parameters))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_self_pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_fields) in
    Obj.repr(
# 891 "ml/parser.mly"
       ( Cstr.mk _1 (extra_cstr 2 (List.rev _2)) )
# 7196 "ml/parser.ml"
               : 'class_structure))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
# 895 "ml/parser.mly"
      ( reloc_pat _2 )
# 7203 "ml/parser.ml"
               : 'class_self_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
# 897 "ml/parser.mly"
      ( mkpat(Ppat_constraint(_2, _4)) )
# 7211 "ml/parser.ml"
               : 'class_self_pattern))
; (fun __caml_parser_env ->
    Obj.repr(
# 899 "ml/parser.mly"
      ( ghpat(Ppat_any) )
# 7217 "ml/parser.ml"
               : 'class_self_pattern))
; (fun __caml_parser_env ->
    Obj.repr(
# 903 "ml/parser.mly"
      ( [] )
# 7223 "ml/parser.ml"
               : 'class_fields))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_fields) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_field) in
    Obj.repr(
# 905 "ml/parser.mly"
      ( _2 :: (text_cstr 2) @ _1 )
# 7231 "ml/parser.ml"
               : 'class_fields))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'value) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 909 "ml/parser.mly"
      ( let v, attrs = _2 in
        mkcf (Pcf_val v) ~attrs:(attrs@_3) ~docs:(symbol_docs ()) )
# 7240 "ml/parser.ml"
               : 'class_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'method_) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 912 "ml/parser.mly"
      ( let meth, attrs = _2 in
        mkcf (Pcf_method meth) ~attrs:(attrs@_3) ~docs:(symbol_docs ()) )
# 7249 "ml/parser.ml"
               : 'class_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'constrain_field) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 915 "ml/parser.mly"
      ( mkcf (Pcf_constraint _3) ~attrs:(_2@_4) ~docs:(symbol_docs ()) )
# 7258 "ml/parser.ml"
               : 'class_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 917 "ml/parser.mly"
      ( mkcf (Pcf_initializer _3) ~attrs:(_2@_4) ~docs:(symbol_docs ()) )
# 7267 "ml/parser.ml"
               : 'class_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'item_extension) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 919 "ml/parser.mly"
      ( mkcf (Pcf_extension _1) ~attrs:_2 ~docs:(symbol_docs ()) )
# 7275 "ml/parser.ml"
               : 'class_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'floating_attribute) in
    Obj.repr(
# 921 "ml/parser.mly"
      ( mark_symbol_docs ();
        mkcf (Pcf_attribute _1) )
# 7283 "ml/parser.ml"
               : 'class_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'attributes) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 927 "ml/parser.mly"
      ( if _1 = Override then syntax_error ();
        (mkloc _5 (rhs_loc 5), Mutable, Cfk_virtual _7), _2 )
# 7294 "ml/parser.ml"
               : 'value))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'mutable_flag) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 930 "ml/parser.mly"
      ( if _1 = Override then syntax_error ();
        (mkrhs _5 5, _4, Cfk_virtual _7), _2 )
# 7306 "ml/parser.ml"
               : 'value))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'mutable_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 933 "ml/parser.mly"
      ( (mkrhs _4 4, _3, Cfk_concrete (_1, _6)), _2 )
# 7317 "ml/parser.ml"
               : 'value))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'mutable_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'type_constraint) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 935 "ml/parser.mly"
      (
       let e = mkexp_constraint _7 _5 in
       (mkrhs _4 4, _3, Cfk_concrete (_1, e)), _2
      )
# 7332 "ml/parser.ml"
               : 'value))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'attributes) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'poly_type) in
    Obj.repr(
# 943 "ml/parser.mly"
      ( if _1 = Override then syntax_error ();
        (mkloc _5 (rhs_loc 5), Private, Cfk_virtual _7), _2 )
# 7343 "ml/parser.ml"
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'private_flag) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'poly_type) in
    Obj.repr(
# 946 "ml/parser.mly"
      ( if _1 = Override then syntax_error ();
        (mkloc _5 (rhs_loc 5), _4, Cfk_virtual _7), _2 )
# 7355 "ml/parser.ml"
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'private_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'strict_binding) in
    Obj.repr(
# 949 "ml/parser.mly"
      ( (mkloc _4 (rhs_loc 4), _3,
        Cfk_concrete (_1, ghexp(Pexp_poly (_5, None)))), _2 )
# 7367 "ml/parser.ml"
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 7 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 6 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'private_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'label) in
    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'poly_type) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 952 "ml/parser.mly"
      ( (mkloc _4 (rhs_loc 4), _3,
        Cfk_concrete (_1, ghexp(Pexp_poly(_8, Some _6)))), _2 )
# 7380 "ml/parser.ml"
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 10 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 9 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 8 : 'private_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 7 : 'label) in
    let _7 = (Parsing.peek_val __caml_parser_env 4 : 'lident_list) in
    let _9 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _11 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 956 "ml/parser.mly"
      ( let exp, poly = wrap_type_annotation _7 _9 _11 in
        (mkloc _4 (rhs_loc 4), _3,
        Cfk_concrete (_1, ghexp(Pexp_poly(exp, Some poly)))), _2 )
# 7395 "ml/parser.ml"
               : 'method_))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_comma_list) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'clty_longident) in
    Obj.repr(
# 965 "ml/parser.mly"
      ( mkcty(Pcty_constr (mkloc _4 (rhs_loc 4), List.rev _2)) )
# 7403 "ml/parser.ml"
               : 'class_signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'clty_longident) in
    Obj.repr(
# 967 "ml/parser.mly"
      ( mkcty(Pcty_constr (mkrhs _1 1, [])) )
# 7410 "ml/parser.ml"
               : 'class_signature))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'class_sig_body) in
    Obj.repr(
# 969 "ml/parser.mly"
      ( mkcty ~attrs:_2 (Pcty_signature _3) )
# 7418 "ml/parser.ml"
               : 'class_signature))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'class_sig_body) in
    Obj.repr(
# 971 "ml/parser.mly"
      ( unclosed "object" 1 "end" 4 )
# 7426 "ml/parser.ml"
               : 'class_signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_signature) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 973 "ml/parser.mly"
      ( Cty.attr _1 _2 )
# 7434 "ml/parser.ml"
               : 'class_signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
# 975 "ml/parser.mly"
      ( mkcty(Pcty_extension _1) )
# 7441 "ml/parser.ml"
               : 'class_signature))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'override_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'attributes) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'class_signature) in
    Obj.repr(
# 977 "ml/parser.mly"
      ( wrap_class_type_attrs (mkcty(Pcty_open(_3, mkrhs _5 5, _7))) _4 )
# 7451 "ml/parser.ml"
               : 'class_signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_self_type) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_sig_fields) in
    Obj.repr(
# 981 "ml/parser.mly"
      ( Csig.mk _1 (extra_csig 2 (List.rev _2)) )
# 7459 "ml/parser.ml"
               : 'class_sig_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
# 985 "ml/parser.mly"
      ( _2 )
# 7466 "ml/parser.ml"
               : 'class_self_type))
; (fun __caml_parser_env ->
    Obj.repr(
# 987 "ml/parser.mly"
      ( mktyp(Ptyp_any) )
# 7472 "ml/parser.ml"
               : 'class_self_type))
; (fun __caml_parser_env ->
    Obj.repr(
# 990 "ml/parser.mly"
                                                ( [] )
# 7478 "ml/parser.ml"
               : 'class_sig_fields))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_sig_fields) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_sig_field) in
    Obj.repr(
# 991 "ml/parser.mly"
                                       ( _2 :: (text_csig 2) @ _1 )
# 7486 "ml/parser.ml"
               : 'class_sig_fields))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'class_signature) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 995 "ml/parser.mly"
      ( mkctf (Pctf_inherit _3) ~attrs:(_2@_4) ~docs:(symbol_docs ()) )
# 7495 "ml/parser.ml"
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'value_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 997 "ml/parser.mly"
      ( mkctf (Pctf_val _3) ~attrs:(_2@_4) ~docs:(symbol_docs ()) )
# 7504 "ml/parser.ml"
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'private_virtual_flags) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'label) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'poly_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1000 "ml/parser.mly"
      (
       let (p, v) = _3 in
       mkctf (Pctf_method (mkrhs _4 4, p, v, _6)) ~attrs:(_2@_7) ~docs:(symbol_docs ())
      )
# 7518 "ml/parser.ml"
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'constrain_field) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1005 "ml/parser.mly"
      ( mkctf (Pctf_constraint _3) ~attrs:(_2@_4) ~docs:(symbol_docs ()) )
# 7527 "ml/parser.ml"
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'item_extension) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1007 "ml/parser.mly"
      ( mkctf (Pctf_extension _1) ~attrs:_2 ~docs:(symbol_docs ()) )
# 7535 "ml/parser.ml"
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'floating_attribute) in
    Obj.repr(
# 1009 "ml/parser.mly"
      ( mark_symbol_docs ();
        mkctf(Pctf_attribute _1) )
# 7543 "ml/parser.ml"
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'mutable_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1014 "ml/parser.mly"
      ( mkrhs _3 3, _2, Virtual, _5 )
# 7552 "ml/parser.ml"
               : 'value_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'virtual_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1016 "ml/parser.mly"
      ( mkrhs _3 3, Mutable, _2, _5 )
# 7561 "ml/parser.ml"
               : 'value_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1018 "ml/parser.mly"
      ( mkrhs _1 1, Immutable, Concrete, _3 )
# 7569 "ml/parser.ml"
               : 'value_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1021 "ml/parser.mly"
                                           ( _1, _3, symbol_rloc() )
# 7577 "ml/parser.ml"
               : 'constrain))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1024 "ml/parser.mly"
                                           ( _1, _3 )
# 7585 "ml/parser.ml"
               : 'constrain_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_type_declaration) in
    Obj.repr(
# 1028 "ml/parser.mly"
      ( let (body, ext) = _1 in ([body],ext) )
# 7592 "ml/parser.ml"
               : 'class_type_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_type_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_class_type_declaration) in
    Obj.repr(
# 1030 "ml/parser.mly"
      ( let (l, ext) = _1 in (_2 :: l, ext) )
# 7600 "ml/parser.ml"
               : 'class_type_declarations))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 6 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 5 : 'virtual_flag) in
    let _5 = (Parsing.peek_val __caml_parser_env 4 : 'class_type_parameters) in
    let _6 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _8 = (Parsing.peek_val __caml_parser_env 1 : 'class_signature) in
    let _9 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1035 "ml/parser.mly"
      ( let (ext, attrs) = _3 in
        Ci.mk (mkrhs _6 6) _8 ~virt:_4 ~params:_5 ~attrs:(attrs@_9)
            ~loc:(symbol_rloc ()) ~docs:(symbol_docs ())
      , ext)
# 7615 "ml/parser.ml"
               : 'class_type_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 6 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'virtual_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'class_type_parameters) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'class_signature) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1043 "ml/parser.mly"
      ( Ci.mk (mkrhs _5 5) _7 ~virt:_3 ~params:_4
         ~attrs:(_2@_8) ~loc:(symbol_rloc ())
         ~text:(symbol_text ()) ~docs:(symbol_docs ()) )
# 7629 "ml/parser.ml"
               : 'and_class_type_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1051 "ml/parser.mly"
                                  ( _1 )
# 7636 "ml/parser.ml"
               : 'seq_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1052 "ml/parser.mly"
                                  ( _1 )
# 7643 "ml/parser.ml"
               : 'seq_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1053 "ml/parser.mly"
                                  ( mkexp(Pexp_sequence(_1, _3)) )
# 7651 "ml/parser.ml"
               : 'seq_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'attr_id) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1055 "ml/parser.mly"
      ( let seq = mkexp(Pexp_sequence (_1, _5)) in
        let payload = PStr [mkstrexp seq []] in
        mkexp (Pexp_extension (_4, payload)) )
# 7662 "ml/parser.ml"
               : 'seq_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label_let_pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_default) in
    Obj.repr(
# 1061 "ml/parser.mly"
      ( (Optional (fst _3), _4, snd _3) )
# 7670 "ml/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_var) in
    Obj.repr(
# 1063 "ml/parser.mly"
      ( (Optional (fst _2), None, snd _2) )
# 7677 "ml/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'let_pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_default) in
    Obj.repr(
# 1065 "ml/parser.mly"
      ( (Optional _1, _4, _3) )
# 7686 "ml/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern_var) in
    Obj.repr(
# 1067 "ml/parser.mly"
      ( (Optional _1, None, _2) )
# 7694 "ml/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'label_let_pattern) in
    Obj.repr(
# 1069 "ml/parser.mly"
      ( (Labelled (fst _3), None, snd _3) )
# 7701 "ml/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_var) in
    Obj.repr(
# 1071 "ml/parser.mly"
      ( (Labelled (fst _2), None, snd _2) )
# 7708 "ml/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern) in
    Obj.repr(
# 1073 "ml/parser.mly"
      ( (Labelled _1, None, _2) )
# 7716 "ml/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern) in
    Obj.repr(
# 1075 "ml/parser.mly"
      ( (Nolabel, None, _1) )
# 7723 "ml/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1078 "ml/parser.mly"
                      ( mkpat(Ppat_var (mkrhs _1 1)) )
# 7730 "ml/parser.ml"
               : 'pattern_var))
; (fun __caml_parser_env ->
    Obj.repr(
# 1079 "ml/parser.mly"
                      ( mkpat Ppat_any )
# 7736 "ml/parser.ml"
               : 'pattern_var))
; (fun __caml_parser_env ->
    Obj.repr(
# 1082 "ml/parser.mly"
                                        ( None )
# 7742 "ml/parser.ml"
               : 'opt_default))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1083 "ml/parser.mly"
                                        ( Some _2 )
# 7749 "ml/parser.ml"
               : 'opt_default))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_var) in
    Obj.repr(
# 1087 "ml/parser.mly"
      ( _1 )
# 7756 "ml/parser.ml"
               : 'label_let_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label_var) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1089 "ml/parser.mly"
      ( let (lab, pat) = _1 in (lab, mkpat(Ppat_constraint(pat, _3))) )
# 7764 "ml/parser.ml"
               : 'label_let_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1092 "ml/parser.mly"
              ( (_1, mkpat(Ppat_var (mkrhs _1 1))) )
# 7771 "ml/parser.ml"
               : 'label_var))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1096 "ml/parser.mly"
      ( _1 )
# 7778 "ml/parser.ml"
               : 'let_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1098 "ml/parser.mly"
      ( mkpat(Ppat_constraint(_1, _3)) )
# 7786 "ml/parser.ml"
               : 'let_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1102 "ml/parser.mly"
      ( _1 )
# 7793 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_labeled_expr_list) in
    Obj.repr(
# 1104 "ml/parser.mly"
      ( mkexp(Pexp_apply(_1, List.rev _2)) )
# 7801 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'let_bindings) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1106 "ml/parser.mly"
      ( expr_of_let_bindings _1 _3 )
# 7809 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'module_binding_body) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1108 "ml/parser.mly"
      ( mkexp_attrs (Pexp_letmodule(mkrhs _4 4, _5, _7)) _3 )
# 7819 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'let_exception_declaration) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1110 "ml/parser.mly"
      ( mkexp_attrs (Pexp_letexception(_4, _6)) _3 )
# 7828 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'override_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1112 "ml/parser.mly"
      ( mkexp_attrs (Pexp_open(_3, mkrhs _5 5, _7)) _4 )
# 7838 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_bar) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'match_cases) in
    Obj.repr(
# 1114 "ml/parser.mly"
      ( mkexp_attrs (Pexp_function(List.rev _4)) _2 )
# 7847 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'labeled_simple_pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'fun_def) in
    Obj.repr(
# 1116 "ml/parser.mly"
      ( let (l,o,p) = _3 in
        mkexp_attrs (Pexp_fun(l, o, p, _4)) _2 )
# 7857 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'ext_attributes) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'lident_list) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'fun_def) in
    Obj.repr(
# 1119 "ml/parser.mly"
      ( mkexp_attrs (mk_newtypes _5 _7).pexp_desc _2 )
# 7866 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_bar) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'match_cases) in
    Obj.repr(
# 1121 "ml/parser.mly"
      ( mkexp_attrs (Pexp_match(_3, List.rev _6)) _2 )
# 7876 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_bar) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'match_cases) in
    Obj.repr(
# 1123 "ml/parser.mly"
      ( mkexp_attrs (Pexp_try(_3, List.rev _6)) _2 )
# 7886 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    Obj.repr(
# 1125 "ml/parser.mly"
      ( syntax_error() )
# 7894 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expr_comma_list) in
    Obj.repr(
# 1127 "ml/parser.mly"
      ( mkexp(Pexp_tuple(List.rev _1)) )
# 7901 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'constr_longident) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1129 "ml/parser.mly"
      ( mkexp(Pexp_construct(mkrhs _1 1, Some _2)) )
# 7909 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1131 "ml/parser.mly"
      ( mkexp(Pexp_variant(_1, Some _2)) )
# 7917 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1133 "ml/parser.mly"
      ( mkexp_attrs(Pexp_ifthenelse(_3, _5, Some _7)) _2 )
# 7927 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1135 "ml/parser.mly"
      ( mkexp_attrs (Pexp_ifthenelse(_3, _5, None)) _2 )
# 7936 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1137 "ml/parser.mly"
      ( mkexp_attrs (Pexp_while(_3, _5)) _2 )
# 7945 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 8 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 7 : 'pattern) in
    let _5 = (Parsing.peek_val __caml_parser_env 5 : 'seq_expr) in
    let _6 = (Parsing.peek_val __caml_parser_env 4 : 'direction_flag) in
    let _7 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _9 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1140 "ml/parser.mly"
      ( mkexp_attrs(Pexp_for(_3, _5, _7, _6, _9)) _2 )
# 7957 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1142 "ml/parser.mly"
      ( mkexp_cons (rhs_loc 2) (ghexp(Pexp_tuple[_1;_3])) (symbol_rloc()) )
# 7965 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1144 "ml/parser.mly"
      ( mkinfix _1 _2 _3 )
# 7974 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1146 "ml/parser.mly"
      ( mkinfix _1 _2 _3 )
# 7983 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1148 "ml/parser.mly"
      ( mkinfix _1 _2 _3 )
# 7992 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1150 "ml/parser.mly"
      ( mkinfix _1 _2 _3 )
# 8001 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1152 "ml/parser.mly"
      ( mkinfix _1 _2 _3 )
# 8010 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1154 "ml/parser.mly"
      ( mkinfix _1 "+" _3 )
# 8018 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1156 "ml/parser.mly"
      ( mkinfix _1 "+." _3 )
# 8026 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1158 "ml/parser.mly"
      ( mkinfix _1 "+=" _3 )
# 8034 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1160 "ml/parser.mly"
      ( mkinfix _1 "-" _3 )
# 8042 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1162 "ml/parser.mly"
      ( mkinfix _1 "-." _3 )
# 8050 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1164 "ml/parser.mly"
      ( mkinfix _1 "*" _3 )
# 8058 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1166 "ml/parser.mly"
      ( mkinfix _1 "%" _3 )
# 8066 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1168 "ml/parser.mly"
      ( mkinfix _1 "=" _3 )
# 8074 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1170 "ml/parser.mly"
    ( mkinfix _1 "<" _3 )
# 8082 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1172 "ml/parser.mly"
      ( mkinfix _1 ">" _3 )
# 8090 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1174 "ml/parser.mly"
      ( mkinfix _1 "or" _3 )
# 8098 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1176 "ml/parser.mly"
      ( mkinfix _1 "||" _3 )
# 8106 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1178 "ml/parser.mly"
      ( mkinfix _1 "&" _3 )
# 8114 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1180 "ml/parser.mly"
      ( mkinfix _1 "&&" _3 )
# 8122 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1182 "ml/parser.mly"
      ( mkinfix _1 ":=" _3 )
# 8130 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'subtractive) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1184 "ml/parser.mly"
      ( mkuminus _1 _2 )
# 8138 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'additive) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1186 "ml/parser.mly"
      ( mkuplus _1 _2 )
# 8146 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1188 "ml/parser.mly"
      ( mkexp(Pexp_setfield(_1, mkrhs _3 3, _5)) )
# 8155 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1190 "ml/parser.mly"
      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "Array" "set")),
                         [Nolabel,_1; Nolabel,_4; Nolabel,_7])) )
# 8165 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1193 "ml/parser.mly"
      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "String" "set")),
                         [Nolabel,_1; Nolabel,_4; Nolabel,_7])) )
# 8175 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1196 "ml/parser.mly"
      ( let id = mkexp @@ Pexp_ident( ghloc @@ Lident ("." ^ _2 ^ "[]<-")) in
        mkexp @@ Pexp_apply(id , [Nolabel, _1; Nolabel, _4; Nolabel, _7]) )
# 8186 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1199 "ml/parser.mly"
      ( let id = mkexp @@ Pexp_ident( ghloc @@ Lident ("." ^ _2 ^ "()<-")) in
        mkexp @@ Pexp_apply(id , [Nolabel, _1; Nolabel, _4; Nolabel, _7]) )
# 8197 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1202 "ml/parser.mly"
      ( let id = mkexp @@ Pexp_ident( ghloc @@ Lident ("." ^ _2 ^ "{}<-")) in
        mkexp @@ Pexp_apply(id , [Nolabel, _1; Nolabel, _4; Nolabel, _7]) )
# 8208 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 8 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 6 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 5 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _9 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1205 "ml/parser.mly"
      ( let id = mkexp @@ Pexp_ident( ghloc @@ Ldot(_3,"." ^ _4 ^ "[]<-")) in
        mkexp @@ Pexp_apply(id , [Nolabel, _1; Nolabel, _6; Nolabel, _9]) )
# 8220 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 8 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 6 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 5 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _9 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1208 "ml/parser.mly"
      ( let id = mkexp @@ Pexp_ident( ghloc @@ Ldot(_3, "." ^ _4 ^ "()<-")) in
        mkexp @@ Pexp_apply(id , [Nolabel, _1; Nolabel, _6; Nolabel, _9]) )
# 8232 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 8 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 6 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 5 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _9 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1211 "ml/parser.mly"
      ( let id = mkexp @@ Pexp_ident( ghloc @@ Ldot(_3, "." ^ _4 ^ "{}<-")) in
        mkexp @@ Pexp_apply(id , [Nolabel, _1; Nolabel, _6; Nolabel, _9]) )
# 8244 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1214 "ml/parser.mly"
      ( mkexp(Pexp_setinstvar(mkrhs _1 1, _3)) )
# 8252 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1216 "ml/parser.mly"
      ( mkexp_attrs (Pexp_assert _3) _2 )
# 8260 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1218 "ml/parser.mly"
      ( mkexp_attrs (Pexp_lazy _3) _2 )
# 8268 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'class_structure) in
    Obj.repr(
# 1220 "ml/parser.mly"
      ( mkexp_attrs (Pexp_object _3) _2 )
# 8276 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'class_structure) in
    Obj.repr(
# 1222 "ml/parser.mly"
      ( unclosed "object" 1 "end" 4 )
# 8284 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 1224 "ml/parser.mly"
      ( Exp.attr _1 _2 )
# 8292 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    Obj.repr(
# 1226 "ml/parser.mly"
     ( not_expecting 1 "wildcard \"_\"" )
# 8298 "ml/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'val_longident) in
    Obj.repr(
# 1230 "ml/parser.mly"
      ( mkexp(Pexp_ident (mkrhs _1 1)) )
# 8305 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constant) in
    Obj.repr(
# 1232 "ml/parser.mly"
      ( mkexp(Pexp_constant _1) )
# 8312 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constr_longident) in
    Obj.repr(
# 1234 "ml/parser.mly"
      ( mkexp(Pexp_construct(mkrhs _1 1, None)) )
# 8319 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_tag) in
    Obj.repr(
# 1236 "ml/parser.mly"
      ( mkexp(Pexp_variant(_1, None)) )
# 8326 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1238 "ml/parser.mly"
      ( reloc_exp _2 )
# 8333 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1240 "ml/parser.mly"
      ( unclosed "(" 1 ")" 3 )
# 8340 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1242 "ml/parser.mly"
      ( wrap_exp_attrs (reloc_exp _3) _2 (* check location *) )
# 8348 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ext_attributes) in
    Obj.repr(
# 1244 "ml/parser.mly"
      ( mkexp_attrs (Pexp_construct (mkloc (Lident "()") (symbol_rloc ()),
                               None)) _2 )
# 8356 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1247 "ml/parser.mly"
      ( unclosed "begin" 1 "end" 4 )
# 8364 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'type_constraint) in
    Obj.repr(
# 1249 "ml/parser.mly"
      ( mkexp_constraint _2 _3 )
# 8372 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'label_longident) in
    Obj.repr(
# 1251 "ml/parser.mly"
      ( mkexp(Pexp_field(_1, mkrhs _3 3)) )
# 8380 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1253 "ml/parser.mly"
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1, _4)) )
# 8388 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'mod_longident) in
    Obj.repr(
# 1255 "ml/parser.mly"
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1,
                        mkexp(Pexp_construct(mkrhs (Lident "()") 1, None)))) )
# 8396 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1258 "ml/parser.mly"
      ( unclosed "(" 3 ")" 5 )
# 8404 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1260 "ml/parser.mly"
      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "Array" "get")),
                         [Nolabel,_1; Nolabel,_4])) )
# 8413 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1263 "ml/parser.mly"
      ( unclosed "(" 3 ")" 5 )
# 8421 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1265 "ml/parser.mly"
      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "String" "get")),
                         [Nolabel,_1; Nolabel,_4])) )
# 8430 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1268 "ml/parser.mly"
      ( unclosed "[" 3 "]" 5 )
# 8438 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1270 "ml/parser.mly"
      ( let id = mkexp @@ Pexp_ident( ghloc @@ Lident ("." ^ _2 ^ "[]")) in
        mkexp @@ Pexp_apply(id, [Nolabel, _1; Nolabel, _4]) )
# 8448 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1273 "ml/parser.mly"
      ( unclosed "[" 3 "]" 5 )
# 8457 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1275 "ml/parser.mly"
      ( let id = mkexp @@ Pexp_ident( ghloc @@ Lident ("." ^ _2 ^ "()")) in
        mkexp @@ Pexp_apply(id, [Nolabel, _1; Nolabel, _4]) )
# 8467 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1278 "ml/parser.mly"
      ( unclosed "(" 3 ")" 5 )
# 8476 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1280 "ml/parser.mly"
      ( let id = mkexp @@ Pexp_ident( ghloc @@ Lident ("." ^ _2 ^ "{}")) in
        mkexp @@ Pexp_apply(id, [Nolabel, _1; Nolabel, _4]) )
# 8486 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1283 "ml/parser.mly"
      ( unclosed "{" 3 "}" 5 )
# 8495 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1285 "ml/parser.mly"
      ( let id = mkexp @@ Pexp_ident( ghloc @@ Ldot(_3, "." ^ _4 ^ "[]")) in
        mkexp @@ Pexp_apply(id, [Nolabel, _1; Nolabel, _6]) )
# 8506 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1288 "ml/parser.mly"
      ( unclosed "[" 5 "]" 7 )
# 8516 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1290 "ml/parser.mly"
      ( let id = mkexp @@ Pexp_ident( ghloc @@ Ldot(_3, "." ^ _4 ^ "()")) in
        mkexp @@ Pexp_apply(id, [Nolabel, _1; Nolabel, _6]) )
# 8527 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1293 "ml/parser.mly"
      ( unclosed "(" 5 ")" 7 )
# 8537 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1295 "ml/parser.mly"
      ( let id = mkexp @@ Pexp_ident( ghloc @@ Ldot(_3, "." ^ _4 ^ "{}")) in
        mkexp @@ Pexp_apply(id, [Nolabel, _1; Nolabel, _6]) )
# 8548 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1298 "ml/parser.mly"
      ( unclosed "{" 5 "}" 7 )
# 8558 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'expr_comma_list) in
    Obj.repr(
# 1300 "ml/parser.mly"
      ( unclosed "{" 3 "}" 5 )
# 8566 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'record_expr) in
    Obj.repr(
# 1302 "ml/parser.mly"
      ( let (exten, fields) = _2 in mkexp (Pexp_record(fields, exten)) )
# 8573 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'record_expr) in
    Obj.repr(
# 1304 "ml/parser.mly"
      ( unclosed "{" 1 "}" 3 )
# 8580 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'record_expr) in
    Obj.repr(
# 1306 "ml/parser.mly"
      ( let (exten, fields) = _4 in
        let rec_exp = mkexp(Pexp_record(fields, exten)) in
        mkexp(Pexp_open(Fresh, mkrhs _1 1, rec_exp)) )
# 8590 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'record_expr) in
    Obj.repr(
# 1310 "ml/parser.mly"
      ( unclosed "{" 3 "}" 5 )
# 8598 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1312 "ml/parser.mly"
      ( mkexp (Pexp_array(List.rev _2)) )
# 8606 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1314 "ml/parser.mly"
      ( unclosed "[|" 1 "|]" 4 )
# 8614 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    Obj.repr(
# 1316 "ml/parser.mly"
      ( mkexp (Pexp_array []) )
# 8620 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1318 "ml/parser.mly"
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1, mkexp(Pexp_array(List.rev _4)))) )
# 8629 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'mod_longident) in
    Obj.repr(
# 1320 "ml/parser.mly"
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1, mkexp(Pexp_array []))) )
# 8636 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1322 "ml/parser.mly"
      ( unclosed "[|" 3 "|]" 6 )
# 8645 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1324 "ml/parser.mly"
      ( reloc_exp (mktailexp (rhs_loc 4) (List.rev _2)) )
# 8653 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1326 "ml/parser.mly"
      ( unclosed "[" 1 "]" 4 )
# 8661 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1328 "ml/parser.mly"
      ( let list_exp = reloc_exp (mktailexp (rhs_loc 6) (List.rev _4)) in
        mkexp(Pexp_open(Fresh, mkrhs _1 1, list_exp)) )
# 8671 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'mod_longident) in
    Obj.repr(
# 1331 "ml/parser.mly"
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1,
                        mkexp(Pexp_construct(mkrhs (Lident "[]") 1, None)))) )
# 8679 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1334 "ml/parser.mly"
      ( unclosed "[" 3 "]" 6 )
# 8688 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1336 "ml/parser.mly"
      ( mkexp(Pexp_apply(mkoperator _1 1, [Nolabel,_2])) )
# 8696 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1338 "ml/parser.mly"
      ( mkexp(Pexp_apply(mkoperator "!" 1, [Nolabel,_2])) )
# 8703 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'field_expr_list) in
    Obj.repr(
# 1340 "ml/parser.mly"
      ( mkexp (Pexp_override _2) )
# 8710 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'field_expr_list) in
    Obj.repr(
# 1342 "ml/parser.mly"
      ( unclosed "{<" 1 ">}" 3 )
# 8717 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    Obj.repr(
# 1344 "ml/parser.mly"
      ( mkexp (Pexp_override []))
# 8723 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'field_expr_list) in
    Obj.repr(
# 1346 "ml/parser.mly"
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1, mkexp (Pexp_override _4))))
# 8731 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'mod_longident) in
    Obj.repr(
# 1348 "ml/parser.mly"
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1, mkexp (Pexp_override []))))
# 8738 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'field_expr_list) in
    Obj.repr(
# 1350 "ml/parser.mly"
      ( unclosed "{<" 3 ">}" 5 )
# 8746 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'label) in
    Obj.repr(
# 1352 "ml/parser.mly"
      ( mkexp(Pexp_send(_1, mkrhs _3 3)) )
# 8754 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1354 "ml/parser.mly"
      ( mkinfix _1 _2 _3 )
# 8763 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    Obj.repr(
# 1356 "ml/parser.mly"
      ( mkexp_attrs (Pexp_pack _4) _3 )
# 8771 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 1358 "ml/parser.mly"
      ( mkexp_attrs (Pexp_constraint (ghexp (Pexp_pack _4),
                                      ghtyp (Ptyp_package _6)))
                    _3 )
# 8782 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'module_expr) in
    Obj.repr(
# 1362 "ml/parser.mly"
      ( unclosed "(" 1 ")" 6 )
# 8790 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 8 : 'mod_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _6 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _8 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 1365 "ml/parser.mly"
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1,
        mkexp_attrs (Pexp_constraint (ghexp (Pexp_pack _6),
                                ghtyp (Ptyp_package _8)))
                    _5 )) )
# 8803 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 7 : 'mod_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'module_expr) in
    Obj.repr(
# 1370 "ml/parser.mly"
      ( unclosed "(" 3 ")" 8 )
# 8812 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
# 1372 "ml/parser.mly"
      ( mkexp (Pexp_extension _1) )
# 8819 "ml/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'labeled_simple_expr) in
    Obj.repr(
# 1376 "ml/parser.mly"
      ( [_1] )
# 8826 "ml/parser.ml"
               : 'simple_labeled_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'simple_labeled_expr_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'labeled_simple_expr) in
    Obj.repr(
# 1378 "ml/parser.mly"
      ( _2 :: _1 )
# 8834 "ml/parser.ml"
               : 'simple_labeled_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1382 "ml/parser.mly"
      ( (Nolabel, _1) )
# 8841 "ml/parser.ml"
               : 'labeled_simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_expr) in
    Obj.repr(
# 1384 "ml/parser.mly"
      ( _1 )
# 8848 "ml/parser.ml"
               : 'labeled_simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1388 "ml/parser.mly"
      ( (Labelled _1, _2) )
# 8856 "ml/parser.ml"
               : 'label_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_ident) in
    Obj.repr(
# 1390 "ml/parser.mly"
      ( (Labelled (fst _2), snd _2) )
# 8863 "ml/parser.ml"
               : 'label_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_ident) in
    Obj.repr(
# 1392 "ml/parser.mly"
      ( (Optional (fst _2), snd _2) )
# 8870 "ml/parser.ml"
               : 'label_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1394 "ml/parser.mly"
      ( (Optional _1, _2) )
# 8878 "ml/parser.ml"
               : 'label_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1397 "ml/parser.mly"
             ( (_1, mkexp(Pexp_ident(mkrhs (Lident _1) 1))) )
# 8885 "ml/parser.ml"
               : 'label_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1400 "ml/parser.mly"
                                      ( [mkrhs _1 1] )
# 8892 "ml/parser.ml"
               : 'lident_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lident_list) in
    Obj.repr(
# 1401 "ml/parser.mly"
                                      ( mkrhs _1 1 :: _2 )
# 8900 "ml/parser.ml"
               : 'lident_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'val_ident) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'strict_binding) in
    Obj.repr(
# 1405 "ml/parser.mly"
      ( (mkpatvar _1 1, _2) )
# 8908 "ml/parser.ml"
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'val_ident) in
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'type_constraint) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1407 "ml/parser.mly"
      ( let v = mkpatvar _1 1 in (* PR#7344 *)
        let t =
          match _2 with
            Some t, None -> t
          | _, Some t -> t
          | _ -> assert false
        in
        (ghpat(Ppat_constraint(v, ghtyp(Ptyp_poly([],t)))),
         mkexp_constraint _4 _2) )
# 8925 "ml/parser.ml"
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'val_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'typevar_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1417 "ml/parser.mly"
      ( (ghpat(Ppat_constraint(mkpatvar _1 1,
                               ghtyp(Ptyp_poly(List.rev _3,_5)))),
         _7) )
# 8937 "ml/parser.ml"
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 7 : 'val_ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'lident_list) in
    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1421 "ml/parser.mly"
      ( let exp, poly = wrap_type_annotation _4 _6 _8 in
        (ghpat(Ppat_constraint(mkpatvar _1 1, poly)), exp) )
# 8948 "ml/parser.ml"
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_no_exn) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1424 "ml/parser.mly"
      ( (_1, _3) )
# 8956 "ml/parser.ml"
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_pattern_not_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1426 "ml/parser.mly"
      ( (ghpat(Ppat_constraint(_1, _3)), _5) )
# 8965 "ml/parser.ml"
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'let_binding) in
    Obj.repr(
# 1429 "ml/parser.mly"
                                                ( _1 )
# 8972 "ml/parser.ml"
               : 'let_bindings))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'let_bindings) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_let_binding) in
    Obj.repr(
# 1430 "ml/parser.mly"
                                                ( addlb _1 _2 )
# 8980 "ml/parser.ml"
               : 'let_bindings))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'rec_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'let_binding_body) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1434 "ml/parser.mly"
      ( let (ext, attr) = _2 in
        mklbs ext _3 (mklb true _4 (attr@_5)) )
# 8991 "ml/parser.ml"
               : 'let_binding))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'let_binding_body) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1439 "ml/parser.mly"
      ( mklb false _3 (_2@_4) )
# 9000 "ml/parser.ml"
               : 'and_let_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'strict_binding) in
    Obj.repr(
# 1443 "ml/parser.mly"
      ( _1 )
# 9007 "ml/parser.ml"
               : 'fun_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'type_constraint) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1445 "ml/parser.mly"
      ( mkexp_constraint _3 _1 )
# 9015 "ml/parser.ml"
               : 'fun_binding))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1449 "ml/parser.mly"
      ( _2 )
# 9022 "ml/parser.ml"
               : 'strict_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'labeled_simple_pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'fun_binding) in
    Obj.repr(
# 1451 "ml/parser.mly"
      ( let (l, o, p) = _1 in ghexp(Pexp_fun(l, o, p, _2)) )
# 9030 "ml/parser.ml"
               : 'strict_binding))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'lident_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'fun_binding) in
    Obj.repr(
# 1453 "ml/parser.mly"
      ( mk_newtypes _3 _5 )
# 9038 "ml/parser.ml"
               : 'strict_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'match_case) in
    Obj.repr(
# 1456 "ml/parser.mly"
               ( [_1] )
# 9045 "ml/parser.ml"
               : 'match_cases))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'match_cases) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'match_case) in
    Obj.repr(
# 1457 "ml/parser.mly"
                               ( _3 :: _1 )
# 9053 "ml/parser.ml"
               : 'match_cases))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1461 "ml/parser.mly"
      ( Exp.case _1 _3 )
# 9061 "ml/parser.ml"
               : 'match_case))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1463 "ml/parser.mly"
      ( Exp.case _1 ~guard:_3 _5 )
# 9070 "ml/parser.ml"
               : 'match_case))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
# 1465 "ml/parser.mly"
      ( Exp.case _1 (Exp.unreachable ~loc:(rhs_loc 3) ()))
# 9077 "ml/parser.ml"
               : 'match_case))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1469 "ml/parser.mly"
      ( _2 )
# 9084 "ml/parser.ml"
               : 'fun_def))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1471 "ml/parser.mly"
      ( mkexp (Pexp_constraint (_4, _2)) )
# 9092 "ml/parser.ml"
               : 'fun_def))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'labeled_simple_pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'fun_def) in
    Obj.repr(
# 1474 "ml/parser.mly"
      (
       let (l,o,p) = _1 in
       ghexp(Pexp_fun(l, o, p, _2))
      )
# 9103 "ml/parser.ml"
               : 'fun_def))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'lident_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'fun_def) in
    Obj.repr(
# 1479 "ml/parser.mly"
      ( mk_newtypes _3 _5 )
# 9111 "ml/parser.ml"
               : 'fun_def))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr_comma_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1482 "ml/parser.mly"
                                                ( _3 :: _1 )
# 9119 "ml/parser.ml"
               : 'expr_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1483 "ml/parser.mly"
                                                ( [_3; _1] )
# 9127 "ml/parser.ml"
               : 'expr_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_expr_list) in
    Obj.repr(
# 1486 "ml/parser.mly"
                                                ( (Some _1, _3) )
# 9135 "ml/parser.ml"
               : 'record_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_expr_list) in
    Obj.repr(
# 1487 "ml/parser.mly"
                                                ( (None, _1) )
# 9142 "ml/parser.ml"
               : 'record_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_expr) in
    Obj.repr(
# 1490 "ml/parser.mly"
              ( [_1] )
# 9149 "ml/parser.ml"
               : 'lbl_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'lbl_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_expr_list) in
    Obj.repr(
# 1491 "ml/parser.mly"
                                 ( _1 :: _3 )
# 9157 "ml/parser.ml"
               : 'lbl_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lbl_expr) in
    Obj.repr(
# 1492 "ml/parser.mly"
                   ( [_1] )
# 9164 "ml/parser.ml"
               : 'lbl_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'label_longident) in
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'opt_type_constraint) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1496 "ml/parser.mly"
      ( (mkrhs _1 1, mkexp_opt_constraint _4 _2) )
# 9173 "ml/parser.ml"
               : 'lbl_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'label_longident) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'opt_type_constraint) in
    Obj.repr(
# 1498 "ml/parser.mly"
      ( (mkrhs _1 1, mkexp_opt_constraint (exp_of_label _1 1) _2) )
# 9181 "ml/parser.ml"
               : 'lbl_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'field_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'opt_semi) in
    Obj.repr(
# 1501 "ml/parser.mly"
                        ( [_1] )
# 9189 "ml/parser.ml"
               : 'field_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'field_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'field_expr_list) in
    Obj.repr(
# 1502 "ml/parser.mly"
                                    ( _1 :: _3 )
# 9197 "ml/parser.ml"
               : 'field_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1506 "ml/parser.mly"
      ( (mkrhs _1 1, _3) )
# 9205 "ml/parser.ml"
               : 'field_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label) in
    Obj.repr(
# 1508 "ml/parser.mly"
      ( (mkrhs _1 1, exp_of_label (Lident _1) 1) )
# 9212 "ml/parser.ml"
               : 'field_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1511 "ml/parser.mly"
                                                ( [_1] )
# 9219 "ml/parser.ml"
               : 'expr_semi_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1512 "ml/parser.mly"
                                                ( _3 :: _1 )
# 9227 "ml/parser.ml"
               : 'expr_semi_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1515 "ml/parser.mly"
                                                ( (Some _2, None) )
# 9234 "ml/parser.ml"
               : 'type_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1516 "ml/parser.mly"
                                                ( (Some _2, Some _4) )
# 9242 "ml/parser.ml"
               : 'type_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1517 "ml/parser.mly"
                                                ( (None, Some _2) )
# 9249 "ml/parser.ml"
               : 'type_constraint))
; (fun __caml_parser_env ->
    Obj.repr(
# 1518 "ml/parser.mly"
                                                ( syntax_error() )
# 9255 "ml/parser.ml"
               : 'type_constraint))
; (fun __caml_parser_env ->
    Obj.repr(
# 1519 "ml/parser.mly"
                                                ( syntax_error() )
# 9261 "ml/parser.ml"
               : 'type_constraint))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_constraint) in
    Obj.repr(
# 1522 "ml/parser.mly"
                    ( Some _1 )
# 9268 "ml/parser.ml"
               : 'opt_type_constraint))
; (fun __caml_parser_env ->
    Obj.repr(
# 1523 "ml/parser.mly"
                ( None )
# 9274 "ml/parser.ml"
               : 'opt_type_constraint))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'val_ident) in
    Obj.repr(
# 1530 "ml/parser.mly"
      ( mkpat(Ppat_alias(_1, mkrhs _3 3)) )
# 9282 "ml/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
# 1532 "ml/parser.mly"
      ( expecting 3 "identifier" )
# 9289 "ml/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pattern_comma_list) in
    Obj.repr(
# 1534 "ml/parser.mly"
      ( mkpat(Ppat_tuple(List.rev _1)) )
# 9296 "ml/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1536 "ml/parser.mly"
      ( mkpat_cons (rhs_loc 2) (ghpat(Ppat_tuple[_1;_3])) (symbol_rloc()) )
# 9304 "ml/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
# 1538 "ml/parser.mly"
      ( expecting 3 "pattern" )
# 9311 "ml/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1540 "ml/parser.mly"
      ( mkpat(Ppat_or(_1, _3)) )
# 9319 "ml/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
# 1542 "ml/parser.mly"
      ( expecting 3 "pattern" )
# 9326 "ml/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1544 "ml/parser.mly"
      ( mkpat_attrs (Ppat_exception _3) _2)
# 9334 "ml/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 1546 "ml/parser.mly"
      ( Pat.attr _1 _2 )
# 9342 "ml/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pattern_gen) in
    Obj.repr(
# 1547 "ml/parser.mly"
                ( _1 )
# 9349 "ml/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_no_exn) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'val_ident) in
    Obj.repr(
# 1551 "ml/parser.mly"
      ( mkpat(Ppat_alias(_1, mkrhs _3 3)) )
# 9357 "ml/parser.ml"
               : 'pattern_no_exn))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_no_exn) in
    Obj.repr(
# 1553 "ml/parser.mly"
      ( expecting 3 "identifier" )
# 9364 "ml/parser.ml"
               : 'pattern_no_exn))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pattern_no_exn_comma_list) in
    Obj.repr(
# 1555 "ml/parser.mly"
      ( mkpat(Ppat_tuple(List.rev _1)) )
# 9371 "ml/parser.ml"
               : 'pattern_no_exn))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_no_exn) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1557 "ml/parser.mly"
      ( mkpat_cons (rhs_loc 2) (ghpat(Ppat_tuple[_1;_3])) (symbol_rloc()) )
# 9379 "ml/parser.ml"
               : 'pattern_no_exn))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_no_exn) in
    Obj.repr(
# 1559 "ml/parser.mly"
      ( expecting 3 "pattern" )
# 9386 "ml/parser.ml"
               : 'pattern_no_exn))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_no_exn) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1561 "ml/parser.mly"
      ( mkpat(Ppat_or(_1, _3)) )
# 9394 "ml/parser.ml"
               : 'pattern_no_exn))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_no_exn) in
    Obj.repr(
# 1563 "ml/parser.mly"
      ( expecting 3 "pattern" )
# 9401 "ml/parser.ml"
               : 'pattern_no_exn))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'pattern_no_exn) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 1565 "ml/parser.mly"
      ( Pat.attr _1 _2 )
# 9409 "ml/parser.ml"
               : 'pattern_no_exn))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pattern_gen) in
    Obj.repr(
# 1566 "ml/parser.mly"
                ( _1 )
# 9416 "ml/parser.ml"
               : 'pattern_no_exn))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern) in
    Obj.repr(
# 1570 "ml/parser.mly"
      ( _1 )
# 9423 "ml/parser.ml"
               : 'pattern_gen))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'constr_longident) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1572 "ml/parser.mly"
      ( mkpat(Ppat_construct(mkrhs _1 1, Some _2)) )
# 9431 "ml/parser.ml"
               : 'pattern_gen))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1574 "ml/parser.mly"
      ( mkpat(Ppat_variant(_1, Some _2)) )
# 9439 "ml/parser.ml"
               : 'pattern_gen))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern) in
    Obj.repr(
# 1576 "ml/parser.mly"
      ( mkpat_attrs (Ppat_lazy _3) _2)
# 9447 "ml/parser.ml"
               : 'pattern_gen))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'val_ident) in
    Obj.repr(
# 1580 "ml/parser.mly"
      ( mkpat(Ppat_var (mkrhs _1 1)) )
# 9454 "ml/parser.ml"
               : 'simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern_not_ident) in
    Obj.repr(
# 1581 "ml/parser.mly"
                             ( _1 )
# 9461 "ml/parser.ml"
               : 'simple_pattern))
; (fun __caml_parser_env ->
    Obj.repr(
# 1585 "ml/parser.mly"
      ( mkpat(Ppat_any) )
# 9467 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'signed_constant) in
    Obj.repr(
# 1587 "ml/parser.mly"
      ( mkpat(Ppat_constant _1) )
# 9474 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'signed_constant) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'signed_constant) in
    Obj.repr(
# 1589 "ml/parser.mly"
      ( mkpat(Ppat_interval (_1, _3)) )
# 9482 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constr_longident) in
    Obj.repr(
# 1591 "ml/parser.mly"
      ( mkpat(Ppat_construct(mkrhs _1 1, None)) )
# 9489 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_tag) in
    Obj.repr(
# 1593 "ml/parser.mly"
      ( mkpat(Ppat_variant(_1, None)) )
# 9496 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'type_longident) in
    Obj.repr(
# 1595 "ml/parser.mly"
      ( mkpat(Ppat_type (mkrhs _2 2)) )
# 9503 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_delimited_pattern) in
    Obj.repr(
# 1597 "ml/parser.mly"
      ( _1 )
# 9510 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_delimited_pattern) in
    Obj.repr(
# 1599 "ml/parser.mly"
      ( mkpat @@ Ppat_open(mkrhs _1 1, _3) )
# 9518 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'mod_longident) in
    Obj.repr(
# 1601 "ml/parser.mly"
    ( mkpat @@ Ppat_open(mkrhs _1 1, mkpat @@
               Ppat_construct ( mkrhs (Lident "[]") 4, None)) )
# 9526 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'mod_longident) in
    Obj.repr(
# 1604 "ml/parser.mly"
      ( mkpat @@ Ppat_open( mkrhs _1 1, mkpat @@
                 Ppat_construct ( mkrhs (Lident "()") 4, None) ) )
# 9534 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
# 1607 "ml/parser.mly"
      ( mkpat @@ Ppat_open (mkrhs _1 1, _4))
# 9542 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
# 1609 "ml/parser.mly"
      (unclosed "(" 3 ")" 5  )
# 9550 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'mod_longident) in
    Obj.repr(
# 1611 "ml/parser.mly"
      ( expecting 4 "pattern" )
# 9557 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
# 1613 "ml/parser.mly"
      ( reloc_pat _2 )
# 9564 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
# 1615 "ml/parser.mly"
      ( unclosed "(" 1 ")" 3 )
# 9571 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
# 1617 "ml/parser.mly"
      ( mkpat(Ppat_constraint(_2, _4)) )
# 9579 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
# 1619 "ml/parser.mly"
      ( unclosed "(" 1 ")" 5 )
# 9587 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
# 1621 "ml/parser.mly"
      ( expecting 4 "type" )
# 9594 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 1623 "ml/parser.mly"
      ( mkpat_attrs (Ppat_unpack (mkrhs _4 4)) _3 )
# 9602 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 1625 "ml/parser.mly"
      ( mkpat_attrs
          (Ppat_constraint(mkpat(Ppat_unpack (mkrhs _4 4)),
                           ghtyp(Ptyp_package _6)))
          _3 )
# 9614 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 1630 "ml/parser.mly"
      ( unclosed "(" 1 ")" 7 )
# 9623 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
# 1632 "ml/parser.mly"
      ( mkpat(Ppat_extension _1) )
# 9630 "ml/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lbl_pattern_list) in
    Obj.repr(
# 1637 "ml/parser.mly"
    ( let (fields, closed) = _2 in mkpat(Ppat_record(fields, closed)) )
# 9637 "ml/parser.ml"
               : 'simple_delimited_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lbl_pattern_list) in
    Obj.repr(
# 1639 "ml/parser.mly"
    ( unclosed "{" 1 "}" 3 )
# 9644 "ml/parser.ml"
               : 'simple_delimited_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1641 "ml/parser.mly"
    ( reloc_pat (mktailpat (rhs_loc 4) (List.rev _2)) )
# 9652 "ml/parser.ml"
               : 'simple_delimited_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1643 "ml/parser.mly"
    ( unclosed "[" 1 "]" 4 )
# 9660 "ml/parser.ml"
               : 'simple_delimited_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1645 "ml/parser.mly"
    ( mkpat(Ppat_array(List.rev _2)) )
# 9668 "ml/parser.ml"
               : 'simple_delimited_pattern))
; (fun __caml_parser_env ->
    Obj.repr(
# 1647 "ml/parser.mly"
    ( mkpat(Ppat_array []) )
# 9674 "ml/parser.ml"
               : 'simple_delimited_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1649 "ml/parser.mly"
    ( unclosed "[|" 1 "|]" 4 )
# 9682 "ml/parser.ml"
               : 'simple_delimited_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_comma_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1652 "ml/parser.mly"
                                                ( _3 :: _1 )
# 9690 "ml/parser.ml"
               : 'pattern_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1653 "ml/parser.mly"
                                                ( [_3; _1] )
# 9698 "ml/parser.ml"
               : 'pattern_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
# 1654 "ml/parser.mly"
                                                ( expecting 3 "pattern" )
# 9705 "ml/parser.ml"
               : 'pattern_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_no_exn_comma_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1657 "ml/parser.mly"
                                                ( _3 :: _1 )
# 9713 "ml/parser.ml"
               : 'pattern_no_exn_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_no_exn) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1658 "ml/parser.mly"
                                                ( [_3; _1] )
# 9721 "ml/parser.ml"
               : 'pattern_no_exn_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_no_exn) in
    Obj.repr(
# 1659 "ml/parser.mly"
                                                ( expecting 3 "pattern" )
# 9728 "ml/parser.ml"
               : 'pattern_no_exn_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1662 "ml/parser.mly"
                                                ( [_1] )
# 9735 "ml/parser.ml"
               : 'pattern_semi_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1663 "ml/parser.mly"
                                                ( _3 :: _1 )
# 9743 "ml/parser.ml"
               : 'pattern_semi_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_pattern) in
    Obj.repr(
# 1666 "ml/parser.mly"
                ( [_1], Closed )
# 9750 "ml/parser.ml"
               : 'lbl_pattern_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lbl_pattern) in
    Obj.repr(
# 1667 "ml/parser.mly"
                     ( [_1], Closed )
# 9757 "ml/parser.ml"
               : 'lbl_pattern_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'lbl_pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'opt_semi) in
    Obj.repr(
# 1668 "ml/parser.mly"
                                         ( [_1], Open )
# 9765 "ml/parser.ml"
               : 'lbl_pattern_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'lbl_pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_pattern_list) in
    Obj.repr(
# 1670 "ml/parser.mly"
      ( let (fields, closed) = _3 in _1 :: fields, closed )
# 9773 "ml/parser.ml"
               : 'lbl_pattern_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'label_longident) in
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'opt_pattern_type_constraint) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1674 "ml/parser.mly"
     ( (mkrhs _1 1, mkpat_opt_constraint _4 _2) )
# 9782 "ml/parser.ml"
               : 'lbl_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'label_longident) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'opt_pattern_type_constraint) in
    Obj.repr(
# 1676 "ml/parser.mly"
     ( (mkrhs _1 1, mkpat_opt_constraint (pat_of_label _1 1) _2) )
# 9790 "ml/parser.ml"
               : 'lbl_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1679 "ml/parser.mly"
                    ( Some _2 )
# 9797 "ml/parser.ml"
               : 'opt_pattern_type_constraint))
; (fun __caml_parser_env ->
    Obj.repr(
# 1680 "ml/parser.mly"
                ( None )
# 9803 "ml/parser.ml"
               : 'opt_pattern_type_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'val_ident) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1687 "ml/parser.mly"
      ( let (ext, attrs) = _2 in
        Val.mk (mkrhs _3 3) _5 ~attrs:(attrs@_6)
              ~loc:(symbol_rloc()) ~docs:(symbol_docs ())
      , ext )
# 9816 "ml/parser.ml"
               : 'value_description))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string * string option) in
    Obj.repr(
# 1696 "ml/parser.mly"
                                                ( [fst _1] )
# 9823 "ml/parser.ml"
               : 'primitive_declaration_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string * string option) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'primitive_declaration_body) in
    Obj.repr(
# 1697 "ml/parser.mly"
                                                ( fst _1 :: _2 )
# 9831 "ml/parser.ml"
               : 'primitive_declaration_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 6 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'val_ident) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'core_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'primitive_declaration_body) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1702 "ml/parser.mly"
      ( let (ext, attrs) = _2 in
        Val.mk (mkrhs _3 3) _5 ~prim:_7 ~attrs:(attrs@_8)
              ~loc:(symbol_rloc ()) ~docs:(symbol_docs ())
      , ext )
# 9845 "ml/parser.ml"
               : 'primitive_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_declaration) in
    Obj.repr(
# 1712 "ml/parser.mly"
      ( let (nonrec_flag, ty, ext) = _1 in (nonrec_flag, [ty], ext) )
# 9852 "ml/parser.ml"
               : 'type_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'type_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_type_declaration) in
    Obj.repr(
# 1714 "ml/parser.mly"
      ( let (nonrec_flag, tys, ext) = _1 in (nonrec_flag, _2 :: tys, ext) )
# 9860 "ml/parser.ml"
               : 'type_declarations))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 6 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'nonrec_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'optional_type_parameters) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'type_kind) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'constraints) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1720 "ml/parser.mly"
      ( let (kind, priv, manifest) = _6 in
        let (ext, attrs) = _2 in
        let ty =
          Type.mk (mkrhs _5 5) ~params:_4 ~cstrs:(List.rev _7) ~kind
            ~priv ?manifest ~attrs:(attrs@_8)
            ~loc:(symbol_rloc ()) ~docs:(symbol_docs ())
        in
          (_3, ty, ext) )
# 9880 "ml/parser.ml"
               : 'type_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'optional_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'type_kind) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'constraints) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1732 "ml/parser.mly"
      ( let (kind, priv, manifest) = _5 in
          Type.mk (mkrhs _4 4) ~params:_3 ~cstrs:(List.rev _6)
            ~kind ~priv ?manifest ~attrs:(_2@_7) ~loc:(symbol_rloc ())
            ~text:(symbol_text ()) ~docs:(symbol_docs ()) )
# 9895 "ml/parser.ml"
               : 'and_type_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'constraints) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'constrain) in
    Obj.repr(
# 1738 "ml/parser.mly"
                                                ( _3 :: _1 )
# 9903 "ml/parser.ml"
               : 'constraints))
; (fun __caml_parser_env ->
    Obj.repr(
# 1739 "ml/parser.mly"
                                                ( [] )
# 9909 "ml/parser.ml"
               : 'constraints))
; (fun __caml_parser_env ->
    Obj.repr(
# 1743 "ml/parser.mly"
      ( (Ptype_abstract, Public, None) )
# 9915 "ml/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1745 "ml/parser.mly"
      ( (Ptype_abstract, Public, Some _2) )
# 9922 "ml/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1747 "ml/parser.mly"
      ( (Ptype_abstract, Private, Some _3) )
# 9929 "ml/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_declarations) in
    Obj.repr(
# 1749 "ml/parser.mly"
      ( (Ptype_variant(List.rev _2), Public, None) )
# 9936 "ml/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_declarations) in
    Obj.repr(
# 1751 "ml/parser.mly"
      ( (Ptype_variant(List.rev _3), Private, None) )
# 9943 "ml/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    Obj.repr(
# 1753 "ml/parser.mly"
      ( (Ptype_open, Public, None) )
# 9949 "ml/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    Obj.repr(
# 1755 "ml/parser.mly"
      ( (Ptype_open, Private, None) )
# 9955 "ml/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'private_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'label_declarations) in
    Obj.repr(
# 1757 "ml/parser.mly"
      ( (Ptype_record _4, _2, None) )
# 9963 "ml/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'core_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'private_flag) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_declarations) in
    Obj.repr(
# 1759 "ml/parser.mly"
      ( (Ptype_variant(List.rev _5), _4, Some _2) )
# 9972 "ml/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'core_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'private_flag) in
    Obj.repr(
# 1761 "ml/parser.mly"
      ( (Ptype_open, _4, Some _2) )
# 9980 "ml/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'core_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'private_flag) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'label_declarations) in
    Obj.repr(
# 1763 "ml/parser.mly"
      ( (Ptype_record _6, _4, Some _2) )
# 9989 "ml/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    Obj.repr(
# 1766 "ml/parser.mly"
                                                ( [] )
# 9995 "ml/parser.ml"
               : 'optional_type_parameters))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'optional_type_parameter) in
    Obj.repr(
# 1767 "ml/parser.mly"
                                                ( [_1] )
# 10002 "ml/parser.ml"
               : 'optional_type_parameters))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'optional_type_parameter_list) in
    Obj.repr(
# 1768 "ml/parser.mly"
                                                ( List.rev _2 )
# 10009 "ml/parser.ml"
               : 'optional_type_parameters))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'type_variance) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'optional_type_variable) in
    Obj.repr(
# 1771 "ml/parser.mly"
                                                ( _2, _1 )
# 10017 "ml/parser.ml"
               : 'optional_type_parameter))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'optional_type_parameter) in
    Obj.repr(
# 1774 "ml/parser.mly"
                                                         ( [_1] )
# 10024 "ml/parser.ml"
               : 'optional_type_parameter_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'optional_type_parameter_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'optional_type_parameter) in
    Obj.repr(
# 1775 "ml/parser.mly"
                                                                  ( _3 :: _1 )
# 10032 "ml/parser.ml"
               : 'optional_type_parameter_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 1778 "ml/parser.mly"
                                                ( mktyp(Ptyp_var _2) )
# 10039 "ml/parser.ml"
               : 'optional_type_variable))
; (fun __caml_parser_env ->
    Obj.repr(
# 1779 "ml/parser.mly"
                                                ( mktyp(Ptyp_any) )
# 10045 "ml/parser.ml"
               : 'optional_type_variable))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'type_variance) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'type_variable) in
    Obj.repr(
# 1784 "ml/parser.mly"
                                                  ( _2, _1 )
# 10053 "ml/parser.ml"
               : 'type_parameter))
; (fun __caml_parser_env ->
    Obj.repr(
# 1787 "ml/parser.mly"
                                                ( Invariant )
# 10059 "ml/parser.ml"
               : 'type_variance))
; (fun __caml_parser_env ->
    Obj.repr(
# 1788 "ml/parser.mly"
                                                ( Covariant )
# 10065 "ml/parser.ml"
               : 'type_variance))
; (fun __caml_parser_env ->
    Obj.repr(
# 1789 "ml/parser.mly"
                                                ( Contravariant )
# 10071 "ml/parser.ml"
               : 'type_variance))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 1792 "ml/parser.mly"
                                                ( mktyp(Ptyp_var _2) )
# 10078 "ml/parser.ml"
               : 'type_variable))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_parameter) in
    Obj.repr(
# 1795 "ml/parser.mly"
                                                ( [_1] )
# 10085 "ml/parser.ml"
               : 'type_parameter_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'type_parameter_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'type_parameter) in
    Obj.repr(
# 1796 "ml/parser.mly"
                                                ( _3 :: _1 )
# 10093 "ml/parser.ml"
               : 'type_parameter_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_declaration) in
    Obj.repr(
# 1799 "ml/parser.mly"
                                                         ( [_1] )
# 10100 "ml/parser.ml"
               : 'constructor_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bar_constructor_declaration) in
    Obj.repr(
# 1800 "ml/parser.mly"
                                                         ( [_1] )
# 10107 "ml/parser.ml"
               : 'constructor_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'constructor_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'bar_constructor_declaration) in
    Obj.repr(
# 1801 "ml/parser.mly"
                                                         ( _2 :: _1 )
# 10115 "ml/parser.ml"
               : 'constructor_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'constr_ident) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'generalized_constructor_arguments) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1805 "ml/parser.mly"
      (
       let args,res = _2 in
       Type.constructor (mkrhs _1 1) ~args ?res ~attrs:_3
         ~loc:(symbol_rloc()) ~info:(symbol_info ())
      )
# 10128 "ml/parser.ml"
               : 'constructor_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'constr_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'generalized_constructor_arguments) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1813 "ml/parser.mly"
      (
       let args,res = _3 in
       Type.constructor (mkrhs _2 2) ~args ?res ~attrs:_4
         ~loc:(symbol_rloc()) ~info:(symbol_info ())
      )
# 10141 "ml/parser.ml"
               : 'bar_constructor_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sig_exception_declaration) in
    Obj.repr(
# 1820 "ml/parser.mly"
                                                 ( _1 )
# 10148 "ml/parser.ml"
               : 'str_exception_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'constr_ident) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'constr_longident) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'attributes) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1823 "ml/parser.mly"
      ( let (ext,attrs) = _2 in
        Te.rebind (mkrhs _3 3) (mkrhs _5 5) ~attrs:(attrs @ _6 @ _7)
          ~loc:(symbol_rloc()) ~docs:(symbol_docs ())
        , ext )
# 10162 "ml/parser.ml"
               : 'str_exception_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'constr_ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'generalized_constructor_arguments) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'attributes) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1831 "ml/parser.mly"
      ( let args, res = _4 in
        let (ext,attrs) = _2 in
          Te.decl (mkrhs _3 3) ~args ?res ~attrs:(attrs @ _5 @ _6)
            ~loc:(symbol_rloc()) ~docs:(symbol_docs ())
        , ext )
# 10177 "ml/parser.ml"
               : 'sig_exception_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'constr_ident) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'generalized_constructor_arguments) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1839 "ml/parser.mly"
      ( let args, res = _2 in
        Te.decl (mkrhs _1 1) ~args ?res ~attrs:_3 ~loc:(symbol_rloc()) )
# 10187 "ml/parser.ml"
               : 'let_exception_declaration))
; (fun __caml_parser_env ->
    Obj.repr(
# 1843 "ml/parser.mly"
                                  ( (Pcstr_tuple [],None) )
# 10193 "ml/parser.ml"
               : 'generalized_constructor_arguments))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_arguments) in
    Obj.repr(
# 1844 "ml/parser.mly"
                                  ( (_2,None) )
# 10200 "ml/parser.ml"
               : 'generalized_constructor_arguments))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'constructor_arguments) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
# 1846 "ml/parser.mly"
                                  ( (_2,Some _4) )
# 10208 "ml/parser.ml"
               : 'generalized_constructor_arguments))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
# 1848 "ml/parser.mly"
                                  ( (Pcstr_tuple [],Some _2) )
# 10215 "ml/parser.ml"
               : 'generalized_constructor_arguments))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_list) in
    Obj.repr(
# 1852 "ml/parser.mly"
                                     ( Pcstr_tuple (List.rev _1) )
# 10222 "ml/parser.ml"
               : 'constructor_arguments))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'label_declarations) in
    Obj.repr(
# 1853 "ml/parser.mly"
                                     ( Pcstr_record _2 )
# 10229 "ml/parser.ml"
               : 'constructor_arguments))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_declaration) in
    Obj.repr(
# 1856 "ml/parser.mly"
                                                ( [_1] )
# 10236 "ml/parser.ml"
               : 'label_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_declaration_semi) in
    Obj.repr(
# 1857 "ml/parser.mly"
                                                ( [_1] )
# 10243 "ml/parser.ml"
               : 'label_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'label_declaration_semi) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_declarations) in
    Obj.repr(
# 1858 "ml/parser.mly"
                                                ( _1 :: _2 )
# 10251 "ml/parser.ml"
               : 'label_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mutable_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'label) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'poly_type_no_attr) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1862 "ml/parser.mly"
      (
       Type.field (mkrhs _2 2) _4 ~mut:_1 ~attrs:_5
         ~loc:(symbol_rloc()) ~info:(symbol_info ())
      )
# 10264 "ml/parser.ml"
               : 'label_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'mutable_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'label) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'poly_type_no_attr) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1869 "ml/parser.mly"
      (
       let info =
         match rhs_info 5 with
         | Some _ as info_before_semi -> info_before_semi
         | None -> symbol_info ()
       in
       Type.field (mkrhs _2 2) _4 ~mut:_1 ~attrs:(_5 @ _7)
         ~loc:(symbol_rloc()) ~info
      )
# 10283 "ml/parser.ml"
               : 'label_declaration_semi))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 7 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 6 : 'nonrec_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 5 : 'optional_type_parameters) in
    let _5 = (Parsing.peek_val __caml_parser_env 4 : 'type_longident) in
    let _7 = (Parsing.peek_val __caml_parser_env 2 : 'private_flag) in
    let _8 = (Parsing.peek_val __caml_parser_env 1 : 'str_extension_constructors) in
    let _9 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1885 "ml/parser.mly"
      ( let (ext, attrs) = _2 in
        if _3 <> Recursive then not_expecting 3 "nonrec flag";
        Te.mk (mkrhs _5 5) (List.rev _8) ~params:_4 ~priv:_7
          ~attrs:(attrs@_9) ~docs:(symbol_docs ())
        , ext )
# 10300 "ml/parser.ml"
               : 'str_type_extension))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 7 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 6 : 'nonrec_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 5 : 'optional_type_parameters) in
    let _5 = (Parsing.peek_val __caml_parser_env 4 : 'type_longident) in
    let _7 = (Parsing.peek_val __caml_parser_env 2 : 'private_flag) in
    let _8 = (Parsing.peek_val __caml_parser_env 1 : 'sig_extension_constructors) in
    let _9 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1894 "ml/parser.mly"
      ( let (ext, attrs) = _2 in
        if _3 <> Recursive then not_expecting 3 "nonrec flag";
        Te.mk (mkrhs _5 5) (List.rev _8) ~params:_4 ~priv:_7
          ~attrs:(attrs @ _9) ~docs:(symbol_docs ())
        , ext )
# 10317 "ml/parser.ml"
               : 'sig_type_extension))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension_constructor_declaration) in
    Obj.repr(
# 1901 "ml/parser.mly"
                                                          ( [_1] )
# 10324 "ml/parser.ml"
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_declaration) in
    Obj.repr(
# 1902 "ml/parser.mly"
                                                          ( [_1] )
# 10331 "ml/parser.ml"
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension_constructor_rebind) in
    Obj.repr(
# 1903 "ml/parser.mly"
                                                          ( [_1] )
# 10338 "ml/parser.ml"
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_rebind) in
    Obj.repr(
# 1904 "ml/parser.mly"
                                                          ( [_1] )
# 10345 "ml/parser.ml"
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'str_extension_constructors) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_declaration) in
    Obj.repr(
# 1906 "ml/parser.mly"
      ( _2 :: _1 )
# 10353 "ml/parser.ml"
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'str_extension_constructors) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_rebind) in
    Obj.repr(
# 1908 "ml/parser.mly"
      ( _2 :: _1 )
# 10361 "ml/parser.ml"
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension_constructor_declaration) in
    Obj.repr(
# 1911 "ml/parser.mly"
                                                          ( [_1] )
# 10368 "ml/parser.ml"
               : 'sig_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_declaration) in
    Obj.repr(
# 1912 "ml/parser.mly"
                                                          ( [_1] )
# 10375 "ml/parser.ml"
               : 'sig_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'sig_extension_constructors) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_declaration) in
    Obj.repr(
# 1914 "ml/parser.mly"
      ( _2 :: _1 )
# 10383 "ml/parser.ml"
               : 'sig_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'constr_ident) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'generalized_constructor_arguments) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1918 "ml/parser.mly"
      ( let args, res = _2 in
        Te.decl (mkrhs _1 1) ~args ?res ~attrs:_3
          ~loc:(symbol_rloc()) ~info:(symbol_info ()) )
# 10394 "ml/parser.ml"
               : 'extension_constructor_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'constr_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'generalized_constructor_arguments) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1924 "ml/parser.mly"
      ( let args, res = _3 in
        Te.decl (mkrhs _2 2) ~args ?res ~attrs:_4
           ~loc:(symbol_rloc()) ~info:(symbol_info ()) )
# 10405 "ml/parser.ml"
               : 'bar_extension_constructor_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'constr_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'constr_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1930 "ml/parser.mly"
      ( Te.rebind (mkrhs _1 1) (mkrhs _3 3) ~attrs:_4
          ~loc:(symbol_rloc()) ~info:(symbol_info ()) )
# 10415 "ml/parser.ml"
               : 'extension_constructor_rebind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'constr_ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'constr_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1935 "ml/parser.mly"
      ( Te.rebind (mkrhs _2 2) (mkrhs _4 4) ~attrs:_5
          ~loc:(symbol_rloc()) ~info:(symbol_info ()) )
# 10425 "ml/parser.ml"
               : 'bar_extension_constructor_rebind))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'with_constraint) in
    Obj.repr(
# 1942 "ml/parser.mly"
                                                ( [_1] )
# 10432 "ml/parser.ml"
               : 'with_constraints))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'with_constraints) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'with_constraint) in
    Obj.repr(
# 1943 "ml/parser.mly"
                                                ( _3 :: _1 )
# 10440 "ml/parser.ml"
               : 'with_constraints))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'optional_type_parameters) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'label_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'with_type_binder) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'core_type_no_attr) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'constraints) in
    Obj.repr(
# 1948 "ml/parser.mly"
      ( Pwith_type
          (mkrhs _3 3,
           (Type.mk (mkrhs (Longident.last _3) 3)
              ~params:_2
              ~cstrs:(List.rev _6)
              ~manifest:_5
              ~priv:_4
              ~loc:(symbol_rloc()))) )
# 10458 "ml/parser.ml"
               : 'with_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'optional_type_parameters) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
# 1959 "ml/parser.mly"
      ( Pwith_typesubst
         (mkrhs _3 3,
           (Type.mk (mkrhs (Longident.last _3) 3)
             ~params:_2
             ~manifest:_5
             ~loc:(symbol_rloc()))) )
# 10472 "ml/parser.ml"
               : 'with_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'mod_ext_longident) in
    Obj.repr(
# 1966 "ml/parser.mly"
      ( Pwith_module (mkrhs _2 2, mkrhs _4 4) )
# 10480 "ml/parser.ml"
               : 'with_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'mod_ext_longident) in
    Obj.repr(
# 1968 "ml/parser.mly"
      ( Pwith_modsubst (mkrhs _2 2, mkrhs _4 4) )
# 10488 "ml/parser.ml"
               : 'with_constraint))
; (fun __caml_parser_env ->
    Obj.repr(
# 1971 "ml/parser.mly"
                   ( Public )
# 10494 "ml/parser.ml"
               : 'with_type_binder))
; (fun __caml_parser_env ->
    Obj.repr(
# 1972 "ml/parser.mly"
                   ( Private )
# 10500 "ml/parser.ml"
               : 'with_type_binder))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 1978 "ml/parser.mly"
                                                ( [mkrhs _2 2] )
# 10507 "ml/parser.ml"
               : 'typevar_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'typevar_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 1979 "ml/parser.mly"
                                                ( mkrhs _3 3 :: _1 )
# 10515 "ml/parser.ml"
               : 'typevar_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1983 "ml/parser.mly"
          ( _1 )
# 10522 "ml/parser.ml"
               : 'poly_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'typevar_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1985 "ml/parser.mly"
          ( mktyp(Ptyp_poly(List.rev _1, _3)) )
# 10530 "ml/parser.ml"
               : 'poly_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
# 1989 "ml/parser.mly"
          ( _1 )
# 10537 "ml/parser.ml"
               : 'poly_type_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'typevar_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
# 1991 "ml/parser.mly"
          ( mktyp(Ptyp_poly(List.rev _1, _3)) )
# 10545 "ml/parser.ml"
               : 'poly_type_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
# 1998 "ml/parser.mly"
      ( _1 )
# 10552 "ml/parser.ml"
               : 'core_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 2000 "ml/parser.mly"
      ( Typ.attr _1 _2 )
# 10560 "ml/parser.ml"
               : 'core_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
# 2004 "ml/parser.mly"
      ( _1 )
# 10567 "ml/parser.ml"
               : 'core_type_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'core_type2) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 2006 "ml/parser.mly"
      ( mktyp(Ptyp_alias(_1, _4)) )
# 10575 "ml/parser.ml"
               : 'core_type_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type_or_tuple) in
    Obj.repr(
# 2010 "ml/parser.mly"
      ( _1 )
# 10582 "ml/parser.ml"
               : 'core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'core_type2) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
# 2012 "ml/parser.mly"
      ( let param = extra_rhs_core_type _4 ~pos:4 in
        mktyp (Ptyp_arrow(Optional _2 , param, _6)) )
# 10592 "ml/parser.ml"
               : 'core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type2) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
# 2015 "ml/parser.mly"
      ( let param = extra_rhs_core_type _2 ~pos:2 in
        mktyp(Ptyp_arrow(Optional _1 , param, _4))
      )
# 10603 "ml/parser.ml"
               : 'core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'core_type2) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
# 2019 "ml/parser.mly"
      ( let param = extra_rhs_core_type _3 ~pos:3 in
        mktyp(Ptyp_arrow(Labelled _1, param, _5)) )
# 10613 "ml/parser.ml"
               : 'core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type2) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
# 2022 "ml/parser.mly"
      ( let param = extra_rhs_core_type _1 ~pos:1 in
        mktyp(Ptyp_arrow(Nolabel, param, _3)) )
# 10622 "ml/parser.ml"
               : 'core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type2) in
    Obj.repr(
# 2028 "ml/parser.mly"
      ( _1 )
# 10629 "ml/parser.ml"
               : 'simple_core_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'core_type_comma_list) in
    Obj.repr(
# 2030 "ml/parser.mly"
      ( match _2 with [sty] -> sty | _ -> raise Parse_error )
# 10636 "ml/parser.ml"
               : 'simple_core_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 2035 "ml/parser.mly"
      ( mktyp(Ptyp_var _2) )
# 10643 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    Obj.repr(
# 2037 "ml/parser.mly"
      ( mktyp(Ptyp_any) )
# 10649 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_longident) in
    Obj.repr(
# 2039 "ml/parser.mly"
      ( mktyp(Ptyp_constr(mkrhs _1 1, [])) )
# 10656 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'simple_core_type2) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'type_longident) in
    Obj.repr(
# 2041 "ml/parser.mly"
      ( mktyp(Ptyp_constr(mkrhs _2 2, [_1])) )
# 10664 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_comma_list) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'type_longident) in
    Obj.repr(
# 2043 "ml/parser.mly"
      ( mktyp(Ptyp_constr(mkrhs _4 4, List.rev _2)) )
# 10672 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'meth_list) in
    Obj.repr(
# 2045 "ml/parser.mly"
      ( let (f, c) = _2 in mktyp(Ptyp_object (f, c)) )
# 10679 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    Obj.repr(
# 2047 "ml/parser.mly"
      ( mktyp(Ptyp_object ([], Closed)) )
# 10685 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
# 2049 "ml/parser.mly"
      ( mktyp(Ptyp_class(mkrhs _2 2, [])) )
# 10692 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type2) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
# 2051 "ml/parser.mly"
      ( mktyp(Ptyp_class(mkrhs _3 3, [_1])) )
# 10700 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'core_type_comma_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
# 2053 "ml/parser.mly"
      ( mktyp(Ptyp_class(mkrhs _5 5, List.rev _2)) )
# 10708 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'tag_field) in
    Obj.repr(
# 2055 "ml/parser.mly"
      ( mktyp(Ptyp_variant([_2], Closed, None)) )
# 10715 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'row_field_list) in
    Obj.repr(
# 2061 "ml/parser.mly"
      ( mktyp(Ptyp_variant(List.rev _3, Closed, None)) )
# 10722 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'row_field) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'row_field_list) in
    Obj.repr(
# 2063 "ml/parser.mly"
      ( mktyp(Ptyp_variant(_2 :: List.rev _4, Closed, None)) )
# 10730 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'opt_bar) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'row_field_list) in
    Obj.repr(
# 2065 "ml/parser.mly"
      ( mktyp(Ptyp_variant(List.rev _3, Open, None)) )
# 10738 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    Obj.repr(
# 2067 "ml/parser.mly"
      ( mktyp(Ptyp_variant([], Open, None)) )
# 10744 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'opt_bar) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'row_field_list) in
    Obj.repr(
# 2069 "ml/parser.mly"
      ( mktyp(Ptyp_variant(List.rev _3, Closed, Some [])) )
# 10752 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'opt_bar) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'row_field_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag_list) in
    Obj.repr(
# 2071 "ml/parser.mly"
      ( mktyp(Ptyp_variant(List.rev _3, Closed, Some (List.rev _5))) )
# 10761 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 2073 "ml/parser.mly"
      ( mktyp_attrs (Ptyp_package _4) _3 )
# 10769 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
# 2075 "ml/parser.mly"
      ( mktyp (Ptyp_extension _1) )
# 10776 "ml/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_type) in
    Obj.repr(
# 2078 "ml/parser.mly"
                ( package_type_of_module_type _1 )
# 10783 "ml/parser.ml"
               : 'package_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'row_field) in
    Obj.repr(
# 2081 "ml/parser.mly"
                                                ( [_1] )
# 10790 "ml/parser.ml"
               : 'row_field_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'row_field_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'row_field) in
    Obj.repr(
# 2082 "ml/parser.mly"
                                                ( _3 :: _1 )
# 10798 "ml/parser.ml"
               : 'row_field_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'tag_field) in
    Obj.repr(
# 2085 "ml/parser.mly"
                                                ( _1 )
# 10805 "ml/parser.ml"
               : 'row_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
# 2086 "ml/parser.mly"
                                                ( Rinherit _1 )
# 10812 "ml/parser.ml"
               : 'row_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'name_tag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'opt_ampersand) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'amper_type_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 2090 "ml/parser.mly"
      ( Rtag (mkrhs _1 1, add_info_attrs (symbol_info ()) _5,
               _3, List.rev _4) )
# 10823 "ml/parser.ml"
               : 'tag_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 2093 "ml/parser.mly"
      ( Rtag (mkrhs _1 1, add_info_attrs (symbol_info ()) _2, true, []) )
# 10831 "ml/parser.ml"
               : 'tag_field))
; (fun __caml_parser_env ->
    Obj.repr(
# 2096 "ml/parser.mly"
                                                ( true )
# 10837 "ml/parser.ml"
               : 'opt_ampersand))
; (fun __caml_parser_env ->
    Obj.repr(
# 2097 "ml/parser.mly"
                                                ( false )
# 10843 "ml/parser.ml"
               : 'opt_ampersand))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
# 2100 "ml/parser.mly"
                                                ( [_1] )
# 10850 "ml/parser.ml"
               : 'amper_type_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'amper_type_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
# 2101 "ml/parser.mly"
                                                ( _3 :: _1 )
# 10858 "ml/parser.ml"
               : 'amper_type_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_tag) in
    Obj.repr(
# 2104 "ml/parser.mly"
                                                ( [_1] )
# 10865 "ml/parser.ml"
               : 'name_tag_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_tag) in
    Obj.repr(
# 2105 "ml/parser.mly"
                                                ( _2 :: _1 )
# 10873 "ml/parser.ml"
               : 'name_tag_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
# 2108 "ml/parser.mly"
                     ( _1 )
# 10880 "ml/parser.ml"
               : 'simple_core_type_or_tuple))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_list) in
    Obj.repr(
# 2110 "ml/parser.mly"
      ( mktyp(Ptyp_tuple(_1 :: List.rev _3)) )
# 10888 "ml/parser.ml"
               : 'simple_core_type_or_tuple))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 2113 "ml/parser.mly"
                                                ( [_1] )
# 10895 "ml/parser.ml"
               : 'core_type_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_comma_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 2114 "ml/parser.mly"
                                                ( _3 :: _1 )
# 10903 "ml/parser.ml"
               : 'core_type_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
# 2117 "ml/parser.mly"
                                                ( [_1] )
# 10910 "ml/parser.ml"
               : 'core_type_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
# 2118 "ml/parser.mly"
                                                ( _3 :: _1 )
# 10918 "ml/parser.ml"
               : 'core_type_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'field_semi) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'meth_list) in
    Obj.repr(
# 2121 "ml/parser.mly"
                                                ( let (f, c) = _2 in (_1 :: f, c) )
# 10926 "ml/parser.ml"
               : 'meth_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'inherit_field_semi) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'meth_list) in
    Obj.repr(
# 2122 "ml/parser.mly"
                                                ( let (f, c) = _2 in (_1 :: f, c) )
# 10934 "ml/parser.ml"
               : 'meth_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'field_semi) in
    Obj.repr(
# 2123 "ml/parser.mly"
                                                ( [_1], Closed )
# 10941 "ml/parser.ml"
               : 'meth_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'field) in
    Obj.repr(
# 2124 "ml/parser.mly"
                                                ( [_1], Closed )
# 10948 "ml/parser.ml"
               : 'meth_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'inherit_field_semi) in
    Obj.repr(
# 2125 "ml/parser.mly"
                                                ( [_1], Closed )
# 10955 "ml/parser.ml"
               : 'meth_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
# 2126 "ml/parser.mly"
                                                ( [Oinherit _1], Closed )
# 10962 "ml/parser.ml"
               : 'meth_list))
; (fun __caml_parser_env ->
    Obj.repr(
# 2127 "ml/parser.mly"
                                                ( [], Open )
# 10968 "ml/parser.ml"
               : 'meth_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'label) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'poly_type_no_attr) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 2131 "ml/parser.mly"
    ( Otag (mkrhs _1 1, add_info_attrs (symbol_info ()) _4, _3) )
# 10977 "ml/parser.ml"
               : 'field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'label) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'poly_type_no_attr) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 2136 "ml/parser.mly"
    ( let info =
        match rhs_info 4 with
        | Some _ as info_before_semi -> info_before_semi
        | None -> symbol_info ()
      in
      ( Otag (mkrhs _1 1, add_info_attrs info (_4 @ _6), _3)) )
# 10992 "ml/parser.ml"
               : 'field_semi))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'simple_core_type) in
    Obj.repr(
# 2145 "ml/parser.mly"
                        ( Oinherit _1 )
# 10999 "ml/parser.ml"
               : 'inherit_field_semi))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2148 "ml/parser.mly"
                                                ( _1 )
# 11006 "ml/parser.ml"
               : 'label))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string * char option) in
    Obj.repr(
# 2154 "ml/parser.mly"
                 ( let (n, m) = _1 in Pconst_integer (n, m) )
# 11013 "ml/parser.ml"
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : char) in
    Obj.repr(
# 2155 "ml/parser.mly"
                 ( Pconst_char _1 )
# 11020 "ml/parser.ml"
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string * string option) in
    Obj.repr(
# 2156 "ml/parser.mly"
                 ( let (s, d) = _1 in Pconst_string (s, d) )
# 11027 "ml/parser.ml"
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string * char option) in
    Obj.repr(
# 2157 "ml/parser.mly"
                 ( let (f, m) = _1 in Pconst_float (f, m) )
# 11034 "ml/parser.ml"
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constant) in
    Obj.repr(
# 2160 "ml/parser.mly"
                 ( _1 )
# 11041 "ml/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string * char option) in
    Obj.repr(
# 2161 "ml/parser.mly"
                 ( let (n, m) = _2 in Pconst_integer("-" ^ n, m) )
# 11048 "ml/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string * char option) in
    Obj.repr(
# 2162 "ml/parser.mly"
                 ( let (f, m) = _2 in Pconst_float("-" ^ f, m) )
# 11055 "ml/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string * char option) in
    Obj.repr(
# 2163 "ml/parser.mly"
                 ( let (n, m) = _2 in Pconst_integer (n, m) )
# 11062 "ml/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string * char option) in
    Obj.repr(
# 2164 "ml/parser.mly"
                 ( let (f, m) = _2 in Pconst_float(f, m) )
# 11069 "ml/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2170 "ml/parser.mly"
                                                ( _1 )
# 11076 "ml/parser.ml"
               : 'ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2171 "ml/parser.mly"
                                                ( _1 )
# 11083 "ml/parser.ml"
               : 'ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2174 "ml/parser.mly"
                                                ( _1 )
# 11090 "ml/parser.ml"
               : 'val_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'operator) in
    Obj.repr(
# 2175 "ml/parser.mly"
                                                ( _2 )
# 11097 "ml/parser.ml"
               : 'val_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'operator) in
    Obj.repr(
# 2176 "ml/parser.mly"
                                                ( unclosed "(" 1 ")" 3 )
# 11104 "ml/parser.ml"
               : 'val_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2177 "ml/parser.mly"
                                                ( expecting 2 "operator" )
# 11110 "ml/parser.ml"
               : 'val_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2178 "ml/parser.mly"
                                                ( expecting 3 "module-expr" )
# 11116 "ml/parser.ml"
               : 'val_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2181 "ml/parser.mly"
                                                ( _1 )
# 11123 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2182 "ml/parser.mly"
                                                ( _1 )
# 11130 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2183 "ml/parser.mly"
                                                ( _1 )
# 11137 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2184 "ml/parser.mly"
                                                ( _1 )
# 11144 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2185 "ml/parser.mly"
                                                ( _1 )
# 11151 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2186 "ml/parser.mly"
                                                ( _1 )
# 11158 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : string) in
    Obj.repr(
# 2187 "ml/parser.mly"
                                                ( "."^ _1 ^"()" )
# 11165 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : string) in
    Obj.repr(
# 2188 "ml/parser.mly"
                                                ( "."^ _1 ^ "()<-" )
# 11172 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : string) in
    Obj.repr(
# 2189 "ml/parser.mly"
                                                ( "."^ _1 ^"[]" )
# 11179 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : string) in
    Obj.repr(
# 2190 "ml/parser.mly"
                                                ( "."^ _1 ^ "[]<-" )
# 11186 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : string) in
    Obj.repr(
# 2191 "ml/parser.mly"
                                                ( "."^ _1 ^"{}" )
# 11193 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : string) in
    Obj.repr(
# 2192 "ml/parser.mly"
                                                ( "."^ _1 ^ "{}<-" )
# 11200 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2193 "ml/parser.mly"
                                                ( _1 )
# 11207 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2194 "ml/parser.mly"
                                                ( "!" )
# 11213 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2195 "ml/parser.mly"
                                                ( "+" )
# 11219 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2196 "ml/parser.mly"
                                                ( "+." )
# 11225 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2197 "ml/parser.mly"
                                                ( "-" )
# 11231 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2198 "ml/parser.mly"
                                                ( "-." )
# 11237 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2199 "ml/parser.mly"
                                                ( "*" )
# 11243 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2200 "ml/parser.mly"
                                                ( "=" )
# 11249 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2201 "ml/parser.mly"
                                                ( "<" )
# 11255 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2202 "ml/parser.mly"
                                                ( ">" )
# 11261 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2203 "ml/parser.mly"
                                                ( "or" )
# 11267 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2204 "ml/parser.mly"
                                                ( "||" )
# 11273 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2205 "ml/parser.mly"
                                                ( "&" )
# 11279 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2206 "ml/parser.mly"
                                                ( "&&" )
# 11285 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2207 "ml/parser.mly"
                                                ( ":=" )
# 11291 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2208 "ml/parser.mly"
                                                ( "+=" )
# 11297 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2209 "ml/parser.mly"
                                                ( "%" )
# 11303 "ml/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2212 "ml/parser.mly"
                                                ( _1 )
# 11310 "ml/parser.ml"
               : 'constr_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2213 "ml/parser.mly"
                                                ( "[]" )
# 11316 "ml/parser.ml"
               : 'constr_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2214 "ml/parser.mly"
                                                ( "()" )
# 11322 "ml/parser.ml"
               : 'constr_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2215 "ml/parser.mly"
                                                ( "::" )
# 11328 "ml/parser.ml"
               : 'constr_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2216 "ml/parser.mly"
                                                ( "false" )
# 11334 "ml/parser.ml"
               : 'constr_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2217 "ml/parser.mly"
                                                ( "true" )
# 11340 "ml/parser.ml"
               : 'constr_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'val_ident) in
    Obj.repr(
# 2221 "ml/parser.mly"
                                                ( Lident _1 )
# 11347 "ml/parser.ml"
               : 'val_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'val_ident) in
    Obj.repr(
# 2222 "ml/parser.mly"
                                                ( Ldot(_1, _3) )
# 11355 "ml/parser.ml"
               : 'val_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'mod_longident) in
    Obj.repr(
# 2225 "ml/parser.mly"
                                                ( _1 )
# 11362 "ml/parser.ml"
               : 'constr_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    Obj.repr(
# 2226 "ml/parser.mly"
                                                ( Ldot(_1,"::") )
# 11369 "ml/parser.ml"
               : 'constr_longident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2227 "ml/parser.mly"
                                                ( Lident "[]" )
# 11375 "ml/parser.ml"
               : 'constr_longident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2228 "ml/parser.mly"
                                                ( Lident "()" )
# 11381 "ml/parser.ml"
               : 'constr_longident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2229 "ml/parser.mly"
                                                ( Lident "::" )
# 11387 "ml/parser.ml"
               : 'constr_longident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2230 "ml/parser.mly"
                                                ( Lident "false" )
# 11393 "ml/parser.ml"
               : 'constr_longident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2231 "ml/parser.mly"
                                                ( Lident "true" )
# 11399 "ml/parser.ml"
               : 'constr_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2234 "ml/parser.mly"
                                                ( Lident _1 )
# 11406 "ml/parser.ml"
               : 'label_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2235 "ml/parser.mly"
                                                ( Ldot(_1, _3) )
# 11414 "ml/parser.ml"
               : 'label_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2238 "ml/parser.mly"
                                                ( Lident _1 )
# 11421 "ml/parser.ml"
               : 'type_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2239 "ml/parser.mly"
                                                ( Ldot(_1, _3) )
# 11429 "ml/parser.ml"
               : 'type_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2242 "ml/parser.mly"
                                                ( Lident _1 )
# 11436 "ml/parser.ml"
               : 'mod_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2243 "ml/parser.mly"
                                                ( Ldot(_1, _3) )
# 11444 "ml/parser.ml"
               : 'mod_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2246 "ml/parser.mly"
                                                ( Lident _1 )
# 11451 "ml/parser.ml"
               : 'mod_ext_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2247 "ml/parser.mly"
                                                ( Ldot(_1, _3) )
# 11459 "ml/parser.ml"
               : 'mod_ext_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'mod_ext_longident) in
    Obj.repr(
# 2248 "ml/parser.mly"
                                                      ( lapply _1 _3 )
# 11467 "ml/parser.ml"
               : 'mod_ext_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 2251 "ml/parser.mly"
                                                ( Lident _1 )
# 11474 "ml/parser.ml"
               : 'mty_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 2252 "ml/parser.mly"
                                                ( Ldot(_1, _3) )
# 11482 "ml/parser.ml"
               : 'mty_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2255 "ml/parser.mly"
                                                ( Lident _1 )
# 11489 "ml/parser.ml"
               : 'clty_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2256 "ml/parser.mly"
                                                ( Ldot(_1, _3) )
# 11497 "ml/parser.ml"
               : 'clty_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2259 "ml/parser.mly"
                                                ( Lident _1 )
# 11504 "ml/parser.ml"
               : 'class_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2260 "ml/parser.mly"
                                                ( Ldot(_1, _3) )
# 11512 "ml/parser.ml"
               : 'class_longident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 2269 "ml/parser.mly"
                                                ( _2 )
# 11519 "ml/parser.ml"
               : 'name_tag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2272 "ml/parser.mly"
                                                ( Nonrecursive )
# 11525 "ml/parser.ml"
               : 'rec_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2273 "ml/parser.mly"
                                                ( Recursive )
# 11531 "ml/parser.ml"
               : 'rec_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2276 "ml/parser.mly"
                                                ( Recursive )
# 11537 "ml/parser.ml"
               : 'nonrec_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2277 "ml/parser.mly"
                                                ( Nonrecursive )
# 11543 "ml/parser.ml"
               : 'nonrec_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2280 "ml/parser.mly"
                                                ( Upto )
# 11549 "ml/parser.ml"
               : 'direction_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2281 "ml/parser.mly"
                                                ( Downto )
# 11555 "ml/parser.ml"
               : 'direction_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2284 "ml/parser.mly"
                                                ( Public )
# 11561 "ml/parser.ml"
               : 'private_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2285 "ml/parser.mly"
                                                ( Private )
# 11567 "ml/parser.ml"
               : 'private_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2288 "ml/parser.mly"
                                                ( Immutable )
# 11573 "ml/parser.ml"
               : 'mutable_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2289 "ml/parser.mly"
                                                ( Mutable )
# 11579 "ml/parser.ml"
               : 'mutable_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2292 "ml/parser.mly"
                                                ( Concrete )
# 11585 "ml/parser.ml"
               : 'virtual_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2293 "ml/parser.mly"
                                                ( Virtual )
# 11591 "ml/parser.ml"
               : 'virtual_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2296 "ml/parser.mly"
                 ( Public, Concrete )
# 11597 "ml/parser.ml"
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
# 2297 "ml/parser.mly"
            ( Private, Concrete )
# 11603 "ml/parser.ml"
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
# 2298 "ml/parser.mly"
            ( Public, Virtual )
# 11609 "ml/parser.ml"
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
# 2299 "ml/parser.mly"
                    ( Private, Virtual )
# 11615 "ml/parser.ml"
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
# 2300 "ml/parser.mly"
                    ( Private, Virtual )
# 11621 "ml/parser.ml"
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
# 2303 "ml/parser.mly"
                                                ( Fresh )
# 11627 "ml/parser.ml"
               : 'override_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2304 "ml/parser.mly"
                                                ( Override )
# 11633 "ml/parser.ml"
               : 'override_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2307 "ml/parser.mly"
                                                ( () )
# 11639 "ml/parser.ml"
               : 'opt_bar))
; (fun __caml_parser_env ->
    Obj.repr(
# 2308 "ml/parser.mly"
                                                ( () )
# 11645 "ml/parser.ml"
               : 'opt_bar))
; (fun __caml_parser_env ->
    Obj.repr(
# 2311 "ml/parser.mly"
                                                ( () )
# 11651 "ml/parser.ml"
               : 'opt_semi))
; (fun __caml_parser_env ->
    Obj.repr(
# 2312 "ml/parser.mly"
                                                ( () )
# 11657 "ml/parser.ml"
               : 'opt_semi))
; (fun __caml_parser_env ->
    Obj.repr(
# 2315 "ml/parser.mly"
                                                ( "-" )
# 11663 "ml/parser.ml"
               : 'subtractive))
; (fun __caml_parser_env ->
    Obj.repr(
# 2316 "ml/parser.mly"
                                                ( "-." )
# 11669 "ml/parser.ml"
               : 'subtractive))
; (fun __caml_parser_env ->
    Obj.repr(
# 2319 "ml/parser.mly"
                                                ( "+" )
# 11675 "ml/parser.ml"
               : 'additive))
; (fun __caml_parser_env ->
    Obj.repr(
# 2320 "ml/parser.mly"
                                                ( "+." )
# 11681 "ml/parser.ml"
               : 'additive))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2326 "ml/parser.mly"
           ( _1 )
# 11688 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2327 "ml/parser.mly"
           ( _1 )
# 11695 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2328 "ml/parser.mly"
        ( "and" )
# 11701 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2329 "ml/parser.mly"
       ( "as" )
# 11707 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2330 "ml/parser.mly"
           ( "assert" )
# 11713 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2331 "ml/parser.mly"
          ( "begin" )
# 11719 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2332 "ml/parser.mly"
          ( "class" )
# 11725 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2333 "ml/parser.mly"
               ( "constraint" )
# 11731 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2334 "ml/parser.mly"
       ( "do" )
# 11737 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2335 "ml/parser.mly"
         ( "done" )
# 11743 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2336 "ml/parser.mly"
           ( "downto" )
# 11749 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2337 "ml/parser.mly"
         ( "else" )
# 11755 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2338 "ml/parser.mly"
        ( "end" )
# 11761 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2339 "ml/parser.mly"
              ( "exception" )
# 11767 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2340 "ml/parser.mly"
             ( "external" )
# 11773 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2341 "ml/parser.mly"
          ( "false" )
# 11779 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2342 "ml/parser.mly"
        ( "for" )
# 11785 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2343 "ml/parser.mly"
        ( "fun" )
# 11791 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2344 "ml/parser.mly"
             ( "function" )
# 11797 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2345 "ml/parser.mly"
            ( "functor" )
# 11803 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2346 "ml/parser.mly"
       ( "if" )
# 11809 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2347 "ml/parser.mly"
       ( "in" )
# 11815 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2348 "ml/parser.mly"
            ( "include" )
# 11821 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2349 "ml/parser.mly"
            ( "inherit" )
# 11827 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2350 "ml/parser.mly"
                ( "initializer" )
# 11833 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2351 "ml/parser.mly"
         ( "lazy" )
# 11839 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2352 "ml/parser.mly"
        ( "let" )
# 11845 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2353 "ml/parser.mly"
          ( "match" )
# 11851 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2354 "ml/parser.mly"
           ( "method" )
# 11857 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2355 "ml/parser.mly"
           ( "module" )
# 11863 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2356 "ml/parser.mly"
            ( "mutable" )
# 11869 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2357 "ml/parser.mly"
        ( "new" )
# 11875 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2358 "ml/parser.mly"
           ( "nonrec" )
# 11881 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2359 "ml/parser.mly"
           ( "object" )
# 11887 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2360 "ml/parser.mly"
       ( "of" )
# 11893 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2361 "ml/parser.mly"
         ( "open" )
# 11899 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2362 "ml/parser.mly"
       ( "or" )
# 11905 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2363 "ml/parser.mly"
            ( "private" )
# 11911 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2364 "ml/parser.mly"
        ( "rec" )
# 11917 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2365 "ml/parser.mly"
        ( "sig" )
# 11923 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2366 "ml/parser.mly"
           ( "struct" )
# 11929 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2367 "ml/parser.mly"
         ( "then" )
# 11935 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2368 "ml/parser.mly"
       ( "to" )
# 11941 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2369 "ml/parser.mly"
         ( "true" )
# 11947 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2370 "ml/parser.mly"
        ( "try" )
# 11953 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2371 "ml/parser.mly"
         ( "type" )
# 11959 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2372 "ml/parser.mly"
        ( "val" )
# 11965 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2373 "ml/parser.mly"
            ( "virtual" )
# 11971 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2374 "ml/parser.mly"
         ( "when" )
# 11977 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2375 "ml/parser.mly"
          ( "while" )
# 11983 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2376 "ml/parser.mly"
         ( "with" )
# 11989 "ml/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'single_attr_id) in
    Obj.repr(
# 2381 "ml/parser.mly"
                   ( mkloc _1 (symbol_rloc()) )
# 11996 "ml/parser.ml"
               : 'attr_id))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'single_attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attr_id) in
    Obj.repr(
# 2382 "ml/parser.mly"
                               ( mkloc (_1 ^ "." ^ _3.txt) (symbol_rloc()))
# 12004 "ml/parser.ml"
               : 'attr_id))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
# 2385 "ml/parser.mly"
                                      ( (_2, _3) )
# 12012 "ml/parser.ml"
               : 'attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
# 2388 "ml/parser.mly"
                                        ( (_2, _3) )
# 12020 "ml/parser.ml"
               : 'post_item_attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
# 2391 "ml/parser.mly"
                                          ( (_2, _3) )
# 12028 "ml/parser.ml"
               : 'floating_attribute))
; (fun __caml_parser_env ->
    Obj.repr(
# 2394 "ml/parser.mly"
                 ( [] )
# 12034 "ml/parser.ml"
               : 'post_item_attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'post_item_attribute) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 2395 "ml/parser.mly"
                                             ( _1 :: _2 )
# 12042 "ml/parser.ml"
               : 'post_item_attributes))
; (fun __caml_parser_env ->
    Obj.repr(
# 2398 "ml/parser.mly"
               ( [] )
# 12048 "ml/parser.ml"
               : 'attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'attribute) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 2399 "ml/parser.mly"
                         ( _1 :: _2 )
# 12056 "ml/parser.ml"
               : 'attributes))
; (fun __caml_parser_env ->
    Obj.repr(
# 2402 "ml/parser.mly"
                 ( None, [] )
# 12062 "ml/parser.ml"
               : 'ext_attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'attribute) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 2403 "ml/parser.mly"
                         ( None, _1 :: _2 )
# 12070 "ml/parser.ml"
               : 'ext_attributes))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 2404 "ml/parser.mly"
                               ( Some _2, _3 )
# 12078 "ml/parser.ml"
               : 'ext_attributes))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
# 2407 "ml/parser.mly"
                                           ( (_2, _3) )
# 12086 "ml/parser.ml"
               : 'extension))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
# 2410 "ml/parser.mly"
                                                  ( (_2, _3) )
# 12094 "ml/parser.ml"
               : 'item_extension))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'structure) in
    Obj.repr(
# 2413 "ml/parser.mly"
              ( PStr _1 )
# 12101 "ml/parser.ml"
               : 'payload))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'signature) in
    Obj.repr(
# 2414 "ml/parser.mly"
                    ( PSig _2 )
# 12108 "ml/parser.ml"
               : 'payload))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 2415 "ml/parser.mly"
                    ( PTyp _2 )
# 12115 "ml/parser.ml"
               : 'payload))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 2416 "ml/parser.mly"
                     ( PPat (_2, None) )
# 12122 "ml/parser.ml"
               : 'payload))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 2417 "ml/parser.mly"
                                   ( PPat (_2, Some _4) )
# 12130 "ml/parser.ml"
               : 'payload))
(* Entry implementation *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry interface *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry parse_core_type *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry parse_expression *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry parse_pattern *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
|]
let yytables =
  { Parsing.actions=yyact;
    Parsing.transl_const=yytransl_const;
    Parsing.transl_block=yytransl_block;
    Parsing.lhs=yylhs;
    Parsing.len=yylen;
    Parsing.defred=yydefred;
    Parsing.dgoto=yydgoto;
    Parsing.sindex=yysindex;
    Parsing.rindex=yyrindex;
    Parsing.gindex=yygindex;
    Parsing.tablesize=yytablesize;
    Parsing.table=yytable;
    Parsing.check=yycheck;
    Parsing.error_function=parse_error;
    Parsing.names_const=yynames_const;
    Parsing.names_block=yynames_block }
let implementation (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 1 lexfun lexbuf : Parsetree.structure)
let interface (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 2 lexfun lexbuf : Parsetree.signature)
let parse_core_type (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 3 lexfun lexbuf : Parsetree.core_type)
let parse_expression (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 4 lexfun lexbuf : Parsetree.expression)
let parse_pattern (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 5 lexfun lexbuf : Parsetree.pattern)
;;

end
module Rescript_cpp : sig 
#1 "rescript_cpp.mli"
(* Copyright (C) 2021- Hongbo Zhang, Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val at_bol : Lexing.lexbuf -> bool

val interpret_directive :
  Lexing.lexbuf ->
  cont:(Lexing.lexbuf -> Parser.token) ->
  token_with_comments:(Lexing.lexbuf -> Parser.token) ->
  Parser.token

val eof_check : Lexing.lexbuf -> unit

val init : unit -> unit

val check_sharp_look_ahead : (unit -> Parser.token) -> Parser.token

(* Methods below are used for cpp, they are not needed by the compiler patches*)
val remove_directive_built_in_value : string -> unit

val replace_directive_string : string -> string -> unit

val replace_directive_bool : string -> bool -> unit

val define_key_value : string -> string -> bool
(** @return false means failed to define *)

val list_variables : Format.formatter -> unit

val filter_directive_from_lexbuf :
  Lexing.lexbuf ->
  token_with_comments:(Lexing.lexbuf -> Parser.token) ->
  (int * int) list

end = struct
#1 "rescript_cpp.ml"
(* Copyright (C) 2021- Hongbo Zhang, Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type directive_type =
  | Dir_type_bool
  | Dir_type_float
  | Dir_type_int
  | Dir_type_string
  | Dir_type_null

type pp_error =
  | Unterminated_paren_in_conditional
  | Unterminated_if
  | Unterminated_else
  | Unexpected_token_in_conditional
  | Expect_hash_then_in_conditional
  | Illegal_semver of string
  | Unexpected_directive
  | Conditional_expr_expected_type of directive_type * directive_type

exception Pp_error of pp_error * Location.t

type directive_value =
  | Dir_bool of bool
  | Dir_float of float
  | Dir_int of int
  | Dir_string of string
  | Dir_null

let type_of_directive x =
  match x with
  | Dir_bool _ -> Dir_type_bool
  | Dir_float _ -> Dir_type_float
  | Dir_int _ -> Dir_type_int
  | Dir_string _ -> Dir_type_string
  | Dir_null -> Dir_type_null

let string_of_type_directive x =
  match x with
  | Dir_type_bool -> "bool"
  | Dir_type_float -> "float"
  | Dir_type_int -> "int"
  | Dir_type_string -> "string"
  | Dir_type_null -> "null"

let prepare_pp_error loc = function
  | Unterminated_if -> Location.errorf ~loc "#if not terminated"
  | Unterminated_else -> Location.errorf ~loc "#else not terminated"
  | Unexpected_directive -> Location.errorf ~loc "Unexpected directive"
  | Unexpected_token_in_conditional ->
      Location.errorf ~loc "Unexpected token in conditional predicate"
  | Unterminated_paren_in_conditional ->
      Location.errorf ~loc "Unterminated parens in conditional predicate"
  | Expect_hash_then_in_conditional ->
      Location.errorf ~loc "Expect `then` after conditional predicate"
  | Conditional_expr_expected_type (a, b) ->
      Location.errorf ~loc "Conditional expression type mismatch (%s,%s)"
        (string_of_type_directive a)
        (string_of_type_directive b)
  | Illegal_semver s ->
      Location.errorf ~loc "Illegal semantic version string %s" s

let () =
  Location.register_error_of_exn (function
    | Pp_error (err, loc) -> Some (prepare_pp_error loc err)
    | _ -> None)

let assert_same_type lexbuf x y =
  let lhs = type_of_directive x in
  let rhs = type_of_directive y in
  if lhs <> rhs then
    raise
      (Pp_error (Conditional_expr_expected_type (lhs, rhs), Location.curr lexbuf))
  else y

let directive_built_in_values = Hashtbl.create 51

let replace_directive_built_in_value k v =
  Hashtbl.replace directive_built_in_values k v

let remove_directive_built_in_value k =
  Hashtbl.replace directive_built_in_values k Dir_null

let replace_directive_bool k v =
  Hashtbl.replace directive_built_in_values k (Dir_bool v)

let replace_directive_string k v =
  Hashtbl.replace directive_built_in_values k (Dir_string v)

let () =
  (* Note we use {!Config} instead of {!Sys} becasue
     we want to overwrite in some cases with the
     same stdlib
  *)
  let version = Config.version (* so that it can be overridden*) in
  replace_directive_built_in_value "OCAML_VERSION" (Dir_string version);
  replace_directive_built_in_value "OS_TYPE" (Dir_string Sys.os_type)

let find_directive_built_in_value k = Hashtbl.find directive_built_in_values k

let iter_directive_built_in_value f = Hashtbl.iter f directive_built_in_values
(* let iter_directive_built_in_value f = Hashtbl.iter f directive_built_in_values *)

(*
     {[
       # semver 0 "12";;
       - : int * int * int * string = (12, 0, 0, "");;
       # semver 0 "12.3";;
       - : int * int * int * string = (12, 3, 0, "");;
         semver 0 "12.3.10";;
       - : int * int * int * string = (12, 3, 10, "");;
       # semver 0 "12.3.10+x";;
       - : int * int * int * string = (12, 3, 10, "+x")
     ]}
  *)
let zero = Char.code '0'

let dot = Char.code '.'

let semantic_version_parse str start last_index =
  let rec aux start acc last_index =
    if start <= last_index then
      let c = Char.code (String.unsafe_get str start) in
      if c = dot then (acc, start + 1) (* consume [4.] instead of [4]*)
      else
        let v = c - zero in
        if v >= 0 && v <= 9 then aux (start + 1) ((acc * 10) + v) last_index
        else (acc, start)
    else (acc, start)
  in
  let major, major_end = aux start 0 last_index in
  let minor, minor_end = aux major_end 0 last_index in
  let patch, patch_end = aux minor_end 0 last_index in
  let additional = String.sub str patch_end (last_index - patch_end + 1) in
  ((major, minor, patch), additional)

(** 
     {[
       semver Location.none "1.2.3" "~1.3.0" = false;;
       semver Location.none "1.2.3" "^1.3.0" = true ;;
       semver Location.none "1.2.3" ">1.3.0" = false ;;
       semver Location.none "1.2.3" ">=1.3.0" = false ;;
       semver Location.none "1.2.3" "<1.3.0" = true ;;
       semver Location.none "1.2.3" "<=1.3.0" = true ;;
     ]}
  *)
let semver loc lhs str =
  let last_index = String.length str - 1 in
  if last_index < 0 then raise (Pp_error (Illegal_semver str, loc))
  else
    let pred, (((major, minor, _patch) as version), _) =
      let v = String.unsafe_get str 0 in
      match v with
      | '>' ->
          if last_index = 0 then raise (Pp_error (Illegal_semver str, loc))
          else if String.unsafe_get str 1 = '=' then
            (`Ge, semantic_version_parse str 2 last_index)
          else (`Gt, semantic_version_parse str 1 last_index)
      | '<' ->
          if last_index = 0 then raise (Pp_error (Illegal_semver str, loc))
          else if String.unsafe_get str 1 = '=' then
            (`Le, semantic_version_parse str 2 last_index)
          else (`Lt, semantic_version_parse str 1 last_index)
      | '^' -> (`Compatible, semantic_version_parse str 1 last_index)
      | '~' -> (`Approximate, semantic_version_parse str 1 last_index)
      | _ -> (`Exact, semantic_version_parse str 0 last_index)
    in
    let ((l_major, l_minor, _l_patch) as lversion), _ =
      semantic_version_parse lhs 0 (String.length lhs - 1)
    in
    match pred with
    | `Ge -> lversion >= version
    | `Gt -> lversion > version
    | `Le -> lversion <= version
    | `Lt -> lversion < version
    | `Approximate -> major = l_major && minor = l_minor
    | `Compatible -> major = l_major
    | `Exact -> lversion = version

let pp_directive_value fmt (x : directive_value) =
  match x with
  | Dir_bool b -> Format.pp_print_bool fmt b
  | Dir_int b -> Format.pp_print_int fmt b
  | Dir_float b -> Format.pp_print_float fmt b
  | Dir_string s -> Format.fprintf fmt "%S" s
  | Dir_null -> Format.pp_print_string fmt "null"

let list_variables fmt =
  iter_directive_built_in_value (fun s dir_value ->
      Format.fprintf fmt "@[%s@ %a@]@." s pp_directive_value dir_value)

let defined str =
  match find_directive_built_in_value str with
  | Dir_null -> false
  | _ -> true
  | exception _ -> (
      try
        ignore @@ Sys.getenv str;
        true
      with _ -> false)

let query _loc str =
  match find_directive_built_in_value str with
  | Dir_null -> Dir_bool false
  | v -> v
  | exception Not_found -> (
      match Sys.getenv str with
      | v -> (
          try Dir_bool (bool_of_string v)
          with _ -> (
            try Dir_int (int_of_string v)
            with _ -> (
              try Dir_float (float_of_string v) with _ -> Dir_string v)))
      | exception Not_found -> Dir_bool false)

let define_key_value key v =
  if String.length key > 0 && Char.uppercase_ascii key.[0] = key.[0] then (
    replace_directive_built_in_value key
      (* NEED Sync up across {!lexer.mll} {!bspp.ml} and here,
         TODO: put it in {!lexer.mll}
      *)
      (try Dir_bool (bool_of_string v)
       with _ -> (
         try Dir_int (int_of_string v)
         with _ -> (
           try Dir_float (float_of_string v) with _ -> Dir_string v)));
    true)
  else false

let cvt_int_literal s = -int_of_string ("-" ^ s)

let value_of_token loc (t : Parser.token) =
  match t with
  | INT (i, None) -> Dir_int (cvt_int_literal i)
  | STRING (s, _) -> Dir_string s
  | FLOAT (s, None) -> Dir_float (float_of_string s)
  | TRUE -> Dir_bool true
  | FALSE -> Dir_bool false
  | UIDENT s -> query loc s
  | _ -> raise (Pp_error (Unexpected_token_in_conditional, loc))

let directive_parse (token_with_comments : Lexing.lexbuf -> Parser.token) lexbuf
    =
  let look_ahead = ref None in
  let token () : Parser.token =
    let v = !look_ahead in
    match v with
    | Some v ->
        look_ahead := None;
        v
    | None ->
        let rec skip () =
          match token_with_comments lexbuf with
          | COMMENT _ | DOCSTRING _ -> skip ()
          | EOF -> raise (Pp_error (Unterminated_if, Location.curr lexbuf))
          | t -> t
        in
        skip ()
  in
  let push e =
    (* INVARIANT: only look at most one token *)
    assert (!look_ahead = None);
    look_ahead := Some e
  in
  let rec token_op calc ~no lhs =
    match token () with
    | (LESS | GREATER | INFIXOP0 "<=" | INFIXOP0 ">=" | EQUAL | INFIXOP0 "<>")
      as op ->
        let f =
          match op with
          | LESS -> ( < )
          | GREATER -> ( > )
          | INFIXOP0 "<=" -> ( <= )
          | EQUAL -> ( = )
          | INFIXOP0 "<>" -> ( <> )
          | _ -> assert false
        in
        let curr_loc = Location.curr lexbuf in
        let rhs = value_of_token curr_loc (token ()) in
        (not calc) || f lhs (assert_same_type lexbuf lhs rhs)
    | INFIXOP0 "=~" -> (
        (not calc)
        ||
        match lhs with
        | Dir_string s -> (
            let curr_loc = Location.curr lexbuf in
            let rhs = value_of_token curr_loc (token ()) in
            match rhs with
            | Dir_string rhs -> semver curr_loc s rhs
            | _ ->
                raise
                  (Pp_error
                     ( Conditional_expr_expected_type
                         (Dir_type_string, type_of_directive lhs),
                       Location.curr lexbuf )))
        | _ ->
            raise
              (Pp_error
                 ( Conditional_expr_expected_type
                     (Dir_type_string, type_of_directive lhs),
                   Location.curr lexbuf )))
    | e -> no e
  and parse_or calc : bool = parse_or_aux calc (parse_and calc)
  and (* a || (b || (c || d))*)
      parse_or_aux calc v : bool =
    (* let l = v  in *)
    match token () with
    | BARBAR ->
        let b = parse_or (calc && not v) in
        v || b
    | e ->
        push e;
        v
  and parse_and calc = parse_and_aux calc (parse_relation calc)
  and parse_and_aux calc v =
    (* a && (b && (c && d)) *)
    (* let l = v  in *)
    match token () with
    | AMPERAMPER ->
        let b = parse_and (calc && v) in
        v && b
    | e ->
        push e;
        v
  and parse_relation (calc : bool) : bool =
    let curr_token = token () in
    let curr_loc = Location.curr lexbuf in
    match curr_token with
    | TRUE -> true
    | FALSE -> false
    | UIDENT v ->
        let value_v = query curr_loc v in
        token_op calc
          ~no:(fun e ->
            push e;
            match value_v with
            | Dir_bool b -> b
            | _ ->
                let ty = type_of_directive value_v in
                raise
                  (Pp_error
                     ( Conditional_expr_expected_type (Dir_type_bool, ty),
                       curr_loc )))
          value_v
    | INT (v, None) ->
        let num_v = cvt_int_literal v in
        token_op calc
          ~no:(fun e ->
            push e;
            num_v <> 0)
          (Dir_int num_v)
    | FLOAT (v, None) ->
        token_op calc
          ~no:(fun _e ->
            raise
              (Pp_error
                 ( Conditional_expr_expected_type (Dir_type_bool, Dir_type_float),
                   curr_loc )))
          (Dir_float (float_of_string v))
    | STRING (v, _) ->
        token_op calc
          ~no:(fun _e ->
            raise
              (Pp_error
                 ( Conditional_expr_expected_type
                     (Dir_type_bool, Dir_type_string),
                   curr_loc )))
          (Dir_string v)
    | LIDENT (("defined" | "undefined") as r) -> (
        let t = token () in
        let loc = Location.curr lexbuf in
        match t with
        | UIDENT s ->
            (not calc) || if r.[0] = 'u' then not @@ defined s else defined s
        | _ -> raise (Pp_error (Unexpected_token_in_conditional, loc)))
    | LPAREN -> (
        let v = parse_or calc in
        match token () with
        | RPAREN -> v
        | _ ->
            raise
              (Pp_error (Unterminated_paren_in_conditional, Location.curr lexbuf))
        )
    | _ -> raise (Pp_error (Unexpected_token_in_conditional, curr_loc))
  in
  let v = parse_or true in
  match token () with
  | THEN | EOL -> v
  | _ ->
      raise (Pp_error (Expect_hash_then_in_conditional, Location.curr lexbuf))

type dir_conditional = Dir_if_true | Dir_if_false | Dir_out

(* let string_of_dir_conditional (x : dir_conditional) = *)
(*   match x with  *)
(*   | Dir_if_true -> "Dir_if_true" *)
(*   | Dir_if_false -> "Dir_if_false" *)
(*   | Dir_out -> "Dir_out" *)

let if_then_else = ref Dir_out

(* store the token after hash, [# token]
   when we see `#if` we do the processing immediately
   when we see #method, we produce `HASH` token and save `method`
   token so that the next lexing produce the right one.
*)
let sharp_look_ahead = ref None

let update_if_then_else v =
  (* Format.fprintf Format.err_formatter "@[update %s \n@]@." (string_of_dir_conditional v); *)
  if_then_else := v

let at_bol lexbuf =
  let pos = Lexing.lexeme_start_p lexbuf in
  pos.pos_cnum = pos.pos_bol

(* skip to #else | #end | #elif *)
let rec skip_from_if_false (token_with_comments : Lexing.lexbuf -> Parser.token)
    cont lexbuf =
  let token = token_with_comments lexbuf in
  if token = EOF then raise (Pp_error (Unterminated_if, Location.curr lexbuf))
  else if token = HASH && at_bol lexbuf then
    let token = token_with_comments lexbuf in
    match token with
    | END | LIDENT "endif" ->
        update_if_then_else Dir_out;
        cont lexbuf
    | ELSE ->
        update_if_then_else Dir_if_false;
        cont lexbuf
    | IF -> raise (Pp_error (Unexpected_directive, Location.curr lexbuf))
    | LIDENT "elif" when directive_parse token_with_comments lexbuf ->
        update_if_then_else Dir_if_true;
        cont lexbuf
    | _ -> skip_from_if_false token_with_comments cont lexbuf
  else skip_from_if_false token_with_comments cont lexbuf

let interpret_directive_cont lexbuf ~cont
    ~(token_with_comments : Lexing.lexbuf -> Parser.token) look_ahead =
  (* current state *)
  let if_then_else = !if_then_else in
  match (token_with_comments lexbuf, if_then_else) with
  | IF, Dir_out ->
      if directive_parse token_with_comments lexbuf then (
        update_if_then_else Dir_if_true (* Next state: ELSE *);
        cont lexbuf)
      else skip_from_if_false token_with_comments cont lexbuf
  | LIDENT (("ifndef" | "ifdef") as s), Dir_out ->
      let rec token () =
        match token_with_comments lexbuf with
        | COMMENT _ | DOCSTRING _ -> token ()
        | EOF -> raise (Pp_error (Unterminated_if, Location.curr lexbuf))
        | t -> t
      in
      let t0 = token () in
      let t =
        match t0 with
        | UIDENT t -> t
        | _ ->
            raise
              (Pp_error (Unexpected_token_in_conditional, Location.curr lexbuf))
      in
      let t1 = token () in
      (match t1 with
      | THEN | EOL -> ()
      | _ ->
          raise
            (Pp_error (Expect_hash_then_in_conditional, Location.curr lexbuf)));
      let boolean = defined t = (s = "ifdef") in
      if boolean then (
        update_if_then_else Dir_if_true (* Next state: ELSE *);
        cont lexbuf)
      else skip_from_if_false token_with_comments cont lexbuf
  | (IF | LIDENT "ifndef" | LIDENT "ifdef"), (Dir_if_false | Dir_if_true) ->
      raise (Pp_error (Unexpected_directive, Location.curr lexbuf))
  | LIDENT "elif", (Dir_if_false | Dir_out) ->
      (* when the predicate is false, it will continue eating `elif` *)
      raise (Pp_error (Unexpected_directive, Location.curr lexbuf))
  | ((LIDENT "elif" | ELSE) as token), Dir_if_true ->
      (* looking for #end, however, it can not see #if anymore,
         we need do some validation *)
      let rec skip_from_if_true else_seen =
        let token = token_with_comments lexbuf in
        if token = EOF then
          raise (Pp_error (Unterminated_else, Location.curr lexbuf))
        else if token = HASH && at_bol lexbuf then
          let token = token_with_comments lexbuf in
          match token with
          | END | LIDENT "endif" ->
              update_if_then_else Dir_out;
              cont lexbuf
          | IF -> raise (Pp_error (Unexpected_directive, Location.curr lexbuf))
          | ELSE ->
              if else_seen then
                raise (Pp_error (Unexpected_directive, Location.curr lexbuf))
              else skip_from_if_true true
          | LIDENT "elif" when else_seen ->
              raise (Pp_error (Unexpected_directive, Location.curr lexbuf))
          | _ -> skip_from_if_true else_seen
        else skip_from_if_true else_seen
      in
      skip_from_if_true (token = ELSE)
  | ELSE, Dir_if_false | ELSE, Dir_out ->
      raise (Pp_error (Unexpected_directive, Location.curr lexbuf))
  | (END | LIDENT "endif"), (Dir_if_false | Dir_if_true) ->
      update_if_then_else Dir_out;
      cont lexbuf
  | (END | LIDENT "endif"), Dir_out ->
      raise (Pp_error (Unexpected_directive, Location.curr lexbuf))
  | token, (Dir_if_true | Dir_if_false | Dir_out) -> look_ahead token

let interpret_directive lexbuf ~cont ~token_with_comments : Parser.token =
  interpret_directive_cont lexbuf ~cont ~token_with_comments
    (fun (token : 'a) : 'a ->
      sharp_look_ahead := Some token;
      HASH)

let eof_check lexbuf =
  if !if_then_else <> Dir_out then
    if !if_then_else = Dir_if_true then
      raise (Pp_error (Unterminated_if, Location.curr lexbuf))
    else raise (Pp_error (Unterminated_else, Location.curr lexbuf))

let init () =
  sharp_look_ahead := None;
  update_if_then_else Dir_out

let check_sharp_look_ahead action : Parser.token =
  match !sharp_look_ahead with
  | None -> action ()
  | Some token ->
      sharp_look_ahead := None;
      token

let rec filter_directive ~(token_with_comments : Lexing.lexbuf -> Parser.token)
    pos acc lexbuf : (int * int) list =
  match token_with_comments lexbuf with
  | HASH when at_bol lexbuf ->
      (* ^[start_pos]#if ... #then^[end_pos] *)
      let start_pos = Lexing.lexeme_start lexbuf in
      interpret_directive_cont lexbuf
        ~cont:(fun lexbuf ->
          filter_directive (Lexing.lexeme_end lexbuf) ~token_with_comments
            ((pos, start_pos) :: acc) lexbuf)
        ~token_with_comments
        (fun _token -> filter_directive pos acc lexbuf ~token_with_comments)
  | EOF -> (pos, Lexing.lexeme_end lexbuf) :: acc
  | _ -> filter_directive ~token_with_comments pos acc lexbuf

let filter_directive_from_lexbuf lexbuf ~token_with_comments =
  List.rev (filter_directive 0 [] lexbuf ~token_with_comments)

end
module Lexer : sig 
#1 "lexer.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* The lexical analyzer *)

val init : unit -> unit
val token: Lexing.lexbuf -> Parser.token
val skip_hash_bang: Lexing.lexbuf -> unit


type error =
  | Illegal_character of char
  | Illegal_escape of string
  | Unterminated_comment of Location.t
  | Unterminated_string
  | Unterminated_string_in_comment of Location.t * Location.t
  | Keyword_as_label of string
  | Invalid_literal of string
  | Invalid_directive of string * string option
                          
;;

exception Error of error * Location.t



val in_comment : unit -> bool;;
val in_string : unit -> bool;;


val print_warnings : bool ref
val handle_docstrings: bool ref
val comments : unit -> (string * Location.t) list
val token_with_comments : Lexing.lexbuf -> Parser.token

(*
  [set_preprocessor init preprocessor] registers [init] as the function
to call to initialize the preprocessor when the lexer is initialized,
and [preprocessor] a function that is called when a new token is needed
by the parser, as [preprocessor lexer lexbuf] where [lexer] is the
lexing function.

When a preprocessor is configured by calling [set_preprocessor], the lexer
changes its behavior to accept backslash-newline as a token-separating blank.
*)

val set_preprocessor :
  (unit -> unit) ->
  ((Lexing.lexbuf -> Parser.token) -> Lexing.lexbuf -> Parser.token) ->
  unit




end = struct
#1 "lexer.ml"
# 18 "ml/lexer.mll"
 
open Lexing
open Misc
open Parser

type error =
  | Illegal_character of char
  | Illegal_escape of string
  | Unterminated_comment of Location.t
  | Unterminated_string
  | Unterminated_string_in_comment of Location.t * Location.t
  | Keyword_as_label of string
  | Invalid_literal of string
  | Invalid_directive of string * string option
;;

exception Error of error * Location.t;;

(* The table of keywords *)

let keyword_table =
  create_hashtable 149 [
    "and", AND;
    "as", AS;
    "assert", ASSERT;
    "begin", BEGIN;
    "class", CLASS;
    "constraint", CONSTRAINT;
    "do", DO;
    "done", DONE;
    "downto", DOWNTO;
    "else", ELSE;
    "end", END;
    "exception", EXCEPTION;
    "external", EXTERNAL;
    "false", FALSE;
    "for", FOR;
    "fun", FUN;
    "function", FUNCTION;
    "functor", FUNCTOR;
    "if", IF;
    "in", IN;
    "include", INCLUDE;
    "inherit", INHERIT;
    "initializer", INITIALIZER;
    "lazy", LAZY;
    "let", LET;
    "match", MATCH;
    "method", METHOD;
    "module", MODULE;
    "mutable", MUTABLE;
    "new", NEW;
    "nonrec", NONREC;
    "object", OBJECT;
    "of", OF;
    "open", OPEN;
    "or", OR;
(*  "parser", PARSER; *)
    "private", PRIVATE;
    "rec", REC;
    "sig", SIG;
    "struct", STRUCT;
    "then", THEN;
    "to", TO;
    "true", TRUE;
    "try", TRY;
    "type", TYPE;
    "val", VAL;
    "virtual", VIRTUAL;
    "when", WHEN;
    "while", WHILE;
    "with", WITH;

    "lor", INFIXOP3("lor"); (* Should be INFIXOP2 *)
    "lxor", INFIXOP3("lxor"); (* Should be INFIXOP2 *)
    "mod", INFIXOP3("mod");
    "land", INFIXOP3("land");
    "lsl", INFIXOP4("lsl");
    "lsr", INFIXOP4("lsr");
    "asr", INFIXOP4("asr")
]

(* To buffer string literals *)

let string_buffer = Buffer.create 256
let reset_string_buffer () = Buffer.reset string_buffer
let get_stored_string () = Buffer.contents string_buffer

let store_string_char c = Buffer.add_char string_buffer c
let store_string_utf_8_uchar u = Buffer.add_utf_8_uchar string_buffer u
let store_string s = Buffer.add_string string_buffer s
let store_lexeme lexbuf = store_string (Lexing.lexeme lexbuf)

(* To store the position of the beginning of a string and comment *)
let string_start_loc = ref Location.none;;
let comment_start_loc = ref [];;
let in_comment () = !comment_start_loc <> [];;
let is_in_string = ref false
let in_string () = !is_in_string
let print_warnings = ref true

(* Escaped chars are interpreted in strings unless they are in comments. *)
let store_escaped_char lexbuf c =
  if in_comment () then store_lexeme lexbuf else store_string_char c

let store_escaped_uchar lexbuf u =
  if in_comment () then store_lexeme lexbuf else store_string_utf_8_uchar u

let with_comment_buffer comment lexbuf =
  let start_loc = Location.curr lexbuf  in
  comment_start_loc := [start_loc];
  reset_string_buffer ();
  let end_loc = comment lexbuf in
  let s = get_stored_string () in
  reset_string_buffer ();
  let loc = { start_loc with Location.loc_end = end_loc.Location.loc_end } in
  s, loc

(* To translate escape sequences *)

let hex_digit_value d = (* assert (d in '0'..'9' 'a'..'f' 'A'..'F') *)
  let d = Char.code d in
  if d >= 97 then d - 87 else
  if d >= 65 then d - 55 else
  d - 48

let hex_num_value lexbuf ~first ~last =
  let rec loop acc i = match i > last with
  | true -> acc
  | false ->
      let value = hex_digit_value (Lexing.lexeme_char lexbuf i) in
      loop (16 * acc + value) (i + 1)
  in
  loop 0 first

let char_for_backslash = function
  | 'n' -> '\010'
  | 'r' -> '\013'
  | 'b' -> '\008'
  | 't' -> '\009'
  | c   -> c

let char_for_decimal_code lexbuf i =
  let c = 100 * (Char.code(Lexing.lexeme_char lexbuf i) - 48) +
           10 * (Char.code(Lexing.lexeme_char lexbuf (i+1)) - 48) +
                (Char.code(Lexing.lexeme_char lexbuf (i+2)) - 48) in
  if not (Uchar.is_valid c ) then
    if in_comment ()
    then 'x'
    else raise (Error(Illegal_escape (Lexing.lexeme lexbuf),
                      Location.curr lexbuf))
  else (Obj.magic (c : int) : char)

let char_for_octal_code lexbuf i =
  let c = 64 * (Char.code(Lexing.lexeme_char lexbuf i) - 48) +
           8 * (Char.code(Lexing.lexeme_char lexbuf (i+1)) - 48) +
               (Char.code(Lexing.lexeme_char lexbuf (i+2)) - 48) in
  Char.chr c

let char_for_hexadecimal_code lexbuf i =
  let byte = hex_num_value lexbuf ~first:i ~last:(i+1) in
  Char.chr byte

let uchar_for_uchar_escape lexbuf =
  let err e =
    raise
      (Error (Illegal_escape (Lexing.lexeme lexbuf ^ e), Location.curr lexbuf))
  in
  let len = Lexing.lexeme_end lexbuf - Lexing.lexeme_start lexbuf in
  let first = 3 (* skip opening \u{ *) in
  let last = len - 2 (* skip closing } *) in
  let digit_count = last - first + 1 in
  match digit_count > 6 with
  | true -> err ", too many digits, expected 1 to 6 hexadecimal digits"
  | false ->
      let cp = hex_num_value lexbuf ~first ~last in
      if Uchar.is_valid cp then Uchar.unsafe_of_int cp else
      err (", " ^ Printf.sprintf "%X" cp ^ " is not a Unicode scalar value")

(* recover the name from a LABEL or OPTLABEL token *)

let get_label_name lexbuf =
  let s = Lexing.lexeme lexbuf in
  let name = String.sub s 1 (String.length s - 2) in
  if Hashtbl.mem keyword_table name then
    raise (Error(Keyword_as_label name, Location.curr lexbuf));
  name
;;

(* Update the current location with file name and line number. *)

let update_loc lexbuf file line absolute chars =
  let pos = lexbuf.lex_curr_p in
  let new_file = match file with
                 | None -> pos.pos_fname
                 | Some s -> s
  in
  lexbuf.lex_curr_p <- { pos with
    pos_fname = new_file;
    pos_lnum = if absolute then line else pos.pos_lnum + line;
    pos_bol = pos.pos_cnum - chars;
  }
;;

let preprocessor = ref None

let escaped_newlines = ref false


let handle_docstrings = ref true
let comment_list = ref []

let add_comment com =
  comment_list := com :: !comment_list

let add_docstring_comment ds =
  let com =
    ("*" ^ Docstrings.docstring_body ds, Docstrings.docstring_loc ds)
  in
    add_comment com

let comments () = List.rev !comment_list

(* Error report *)

open Format

let report_error ppf = function
  | Illegal_character c ->
      fprintf ppf "Illegal character (%s)" (Char.escaped c)
  | Illegal_escape s ->
      fprintf ppf "Illegal backslash escape in string or character (%s)" s
  | Unterminated_comment _ ->
      fprintf ppf "Comment not terminated"
  | Unterminated_string ->
      fprintf ppf "String literal not terminated"
  | Unterminated_string_in_comment (_, loc) ->
      fprintf ppf "This comment contains an unterminated string literal@.\
                   %aString literal begins here"
              Location.print_error loc
  | Keyword_as_label kwd ->
      fprintf ppf "`%s' is a keyword, it cannot be used as label name" kwd
  | Invalid_literal s ->
      fprintf ppf "Invalid literal %s" s
  | Invalid_directive (dir, explanation) ->
      fprintf ppf "Invalid lexer directive %S" dir;
      begin match explanation with
        | None -> ()
        | Some expl -> fprintf ppf ": %s" expl
      end

let () =
  Location.register_error_of_exn
    (function
      | Error (err, loc) ->
          Some (Location.error_of_printer loc report_error err)
      | _ ->
          None
    )


# 264 "ml/lexer.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base =
   "\000\000\166\255\167\255\094\000\129\000\164\000\199\000\234\000\
    \013\001\190\255\048\001\085\001\198\255\041\001\124\001\159\001\
    \069\000\084\000\193\001\228\001\216\255\218\255\221\255\007\002\
    \102\002\137\002\087\000\125\000\167\002\240\255\251\002\079\003\
    \163\003\247\003\081\004\173\004\001\005\138\000\254\255\001\000\
    \005\000\255\255\006\000\007\000\091\005\121\005\250\255\205\005\
    \248\255\033\006\117\006\201\006\029\007\113\007\197\007\025\008\
    \109\008\193\008\021\009\105\009\129\000\189\009\017\010\101\010\
    \185\010\013\011\024\002\196\255\239\255\135\002\104\011\094\000\
    \095\000\011\000\238\255\237\255\232\255\138\011\164\000\034\002\
    \104\000\236\255\064\002\105\000\235\255\054\002\074\002\109\000\
    \234\255\177\011\110\000\233\255\118\000\228\255\127\000\227\255\
    \153\000\222\011\226\255\001\012\022\012\137\002\225\255\012\000\
    \013\000\241\000\020\001\017\000\225\255\018\000\051\012\086\012\
    \121\012\156\012\191\012\213\255\208\255\209\255\210\255\206\255\
    \226\012\114\000\089\000\199\255\200\255\201\255\097\000\186\255\
    \184\255\193\255\005\013\189\255\191\255\040\013\075\013\110\013\
    \145\013\125\004\243\255\244\255\186\000\245\255\141\001\143\013\
    \253\255\122\000\131\000\255\255\254\255\252\255\175\013\010\014\
    \159\000\164\000\195\000\251\255\250\255\249\255\044\014\154\002\
    \165\000\248\255\164\002\177\000\247\255\083\014\180\000\246\255\
    \220\000\142\001\245\255\246\255\247\255\221\000\154\014\255\255\
    \248\255\098\000\188\014\199\000\098\004\253\255\220\000\230\000\
    \255\000\173\004\252\255\155\003\239\003\251\255\227\014\250\255\
    \250\014\032\015\249\255\018\001\051\001\252\255\061\015\254\255\
    \255\255\034\001\035\001\253\255\090\015\203\000\206\000\012\001\
    \016\001\231\000\025\001\231\000\019\000\255\255";
  Lexing.lex_backtrk =
   "\255\255\255\255\255\255\086\000\085\000\082\000\081\000\074\000\
    \072\000\255\255\063\000\060\000\255\255\053\000\052\000\050\000\
    \048\000\044\000\041\000\077\000\255\255\255\255\255\255\032\000\
    \031\000\038\000\036\000\035\000\058\000\255\255\010\000\010\000\
    \009\000\008\000\006\000\004\000\003\000\002\000\255\255\089\000\
    \089\000\255\255\255\255\255\255\080\000\255\255\255\255\255\255\
    \255\255\014\000\014\000\012\000\011\000\014\000\011\000\011\000\
    \010\000\012\000\011\000\012\000\255\255\013\000\013\000\010\000\
    \010\000\012\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\023\000\023\000\023\000\
    \023\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\024\000\255\255\025\000\255\255\
    \026\000\084\000\255\255\087\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\033\000\083\000\
    \078\000\040\000\043\000\255\255\255\255\255\255\255\255\255\255\
    \051\000\070\000\067\000\255\255\255\255\255\255\068\000\255\255\
    \255\255\255\255\061\000\255\255\255\255\079\000\073\000\076\000\
    \075\000\255\255\255\255\255\255\012\000\255\255\012\000\012\000\
    \255\255\012\000\012\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\010\000\010\000\255\255\
    \255\255\007\000\007\000\007\000\007\000\255\255\001\000\007\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\003\000\255\255\
    \255\255\003\000\255\255\255\255\255\255\002\000\255\255\255\255\
    \001\000\255\255\255\255\255\255\255\255\255\255";
  Lexing.lex_default =
   "\001\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\255\255\255\255\000\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\000\000\000\000\255\255\
    \255\255\255\255\255\255\071\000\255\255\000\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\
    \255\255\000\000\255\255\255\255\255\255\255\255\000\000\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\000\000\000\000\255\255\076\000\255\255\
    \255\255\255\255\000\000\000\000\000\000\255\255\255\255\255\255\
    \255\255\000\000\255\255\255\255\000\000\255\255\255\255\255\255\
    \000\000\255\255\255\255\000\000\255\255\000\000\255\255\000\000\
    \255\255\255\255\000\000\255\255\104\000\255\255\000\000\255\255\
    \104\000\105\000\104\000\107\000\000\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\000\000\000\000\000\000\000\000\000\000\
    \255\255\255\255\255\255\000\000\000\000\000\000\255\255\000\000\
    \000\000\000\000\255\255\000\000\000\000\255\255\255\255\255\255\
    \255\255\138\000\000\000\000\000\255\255\000\000\152\000\255\255\
    \000\000\255\255\255\255\000\000\000\000\000\000\255\255\255\255\
    \255\255\255\255\255\255\000\000\000\000\000\000\255\255\255\255\
    \255\255\000\000\255\255\255\255\000\000\255\255\255\255\000\000\
    \255\255\170\000\000\000\000\000\000\000\255\255\176\000\000\000\
    \000\000\255\255\255\255\255\255\255\255\000\000\255\255\255\255\
    \255\255\255\255\000\000\255\255\255\255\000\000\255\255\000\000\
    \255\255\255\255\000\000\255\255\197\000\000\000\255\255\000\000\
    \000\000\255\255\255\255\000\000\255\255\255\255\255\255\207\000\
    \210\000\255\255\210\000\255\255\255\255\000\000";
  Lexing.lex_trans =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\037\000\038\000\038\000\037\000\039\000\043\000\041\000\
    \041\000\038\000\042\000\042\000\043\000\072\000\102\000\102\000\
    \073\000\103\000\103\000\108\000\108\000\213\000\109\000\109\000\
    \037\000\008\000\029\000\024\000\006\000\004\000\023\000\027\000\
    \026\000\021\000\025\000\007\000\020\000\019\000\018\000\003\000\
    \031\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\017\000\016\000\015\000\014\000\010\000\034\000\
    \005\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\013\000\040\000\012\000\005\000\036\000\
    \022\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\028\000\011\000\009\000\035\000\003\000\
    \119\000\092\000\003\000\003\000\003\000\075\000\074\000\072\000\
    \003\000\003\000\073\000\003\000\003\000\003\000\118\000\081\000\
    \084\000\117\000\116\000\037\000\088\000\091\000\037\000\128\000\
    \003\000\126\000\003\000\003\000\003\000\003\000\003\000\093\000\
    \094\000\127\000\003\000\148\000\255\255\003\000\003\000\003\000\
    \095\000\096\000\037\000\003\000\003\000\147\000\003\000\003\000\
    \003\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\095\000\096\000\139\000\005\000\157\000\168\000\
    \005\000\005\000\005\000\156\000\161\000\153\000\005\000\005\000\
    \154\000\005\000\005\000\005\000\085\000\085\000\085\000\085\000\
    \164\000\070\000\003\000\167\000\003\000\192\000\005\000\003\000\
    \005\000\005\000\005\000\005\000\005\000\182\000\139\000\172\000\
    \006\000\168\000\195\000\006\000\006\000\006\000\206\000\207\000\
    \182\000\006\000\006\000\184\000\006\000\006\000\006\000\187\000\
    \187\000\187\000\187\000\102\000\182\000\003\000\103\000\003\000\
    \002\000\006\000\005\000\006\000\006\000\006\000\006\000\006\000\
    \211\000\182\000\212\000\111\000\184\000\255\255\111\000\111\000\
    \111\000\255\255\000\000\107\000\111\000\111\000\208\000\111\000\
    \136\000\111\000\209\000\000\000\172\000\106\000\102\000\195\000\
    \005\000\103\000\005\000\209\000\111\000\006\000\111\000\135\000\
    \111\000\111\000\111\000\000\000\200\000\200\000\133\000\202\000\
    \202\000\133\000\133\000\133\000\106\000\000\000\105\000\133\000\
    \133\000\000\000\133\000\133\000\133\000\200\000\000\000\000\000\
    \201\000\000\000\000\000\006\000\000\000\006\000\000\000\133\000\
    \111\000\133\000\134\000\133\000\133\000\133\000\121\000\000\000\
    \000\000\006\000\000\000\000\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\000\000\000\000\124\000\111\000\123\000\
    \111\000\122\000\006\000\133\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\000\000\000\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\000\000\255\255\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \000\000\133\000\000\000\133\000\000\000\132\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\000\000\153\000\
    \172\000\000\000\154\000\173\000\000\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\000\000\000\000\125\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\006\000\131\000\006\000\198\000\
    \175\000\000\000\129\000\006\000\155\000\000\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\120\000\006\000\006\000\000\000\
    \000\000\130\000\000\000\006\000\000\000\000\000\000\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\114\000\000\000\000\000\114\000\114\000\114\000\
    \000\000\151\000\174\000\114\000\114\000\000\000\114\000\115\000\
    \114\000\255\255\000\000\000\000\000\000\000\000\000\000\000\000\
    \006\000\000\000\006\000\114\000\000\000\006\000\114\000\114\000\
    \114\000\114\000\000\000\000\000\000\000\111\000\000\000\000\000\
    \111\000\111\000\111\000\000\000\255\255\000\000\111\000\111\000\
    \255\255\111\000\112\000\111\000\255\255\000\000\000\000\000\000\
    \000\000\255\255\000\000\006\000\000\000\006\000\111\000\114\000\
    \111\000\111\000\113\000\111\000\111\000\000\000\000\000\000\000\
    \006\000\000\000\000\000\006\000\006\000\110\000\000\000\000\000\
    \000\000\006\000\006\000\199\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\114\000\000\000\114\000\
    \000\000\006\000\111\000\006\000\006\000\006\000\006\000\006\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \065\000\065\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\082\000\082\000\000\000\000\000\000\000\000\000\
    \111\000\000\000\111\000\000\000\000\000\006\000\086\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\000\000\101\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\083\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\000\000\006\000\000\000\006\000\101\000\099\000\
    \000\000\099\000\099\000\099\000\099\000\255\255\171\000\000\000\
    \099\000\099\000\101\000\099\000\099\000\099\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \099\000\000\000\099\000\099\000\099\000\099\000\099\000\000\000\
    \000\000\101\000\003\000\000\000\000\000\003\000\003\000\003\000\
    \000\000\000\000\098\000\097\000\003\000\000\000\003\000\003\000\
    \003\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\003\000\099\000\003\000\003\000\003\000\
    \003\000\003\000\162\000\162\000\162\000\162\000\162\000\162\000\
    \162\000\162\000\162\000\162\000\163\000\163\000\163\000\163\000\
    \163\000\163\000\163\000\163\000\163\000\163\000\000\000\000\000\
    \000\000\000\000\099\000\067\000\099\000\000\000\069\000\003\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\000\000\068\000\000\000\003\000\069\000\003\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\049\000\068\000\000\000\000\000\000\000\000\000\
    \000\000\051\000\000\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\049\000\049\000\049\000\049\000\
    \050\000\049\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\000\000\000\000\
    \000\000\000\000\030\000\000\000\049\000\049\000\049\000\049\000\
    \050\000\049\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\049\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\051\000\000\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \049\000\053\000\049\000\049\000\050\000\049\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\054\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\055\000\
    \052\000\052\000\000\000\000\000\000\000\000\000\030\000\000\000\
    \049\000\053\000\049\000\049\000\050\000\049\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\054\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\055\000\
    \052\000\052\000\032\000\188\000\188\000\188\000\188\000\188\000\
    \188\000\188\000\188\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\000\000\000\000\
    \000\000\000\000\032\000\000\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\033\000\189\000\
    \189\000\189\000\189\000\189\000\189\000\189\000\189\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\000\000\000\000\000\000\000\000\033\000\000\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\044\000\000\000\000\000\044\000\044\000\044\000\
    \000\000\000\000\000\000\044\000\044\000\000\000\044\000\044\000\
    \044\000\000\000\000\000\000\000\000\000\000\000\000\000\139\000\
    \000\000\000\000\140\000\044\000\000\000\044\000\044\000\044\000\
    \044\000\044\000\185\000\185\000\185\000\185\000\185\000\185\000\
    \185\000\185\000\185\000\185\000\000\000\000\000\000\000\144\000\
    \000\000\000\000\000\000\000\000\142\000\146\000\000\000\145\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\044\000\
    \047\000\000\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\000\000\044\000\044\000\044\000\
    \000\000\044\000\044\000\044\000\000\000\000\000\000\000\044\000\
    \044\000\000\000\044\000\044\000\044\000\186\000\186\000\186\000\
    \186\000\186\000\186\000\186\000\186\000\186\000\186\000\044\000\
    \000\000\044\000\044\000\044\000\044\000\044\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \143\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\044\000\045\000\000\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \033\000\044\000\000\000\044\000\000\000\000\000\000\000\000\000\
    \000\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\000\000\000\000\000\000\000\000\
    \033\000\000\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\044\000\141\000\000\000\044\000\
    \044\000\044\000\000\000\000\000\000\000\044\000\044\000\000\000\
    \044\000\044\000\044\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\044\000\000\000\044\000\
    \044\000\044\000\044\000\044\000\000\000\000\000\000\000\000\000\
    \045\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\046\000\000\000\000\000\000\000\000\000\
    \000\000\044\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\000\000\000\000\000\000\044\000\
    \045\000\044\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\047\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\048\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \000\000\000\000\000\000\000\000\047\000\000\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \049\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\000\000\000\000\000\000\000\000\
    \049\000\000\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\000\000\000\000\000\000\
    \066\000\000\000\066\000\000\000\000\000\065\000\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \000\000\000\000\000\000\000\000\049\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\049\000\049\000\049\000\049\000\050\000\049\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\000\000\000\000\000\000\000\000\
    \051\000\000\000\049\000\049\000\049\000\049\000\050\000\049\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\049\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \000\000\000\000\000\000\000\000\049\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\064\000\064\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\000\000\000\000\000\000\000\000\
    \049\000\000\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\049\000\049\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \000\000\000\000\000\000\000\000\049\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\056\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \056\000\056\000\056\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\000\000\000\000\000\000\000\000\
    \049\000\000\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\057\000\000\000\056\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\058\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \000\000\000\000\000\000\000\000\056\000\000\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\058\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \049\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\062\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\000\000\000\000\000\000\000\000\
    \057\000\000\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\062\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\049\000\000\000\000\000\000\000\
    \060\000\000\000\060\000\000\000\000\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \000\000\000\000\000\000\000\000\049\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\000\000\000\000\000\000\000\000\
    \059\000\000\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\049\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \000\000\000\000\000\000\000\000\049\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\000\000\000\000\000\000\060\000\000\000\060\000\000\000\
    \000\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\000\000\000\000\000\000\000\000\
    \049\000\000\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\049\000\049\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \000\000\000\000\000\000\000\000\063\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \049\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\064\000\064\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\000\000\000\000\000\000\000\000\
    \064\000\000\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\049\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\065\000\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \000\000\000\000\000\000\000\000\065\000\000\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \080\000\000\000\080\000\000\000\000\000\000\000\000\000\080\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\089\000\080\000\000\000\000\000\000\000\
    \000\000\000\000\080\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\000\000\000\000\000\000\000\000\000\000\080\000\078\000\
    \000\000\000\000\080\000\000\000\080\000\000\000\000\000\000\000\
    \077\000\090\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\090\000\090\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\000\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\097\000\
    \000\000\000\000\097\000\097\000\097\000\000\000\000\000\000\000\
    \097\000\097\000\000\000\097\000\097\000\097\000\000\000\000\000\
    \000\000\000\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \097\000\000\000\097\000\097\000\097\000\097\000\097\000\106\000\
    \102\000\000\000\099\000\103\000\099\000\099\000\099\000\099\000\
    \000\000\000\000\000\000\099\000\099\000\000\000\099\000\099\000\
    \099\000\000\000\000\000\000\000\000\000\000\000\106\000\000\000\
    \105\000\000\000\000\000\099\000\097\000\099\000\099\000\099\000\
    \099\000\099\000\000\000\000\000\000\000\000\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \000\000\000\000\000\000\000\000\006\000\000\000\000\000\006\000\
    \006\000\006\000\097\000\000\000\097\000\006\000\006\000\099\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\000\000\000\000\
    \255\255\000\000\000\000\000\000\000\000\006\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\000\000\000\000\000\000\111\000\
    \000\000\000\000\111\000\111\000\111\000\099\000\000\000\099\000\
    \111\000\111\000\000\000\111\000\111\000\111\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \111\000\006\000\111\000\111\000\111\000\111\000\111\000\000\000\
    \000\000\000\000\111\000\000\000\000\000\111\000\111\000\111\000\
    \000\000\000\000\000\000\111\000\111\000\000\000\111\000\111\000\
    \111\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000\
    \000\000\006\000\000\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\000\000\000\000\000\000\111\000\000\000\000\000\
    \111\000\111\000\111\000\000\000\000\000\000\000\111\000\111\000\
    \000\000\111\000\111\000\111\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\111\000\000\000\111\000\000\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\000\000\000\000\000\000\
    \114\000\000\000\000\000\114\000\114\000\114\000\000\000\000\000\
    \000\000\114\000\114\000\000\000\114\000\114\000\114\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\111\000\000\000\111\000\
    \000\000\114\000\111\000\114\000\114\000\114\000\114\000\114\000\
    \000\000\000\000\000\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\000\000\255\255\000\000\
    \111\000\000\000\111\000\000\000\006\000\114\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\114\000\000\000\114\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\133\000\000\000\000\000\133\000\133\000\133\000\000\000\
    \000\000\000\000\133\000\133\000\000\000\133\000\133\000\133\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\006\000\000\000\
    \006\000\000\000\133\000\006\000\133\000\133\000\133\000\133\000\
    \133\000\000\000\000\000\000\000\133\000\000\000\000\000\133\000\
    \133\000\133\000\000\000\000\000\000\000\133\000\133\000\000\000\
    \133\000\133\000\133\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\006\000\000\000\006\000\000\000\133\000\133\000\133\000\
    \133\000\133\000\133\000\133\000\000\000\000\000\000\000\111\000\
    \000\000\000\000\111\000\111\000\111\000\000\000\000\000\000\000\
    \111\000\111\000\000\000\111\000\111\000\111\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\133\000\000\000\133\000\000\000\
    \111\000\133\000\111\000\111\000\111\000\111\000\111\000\000\000\
    \000\000\000\000\111\000\000\000\000\000\111\000\111\000\111\000\
    \000\000\000\000\000\000\111\000\111\000\000\000\111\000\111\000\
    \111\000\000\000\000\000\000\000\000\000\000\000\000\000\133\000\
    \000\000\133\000\000\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\111\000\000\000\111\000\000\000\150\000\111\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\000\000\149\000\000\000\111\000\150\000\111\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\160\000\149\000\160\000\000\000\000\000\000\000\
    \000\000\160\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\159\000\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\159\000\159\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\165\000\165\000\165\000\165\000\
    \165\000\165\000\165\000\165\000\165\000\165\000\160\000\000\000\
    \000\000\000\000\000\000\000\000\160\000\165\000\165\000\165\000\
    \165\000\165\000\165\000\000\000\000\000\000\000\000\000\000\000\
    \160\000\000\000\000\000\000\000\160\000\000\000\160\000\000\000\
    \000\000\000\000\158\000\166\000\166\000\166\000\166\000\166\000\
    \166\000\166\000\166\000\166\000\166\000\165\000\165\000\165\000\
    \165\000\165\000\165\000\000\000\166\000\166\000\166\000\166\000\
    \166\000\166\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\182\000\000\000\000\000\183\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\166\000\166\000\166\000\166\000\
    \166\000\166\000\181\000\000\000\181\000\000\000\000\000\000\000\
    \000\000\181\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\180\000\180\000\180\000\180\000\180\000\180\000\
    \180\000\180\000\180\000\180\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\190\000\190\000\190\000\190\000\
    \190\000\190\000\190\000\190\000\190\000\190\000\181\000\000\000\
    \000\000\000\000\000\000\000\000\181\000\190\000\190\000\190\000\
    \190\000\190\000\190\000\000\000\000\000\000\000\000\000\000\000\
    \181\000\179\000\000\000\000\000\181\000\000\000\181\000\177\000\
    \000\000\000\000\178\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\190\000\190\000\190\000\
    \190\000\190\000\190\000\000\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\193\000\193\000\193\000\193\000\193\000\193\000\
    \193\000\193\000\193\000\193\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\193\000\193\000\193\000\193\000\193\000\
    \193\000\000\000\000\000\000\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \193\000\193\000\193\000\193\000\193\000\193\000\193\000\193\000\
    \193\000\193\000\000\000\193\000\193\000\193\000\193\000\193\000\
    \193\000\193\000\193\000\193\000\193\000\193\000\193\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\193\000\193\000\193\000\193\000\193\000\193\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\255\255\000\000\204\000\194\000\204\000\204\000\
    \204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
    \204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
    \204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
    \000\000\204\000\203\000\204\000\204\000\204\000\204\000\204\000\
    \204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
    \204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
    \204\000\204\000\204\000\204\000\204\000\000\000\000\000\203\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000";
  Lexing.lex_check =
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\039\000\000\000\000\000\039\000\040\000\
    \042\000\043\000\040\000\042\000\043\000\073\000\103\000\104\000\
    \073\000\103\000\104\000\107\000\109\000\212\000\107\000\109\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000\
    \016\000\026\000\003\000\003\000\003\000\071\000\072\000\027\000\
    \003\000\003\000\027\000\003\000\003\000\003\000\017\000\080\000\
    \083\000\017\000\017\000\037\000\087\000\090\000\037\000\121\000\
    \003\000\122\000\003\000\003\000\003\000\003\000\003\000\092\000\
    \092\000\126\000\004\000\145\000\027\000\004\000\004\000\004\000\
    \094\000\094\000\037\000\004\000\004\000\146\000\004\000\004\000\
    \004\000\060\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \060\000\060\000\060\000\004\000\003\000\004\000\004\000\004\000\
    \004\000\004\000\096\000\096\000\140\000\005\000\152\000\140\000\
    \005\000\005\000\005\000\153\000\160\000\154\000\005\000\005\000\
    \154\000\005\000\005\000\005\000\078\000\078\000\078\000\078\000\
    \163\000\027\000\003\000\166\000\003\000\177\000\005\000\004\000\
    \005\000\005\000\005\000\005\000\005\000\182\000\168\000\173\000\
    \006\000\168\000\173\000\006\000\006\000\006\000\205\000\206\000\
    \183\000\006\000\006\000\183\000\006\000\006\000\006\000\179\000\
    \179\000\179\000\179\000\105\000\182\000\004\000\105\000\004\000\
    \000\000\006\000\005\000\006\000\006\000\006\000\006\000\006\000\
    \209\000\184\000\211\000\007\000\184\000\104\000\007\000\007\000\
    \007\000\107\000\255\255\105\000\007\000\007\000\207\000\007\000\
    \007\000\007\000\208\000\255\255\195\000\106\000\106\000\195\000\
    \005\000\106\000\005\000\210\000\007\000\006\000\007\000\007\000\
    \007\000\007\000\007\000\255\255\201\000\202\000\008\000\201\000\
    \202\000\008\000\008\000\008\000\106\000\255\255\106\000\008\000\
    \008\000\255\255\008\000\008\000\008\000\196\000\255\255\255\255\
    \196\000\255\255\255\255\006\000\255\255\006\000\255\255\008\000\
    \007\000\008\000\008\000\008\000\008\000\008\000\013\000\255\255\
    \255\255\010\000\255\255\255\255\010\000\010\000\010\000\255\255\
    \255\255\255\255\010\000\010\000\255\255\010\000\010\000\010\000\
    \255\255\255\255\255\255\255\255\255\255\013\000\007\000\013\000\
    \007\000\013\000\010\000\008\000\010\000\010\000\010\000\010\000\
    \010\000\255\255\255\255\255\255\255\255\255\255\011\000\255\255\
    \255\255\011\000\011\000\011\000\255\255\027\000\255\255\011\000\
    \011\000\255\255\011\000\011\000\011\000\255\255\255\255\255\255\
    \255\255\008\000\255\255\008\000\255\255\010\000\010\000\011\000\
    \255\255\011\000\011\000\011\000\011\000\011\000\255\255\142\000\
    \169\000\255\255\142\000\169\000\255\255\014\000\255\255\255\255\
    \014\000\014\000\014\000\255\255\255\255\013\000\014\000\014\000\
    \255\255\014\000\014\000\014\000\010\000\010\000\010\000\196\000\
    \169\000\255\255\011\000\011\000\142\000\255\255\014\000\255\255\
    \014\000\014\000\014\000\014\000\014\000\255\255\255\255\255\255\
    \015\000\255\255\255\255\015\000\015\000\015\000\255\255\255\255\
    \255\255\015\000\015\000\255\255\015\000\015\000\015\000\255\255\
    \255\255\011\000\255\255\011\000\255\255\255\255\255\255\255\255\
    \255\255\015\000\014\000\015\000\015\000\015\000\015\000\015\000\
    \255\255\255\255\018\000\255\255\255\255\018\000\018\000\018\000\
    \255\255\142\000\169\000\018\000\018\000\255\255\018\000\018\000\
    \018\000\105\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \014\000\255\255\014\000\018\000\255\255\015\000\018\000\018\000\
    \018\000\018\000\255\255\255\255\255\255\019\000\255\255\255\255\
    \019\000\019\000\019\000\255\255\207\000\255\255\019\000\019\000\
    \208\000\019\000\019\000\019\000\106\000\255\255\255\255\255\255\
    \255\255\210\000\255\255\015\000\255\255\015\000\019\000\018\000\
    \019\000\019\000\019\000\019\000\019\000\255\255\255\255\255\255\
    \023\000\255\255\255\255\023\000\023\000\023\000\255\255\255\255\
    \255\255\023\000\023\000\196\000\023\000\023\000\023\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\018\000\255\255\018\000\
    \255\255\023\000\019\000\023\000\023\000\023\000\023\000\023\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \066\000\066\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\255\255\255\255\255\255\255\255\
    \019\000\255\255\019\000\255\255\255\255\023\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\255\255\024\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\086\000\255\255\023\000\255\255\023\000\024\000\024\000\
    \255\255\024\000\024\000\024\000\024\000\142\000\169\000\255\255\
    \024\000\024\000\101\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\255\255\024\000\024\000\024\000\024\000\024\000\255\255\
    \255\255\101\000\025\000\255\255\255\255\025\000\025\000\025\000\
    \255\255\255\255\025\000\025\000\025\000\255\255\025\000\025\000\
    \025\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\025\000\024\000\025\000\025\000\025\000\
    \025\000\025\000\159\000\159\000\159\000\159\000\159\000\159\000\
    \159\000\159\000\159\000\159\000\162\000\162\000\162\000\162\000\
    \162\000\162\000\162\000\162\000\162\000\162\000\255\255\255\255\
    \255\255\255\255\024\000\028\000\024\000\255\255\069\000\025\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\255\255\069\000\255\255\025\000\028\000\025\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\030\000\028\000\255\255\255\255\255\255\255\255\
    \255\255\030\000\255\255\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\255\255\255\255\
    \255\255\255\255\030\000\255\255\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\031\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\031\000\255\255\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\255\255\255\255\255\255\255\255\031\000\255\255\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\032\000\187\000\187\000\187\000\187\000\187\000\
    \187\000\187\000\187\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\255\255\255\255\
    \255\255\255\255\032\000\255\255\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\033\000\188\000\
    \188\000\188\000\188\000\188\000\188\000\188\000\188\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\255\255\255\255\255\255\255\255\033\000\255\255\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\034\000\255\255\255\255\034\000\034\000\034\000\
    \255\255\255\255\255\255\034\000\034\000\255\255\034\000\034\000\
    \034\000\255\255\255\255\255\255\255\255\255\255\255\255\137\000\
    \255\255\255\255\137\000\034\000\255\255\034\000\034\000\034\000\
    \034\000\034\000\180\000\180\000\180\000\180\000\180\000\180\000\
    \180\000\180\000\180\000\180\000\255\255\255\255\255\255\137\000\
    \255\255\255\255\255\255\255\255\137\000\137\000\255\255\137\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\034\000\
    \034\000\255\255\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\255\255\034\000\035\000\034\000\
    \255\255\035\000\035\000\035\000\255\255\255\255\255\255\035\000\
    \035\000\255\255\035\000\035\000\035\000\185\000\185\000\185\000\
    \185\000\185\000\185\000\185\000\185\000\185\000\185\000\035\000\
    \255\255\035\000\035\000\035\000\035\000\035\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \137\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\035\000\035\000\255\255\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \036\000\035\000\255\255\035\000\255\255\255\255\255\255\255\255\
    \255\255\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\255\255\255\255\255\255\255\255\
    \036\000\255\255\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\044\000\137\000\255\255\044\000\
    \044\000\044\000\255\255\255\255\255\255\044\000\044\000\255\255\
    \044\000\044\000\044\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\044\000\255\255\044\000\
    \044\000\044\000\044\000\044\000\255\255\255\255\255\255\255\255\
    \045\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\255\255\255\255\255\255\255\255\
    \255\255\044\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\255\255\255\255\255\255\044\000\
    \045\000\044\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\047\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \255\255\255\255\255\255\255\255\047\000\255\255\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \049\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\255\255\255\255\255\255\255\255\
    \049\000\255\255\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\049\000\049\000\049\000\050\000\255\255\255\255\255\255\
    \050\000\255\255\050\000\255\255\255\255\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \255\255\255\255\255\255\255\255\050\000\255\255\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \051\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\255\255\255\255\255\255\255\255\
    \051\000\255\255\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\052\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \255\255\255\255\255\255\255\255\052\000\255\255\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \053\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\255\255\255\255\255\255\255\255\
    \053\000\255\255\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\054\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\054\000\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \255\255\255\255\255\255\255\255\054\000\255\255\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\054\000\
    \055\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\055\000\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\055\000\255\255\255\255\255\255\255\255\
    \055\000\255\255\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\055\000\055\000\055\000\055\000\055\000\
    \055\000\055\000\055\000\055\000\056\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\056\000\255\255\056\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \255\255\255\255\255\255\255\255\056\000\255\255\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \056\000\056\000\056\000\056\000\056\000\056\000\056\000\056\000\
    \057\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\057\000\255\255\255\255\255\255\255\255\
    \057\000\255\255\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\057\000\058\000\255\255\255\255\255\255\
    \058\000\255\255\058\000\255\255\255\255\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \255\255\255\255\255\255\255\255\058\000\255\255\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \059\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\255\255\255\255\255\255\255\255\
    \059\000\255\255\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\061\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \255\255\255\255\255\255\255\255\061\000\255\255\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \062\000\255\255\255\255\255\255\062\000\255\255\062\000\255\255\
    \255\255\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\062\000\062\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\062\000\062\000\062\000\255\255\255\255\255\255\255\255\
    \062\000\255\255\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\062\000\062\000\062\000\063\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \255\255\255\255\255\255\255\255\063\000\255\255\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \064\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\064\000\064\000\064\000\064\000\064\000\064\000\064\000\
    \064\000\064\000\064\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\064\000\064\000\064\000\064\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\255\255\255\255\255\255\255\255\
    \064\000\255\255\064\000\064\000\064\000\064\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\065\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\065\000\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \255\255\255\255\255\255\255\255\065\000\255\255\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \065\000\065\000\065\000\065\000\065\000\065\000\065\000\065\000\
    \070\000\255\255\070\000\255\255\255\255\255\255\255\255\070\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\077\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\077\000\077\000\077\000\070\000\255\255\255\255\255\255\
    \255\255\255\255\070\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\255\255\255\255\255\255\255\255\255\255\070\000\070\000\
    \255\255\255\255\070\000\255\255\070\000\255\255\255\255\255\255\
    \070\000\089\000\089\000\089\000\089\000\089\000\089\000\089\000\
    \089\000\089\000\089\000\077\000\077\000\077\000\077\000\077\000\
    \077\000\255\255\089\000\089\000\089\000\089\000\089\000\089\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\097\000\
    \255\255\255\255\097\000\097\000\097\000\255\255\255\255\255\255\
    \097\000\097\000\255\255\097\000\097\000\097\000\255\255\255\255\
    \255\255\255\255\089\000\089\000\089\000\089\000\089\000\089\000\
    \097\000\255\255\097\000\097\000\097\000\097\000\097\000\100\000\
    \100\000\255\255\099\000\100\000\099\000\099\000\099\000\099\000\
    \255\255\255\255\255\255\099\000\099\000\255\255\099\000\099\000\
    \099\000\255\255\255\255\255\255\255\255\255\255\100\000\255\255\
    \100\000\255\255\255\255\099\000\097\000\099\000\099\000\099\000\
    \099\000\099\000\255\255\255\255\255\255\255\255\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \255\255\255\255\255\255\255\255\110\000\255\255\255\255\110\000\
    \110\000\110\000\097\000\255\255\097\000\110\000\110\000\099\000\
    \110\000\110\000\110\000\255\255\255\255\255\255\255\255\255\255\
    \070\000\255\255\255\255\255\255\255\255\110\000\255\255\110\000\
    \110\000\110\000\110\000\110\000\255\255\255\255\255\255\111\000\
    \255\255\255\255\111\000\111\000\111\000\099\000\255\255\099\000\
    \111\000\111\000\255\255\111\000\111\000\111\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \111\000\110\000\111\000\111\000\111\000\111\000\111\000\255\255\
    \255\255\255\255\112\000\255\255\255\255\112\000\112\000\112\000\
    \255\255\255\255\255\255\112\000\112\000\255\255\112\000\112\000\
    \112\000\255\255\255\255\255\255\255\255\255\255\255\255\110\000\
    \255\255\110\000\255\255\112\000\111\000\112\000\112\000\112\000\
    \112\000\112\000\255\255\255\255\255\255\113\000\255\255\255\255\
    \113\000\113\000\113\000\255\255\255\255\255\255\113\000\113\000\
    \255\255\113\000\113\000\113\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\111\000\255\255\111\000\255\255\113\000\112\000\
    \113\000\113\000\113\000\113\000\113\000\255\255\255\255\255\255\
    \114\000\255\255\255\255\114\000\114\000\114\000\255\255\255\255\
    \255\255\114\000\114\000\255\255\114\000\114\000\114\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\112\000\255\255\112\000\
    \255\255\114\000\113\000\114\000\114\000\114\000\114\000\114\000\
    \255\255\255\255\255\255\120\000\255\255\255\255\120\000\120\000\
    \120\000\255\255\255\255\255\255\120\000\120\000\255\255\120\000\
    \120\000\120\000\255\255\255\255\255\255\255\255\100\000\255\255\
    \113\000\255\255\113\000\255\255\120\000\114\000\120\000\120\000\
    \120\000\120\000\120\000\255\255\255\255\255\255\130\000\255\255\
    \255\255\130\000\130\000\130\000\255\255\255\255\255\255\130\000\
    \130\000\255\255\130\000\130\000\130\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\114\000\255\255\114\000\255\255\130\000\
    \120\000\130\000\130\000\130\000\130\000\130\000\255\255\255\255\
    \255\255\133\000\255\255\255\255\133\000\133\000\133\000\255\255\
    \255\255\255\255\133\000\133\000\255\255\133\000\133\000\133\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\120\000\255\255\
    \120\000\255\255\133\000\130\000\133\000\133\000\133\000\133\000\
    \133\000\255\255\255\255\255\255\134\000\255\255\255\255\134\000\
    \134\000\134\000\255\255\255\255\255\255\134\000\134\000\255\255\
    \134\000\134\000\134\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\130\000\255\255\130\000\255\255\134\000\133\000\134\000\
    \134\000\134\000\134\000\134\000\255\255\255\255\255\255\135\000\
    \255\255\255\255\135\000\135\000\135\000\255\255\255\255\255\255\
    \135\000\135\000\255\255\135\000\135\000\135\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\133\000\255\255\133\000\255\255\
    \135\000\134\000\135\000\135\000\135\000\135\000\135\000\255\255\
    \255\255\255\255\136\000\255\255\255\255\136\000\136\000\136\000\
    \255\255\255\255\255\255\136\000\136\000\255\255\136\000\136\000\
    \136\000\255\255\255\255\255\255\255\255\255\255\255\255\134\000\
    \255\255\134\000\255\255\136\000\135\000\136\000\136\000\136\000\
    \136\000\136\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\135\000\255\255\135\000\255\255\143\000\136\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\255\255\143\000\255\255\136\000\150\000\136\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\151\000\150\000\151\000\255\255\255\255\255\255\
    \255\255\151\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\151\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\158\000\158\000\158\000\158\000\
    \158\000\158\000\158\000\158\000\158\000\158\000\151\000\255\255\
    \255\255\255\255\255\255\255\255\151\000\158\000\158\000\158\000\
    \158\000\158\000\158\000\255\255\255\255\255\255\255\255\255\255\
    \151\000\255\255\255\255\255\255\151\000\255\255\151\000\255\255\
    \255\255\255\255\151\000\165\000\165\000\165\000\165\000\165\000\
    \165\000\165\000\165\000\165\000\165\000\158\000\158\000\158\000\
    \158\000\158\000\158\000\255\255\165\000\165\000\165\000\165\000\
    \165\000\165\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\174\000\255\255\255\255\174\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\165\000\165\000\165\000\165\000\
    \165\000\165\000\174\000\255\255\174\000\255\255\255\255\255\255\
    \255\255\174\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\174\000\174\000\174\000\174\000\174\000\174\000\
    \174\000\174\000\174\000\174\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\178\000\178\000\178\000\178\000\
    \178\000\178\000\178\000\178\000\178\000\178\000\174\000\255\255\
    \255\255\255\255\255\255\255\255\174\000\178\000\178\000\178\000\
    \178\000\178\000\178\000\255\255\255\255\255\255\255\255\255\255\
    \174\000\174\000\255\255\255\255\174\000\255\255\174\000\174\000\
    \255\255\255\255\174\000\190\000\190\000\190\000\190\000\190\000\
    \190\000\190\000\190\000\190\000\190\000\178\000\178\000\178\000\
    \178\000\178\000\178\000\255\255\190\000\190\000\190\000\190\000\
    \190\000\190\000\192\000\192\000\192\000\192\000\192\000\192\000\
    \192\000\192\000\192\000\192\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\192\000\192\000\192\000\192\000\192\000\
    \192\000\255\255\255\255\255\255\190\000\190\000\190\000\190\000\
    \190\000\190\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \193\000\193\000\193\000\193\000\193\000\193\000\193\000\193\000\
    \193\000\193\000\255\255\192\000\192\000\192\000\192\000\192\000\
    \192\000\193\000\193\000\193\000\193\000\193\000\193\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\193\000\193\000\193\000\193\000\193\000\193\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\174\000\255\255\198\000\193\000\198\000\198\000\
    \198\000\198\000\198\000\198\000\198\000\198\000\198\000\198\000\
    \198\000\198\000\198\000\198\000\198\000\198\000\198\000\198\000\
    \198\000\198\000\198\000\198\000\198\000\198\000\198\000\198\000\
    \255\255\204\000\198\000\204\000\204\000\204\000\204\000\204\000\
    \204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
    \204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
    \204\000\204\000\204\000\204\000\204\000\255\255\255\255\204\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255";
  Lexing.lex_base_code =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\010\000\036\000\022\000\000\000\
    \000\000\000\000\005\000\000\000\039\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\001\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\
    \005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_backtrk_code =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\053\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_default_code =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\031\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_trans_code =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\001\000\000\000\050\000\050\000\000\000\009\000\050\000\
    \000\000\000\000\000\000\009\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \001\000\000\000\009\000\001\000\000\000\009\000\000\000\034\000\
    \000\000\000\000\009\000\000\000\012\000\001\000\000\000\000\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\017\000\017\000\017\000\017\000\017\000\017\000\
    \017\000\017\000\017\000\017\000\001\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\017\000\017\000\017\000\017\000\
    \017\000\017\000\017\000\017\000\017\000\017\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_check_code =
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\024\000\105\000\174\000\183\000\105\000\106\000\184\000\
    \255\255\255\255\255\255\100\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \024\000\255\255\105\000\000\000\255\255\106\000\255\255\106\000\
    \255\255\255\255\100\000\255\255\100\000\101\000\255\255\255\255\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\101\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \105\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255";
  Lexing.lex_code =
   "\255\005\255\255\007\255\006\255\255\007\255\255\009\255\008\255\
    \255\006\255\007\255\255\004\255\000\005\001\006\002\007\255\009\
    \255\255\008\255\009\255\255\000\005\001\006\004\008\003\009\002\
    \007\255\001\255\255\000\001\255";
}

let rec token lexbuf =
  lexbuf.Lexing.lex_mem <- Array.make 10 (-1); __ocaml_lex_token_rec lexbuf 0
and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 313 "ml/lexer.mll"
                 (
      if not !escaped_newlines then
        raise (Error(Illegal_character (Lexing.lexeme_char lexbuf 0),
                     Location.curr lexbuf));
      update_loc lexbuf None 1 false 0;
      token lexbuf )
# 1579 "ml/lexer.ml"

  | 1 ->
# 320 "ml/lexer.mll"
      ( update_loc lexbuf None 1 false 0;
        EOL )
# 1585 "ml/lexer.ml"

  | 2 ->
# 323 "ml/lexer.mll"
      ( token lexbuf )
# 1590 "ml/lexer.ml"

  | 3 ->
# 325 "ml/lexer.mll"
      ( UNDERSCORE )
# 1595 "ml/lexer.ml"

  | 4 ->
# 327 "ml/lexer.mll"
      ( TILDE )
# 1600 "ml/lexer.ml"

  | 5 ->
# 329 "ml/lexer.mll"
      ( LABEL (get_label_name lexbuf) )
# 1605 "ml/lexer.ml"

  | 6 ->
# 331 "ml/lexer.mll"
      ( QUESTION )
# 1610 "ml/lexer.ml"

  | 7 ->
# 333 "ml/lexer.mll"
      ( OPTLABEL (get_label_name lexbuf) )
# 1615 "ml/lexer.ml"

  | 8 ->
# 335 "ml/lexer.mll"
      ( let s = Lexing.lexeme lexbuf in
        try Hashtbl.find keyword_table s
        with Not_found -> LIDENT s )
# 1622 "ml/lexer.ml"

  | 9 ->
# 339 "ml/lexer.mll"
      ( UIDENT(Lexing.lexeme lexbuf) )
# 1627 "ml/lexer.ml"

  | 10 ->
# 340 "ml/lexer.mll"
                ( INT (Lexing.lexeme lexbuf, None) )
# 1632 "ml/lexer.ml"

  | 11 ->
let
# 341 "ml/lexer.mll"
                    lit
# 1638 "ml/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos (lexbuf.Lexing.lex_curr_pos + -1)
and
# 341 "ml/lexer.mll"
                                              modif
# 1643 "ml/lexer.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_curr_pos + -1) in
# 342 "ml/lexer.mll"
      ( INT (lit, Some modif) )
# 1647 "ml/lexer.ml"

  | 12 ->
# 344 "ml/lexer.mll"
      ( FLOAT (Lexing.lexeme lexbuf, None) )
# 1652 "ml/lexer.ml"

  | 13 ->
let
# 345 "ml/lexer.mll"
                                            lit
# 1658 "ml/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos (lexbuf.Lexing.lex_curr_pos + -1)
and
# 345 "ml/lexer.mll"
                                                                      modif
# 1663 "ml/lexer.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_curr_pos + -1) in
# 346 "ml/lexer.mll"
      ( FLOAT (lit, Some modif) )
# 1667 "ml/lexer.ml"

  | 14 ->
# 348 "ml/lexer.mll"
      ( raise (Error(Invalid_literal (Lexing.lexeme lexbuf),
                     Location.curr lexbuf)) )
# 1673 "ml/lexer.ml"

  | 15 ->
# 351 "ml/lexer.mll"
      ( reset_string_buffer();
        is_in_string := true;
        let string_start = lexbuf.lex_start_p in
        string_start_loc := Location.curr lexbuf;
        string lexbuf;
        is_in_string := false;
        lexbuf.lex_start_p <- string_start;
        STRING (get_stored_string(), None) )
# 1685 "ml/lexer.ml"

  | 16 ->
# 360 "ml/lexer.mll"
      ( reset_string_buffer();
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 1 (String.length delim - 2) in
        is_in_string := true;
        let string_start = lexbuf.lex_start_p in
        string_start_loc := Location.curr lexbuf;
        quoted_string delim lexbuf;
        is_in_string := false;
        lexbuf.lex_start_p <- string_start;
        STRING (get_stored_string(), Some delim) )
# 1699 "ml/lexer.ml"

  | 17 ->
# 371 "ml/lexer.mll"
      ( update_loc lexbuf None 1 false 1;
        CHAR (Lexing.lexeme_char lexbuf 1) )
# 1705 "ml/lexer.ml"

  | 18 ->
# 374 "ml/lexer.mll"
      ( CHAR(Lexing.lexeme_char lexbuf 1) )
# 1710 "ml/lexer.ml"

  | 19 ->
# 376 "ml/lexer.mll"
      ( CHAR(char_for_backslash (Lexing.lexeme_char lexbuf 2)) )
# 1715 "ml/lexer.ml"

  | 20 ->
# 378 "ml/lexer.mll"
      ( CHAR(char_for_decimal_code lexbuf 2) )
# 1720 "ml/lexer.ml"

  | 21 ->
# 380 "ml/lexer.mll"
      ( CHAR(char_for_octal_code lexbuf 3) )
# 1725 "ml/lexer.ml"

  | 22 ->
# 382 "ml/lexer.mll"
      ( CHAR(char_for_hexadecimal_code lexbuf 3) )
# 1730 "ml/lexer.ml"

  | 23 ->
# 384 "ml/lexer.mll"
      ( let l = Lexing.lexeme lexbuf in
        let esc = String.sub l 1 (String.length l - 1) in
        raise (Error(Illegal_escape esc, Location.curr lexbuf))
      )
# 1738 "ml/lexer.ml"

  | 24 ->
# 389 "ml/lexer.mll"
      ( let s, loc = with_comment_buffer comment lexbuf in
        COMMENT (s, loc) )
# 1744 "ml/lexer.ml"

  | 25 ->
# 392 "ml/lexer.mll"
      ( let s, loc = with_comment_buffer comment lexbuf in
        if !handle_docstrings then
          DOCSTRING (Docstrings.docstring s loc)
        else
          COMMENT ("*" ^ s, loc)
      )
# 1754 "ml/lexer.ml"

  | 26 ->
let
# 398 "ml/lexer.mll"
                     stars
# 1760 "ml/lexer.ml"
= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 3) lexbuf.Lexing.lex_curr_pos in
# 399 "ml/lexer.mll"
      ( let s, loc =
          with_comment_buffer
            (fun lexbuf ->
               store_string ("*" ^ stars);
               comment lexbuf)
            lexbuf
        in
        COMMENT (s, loc) )
# 1771 "ml/lexer.ml"

  | 27 ->
# 408 "ml/lexer.mll"
      ( if !print_warnings then
          Location.prerr_warning (Location.curr lexbuf) Warnings.Comment_start;
        let s, loc = with_comment_buffer comment lexbuf in
        COMMENT (s, loc) )
# 1779 "ml/lexer.ml"

  | 28 ->
let
# 412 "ml/lexer.mll"
                    stars
# 1785 "ml/lexer.ml"
= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 2) (lexbuf.Lexing.lex_curr_pos + -2) in
# 413 "ml/lexer.mll"
      ( if !handle_docstrings && stars="" then
         (* (**) is an empty docstring *)
          DOCSTRING(Docstrings.docstring "" (Location.curr lexbuf))
        else
          COMMENT (stars, Location.curr lexbuf) )
# 1793 "ml/lexer.ml"

  | 29 ->
# 419 "ml/lexer.mll"
      ( let loc = Location.curr lexbuf in
        Location.prerr_warning loc Warnings.Comment_not_end;
        lexbuf.Lexing.lex_curr_pos <- lexbuf.Lexing.lex_curr_pos - 1;
        let curpos = lexbuf.lex_curr_p in
        lexbuf.lex_curr_p <- { curpos with pos_cnum = curpos.pos_cnum - 1 };
        STAR
      )
# 1804 "ml/lexer.ml"

  | 30 ->
let
# 426 "ml/lexer.mll"
                                    num
# 1810 "ml/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(0) lexbuf.Lexing.lex_mem.(1)
and
# 427 "ml/lexer.mll"
                                            name
# 1815 "ml/lexer.ml"
= Lexing.sub_lexeme_opt lexbuf lexbuf.Lexing.lex_mem.(4) lexbuf.Lexing.lex_mem.(3)
and
# 427 "ml/lexer.mll"
                                                             directive
# 1820 "ml/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_mem.(2) in
# 429 "ml/lexer.mll"
      (
        match int_of_string num with
        | exception _ ->
            (* PR#7165 *)
            let loc = Location.curr lexbuf in
            let explanation = "line number out of range" in
            let error = Invalid_directive (directive, Some explanation) in
            raise (Error (error, loc))
        | line_num ->
           (* Documentation says that the line number should be
              positive, but we have never guarded against this and it
              might have useful hackish uses. *)
            update_loc lexbuf name line_num true 0;
            token lexbuf
      )
# 1838 "ml/lexer.ml"

  | 31 ->
# 444 "ml/lexer.mll"
         ( HASH )
# 1843 "ml/lexer.ml"

  | 32 ->
# 445 "ml/lexer.mll"
         ( AMPERSAND )
# 1848 "ml/lexer.ml"

  | 33 ->
# 446 "ml/lexer.mll"
         ( AMPERAMPER )
# 1853 "ml/lexer.ml"

  | 34 ->
# 447 "ml/lexer.mll"
         ( BACKQUOTE )
# 1858 "ml/lexer.ml"

  | 35 ->
# 448 "ml/lexer.mll"
         ( QUOTE )
# 1863 "ml/lexer.ml"

  | 36 ->
# 449 "ml/lexer.mll"
         ( LPAREN )
# 1868 "ml/lexer.ml"

  | 37 ->
# 450 "ml/lexer.mll"
         ( RPAREN )
# 1873 "ml/lexer.ml"

  | 38 ->
# 451 "ml/lexer.mll"
         ( STAR )
# 1878 "ml/lexer.ml"

  | 39 ->
# 452 "ml/lexer.mll"
         ( COMMA )
# 1883 "ml/lexer.ml"

  | 40 ->
# 453 "ml/lexer.mll"
         ( MINUSGREATER )
# 1888 "ml/lexer.ml"

  | 41 ->
# 454 "ml/lexer.mll"
         ( DOT )
# 1893 "ml/lexer.ml"

  | 42 ->
# 455 "ml/lexer.mll"
         ( DOTDOT )
# 1898 "ml/lexer.ml"

  | 43 ->
let
# 456 "ml/lexer.mll"
                                      s
# 1904 "ml/lexer.ml"
= Lexing.sub_lexeme lexbuf (lexbuf.Lexing.lex_start_pos + 1) lexbuf.Lexing.lex_curr_pos in
# 456 "ml/lexer.mll"
                                         ( DOTOP s )
# 1908 "ml/lexer.ml"

  | 44 ->
# 457 "ml/lexer.mll"
         ( COLON )
# 1913 "ml/lexer.ml"

  | 45 ->
# 458 "ml/lexer.mll"
         ( COLONCOLON )
# 1918 "ml/lexer.ml"

  | 46 ->
# 459 "ml/lexer.mll"
         ( COLONEQUAL )
# 1923 "ml/lexer.ml"

  | 47 ->
# 460 "ml/lexer.mll"
         ( COLONGREATER )
# 1928 "ml/lexer.ml"

  | 48 ->
# 461 "ml/lexer.mll"
         ( SEMI )
# 1933 "ml/lexer.ml"

  | 49 ->
# 462 "ml/lexer.mll"
         ( SEMISEMI )
# 1938 "ml/lexer.ml"

  | 50 ->
# 463 "ml/lexer.mll"
         ( LESS )
# 1943 "ml/lexer.ml"

  | 51 ->
# 464 "ml/lexer.mll"
         ( LESSMINUS )
# 1948 "ml/lexer.ml"

  | 52 ->
# 465 "ml/lexer.mll"
         ( EQUAL )
# 1953 "ml/lexer.ml"

  | 53 ->
# 466 "ml/lexer.mll"
         ( LBRACKET )
# 1958 "ml/lexer.ml"

  | 54 ->
# 467 "ml/lexer.mll"
         ( LBRACKETBAR )
# 1963 "ml/lexer.ml"

  | 55 ->
# 468 "ml/lexer.mll"
         ( LBRACKETLESS )
# 1968 "ml/lexer.ml"

  | 56 ->
# 469 "ml/lexer.mll"
         ( LBRACKETGREATER )
# 1973 "ml/lexer.ml"

  | 57 ->
# 470 "ml/lexer.mll"
         ( RBRACKET )
# 1978 "ml/lexer.ml"

  | 58 ->
# 471 "ml/lexer.mll"
         ( LBRACE )
# 1983 "ml/lexer.ml"

  | 59 ->
# 472 "ml/lexer.mll"
         ( LBRACELESS )
# 1988 "ml/lexer.ml"

  | 60 ->
# 473 "ml/lexer.mll"
         ( BAR )
# 1993 "ml/lexer.ml"

  | 61 ->
# 474 "ml/lexer.mll"
         ( BARBAR )
# 1998 "ml/lexer.ml"

  | 62 ->
# 475 "ml/lexer.mll"
         ( BARRBRACKET )
# 2003 "ml/lexer.ml"

  | 63 ->
# 476 "ml/lexer.mll"
         ( GREATER )
# 2008 "ml/lexer.ml"

  | 64 ->
# 477 "ml/lexer.mll"
         ( GREATERRBRACKET )
# 2013 "ml/lexer.ml"

  | 65 ->
# 478 "ml/lexer.mll"
         ( RBRACE )
# 2018 "ml/lexer.ml"

  | 66 ->
# 479 "ml/lexer.mll"
         ( GREATERRBRACE )
# 2023 "ml/lexer.ml"

  | 67 ->
# 480 "ml/lexer.mll"
         ( LBRACKETAT )
# 2028 "ml/lexer.ml"

  | 68 ->
# 481 "ml/lexer.mll"
           ( LBRACKETATAT )
# 2033 "ml/lexer.ml"

  | 69 ->
# 482 "ml/lexer.mll"
           ( LBRACKETATATAT )
# 2038 "ml/lexer.ml"

  | 70 ->
# 483 "ml/lexer.mll"
           ( LBRACKETPERCENT )
# 2043 "ml/lexer.ml"

  | 71 ->
# 484 "ml/lexer.mll"
           ( LBRACKETPERCENTPERCENT )
# 2048 "ml/lexer.ml"

  | 72 ->
# 485 "ml/lexer.mll"
         ( BANG )
# 2053 "ml/lexer.ml"

  | 73 ->
# 486 "ml/lexer.mll"
         ( INFIXOP0 "!=" )
# 2058 "ml/lexer.ml"

  | 74 ->
# 487 "ml/lexer.mll"
         ( PLUS )
# 2063 "ml/lexer.ml"

  | 75 ->
# 488 "ml/lexer.mll"
         ( PLUSDOT )
# 2068 "ml/lexer.ml"

  | 76 ->
# 489 "ml/lexer.mll"
         ( PLUSEQ )
# 2073 "ml/lexer.ml"

  | 77 ->
# 490 "ml/lexer.mll"
         ( MINUS )
# 2078 "ml/lexer.ml"

  | 78 ->
# 491 "ml/lexer.mll"
         ( MINUSDOT )
# 2083 "ml/lexer.ml"

  | 79 ->
# 494 "ml/lexer.mll"
            ( PREFIXOP(Lexing.lexeme lexbuf) )
# 2088 "ml/lexer.ml"

  | 80 ->
# 496 "ml/lexer.mll"
            ( PREFIXOP(Lexing.lexeme lexbuf) )
# 2093 "ml/lexer.ml"

  | 81 ->
# 498 "ml/lexer.mll"
            ( INFIXOP0(Lexing.lexeme lexbuf) )
# 2098 "ml/lexer.ml"

  | 82 ->
# 500 "ml/lexer.mll"
            ( INFIXOP1(Lexing.lexeme lexbuf) )
# 2103 "ml/lexer.ml"

  | 83 ->
# 502 "ml/lexer.mll"
            ( INFIXOP2(Lexing.lexeme lexbuf) )
# 2108 "ml/lexer.ml"

  | 84 ->
# 504 "ml/lexer.mll"
            ( INFIXOP4(Lexing.lexeme lexbuf) )
# 2113 "ml/lexer.ml"

  | 85 ->
# 505 "ml/lexer.mll"
            ( PERCENT )
# 2118 "ml/lexer.ml"

  | 86 ->
# 507 "ml/lexer.mll"
            ( INFIXOP3(Lexing.lexeme lexbuf) )
# 2123 "ml/lexer.ml"

  | 87 ->
# 509 "ml/lexer.mll"
            ( HASHOP(Lexing.lexeme lexbuf) )
# 2128 "ml/lexer.ml"

  | 88 ->
# 510 "ml/lexer.mll"
        ( Rescript_cpp.eof_check lexbuf; EOF)
# 2133 "ml/lexer.ml"

  | 89 ->
# 512 "ml/lexer.mll"
      ( raise (Error(Illegal_character (Lexing.lexeme_char lexbuf 0),
                     Location.curr lexbuf))
      )
# 2140 "ml/lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_token_rec lexbuf __ocaml_lex_state

and comment lexbuf =
   __ocaml_lex_comment_rec lexbuf 137
and __ocaml_lex_comment_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 518 "ml/lexer.mll"
      ( comment_start_loc := (Location.curr lexbuf) :: !comment_start_loc;
        store_lexeme lexbuf;
        comment lexbuf
      )
# 2155 "ml/lexer.ml"

  | 1 ->
# 523 "ml/lexer.mll"
      ( match !comment_start_loc with
        | [] -> assert false
        | [_] -> comment_start_loc := []; Location.curr lexbuf
        | _ :: l -> comment_start_loc := l;
                  store_lexeme lexbuf;
                  comment lexbuf
       )
# 2166 "ml/lexer.ml"

  | 2 ->
# 531 "ml/lexer.mll"
      (
        string_start_loc := Location.curr lexbuf;
        store_string_char '\"';
        is_in_string := true;
        begin try string lexbuf
        with Error (Unterminated_string, str_start) ->
          match !comment_start_loc with
          | [] -> assert false
          | loc :: _ ->
            let start = List.hd (List.rev !comment_start_loc) in
            comment_start_loc := [];
            raise (Error (Unterminated_string_in_comment (start, str_start),
                          loc))
        end;
        is_in_string := false;
        store_string_char '\"';
        comment lexbuf )
# 2187 "ml/lexer.ml"

  | 3 ->
# 549 "ml/lexer.mll"
      (
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 1 (String.length delim - 2) in
        string_start_loc := Location.curr lexbuf;
        store_lexeme lexbuf;
        is_in_string := true;
        begin try quoted_string delim lexbuf
        with Error (Unterminated_string, str_start) ->
          match !comment_start_loc with
          | [] -> assert false
          | loc :: _ ->
            let start = List.hd (List.rev !comment_start_loc) in
            comment_start_loc := [];
            raise (Error (Unterminated_string_in_comment (start, str_start),
                          loc))
        end;
        is_in_string := false;
        store_string_char '|';
        store_string delim;
        store_string_char '}';
        comment lexbuf )
# 2212 "ml/lexer.ml"

  | 4 ->
# 572 "ml/lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2217 "ml/lexer.ml"

  | 5 ->
# 574 "ml/lexer.mll"
      ( update_loc lexbuf None 1 false 1;
        store_lexeme lexbuf;
        comment lexbuf
      )
# 2225 "ml/lexer.ml"

  | 6 ->
# 579 "ml/lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2230 "ml/lexer.ml"

  | 7 ->
# 581 "ml/lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2235 "ml/lexer.ml"

  | 8 ->
# 583 "ml/lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2240 "ml/lexer.ml"

  | 9 ->
# 585 "ml/lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2245 "ml/lexer.ml"

  | 10 ->
# 587 "ml/lexer.mll"
      ( match !comment_start_loc with
        | [] -> assert false
        | loc :: _ ->
          let start = List.hd (List.rev !comment_start_loc) in
          comment_start_loc := [];
          raise (Error (Unterminated_comment start, loc))
      )
# 2256 "ml/lexer.ml"

  | 11 ->
# 595 "ml/lexer.mll"
      ( update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        comment lexbuf
      )
# 2264 "ml/lexer.ml"

  | 12 ->
# 600 "ml/lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2269 "ml/lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_comment_rec lexbuf __ocaml_lex_state

and string lexbuf =
  lexbuf.Lexing.lex_mem <- Array.make 2 (-1); __ocaml_lex_string_rec lexbuf 169
and __ocaml_lex_string_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 604 "ml/lexer.mll"
      ( () )
# 2281 "ml/lexer.ml"

  | 1 ->
let
# 605 "ml/lexer.mll"
                                  space
# 2287 "ml/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(0) lexbuf.Lexing.lex_curr_pos in
# 606 "ml/lexer.mll"
      ( update_loc lexbuf None 1 false (String.length space);
        if in_comment () then store_lexeme lexbuf;
        string lexbuf
      )
# 2294 "ml/lexer.ml"

  | 2 ->
# 611 "ml/lexer.mll"
      ( store_escaped_char lexbuf
                           (char_for_backslash(Lexing.lexeme_char lexbuf 1));
        string lexbuf )
# 2301 "ml/lexer.ml"

  | 3 ->
# 615 "ml/lexer.mll"
      ( store_escaped_char lexbuf (char_for_decimal_code lexbuf 1);
         string lexbuf )
# 2307 "ml/lexer.ml"

  | 4 ->
# 618 "ml/lexer.mll"
      ( store_escaped_char lexbuf (char_for_octal_code lexbuf 2);
         string lexbuf )
# 2313 "ml/lexer.ml"

  | 5 ->
# 621 "ml/lexer.mll"
      ( store_escaped_char lexbuf (char_for_hexadecimal_code lexbuf 2);
         string lexbuf )
# 2319 "ml/lexer.ml"

  | 6 ->
# 624 "ml/lexer.mll"
        ( store_escaped_uchar lexbuf (uchar_for_uchar_escape lexbuf);
          string lexbuf )
# 2325 "ml/lexer.ml"

  | 7 ->
# 627 "ml/lexer.mll"
      ( if not (in_comment ()) then begin
(*  Should be an error, but we are very lax.
          raise (Error (Illegal_escape (Lexing.lexeme lexbuf),
                        Location.curr lexbuf))
*)
          let loc = Location.curr lexbuf in
          Location.prerr_warning loc Warnings.Illegal_backslash;
        end;
        store_lexeme lexbuf;
        string lexbuf
      )
# 2340 "ml/lexer.ml"

  | 8 ->
# 639 "ml/lexer.mll"
      ( if not (in_comment ()) then
          Location.prerr_warning (Location.curr lexbuf) Warnings.Eol_in_string;
        update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        string lexbuf
      )
# 2350 "ml/lexer.ml"

  | 9 ->
# 646 "ml/lexer.mll"
      ( is_in_string := false;
        raise (Error (Unterminated_string, !string_start_loc)) )
# 2356 "ml/lexer.ml"

  | 10 ->
# 649 "ml/lexer.mll"
      ( store_string_char(Lexing.lexeme_char lexbuf 0);
        string lexbuf )
# 2362 "ml/lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_string_rec lexbuf __ocaml_lex_state

and quoted_string delim lexbuf =
   __ocaml_lex_quoted_string_rec delim lexbuf 196
and __ocaml_lex_quoted_string_rec delim lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 654 "ml/lexer.mll"
      ( update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        quoted_string delim lexbuf
      )
# 2377 "ml/lexer.ml"

  | 1 ->
# 659 "ml/lexer.mll"
      ( is_in_string := false;
        raise (Error (Unterminated_string, !string_start_loc)) )
# 2383 "ml/lexer.ml"

  | 2 ->
# 662 "ml/lexer.mll"
      (
        let edelim = Lexing.lexeme lexbuf in
        let edelim = String.sub edelim 1 (String.length edelim - 2) in
        if delim = edelim then ()
        else (store_lexeme lexbuf; quoted_string delim lexbuf)
      )
# 2393 "ml/lexer.ml"

  | 3 ->
# 669 "ml/lexer.mll"
      ( store_string_char(Lexing.lexeme_char lexbuf 0);
        quoted_string delim lexbuf )
# 2399 "ml/lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_quoted_string_rec delim lexbuf __ocaml_lex_state

and skip_hash_bang lexbuf =
   __ocaml_lex_skip_hash_bang_rec lexbuf 205
and __ocaml_lex_skip_hash_bang_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 674 "ml/lexer.mll"
       ( update_loc lexbuf None 3 false 0 )
# 2411 "ml/lexer.ml"

  | 1 ->
# 676 "ml/lexer.mll"
       ( update_loc lexbuf None 1 false 0 )
# 2416 "ml/lexer.ml"

  | 2 ->
# 677 "ml/lexer.mll"
       ( () )
# 2421 "ml/lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_skip_hash_bang_rec lexbuf __ocaml_lex_state

;;

# 679 "ml/lexer.mll"
 
  let token_with_comments lexbuf =
    match !preprocessor with
    | None -> token lexbuf
    | Some (_init, preprocess) -> preprocess token lexbuf

  type newline_state =
    | NoLine (* There have been no blank lines yet. *)
    | NewLine
        (* There have been no blank lines, and the previous
           token was a newline. *)
    | BlankLine (* There have been blank lines. *)

  type doc_state =
    | Initial  (* There have been no docstrings yet *)
    | After of docstring list
        (* There have been docstrings, none of which were
           preceded by a blank line *)
    | Before of docstring list * docstring list * docstring list
        (* There have been docstrings, some of which were
           preceded by a blank line *)

  and docstring = Docstrings.docstring

  let token lexbuf =
    let post_pos = lexeme_end_p lexbuf in
    let attach lines docs pre_pos =
      let open Docstrings in
        match docs, lines with
        | Initial, _ -> ()
        | After a, (NoLine | NewLine) ->
            set_post_docstrings post_pos (List.rev a);
            set_pre_docstrings pre_pos a;
        | After a, BlankLine ->
            set_post_docstrings post_pos (List.rev a);
            set_pre_extra_docstrings pre_pos (List.rev a)
        | Before(a, f, b), (NoLine | NewLine) ->
            set_post_docstrings post_pos (List.rev a);
            set_post_extra_docstrings post_pos
              (List.rev_append f (List.rev b));
            set_floating_docstrings pre_pos (List.rev f);
            set_pre_extra_docstrings pre_pos (List.rev a);
            set_pre_docstrings pre_pos b
        | Before(a, f, b), BlankLine ->
            set_post_docstrings post_pos (List.rev a);
            set_post_extra_docstrings post_pos
              (List.rev_append f (List.rev b));
            set_floating_docstrings pre_pos
              (List.rev_append f (List.rev b));
            set_pre_extra_docstrings pre_pos (List.rev a)
    in
    let rec loop lines docs lexbuf =
      match token_with_comments lexbuf with
      | COMMENT (s, loc) ->
          add_comment (s, loc);
          let lines' =
            match lines with
            | NoLine -> NoLine
            | NewLine -> NoLine
            | BlankLine -> BlankLine
          in
          loop lines' docs lexbuf
      | EOL ->
          let lines' =
            match lines with
            | NoLine -> NewLine
            | NewLine -> BlankLine
            | BlankLine -> BlankLine
          in
          loop lines' docs lexbuf
      | HASH when Rescript_cpp.at_bol lexbuf -> 
          Rescript_cpp.interpret_directive lexbuf 
            ~cont:(fun lexbuf -> loop lines docs lexbuf)
            ~token_with_comments
      | DOCSTRING doc ->
          Docstrings.register doc;
          add_docstring_comment doc;
          let docs' =
            if Docstrings.docstring_body doc = "/*" then
              match docs with
              | Initial -> Before([], [doc], [])
              | After a -> Before (a, [doc], [])
              | Before(a, f, b) -> Before(a, doc :: b @ f, [])
            else
              match docs, lines with
              | Initial, (NoLine | NewLine) -> After [doc]
              | Initial, BlankLine -> Before([], [], [doc])
              | After a, (NoLine | NewLine) -> After (doc :: a)
              | After a, BlankLine -> Before (a, [], [doc])
              | Before(a, f, b), (NoLine | NewLine) -> Before(a, f, doc :: b)
              | Before(a, f, b), BlankLine -> Before(a, b @ f, [doc])
          in
          loop NoLine docs' lexbuf
      | tok ->
          attach lines docs (lexeme_start_p lexbuf);
          tok
    in
    Rescript_cpp.check_sharp_look_ahead (fun _ -> loop NoLine Initial lexbuf)

  let init () =
    Rescript_cpp.init ();
    is_in_string := false;
    comment_start_loc := [];
    comment_list := [];
    match !preprocessor with
    | None -> ()
    | Some (init, _preprocess) -> init ()


  let set_preprocessor init preprocess =
    escaped_newlines := true;
    preprocessor := Some (init, preprocess)


# 2543 "ml/lexer.ml"

end
module Parse : sig 
#1 "parse.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Entry points in the parser *)

val implementation : Lexing.lexbuf -> Parsetree.structure
val interface : Lexing.lexbuf -> Parsetree.signature
val core_type : Lexing.lexbuf -> Parsetree.core_type
val expression : Lexing.lexbuf -> Parsetree.expression
val pattern : Lexing.lexbuf -> Parsetree.pattern

end = struct
#1 "parse.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Entry points in the parser *)


let wrap parsing_fun lexbuf =
  try
    Docstrings.init ();
    Lexer.init ();
    let ast = parsing_fun Lexer.token lexbuf in
    Parsing.clear_parser();
    Docstrings.warn_bad_docstrings ();
    ast
  with
  | Parsing.Parse_error | Syntaxerr.Escape_error ->
      let loc = Location.curr lexbuf in
      raise(Syntaxerr.Error(Syntaxerr.Other loc))

let implementation = wrap Parser.implementation
and interface = wrap Parser.interface
and core_type = wrap Parser.parse_core_type
and expression = wrap Parser.parse_expression
and pattern = wrap Parser.parse_pattern

end
module Ounit_depends_format_test
= struct
#1 "ounit_depends_format_test.ml"
let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let (=~) (xs : string list) (ys : string list) = 
     OUnit.assert_equal xs ys 
     ~printer:(fun xs -> String.concat "," xs )

let f (x : string) = 
     let stru = Parse.implementation (Lexing.from_string x)  in 
     Ast_extract.Set_string.elements (Ast_extract.read_parse_and_extract Ml_binary.Ml stru)


let suites = 
  __FILE__
  >::: [
    __LOC__ >:: begin fun _ -> 
      f {|module X = List|} =~ ["List"];
      f {|module X = List module X0 = List1|} =~ ["List";"List1"]
    end 
  ]
end
module Ounit_ffi_error_debug_test
= struct
#1 "ounit_ffi_error_debug_test.ml"
let (//) = Filename.concat




let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal




let bsc_eval = Ounit_cmd_util.bsc_check_eval

let debug_output = Ounit_cmd_util.debug_output


let suites = 
    __FILE__ 
    >::: [
        __LOC__ >:: begin fun _ -> 
        let output = bsc_eval {|
external err : 
   hi_should_error:([`a of int | `b of string ] [@bs.string]) ->         
   unit -> _ = "" [@@bs.obj]
        |} in
        OUnit.assert_bool __LOC__
            (Ext_string.contain_substring output.stderr "hi_should_error")
        end;
        __LOC__ >:: begin fun _ -> 
let output = bsc_eval {|
    external err : 
   ?hi_should_error:([`a of int | `b of string ] [@bs.string]) ->         
   unit -> _ = "" [@@bs.obj]
        |} in
        OUnit.assert_bool __LOC__
            (Ext_string.contain_substring output.stderr "hi_should_error")        
        end;
        __LOC__ >:: begin fun _ -> 
        let output = bsc_eval {|
    external err : 
   ?hi_should_error:([`a of int | `b of string ] [@bs.string]) ->         
   unit -> unit = "err" [@@bs.val]
        |} in
        OUnit.assert_bool __LOC__
            (Ext_string.contain_substring output.stderr "hi_should_error")        
        end;

        __LOC__ >:: begin fun _ ->
          (*
             Each [@bs.unwrap] variant constructor requires an argument
          *)
          let output =
            bsc_eval {|
              external err :
              ?hi_should_error:([`a of int | `b] [@bs.unwrap]) -> unit -> unit = "err" [@@bs.val]
            |}
          in
          OUnit.assert_bool __LOC__
            (Ext_string.contain_substring output.stderr "unwrap")
        end;

        __LOC__ >:: begin fun _ ->
          (*
             [@bs.unwrap] args are not supported in [@@bs.obj] functions
          *)
          let output =
            bsc_eval {|
              external err :
              ?hi_should_error:([`a of int] [@bs.unwrap]) -> unit -> _ = "" [@@bs.obj]
            |}
          in
          OUnit.assert_bool __LOC__
            (Ext_string.contain_substring output.stderr "hi_should_error")
        end

    ]

end
module Hash_set_gen
= struct
#1 "hash_set_gen.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(* We do dynamic hashing, and resize the table and rehash the elements
   when buckets become too long. *)

type 'a bucket =
  | Empty
  | Cons of { mutable key : 'a; mutable next : 'a bucket }

type 'a t = {
  mutable size : int;
  (* number of entries *)
  mutable data : 'a bucket array;
  (* the buckets *)
  initial_size : int; (* initial array size *)
}

let create initial_size =
  let s = Ext_util.power_2_above 16 initial_size in
  { initial_size = s; size = 0; data = Array.make s Empty }

let clear h =
  h.size <- 0;
  let len = Array.length h.data in
  for i = 0 to len - 1 do
    Array.unsafe_set h.data i Empty
  done

let reset h =
  h.size <- 0;
  h.data <- Array.make h.initial_size Empty

let length h = h.size

let resize indexfun h =
  let odata = h.data in
  let osize = Array.length odata in
  let nsize = osize * 2 in
  if nsize < Sys.max_array_length then (
    let ndata = Array.make nsize Empty in
    let ndata_tail = Array.make nsize Empty in
    h.data <- ndata;
    (* so that indexfun sees the new bucket count *)
    let rec insert_bucket = function
      | Empty -> ()
      | Cons { key; next } as cell ->
          let nidx = indexfun h key in
          (match Array.unsafe_get ndata_tail nidx with
          | Empty -> Array.unsafe_set ndata nidx cell
          | Cons tail -> tail.next <- cell);
          Array.unsafe_set ndata_tail nidx cell;
          insert_bucket next
    in
    for i = 0 to osize - 1 do
      insert_bucket (Array.unsafe_get odata i)
    done;
    for i = 0 to nsize - 1 do
      match Array.unsafe_get ndata_tail i with
      | Empty -> ()
      | Cons tail -> tail.next <- Empty
    done)

let iter h f =
  let rec do_bucket = function
    | Empty -> ()
    | Cons l ->
        f l.key;
        do_bucket l.next
  in
  let d = h.data in
  for i = 0 to Array.length d - 1 do
    do_bucket (Array.unsafe_get d i)
  done

let fold h init f =
  let rec do_bucket b accu =
    match b with Empty -> accu | Cons l -> do_bucket l.next (f l.key accu)
  in
  let d = h.data in
  let accu = ref init in
  for i = 0 to Array.length d - 1 do
    accu := do_bucket (Array.unsafe_get d i) !accu
  done;
  !accu

let to_list set = fold set [] List.cons

let rec small_bucket_mem eq key lst =
  match lst with
  | Empty -> false
  | Cons lst -> (
      eq key lst.key
      ||
      match lst.next with
      | Empty -> false
      | Cons lst -> (
          eq key lst.key
          ||
          match lst.next with
          | Empty -> false
          | Cons lst -> eq key lst.key || small_bucket_mem eq key lst.next))

let rec remove_bucket (h : _ t) (i : int) key ~(prec : _ bucket)
    (buck : _ bucket) eq_key =
  match buck with
  | Empty -> ()
  | Cons { key = k; next } ->
      if eq_key k key then (
        h.size <- h.size - 1;
        match prec with
        | Empty -> Array.unsafe_set h.data i next
        | Cons c -> c.next <- next)
      else remove_bucket h i key ~prec:buck next eq_key

module type S = sig
  type key

  type t

  val create : int -> t

  val clear : t -> unit

  val reset : t -> unit

  (* val copy: t -> t *)
  val remove : t -> key -> unit

  val add : t -> key -> unit

  val of_array : key array -> t

  val check_add : t -> key -> bool

  val mem : t -> key -> bool

  val iter : t -> (key -> unit) -> unit

  val fold : t -> 'b -> (key -> 'b -> 'b) -> 'b

  val length : t -> int

  (* val stats:  t -> Hashtbl.statistics *)
  val to_list : t -> key list
end

end
module Hash_set : sig 
#1 "hash_set.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** Ideas are based on {!Hash}, 
    however, {!Hash.add} does not really optimize and has a bad semantics for {!Hash_set}, 
    This module fixes the semantics of [add].
    [remove] is not optimized since it is not used too much 
*)

(** A naive t implementation on top of [hashtbl], the value is [unit]*)
module Make (H : Hashtbl.HashedType) : Hash_set_gen.S with type key = H.t

end = struct
#1 "hash_set.ml"
# 1 "ext/hash_set.cppo.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
[@@@warning "-32"] (* FIXME *)
# 44 "ext/hash_set.cppo.ml"
module Make (H: Hashtbl.HashedType) : (Hash_set_gen.S with type key = H.t) = struct 
  type key = H.t 
  let eq_key = H.equal
  let key_index (h :  _ Hash_set_gen.t ) key =
    (H.hash  key) land (Array.length h.data - 1)
  type t = key Hash_set_gen.t



      
# 65 "ext/hash_set.cppo.ml"
      let create = Hash_set_gen.create
  let clear = Hash_set_gen.clear
  let reset = Hash_set_gen.reset
  (* let copy = Hash_set_gen.copy *)
  let iter = Hash_set_gen.iter
  let fold = Hash_set_gen.fold
  let length = Hash_set_gen.length
  (* let stats = Hash_set_gen.stats *)
  let to_list = Hash_set_gen.to_list



  let remove (h : _ Hash_set_gen.t ) key =
    let i = key_index h key in
    let h_data = h.data in 
    Hash_set_gen.remove_bucket h i key ~prec:Empty (Array.unsafe_get h_data i) eq_key    



  let add (h : _ Hash_set_gen.t) key =
    let i = key_index h key  in 
    let h_data = h.data in 
    let old_bucket = (Array.unsafe_get h_data i) in
    if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
      begin 
        Array.unsafe_set h_data i (Cons {key = key ; next =  old_bucket});
        h.size <- h.size + 1 ;
        if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h
      end

  let of_array arr = 
    let len = Array.length arr in 
    let tbl = create len in 
    for i = 0 to len - 1  do
      add tbl (Array.unsafe_get arr i);
    done ;
    tbl 


  let check_add (h : _ Hash_set_gen.t) key : bool =
    let i = key_index h key  in 
    let h_data = h.data in  
    let old_bucket = (Array.unsafe_get h_data i) in
    if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
      begin 
        Array.unsafe_set h_data i  (Cons { key = key ; next =  old_bucket});
        h.size <- h.size + 1 ;
        if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h;
        true 
      end
    else false 


  let mem (h :  _ Hash_set_gen.t) key =
    Hash_set_gen.small_bucket_mem eq_key key (Array.unsafe_get h.data (key_index h key)) 

# 122 "ext/hash_set.cppo.ml"
end


end
module Hash_set_poly : sig 
#1 "hash_set_poly.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type 'a t

val create : int -> 'a t

val clear : 'a t -> unit

val reset : 'a t -> unit

(* val copy : 'a t -> 'a t *)

val add : 'a t -> 'a -> unit

val remove : 'a t -> 'a -> unit

val mem : 'a t -> 'a -> bool

val iter : 'a t -> ('a -> unit) -> unit

val to_list : 'a t -> 'a list

val length : 'a t -> int

(* val stats:  'a t -> Hashtbl.statistics *)

end = struct
#1 "hash_set_poly.ml"
# 1 "ext/hash_set.cppo.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
[@@@warning "-32"] (* FIXME *)
  
# 52 "ext/hash_set.cppo.ml"
  [@@@ocaml.warning "-3"]
  (* we used cppo the mixture does not work*)
  external seeded_hash_param :
    int -> int -> int -> 'a -> int = "caml_hash" "noalloc"
  let key_index (h :  _ Hash_set_gen.t ) (key : 'a) =
    seeded_hash_param 10 100 0 key land (Array.length h.data - 1)
  let eq_key = (=)
  type  'a t = 'a Hash_set_gen.t 


      
# 65 "ext/hash_set.cppo.ml"
      let create = Hash_set_gen.create
  let clear = Hash_set_gen.clear
  let reset = Hash_set_gen.reset
  (* let copy = Hash_set_gen.copy *)
  let iter = Hash_set_gen.iter
  let fold = Hash_set_gen.fold
  let length = Hash_set_gen.length
  (* let stats = Hash_set_gen.stats *)
  let to_list = Hash_set_gen.to_list



  let remove (h : _ Hash_set_gen.t ) key =
    let i = key_index h key in
    let h_data = h.data in 
    Hash_set_gen.remove_bucket h i key ~prec:Empty (Array.unsafe_get h_data i) eq_key    



  let add (h : _ Hash_set_gen.t) key =
    let i = key_index h key  in 
    let h_data = h.data in 
    let old_bucket = (Array.unsafe_get h_data i) in
    if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
      begin 
        Array.unsafe_set h_data i (Cons {key = key ; next =  old_bucket});
        h.size <- h.size + 1 ;
        if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h
      end

  let of_array arr = 
    let len = Array.length arr in 
    let tbl = create len in 
    for i = 0 to len - 1  do
      add tbl (Array.unsafe_get arr i);
    done ;
    tbl 


  let check_add (h : _ Hash_set_gen.t) key : bool =
    let i = key_index h key  in 
    let h_data = h.data in  
    let old_bucket = (Array.unsafe_get h_data i) in
    if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
      begin 
        Array.unsafe_set h_data i  (Cons { key = key ; next =  old_bucket});
        h.size <- h.size + 1 ;
        if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h;
        true 
      end
    else false 


  let mem (h :  _ Hash_set_gen.t) key =
    Hash_set_gen.small_bucket_mem eq_key key (Array.unsafe_get h.data (key_index h key)) 



end
module Hash_set_string : sig 
#1 "hash_set_string.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

include Hash_set_gen.S with type key = string

end = struct
#1 "hash_set_string.ml"
# 1 "ext/hash_set.cppo.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
[@@@warning "-32"] (* FIXME *)
# 32 "ext/hash_set.cppo.ml"
type key = string 
let key_index (h :  _ Hash_set_gen.t ) (key : key) =
  (Bs_hash_stubs.hash_string  key) land (Array.length h.data - 1)
let eq_key = Ext_string.equal 
type  t = key  Hash_set_gen.t 


      
# 65 "ext/hash_set.cppo.ml"
      let create = Hash_set_gen.create
  let clear = Hash_set_gen.clear
  let reset = Hash_set_gen.reset
  (* let copy = Hash_set_gen.copy *)
  let iter = Hash_set_gen.iter
  let fold = Hash_set_gen.fold
  let length = Hash_set_gen.length
  (* let stats = Hash_set_gen.stats *)
  let to_list = Hash_set_gen.to_list



  let remove (h : _ Hash_set_gen.t ) key =
    let i = key_index h key in
    let h_data = h.data in 
    Hash_set_gen.remove_bucket h i key ~prec:Empty (Array.unsafe_get h_data i) eq_key    



  let add (h : _ Hash_set_gen.t) key =
    let i = key_index h key  in 
    let h_data = h.data in 
    let old_bucket = (Array.unsafe_get h_data i) in
    if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
      begin 
        Array.unsafe_set h_data i (Cons {key = key ; next =  old_bucket});
        h.size <- h.size + 1 ;
        if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h
      end

  let of_array arr = 
    let len = Array.length arr in 
    let tbl = create len in 
    for i = 0 to len - 1  do
      add tbl (Array.unsafe_get arr i);
    done ;
    tbl 


  let check_add (h : _ Hash_set_gen.t) key : bool =
    let i = key_index h key  in 
    let h_data = h.data in  
    let old_bucket = (Array.unsafe_get h_data i) in
    if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
      begin 
        Array.unsafe_set h_data i  (Cons { key = key ; next =  old_bucket});
        h.size <- h.size + 1 ;
        if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h;
        true 
      end
    else false 


  let mem (h :  _ Hash_set_gen.t) key =
    Hash_set_gen.small_bucket_mem eq_key key (Array.unsafe_get h.data (key_index h key)) 



end
module Ounit_hash_set_tests
= struct
#1 "ounit_hash_set_tests.ml"
let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal

type id = { name : string ; stamp : int }

module Id_hash_set = Hash_set.Make(struct 
    type t = id 
    let equal x y = x.stamp = y.stamp && x.name = y.name 
    let hash x = Hashtbl.hash x.stamp
  end
  )

let const_tbl = [|"0"; "1"; "2"; "3"; "4"; "5"; "6"; "7"; "8"; "9"; "10"; "100"; "99"; "98";
          "97"; "96"; "95"; "94"; "93"; "92"; "91"; "90"; "89"; "88"; "87"; "86"; "85";
          "84"; "83"; "82"; "81"; "80"; "79"; "78"; "77"; "76"; "75"; "74"; "73"; "72";
          "71"; "70"; "69"; "68"; "67"; "66"; "65"; "64"; "63"; "62"; "61"; "60"; "59";
          "58"; "57"; "56"; "55"; "54"; "53"; "52"; "51"; "50"; "49"; "48"; "47"; "46";
          "45"; "44"; "43"; "42"; "41"; "40"; "39"; "38"; "37"; "36"; "35"; "34"; "33";
          "32"; "31"; "30"; "29"; "28"; "27"; "26"; "25"; "24"; "23"; "22"; "21"; "20";
          "19"; "18"; "17"; "16"; "15"; "14"; "13"; "12"; "11"|]
let suites = 
  __FILE__
  >:::
  [
    __LOC__ >:: begin fun _ ->
      let v = Hash_set_poly.create 31 in
      for i = 0 to 1000 do
        Hash_set_poly.add v i  
      done  ;
      OUnit.assert_equal (Hash_set_poly.length v) 1001
    end ;
    __LOC__ >:: begin fun _ ->
      let v = Hash_set_poly.create 31 in
      for _ = 0 to 1_0_000 do
        Hash_set_poly.add v 0
      done  ;
      OUnit.assert_equal (Hash_set_poly.length v) 1
    end ;
    __LOC__ >:: begin fun _ -> 
      let v = Hash_set_poly.create 30 in 
      for i = 0 to 2_000 do 
        Hash_set_poly.add v {name = "x" ; stamp = i}
      done ;
      for i = 0 to 2_000 do 
        Hash_set_poly.add v {name = "x" ; stamp = i}
      done  ; 
      for i = 0 to 2_000 do 
        assert (Hash_set_poly.mem v {name = "x"; stamp = i})
      done;  
      OUnit.assert_equal (Hash_set_poly.length v)  2_001;
      for i =  1990 to 3_000 do 
        Hash_set_poly.remove v {name = "x"; stamp = i}
      done ;
      OUnit.assert_equal (Hash_set_poly.length v) 1990;
      (* OUnit.assert_equal (Hash_set.stats v) *)
      (*   {Hashtbl.num_bindings = 1990; num_buckets = 1024; max_bucket_length = 7; *)
      (*    bucket_histogram = [|139; 303; 264; 178; 93; 32; 12; 3|]} *)
    end ;
    __LOC__ >:: begin fun _ -> 
      let v = Id_hash_set.create 30 in 
      for i = 0 to 2_000 do 
        Id_hash_set.add v {name = "x" ; stamp = i}
      done ;
      for i = 0 to 2_000 do 
        Id_hash_set.add v {name = "x" ; stamp = i}
      done  ; 
      for i = 0 to 2_000 do 
        assert (Id_hash_set.mem v {name = "x"; stamp = i})
      done;  
      OUnit.assert_equal (Id_hash_set.length v)  2_001;
      for i =  1990 to 3_000 do 
        Id_hash_set.remove v {name = "x"; stamp = i}
      done ;
      OUnit.assert_equal (Id_hash_set.length v) 1990;
      for i = 1000 to 3990 do 
        Id_hash_set.remove v { name = "x"; stamp = i }
      done;
      OUnit.assert_equal (Id_hash_set.length v) 1000;
      for i = 1000 to 1100 do 
        Id_hash_set.add v { name = "x"; stamp = i};
      done;
      OUnit.assert_equal (Id_hash_set.length v ) 1101;
      for i = 0 to 1100 do 
        OUnit.assert_bool "exist" (Id_hash_set.mem v {name = "x"; stamp = i})
      done  
      (* OUnit.assert_equal (Hash_set.stats v) *)
      (*   {num_bindings = 1990; num_buckets = 1024; max_bucket_length = 8; *)
      (*    bucket_histogram = [|148; 275; 285; 182; 95; 21; 14; 2; 2|]} *)

    end 
    ;
    __LOC__ >:: begin fun _ -> 
      let duplicate arr = 
        let len = Array.length arr in 
        let rec aux tbl off = 
          if off >= len  then None
          else 
            let curr = (Array.unsafe_get arr off) in
            if Hash_set_string.check_add tbl curr then 
              aux tbl (off + 1)
            else   Some curr in 
        aux (Hash_set_string.create len) 0 in 
      let v = [| "if"; "a"; "b"; "c" |] in 
      OUnit.assert_equal (duplicate v) None;
      OUnit.assert_equal (duplicate [|"if"; "a"; "b"; "b"; "c"|]) (Some "b")
    end;
    __LOC__ >:: begin fun _ -> 
      let of_array lst =
        let len = Array.length lst in 
        let tbl = Hash_set_string.create len in 
        Ext_array.iter lst (Hash_set_string.add tbl) ; tbl  in 
      let hash = of_array const_tbl  in 
      let len = Hash_set_string.length hash in 
      Hash_set_string.remove hash "x";
      OUnit.assert_equal len (Hash_set_string.length hash);
      Hash_set_string.remove hash "0";
      OUnit.assert_equal (len - 1 ) (Hash_set_string.length hash)
    end
  ]

end
module Hash_set_int : sig 
#1 "hash_set_int.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

include Hash_set_gen.S with type key = int

end = struct
#1 "hash_set_int.ml"
# 1 "ext/hash_set.cppo.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
[@@@warning "-32"] (* FIXME *)
# 26 "ext/hash_set.cppo.ml"
type key = int
let key_index (h :  _ Hash_set_gen.t ) (key : key) =
  (Bs_hash_stubs.hash_int  key) land (Array.length h.data - 1)
let eq_key = Ext_int.equal 
type  t = key  Hash_set_gen.t 


      
# 65 "ext/hash_set.cppo.ml"
      let create = Hash_set_gen.create
  let clear = Hash_set_gen.clear
  let reset = Hash_set_gen.reset
  (* let copy = Hash_set_gen.copy *)
  let iter = Hash_set_gen.iter
  let fold = Hash_set_gen.fold
  let length = Hash_set_gen.length
  (* let stats = Hash_set_gen.stats *)
  let to_list = Hash_set_gen.to_list



  let remove (h : _ Hash_set_gen.t ) key =
    let i = key_index h key in
    let h_data = h.data in 
    Hash_set_gen.remove_bucket h i key ~prec:Empty (Array.unsafe_get h_data i) eq_key    



  let add (h : _ Hash_set_gen.t) key =
    let i = key_index h key  in 
    let h_data = h.data in 
    let old_bucket = (Array.unsafe_get h_data i) in
    if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
      begin 
        Array.unsafe_set h_data i (Cons {key = key ; next =  old_bucket});
        h.size <- h.size + 1 ;
        if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h
      end

  let of_array arr = 
    let len = Array.length arr in 
    let tbl = create len in 
    for i = 0 to len - 1  do
      add tbl (Array.unsafe_get arr i);
    done ;
    tbl 


  let check_add (h : _ Hash_set_gen.t) key : bool =
    let i = key_index h key  in 
    let h_data = h.data in  
    let old_bucket = (Array.unsafe_get h_data i) in
    if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
      begin 
        Array.unsafe_set h_data i  (Cons { key = key ; next =  old_bucket});
        h.size <- h.size + 1 ;
        if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h;
        true 
      end
    else false 


  let mem (h :  _ Hash_set_gen.t) key =
    Hash_set_gen.small_bucket_mem eq_key key (Array.unsafe_get h.data (key_index h key)) 



end
module Ounit_hash_stubs_test
= struct
#1 "ounit_hash_stubs_test.ml"
let ((>::),
    (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal

let count = 2_000_000

let bench () = 
  Ounit_tests_util.time "int hash set" begin fun _ -> 
    let v = Hash_set_int.create 2_000_000 in 
    for i = 0 to  count do 
      Hash_set_int.add  v i
    done ;
    for _ = 0 to 3 do 
      for i = 0 to count do 
        assert (Hash_set_int.mem v i)
      done
    done
  end;
  Ounit_tests_util.time "int hash set" begin fun _ -> 
    let v = Hash_set_poly.create 2_000_000 in 
    for i = 0 to  count do 
      Hash_set_poly.add  v i
    done ;
    for _ = 0 to 3 do 
      for i = 0 to count do 
        assert (Hash_set_poly.mem v i)
     done
    done
  end


type id (* = Ident.t *) = { stamp : int; name : string; mutable flags : int; }
let hash id = Bs_hash_stubs.hash_stamp_and_name id.stamp id.name 
let suites = 
    __FILE__
    >:::
    [
      __LOC__ >:: begin fun _ -> 
        Bs_hash_stubs.hash_int 0 =~ Hashtbl.hash 0
      end;
      __LOC__ >:: begin fun _ -> 
        Bs_hash_stubs.hash_int max_int =~ Hashtbl.hash max_int
      end;
      __LOC__ >:: begin fun _ -> 
        Bs_hash_stubs.hash_int max_int =~ Hashtbl.hash max_int
      end;
      __LOC__ >:: begin fun _ -> 
        Bs_hash_stubs.hash_string "The quick brown fox jumps over the lazy dog"  =~ 
        Hashtbl.hash "The quick brown fox jumps over the lazy dog"
      end;
      __LOC__ >:: begin fun _ ->
        Array.init 100 (fun i -> String.make i 'a' )
        |> Array.iter (fun x -> 
          Bs_hash_stubs.hash_string x =~ Hashtbl.hash x) 
      end;
      __LOC__ >:: begin fun _ ->
        (* only stamp matters here *)
        hash {stamp = 1 ; name = "xx"; flags = 0} =~ Bs_hash_stubs.hash_small_int 1 ;
        hash {stamp = 11 ; name = "xx"; flags = 0} =~ Bs_hash_stubs.hash_small_int 11;
      end;
      __LOC__ >:: begin fun _ ->
        (* only string matters here *)
        hash {stamp = 0 ; name = "Pervasives"; flags = 0} =~ Bs_hash_stubs.hash_string "Pervasives";
        hash {stamp = 0 ; name = "UU"; flags = 0} =~ Bs_hash_stubs.hash_string "UU";
      end;
      __LOC__ >:: begin fun _ -> 
        let v = Array.init 20 (fun i -> i) in 
        let u = Array.init 30 (fun i ->   (0-i)  ) in  
        Bs_hash_stubs.int_unsafe_blit 
         v 0 u 10 20 ; 
        OUnit.assert_equal u (Array.init 30 (fun i -> if i < 10 then -i else i - 10)) 
      end
    ]

end
module Ext_obj : sig 
#1 "ext_obj.mli"
(* Copyright (C) 2019-Present Authors of ReScript 
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
val dump : 'a -> string

val dump_endline : ?__LOC__:string -> 'a -> unit

val pp_any : Format.formatter -> 'a -> unit

val bt : unit -> unit

end = struct
#1 "ext_obj.ml"
(* Copyright (C) 2019-Present Hongbo Zhang, Authors of ReScript 
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let rec dump r =
  if Obj.is_int r then string_of_int (Obj.magic r : int)
  else
    (* Block. *)
    let rec get_fields acc = function
      | 0 -> acc
      | n ->
          let n = n - 1 in
          get_fields (Obj.field r n :: acc) n
    in
    let rec is_list r =
      if Obj.is_int r then r = Obj.repr 0 (* [] *)
      else
        let s = Obj.size r and t = Obj.tag r in
        t = 0 && s = 2 && is_list (Obj.field r 1)
      (* h :: t *)
    in
    let rec get_list r =
      if Obj.is_int r then []
      else
        let h = Obj.field r 0 and t = get_list (Obj.field r 1) in
        h :: t
    in
    let opaque name =
      (* XXX In future, print the address of value 'r'.  Not possible
       * in pure OCaml at the moment. *)
      "<" ^ name ^ ">"
    in
    let s = Obj.size r and t = Obj.tag r in
    (* From the tag, determine the type of block. *)
    match t with
    | _ when is_list r ->
        let fields = get_list r in
        "[" ^ String.concat "; " (Ext_list.map fields dump) ^ "]"
    | 0 ->
        let fields = get_fields [] s in
        "(" ^ String.concat ", " (Ext_list.map fields dump) ^ ")"
    | x when x = Obj.lazy_tag ->
        (* Note that [lazy_tag .. forward_tag] are < no_scan_tag.  Not
           * clear if very large constructed values could have the same
           * tag. XXX *)
        opaque "lazy"
    | x when x = Obj.closure_tag -> opaque "closure"
    | x when x = Obj.object_tag ->
        let fields = get_fields [] s in
        let _clasz, id, slots =
          match fields with h :: h' :: t -> (h, h', t) | _ -> assert false
        in
        (* No information on decoding the class (first field).  So just print
           * out the ID and the slots. *)
        "Object #" ^ dump id ^ " ("
        ^ String.concat ", " (Ext_list.map slots dump)
        ^ ")"
    | x when x = Obj.infix_tag -> opaque "infix"
    | x when x = Obj.forward_tag -> opaque "forward"
    | x when x < Obj.no_scan_tag ->
        let fields = get_fields [] s in
        "Tag" ^ string_of_int t ^ " ("
        ^ String.concat ", " (Ext_list.map fields dump)
        ^ ")"
    | x when x = Obj.string_tag ->
        "\"" ^ String.escaped (Obj.magic r : string) ^ "\""
    | x when x = Obj.double_tag -> string_of_float (Obj.magic r : float)
    | x when x = Obj.abstract_tag -> opaque "abstract"
    | x when x = Obj.custom_tag -> opaque "custom"
    | x when x = Obj.custom_tag -> opaque "final"
    | x when x = Obj.double_array_tag ->
        "[|"
        ^ String.concat ";"
            (Array.to_list
               (Array.map string_of_float (Obj.magic r : float array)))
        ^ "|]"
    | _ -> opaque (Printf.sprintf "unknown: tag %d size %d" t s)

let dump v = dump (Obj.repr v)

let dump_endline ?(__LOC__ = "") v =
  print_endline __LOC__;
  print_endline (dump v)

let pp_any fmt v = Format.fprintf fmt "@[%s@]" (dump v)

let bt () =
  let raw_bt = Printexc.backtrace_slots (Printexc.get_raw_backtrace ()) in
  match raw_bt with
  | None -> ()
  | Some raw_bt ->
      let acc = ref [] in
      for i = Array.length raw_bt - 1 downto 0 do
        let slot = raw_bt.(i) in
        match Printexc.Slot.location slot with
        | None -> ()
        | Some bt -> (
            match !acc with
            | [] -> acc := [ bt ]
            | hd :: _ -> if hd <> bt then acc := bt :: !acc)
      done;
      Ext_list.iter !acc (fun bt ->
          Printf.eprintf "File \"%s\", line %d, characters %d-%d\n" bt.filename
            bt.line_number bt.start_char bt.end_char)

end
module Ounit_hashtbl_tests
= struct
#1 "ounit_hashtbl_tests.ml"
let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal ~printer:Ext_obj.dump


let suites = 
  __FILE__
  >:::[
    (* __LOC__ >:: begin fun _ ->  *)
    (*   let h = Hash_string.create 0 in  *)
    (*   let accu key = *)
    (*     Hash_string.replace_or_init h key   succ 1 in  *)
    (*   let count = 1000 in  *)
    (*   for i = 0 to count - 1 do      *)
    (*     Array.iter accu  [|"a";"b";"c";"d";"e";"f"|]     *)
    (*   done; *)
    (*   Hash_string.length h =~ 6; *)
    (*   Hash_string.iter (fun _ v -> v =~ count ) h *)
    (* end; *)

    "add semantics " >:: begin fun _ -> 
      let h = Hash_string.create 0 in 
      let count = 1000 in 
      for _ = 0 to 1 do  
        for i = 0 to count - 1 do                 
          Hash_string.add h (string_of_int i) i 
        done
      done ;
      Hash_string.length h =~ 2 * count 
    end; 
    "replace semantics" >:: begin fun _ -> 
      let h = Hash_string.create 0 in 
      let count = 1000 in 
      for _ = 0 to 1 do  
        for i = 0 to count - 1 do                 
          Hash_string.replace h (string_of_int i) i 
        done
      done ;
      Hash_string.length h =~  count 
    end; 
    
    __LOC__ >:: begin fun _ ->
      let h = Hash_string.create 0 in 
      let count = 10 in 
      for i = 0 to count - 1 do 
        Hash_string.replace h (string_of_int i) i
      done; 
      let xs = Hash_string.to_list h (fun k _ -> k) in 
      let ys = List.sort compare xs  in 
      ys =~ ["0";"1";"2";"3";"4";"5";"6";"7";"8";"9"]
    end
  ]

end
module Identifiable : sig 
#1 "identifiable.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                       Pierre Chambart, OCamlPro                        *)
(*           Mark Shinwell and Leo White, Jane Street Europe              *)
(*                                                                        *)
(*   Copyright 2013--2016 OCamlPro SAS                                    *)
(*   Copyright 2014--2016 Jane Street Group LLC                           *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Uniform interface for common data structures over various things. *)

module type Thing = sig
  type t

  include Hashtbl.HashedType with type t := t
  include Map.OrderedType with type t := t

  val output : out_channel -> t -> unit
  val print : Format.formatter -> t -> unit
end

module Pair : functor (A : Thing) (B : Thing) -> Thing with type t = A.t * B.t

module type Set = sig
  module T : Set.OrderedType
  include Set.S
    with type elt = T.t
     and type t = Set.Make (T).t

  val output : out_channel -> t -> unit
  val print : Format.formatter -> t -> unit
  val to_string : t -> string
  val of_list : elt list -> t
  val map : (elt -> elt) -> t -> t
end

module type Map = sig
  module T : Map.OrderedType
  include Map.S
    with type key = T.t
     and type 'a t = 'a Map.Make (T).t

  val filter_map : (key -> 'a -> 'b option) -> 'a t -> 'b t
  val of_list : (key * 'a) list -> 'a t

  (** [disjoint_union m1 m2] contains all bindings from [m1] and
      [m2]. If some binding is present in both and the associated
      value is not equal, a Fatal_error is raised *)
  val disjoint_union : ?eq:('a -> 'a -> bool) -> ?print:(Format.formatter -> 'a -> unit) -> 'a t -> 'a t -> 'a t

  (** [union_right m1 m2] contains all bindings from [m1] and [m2]. If
      some binding is present in both, the one from [m2] is taken *)
  val union_right : 'a t -> 'a t -> 'a t

  (** [union_left m1 m2 = union_right m2 m1] *)
  val union_left : 'a t -> 'a t -> 'a t

  val union_merge : ('a -> 'a -> 'a) -> 'a t -> 'a t -> 'a t
  val rename : key t -> key -> key
  val map_keys : (key -> key) -> 'a t -> 'a t
  val keys : 'a t -> Set.Make(T).t
  val data : 'a t -> 'a list
  val of_set : (key -> 'a) -> Set.Make(T).t -> 'a t
  val transpose_keys_and_data : key t -> key t
  val transpose_keys_and_data_set : key t -> Set.Make(T).t t
  val print :
    (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a t -> unit
end

module type Tbl = sig
  module T : sig
    type t
    include Map.OrderedType with type t := t
    include Hashtbl.HashedType with type t := t
  end
  include Hashtbl.S
    with type key = T.t
     and type 'a t = 'a Hashtbl.Make (T).t

  val to_list : 'a t -> (T.t * 'a) list
  val of_list : (T.t * 'a) list -> 'a t

  val to_map : 'a t -> 'a Map.Make(T).t
  val of_map : 'a Map.Make(T).t -> 'a t
  val memoize : 'a t -> (key -> 'a) -> key -> 'a
  val map : 'a t -> ('a -> 'b) -> 'b t
end

module type S = sig
  type t

  module T : Thing with type t = t
  include Thing with type t := T.t

  module Set : Set with module T := T
  module Map : Map with module T := T
  module Tbl : Tbl with module T := T
end

module Make (T : Thing) : S with type t := T.t

end = struct
#1 "identifiable.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                       Pierre Chambart, OCamlPro                        *)
(*           Mark Shinwell and Leo White, Jane Street Europe              *)
(*                                                                        *)
(*   Copyright 2013--2016 OCamlPro SAS                                    *)
(*   Copyright 2014--2016 Jane Street Group LLC                           *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module type Thing = sig
  type t

  include Hashtbl.HashedType with type t := t
  include Map.OrderedType with type t := t

  val output : out_channel -> t -> unit
  val print : Format.formatter -> t -> unit
end

module type Set = sig
  module T : Set.OrderedType
  include Set.S
    with type elt = T.t
     and type t = Set.Make (T).t

  val output : out_channel -> t -> unit
  val print : Format.formatter -> t -> unit
  val to_string : t -> string
  val of_list : elt list -> t
  val map : (elt -> elt) -> t -> t
end

module type Map = sig
  module T : Map.OrderedType
  include Map.S
    with type key = T.t
     and type 'a t = 'a Map.Make (T).t

  val filter_map : (key -> 'a -> 'b option) -> 'a t -> 'b t
  val of_list : (key * 'a) list -> 'a t

  val disjoint_union : ?eq:('a -> 'a -> bool) -> ?print:(Format.formatter -> 'a -> unit) -> 'a t -> 'a t -> 'a t

  val union_right : 'a t -> 'a t -> 'a t

  val union_left : 'a t -> 'a t -> 'a t

  val union_merge : ('a -> 'a -> 'a) -> 'a t -> 'a t -> 'a t
  val rename : key t -> key -> key
  val map_keys : (key -> key) -> 'a t -> 'a t
  val keys : 'a t -> Set.Make(T).t
  val data : 'a t -> 'a list
  val of_set : (key -> 'a) -> Set.Make(T).t -> 'a t
  val transpose_keys_and_data : key t -> key t
  val transpose_keys_and_data_set : key t -> Set.Make(T).t t
  val print :
    (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a t -> unit
end

module type Tbl = sig
  module T : sig
    type t
    include Map.OrderedType with type t := t
    include Hashtbl.HashedType with type t := t
  end
  include Hashtbl.S
    with type key = T.t
     and type 'a t = 'a Hashtbl.Make (T).t

  val to_list : 'a t -> (T.t * 'a) list
  val of_list : (T.t * 'a) list -> 'a t

  val to_map : 'a t -> 'a Map.Make(T).t
  val of_map : 'a Map.Make(T).t -> 'a t
  val memoize : 'a t -> (key -> 'a) -> key -> 'a
  val map : 'a t -> ('a -> 'b) -> 'b t
end

module Pair (A : Thing) (B : Thing) : Thing with type t = A.t * B.t = struct
  type t = A.t * B.t

  let compare (a1, b1) (a2, b2) =
    let c = A.compare a1 a2 in
    if c <> 0 then c
    else B.compare b1 b2

  let output oc (a, b) = Printf.fprintf oc " (%a, %a)" A.output a B.output b
  let hash (a, b) = Hashtbl.hash (A.hash a, B.hash b)
  let equal (a1, b1) (a2, b2) = A.equal a1 a2 && B.equal b1 b2
  let print ppf (a, b) = Format.fprintf ppf " (%a, @ %a)" A.print a B.print b
end

module Make_map (T : Thing) = struct
  include Map.Make (T)

  let filter_map f t  =
    fold (fun id v map ->
        match f id v with
        | None -> map
        | Some r -> add id r map) t empty

  let of_list l =
    List.fold_left (fun map (id, v) -> add id v map) empty l

  let disjoint_union ?eq ?print m1 m2 =
    union (fun id v1 v2 ->
        let ok = match eq with
          | None -> false
          | Some eq -> eq v1 v2
        in
        if not ok then
          let err =
            match print with
            | None ->
              Format.asprintf "Map.disjoint_union %a" T.print id
            | Some print ->
              Format.asprintf "Map.disjoint_union %a => %a <> %a"
                T.print id print v1 print v2
          in
          Misc.fatal_error err
        else Some v1)
      m1 m2

  let union_right m1 m2 =
    merge (fun _id x y -> match x, y with
        | None, None -> None
        | None, Some v
        | Some v, None
        | Some _, Some v -> Some v)
      m1 m2

  let union_left m1 m2 = union_right m2 m1

  let union_merge f m1 m2 =
    let aux _ m1 m2 =
      match m1, m2 with
      | None, m | m, None -> m
      | Some m1, Some m2 -> Some (f m1 m2)
    in
    merge aux m1 m2

  let rename m v =
    try find v m
    with Not_found -> v

  let map_keys f m =
    of_list (List.map (fun (k, v) -> f k, v) (bindings m))

  let print f ppf s =
    let elts ppf s = iter (fun id v ->
        Format.fprintf ppf "@ (@[%a@ %a@])" T.print id f v) s in
    Format.fprintf ppf "@[<1>{@[%a@ @]}@]" elts s

  module T_set = Set.Make (T)

  let keys map = fold (fun k _ set -> T_set.add k set) map T_set.empty

  let data t = List.map snd (bindings t)

  let of_set f set = T_set.fold (fun e map -> add e (f e) map) set empty

  let transpose_keys_and_data map = fold (fun k v m -> add v k m) map empty
  let transpose_keys_and_data_set map =
    fold (fun k v m ->
        let set =
          match find v m with
          | exception Not_found ->
            T_set.singleton k
          | set ->
            T_set.add k set
        in
        add v set m)
      map empty
end

module Make_set (T : Thing) = struct
  include Set.Make (T)

  let output oc s =
    Printf.fprintf oc " ( ";
    iter (fun v -> Printf.fprintf oc "%a " T.output v) s;
    Printf.fprintf oc ")"

  let print ppf s =
    let elts ppf s = iter (fun e -> Format.fprintf ppf "@ %a" T.print e) s in
    Format.fprintf ppf "@[<1>{@[%a@ @]}@]" elts s

  let to_string s = Format.asprintf "%a" print s

  let of_list l = match l with
    | [] -> empty
    | [t] -> singleton t
    | t :: q -> List.fold_left (fun acc e -> add e acc) (singleton t) q

  let map f s = of_list (List.map f (elements s))
end

module Make_tbl (T : Thing) = struct
  include Hashtbl.Make (T)

  module T_map = Make_map (T)

  let to_list t =
    fold (fun key datum elts -> (key, datum)::elts) t []

  let of_list elts =
    let t = create 42 in
    List.iter (fun (key, datum) -> add t key datum) elts;
    t

  let to_map v = fold T_map.add v T_map.empty

  let of_map m =
    let t = create (T_map.cardinal m) in
    T_map.iter (fun k v -> add t k v) m;
    t

  let memoize t f = fun key ->
    try find t key with
    | Not_found ->
      let r = f key in
      add t key r;
      r

  let map t f =
    of_map (T_map.map f (to_map t))
end

module type S = sig
  type t

  module T : Thing with type t = t
  include Thing with type t := T.t

  module Set : Set with module T := T
  module Map : Map with module T := T
  module Tbl : Tbl with module T := T
end

module Make (T : Thing) = struct
  module T = T
  include T

  module Set = Make_set (T)
  module Map = Make_map (T)
  module Tbl = Make_tbl (T)
end

end
module Ident : sig 
#1 "ident.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Identifiers (unique names) *)

type t = { stamp: int; name: string; mutable flags: int }

include Identifiable.S with type t := t
(* Notes:
   - [equal] compares identifiers by name
   - [compare x y] is 0 if [same x y] is true.
   - [compare] compares identifiers by binding location
*)


val create: string -> t
val create_persistent: string -> t
val create_predef_exn: string -> t
val rename: t -> t
val name: t -> string
val unique_name: t -> string
val unique_toplevel_name: t -> string
val persistent: t -> bool
val same: t -> t -> bool
        (* Compare identifiers by binding location.
           Two identifiers are the same either if they are both
           non-persistent and have been created by the same call to
           [new], or if they are both persistent and have the same
           name. *)
val compare: t -> t -> int
val hide: t -> t
        (* Return an identifier with same name as the given identifier,
           but stamp different from any stamp returned by new.
           When put in a 'a tbl, this identifier can only be looked
           up by name. *)

val make_global: t -> unit
val global: t -> bool
val is_predef_exn: t -> bool

val binding_time: t -> int
val current_time: unit -> int
val set_current_time: int -> unit
val reinit: unit -> unit

type 'a tbl
        (* Association tables from identifiers to type 'a. *)

val empty: 'a tbl
val add: t -> 'a -> 'a tbl -> 'a tbl
val find_same: t -> 'a tbl -> 'a
val find_name: string -> 'a tbl -> t * 'a
val find_all: string -> 'a tbl -> (t * 'a) list
val fold_name: (t -> 'a -> 'b -> 'b) -> 'a tbl -> 'b -> 'b
val fold_all: (t -> 'a -> 'b -> 'b) -> 'a tbl -> 'b -> 'b
val iter: (t -> 'a -> unit) -> 'a tbl -> unit


(* Idents for sharing keys *)

val make_key_generator : unit -> (t -> t)

end = struct
#1 "ident.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

open Format

type t = { stamp: int; name: string; mutable flags: int }

let [@inlnie] max (x:int) y = if x >= y then x else y 
let global_flag = 1
let predef_exn_flag = 2

(* A stamp of 0 denotes a persistent identifier *)

let currentstamp = ref 0

let create s =
  incr currentstamp;
  { name = s; stamp = !currentstamp; flags = 0 }

let create_predef_exn s =
  incr currentstamp;
  { name = s; stamp = !currentstamp; flags = predef_exn_flag }

let create_persistent s =
  { name = s; stamp = 0; flags = global_flag }

let rename i =
  incr currentstamp;
  { i with stamp = !currentstamp }

let name i = i.name

let unique_name i = i.name ^ "_" ^ string_of_int i.stamp

let unique_toplevel_name i = i.name ^ "/" ^ string_of_int i.stamp

let persistent i = (i.stamp = 0)

let equal i1 i2 = i1.name = i2.name

let same ({stamp; name } : t) i2 =   
  if stamp <> 0
  then stamp = i2.stamp
  else i2.stamp = 0 && name = i2.name 



let binding_time i = i.stamp

let current_time() = !currentstamp
let set_current_time t = currentstamp := max !currentstamp t

let reinit_level = ref (-1)

let reinit () =
  if !reinit_level < 0
  then reinit_level := !currentstamp
  else currentstamp := !reinit_level

let hide i =
  { i with stamp = -1 }

let make_global i =
  i.flags <- i.flags lor global_flag

let global i =
  (i.flags land global_flag) <> 0

let is_predef_exn i =
  (i.flags land predef_exn_flag) <> 0

let print ppf i =
  match i.stamp with
  | 0 -> fprintf ppf "%s!" i.name
  | -1 -> fprintf ppf "%s#" i.name
  | n -> fprintf ppf "%s/%i%s" i.name n (if global i then "g" else "")

type 'a tbl =
    Empty
  | Node of 'a tbl * 'a data * 'a tbl * int

and 'a data =
  { ident: t;
    data: 'a;
    previous: 'a data option }

let empty = Empty

(* Inline expansion of height for better speed
 * let height = function
 *     Empty -> 0
 *   | Node(_,_,_,h) -> h
 *)

let mknode l d r =
  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
  Node(l, d, r, (if hl >= hr then hl + 1 else hr + 1))

let balance l d r =
  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
  if hl > hr + 1 then
    match l with
    | Node (ll, ld, lr, _)
      when (match ll with Empty -> 0 | Node(_,_,_,h) -> h) >=
           (match lr with Empty -> 0 | Node(_,_,_,h) -> h) ->
        mknode ll ld (mknode lr d r)
    | Node (ll, ld, Node(lrl, lrd, lrr, _), _) ->
        mknode (mknode ll ld lrl) lrd (mknode lrr d r)
    | _ -> assert false
  else if hr > hl + 1 then
    match r with
    | Node (rl, rd, rr, _)
      when (match rr with Empty -> 0 | Node(_,_,_,h) -> h) >=
           (match rl with Empty -> 0 | Node(_,_,_,h) -> h) ->
        mknode (mknode l d rl) rd rr
    | Node (Node (rll, rld, rlr, _), rd, rr, _) ->
        mknode (mknode l d rll) rld (mknode rlr rd rr)
    | _ -> assert false
  else
    mknode l d r

let rec add id data = function
    Empty ->
      Node(Empty, {ident = id; data = data; previous = None}, Empty, 1)
  | Node(l, k, r, h) ->
      let c = compare id.name k.ident.name in
      if c = 0 then
        Node(l, {ident = id; data = data; previous = Some k}, r, h)
      else if c < 0 then
        balance (add id data l) k r
      else
        balance l k (add id data r)

let rec find_stamp s = function
    None ->
      raise Not_found
  | Some k ->
      if k.ident.stamp = s then k.data else find_stamp s k.previous

let rec find_same id = function
    Empty ->
      raise Not_found
  | Node(l, k, r, _) ->
      let c = compare id.name k.ident.name in
      if c = 0 then
        if id.stamp = k.ident.stamp
        then k.data
        else find_stamp id.stamp k.previous
      else
        find_same id (if c < 0 then l else r)

let rec find_name name = function
    Empty ->
      raise Not_found
  | Node(l, k, r, _) ->
      let c = compare name k.ident.name in
      if c = 0 then
        k.ident, k.data
      else
        find_name name (if c < 0 then l else r)

let rec get_all = function
  | None -> []
  | Some k -> (k.ident, k.data) :: get_all k.previous

let rec find_all name = function
    Empty ->
      []
  | Node(l, k, r, _) ->
      let c = compare name k.ident.name in
      if c = 0 then
        (k.ident, k.data) :: get_all k.previous
      else
        find_all name (if c < 0 then l else r)

let rec fold_aux f stack accu = function
    Empty ->
      begin match stack with
        [] -> accu
      | a :: l -> fold_aux f l accu a
      end
  | Node(l, k, r, _) ->
      fold_aux f (l :: stack) (f k accu) r

let fold_name f tbl accu = fold_aux (fun k -> f k.ident k.data) [] accu tbl

let rec fold_data f d accu =
  match d with
    None -> accu
  | Some k -> f k.ident k.data (fold_data f k.previous accu)

let fold_all f tbl accu =
  fold_aux (fun k -> fold_data f (Some k)) [] accu tbl

(* let keys tbl = fold_name (fun k _ accu -> k::accu) tbl [] *)

let rec iter f = function
    Empty -> ()
  | Node(l, k, r, _) ->
      iter f l; f k.ident k.data; iter f r

(* Idents for sharing keys *)

(* They should be 'totally fresh' -> neg numbers *)
let key_name = ""

let make_key_generator () =
  let c = ref 1 in
  fun id ->
    let stamp = !c in
    decr c ;
    { id with name = key_name; stamp = stamp; }

let compare x y =
  let c = x.stamp - y.stamp in
  if c <> 0 then c
  else
    let c = compare x.name y.name in
    if c <> 0 then c
    else
      compare x.flags y.flags

let output oc id = output_string oc (unique_name id)
let hash i = (Char.code i.name.[0]) lxor i.stamp

let original_equal = equal
include Identifiable.Make (struct
  type nonrec t = t
  let compare = compare
  let output = output
  let print = print
  let hash = hash
  let equal = same
end)
let equal = original_equal

end
module Js_reserved_map : sig 
#1 "js_reserved_map.mli"
(* Copyright (C) 2019-Present Authors of ReScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val is_reserved : string -> bool

end = struct
#1 "js_reserved_map.ml"

(* Copyright (C) 2019-Present Hongbo Zhang, Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let sorted_keywords = [|
  "AbortController";
  "AbortSignal";
  "ActiveXObject";
  "AnalyserNode";
  "AnimationEvent";
  "Array";
  "ArrayBuffer";
  "Atomics";
  "Attr";
  "Audio";
  "AudioBuffer";
  "AudioBufferSourceNode";
  "AudioContext";
  "AudioDestinationNode";
  "AudioListener";
  "AudioNode";
  "AudioParam";
  "AudioParamMap";
  "AudioProcessingEvent";
  "AudioScheduledSourceNode";
  "AudioWorkletNode";
  "BarProp";
  "BaseAudioContext";
  "BatteryManager";
  "BeforeInstallPromptEvent";
  "BeforeUnloadEvent";
  "BigInt";
  "BigInt64Array";
  "BigUint64Array";
  "BiquadFilterNode";
  "Blob";
  "BlobEvent";
  "BluetoothUUID";
  "Boolean";
  "BroadcastChannel";
  "Buffer";
  "ByteLengthQueuingStrategy";
  "CDATASection";
  "CSS";
  "CSSConditionRule";
  "CSSFontFaceRule";
  "CSSGroupingRule";
  "CSSImageValue";
  "CSSImportRule";
  "CSSKeyframeRule";
  "CSSKeyframesRule";
  "CSSKeywordValue";
  "CSSMathInvert";
  "CSSMathMax";
  "CSSMathMin";
  "CSSMathNegate";
  "CSSMathProduct";
  "CSSMathSum";
  "CSSMathValue";
  "CSSMatrixComponent";
  "CSSMediaRule";
  "CSSNamespaceRule";
  "CSSNumericArray";
  "CSSNumericValue";
  "CSSPageRule";
  "CSSPerspective";
  "CSSPositionValue";
  "CSSRotate";
  "CSSRule";
  "CSSRuleList";
  "CSSScale";
  "CSSSkew";
  "CSSSkewX";
  "CSSSkewY";
  "CSSStyleDeclaration";
  "CSSStyleRule";
  "CSSStyleSheet";
  "CSSStyleValue";
  "CSSSupportsRule";
  "CSSTransformComponent";
  "CSSTransformValue";
  "CSSTranslate";
  "CSSUnitValue";
  "CSSUnparsedValue";
  "CSSVariableReferenceValue";
  "CanvasCaptureMediaStreamTrack";
  "CanvasGradient";
  "CanvasPattern";
  "CanvasRenderingContext2D";
  "ChannelMergerNode";
  "ChannelSplitterNode";
  "CharacterData";
  "ClipboardEvent";
  "CloseEvent";
  "Comment";
  "CompositionEvent";
  "ConstantSourceNode";
  "ConvolverNode";
  "CountQueuingStrategy";
  "Crypto";
  "CryptoKey";
  "CustomElementRegistry";
  "CustomEvent";
  "DOMError";
  "DOMException";
  "DOMImplementation";
  "DOMMatrix";
  "DOMMatrixReadOnly";
  "DOMParser";
  "DOMPoint";
  "DOMPointReadOnly";
  "DOMQuad";
  "DOMRect";
  "DOMRectList";
  "DOMRectReadOnly";
  "DOMStringList";
  "DOMStringMap";
  "DOMTokenList";
  "DataTransfer";
  "DataTransferItem";
  "DataTransferItemList";
  "DataView";
  "Date";
  "DelayNode";
  "DeviceMotionEvent";
  "DeviceOrientationEvent";
  "Document";
  "DocumentFragment";
  "DocumentType";
  "DragEvent";
  "DynamicsCompressorNode";
  "Element";
  "EnterPictureInPictureEvent";
  "Error";
  "ErrorEvent";
  "EvalError";
  "Event";
  "EventSource";
  "EventTarget";
  "File";
  "FileList";
  "FileReader";
  "Float32Array";
  "Float64Array";
  "FocusEvent";
  "FontFace";
  "FontFaceSetLoadEvent";
  "FormData";
  "Function";
  "GainNode";
  "Gamepad";
  "GamepadButton";
  "GamepadEvent";
  "GamepadHapticActuator";
  "HTMLAllCollection";
  "HTMLAnchorElement";
  "HTMLAreaElement";
  "HTMLAudioElement";
  "HTMLBRElement";
  "HTMLBaseElement";
  "HTMLBodyElement";
  "HTMLButtonElement";
  "HTMLCanvasElement";
  "HTMLCollection";
  "HTMLContentElement";
  "HTMLDListElement";
  "HTMLDataElement";
  "HTMLDataListElement";
  "HTMLDetailsElement";
  "HTMLDialogElement";
  "HTMLDirectoryElement";
  "HTMLDivElement";
  "HTMLDocument";
  "HTMLElement";
  "HTMLEmbedElement";
  "HTMLFieldSetElement";
  "HTMLFontElement";
  "HTMLFormControlsCollection";
  "HTMLFormElement";
  "HTMLFrameElement";
  "HTMLFrameSetElement";
  "HTMLHRElement";
  "HTMLHeadElement";
  "HTMLHeadingElement";
  "HTMLHtmlElement";
  "HTMLIFrameElement";
  "HTMLImageElement";
  "HTMLInputElement";
  "HTMLLIElement";
  "HTMLLabelElement";
  "HTMLLegendElement";
  "HTMLLinkElement";
  "HTMLMapElement";
  "HTMLMarqueeElement";
  "HTMLMediaElement";
  "HTMLMenuElement";
  "HTMLMetaElement";
  "HTMLMeterElement";
  "HTMLModElement";
  "HTMLOListElement";
  "HTMLObjectElement";
  "HTMLOptGroupElement";
  "HTMLOptionElement";
  "HTMLOptionsCollection";
  "HTMLOutputElement";
  "HTMLParagraphElement";
  "HTMLParamElement";
  "HTMLPictureElement";
  "HTMLPreElement";
  "HTMLProgressElement";
  "HTMLQuoteElement";
  "HTMLScriptElement";
  "HTMLSelectElement";
  "HTMLShadowElement";
  "HTMLSlotElement";
  "HTMLSourceElement";
  "HTMLSpanElement";
  "HTMLStyleElement";
  "HTMLTableCaptionElement";
  "HTMLTableCellElement";
  "HTMLTableColElement";
  "HTMLTableElement";
  "HTMLTableRowElement";
  "HTMLTableSectionElement";
  "HTMLTemplateElement";
  "HTMLTextAreaElement";
  "HTMLTimeElement";
  "HTMLTitleElement";
  "HTMLTrackElement";
  "HTMLUListElement";
  "HTMLUnknownElement";
  "HTMLVideoElement";
  "HashChangeEvent";
  "Headers";
  "History";
  "IDBCursor";
  "IDBCursorWithValue";
  "IDBDatabase";
  "IDBFactory";
  "IDBIndex";
  "IDBKeyRange";
  "IDBObjectStore";
  "IDBOpenDBRequest";
  "IDBRequest";
  "IDBTransaction";
  "IDBVersionChangeEvent";
  "IIRFilterNode";
  "IdleDeadline";
  "Image";
  "ImageBitmap";
  "ImageBitmapRenderingContext";
  "ImageCapture";
  "ImageData";
  "Infinity";
  "InputDeviceCapabilities";
  "InputDeviceInfo";
  "InputEvent";
  "Int16Array";
  "Int32Array";
  "Int8Array";
  "IntersectionObserver";
  "IntersectionObserverEntry";
  "Intl";
  "JSON";
  "KeyboardEvent";
  "Location";
  "MIDIAccess";
  "MIDIConnectionEvent";
  "MIDIInput";
  "MIDIInputMap";
  "MIDIMessageEvent";
  "MIDIOutput";
  "MIDIOutputMap";
  "MIDIPort";
  "Map";
  "Math";
  "MediaCapabilities";
  "MediaCapabilitiesInfo";
  "MediaDeviceInfo";
  "MediaDevices";
  "MediaElementAudioSourceNode";
  "MediaEncryptedEvent";
  "MediaError";
  "MediaList";
  "MediaQueryList";
  "MediaQueryListEvent";
  "MediaRecorder";
  "MediaSettingsRange";
  "MediaSource";
  "MediaStream";
  "MediaStreamAudioDestinationNode";
  "MediaStreamAudioSourceNode";
  "MediaStreamEvent";
  "MediaStreamTrack";
  "MediaStreamTrackEvent";
  "MessageChannel";
  "MessageEvent";
  "MessagePort";
  "MimeType";
  "MimeTypeArray";
  "MouseEvent";
  "MutationEvent";
  "MutationObserver";
  "MutationRecord";
  "NaN";
  "NamedNodeMap";
  "Navigator";
  "NetworkInformation";
  "Node";
  "NodeFilter";
  "NodeIterator";
  "NodeList";
  "Notification";
  "Number";
  "Object";
  "OfflineAudioCompletionEvent";
  "OfflineAudioContext";
  "OffscreenCanvas";
  "OffscreenCanvasRenderingContext2D";
  "Option";
  "OscillatorNode";
  "OverconstrainedError";
  "PageTransitionEvent";
  "PannerNode";
  "Path2D";
  "PaymentInstruments";
  "PaymentManager";
  "PaymentRequestUpdateEvent";
  "Performance";
  "PerformanceEntry";
  "PerformanceLongTaskTiming";
  "PerformanceMark";
  "PerformanceMeasure";
  "PerformanceNavigation";
  "PerformanceNavigationTiming";
  "PerformanceObserver";
  "PerformanceObserverEntryList";
  "PerformancePaintTiming";
  "PerformanceResourceTiming";
  "PerformanceServerTiming";
  "PerformanceTiming";
  "PeriodicWave";
  "PermissionStatus";
  "Permissions";
  "PhotoCapabilities";
  "PictureInPictureWindow";
  "Plugin";
  "PluginArray";
  "PointerEvent";
  "PopStateEvent";
  "ProcessingInstruction";
  "ProgressEvent";
  "Promise";
  "PromiseRejectionEvent";
  "Proxy";
  "PushManager";
  "PushSubscription";
  "PushSubscriptionOptions";
  "RTCCertificate";
  "RTCDTMFSender";
  "RTCDTMFToneChangeEvent";
  "RTCDataChannel";
  "RTCDataChannelEvent";
  "RTCIceCandidate";
  "RTCPeerConnection";
  "RTCPeerConnectionIceEvent";
  "RTCRtpContributingSource";
  "RTCRtpReceiver";
  "RTCRtpSender";
  "RTCRtpTransceiver";
  "RTCSessionDescription";
  "RTCStatsReport";
  "RTCTrackEvent";
  "RadioNodeList";
  "Range";
  "RangeError";
  "ReadableStream";
  "ReferenceError";
  "Reflect";
  "RegExp";
  "RemotePlayback";
  "ReportingObserver";
  "Request";
  "ResizeObserver";
  "ResizeObserverEntry";
  "Response";
  "SVGAElement";
  "SVGAngle";
  "SVGAnimateElement";
  "SVGAnimateMotionElement";
  "SVGAnimateTransformElement";
  "SVGAnimatedAngle";
  "SVGAnimatedBoolean";
  "SVGAnimatedEnumeration";
  "SVGAnimatedInteger";
  "SVGAnimatedLength";
  "SVGAnimatedLengthList";
  "SVGAnimatedNumber";
  "SVGAnimatedNumberList";
  "SVGAnimatedPreserveAspectRatio";
  "SVGAnimatedRect";
  "SVGAnimatedString";
  "SVGAnimatedTransformList";
  "SVGAnimationElement";
  "SVGCircleElement";
  "SVGClipPathElement";
  "SVGComponentTransferFunctionElement";
  "SVGDefsElement";
  "SVGDescElement";
  "SVGDiscardElement";
  "SVGElement";
  "SVGEllipseElement";
  "SVGFEBlendElement";
  "SVGFEColorMatrixElement";
  "SVGFEComponentTransferElement";
  "SVGFECompositeElement";
  "SVGFEConvolveMatrixElement";
  "SVGFEDiffuseLightingElement";
  "SVGFEDisplacementMapElement";
  "SVGFEDistantLightElement";
  "SVGFEDropShadowElement";
  "SVGFEFloodElement";
  "SVGFEFuncAElement";
  "SVGFEFuncBElement";
  "SVGFEFuncGElement";
  "SVGFEFuncRElement";
  "SVGFEGaussianBlurElement";
  "SVGFEImageElement";
  "SVGFEMergeElement";
  "SVGFEMergeNodeElement";
  "SVGFEMorphologyElement";
  "SVGFEOffsetElement";
  "SVGFEPointLightElement";
  "SVGFESpecularLightingElement";
  "SVGFESpotLightElement";
  "SVGFETileElement";
  "SVGFETurbulenceElement";
  "SVGFilterElement";
  "SVGForeignObjectElement";
  "SVGGElement";
  "SVGGeometryElement";
  "SVGGradientElement";
  "SVGGraphicsElement";
  "SVGImageElement";
  "SVGLength";
  "SVGLengthList";
  "SVGLineElement";
  "SVGLinearGradientElement";
  "SVGMPathElement";
  "SVGMarkerElement";
  "SVGMaskElement";
  "SVGMatrix";
  "SVGMetadataElement";
  "SVGNumber";
  "SVGNumberList";
  "SVGPathElement";
  "SVGPatternElement";
  "SVGPoint";
  "SVGPointList";
  "SVGPolygonElement";
  "SVGPolylineElement";
  "SVGPreserveAspectRatio";
  "SVGRadialGradientElement";
  "SVGRect";
  "SVGRectElement";
  "SVGSVGElement";
  "SVGScriptElement";
  "SVGSetElement";
  "SVGStopElement";
  "SVGStringList";
  "SVGStyleElement";
  "SVGSwitchElement";
  "SVGSymbolElement";
  "SVGTSpanElement";
  "SVGTextContentElement";
  "SVGTextElement";
  "SVGTextPathElement";
  "SVGTextPositioningElement";
  "SVGTitleElement";
  "SVGTransform";
  "SVGTransformList";
  "SVGUnitTypes";
  "SVGUseElement";
  "SVGViewElement";
  "Screen";
  "ScreenOrientation";
  "ScriptProcessorNode";
  "SecurityPolicyViolationEvent";
  "Selection";
  "Set";
  "ShadowRoot";
  "SharedArrayBuffer";
  "SharedWorker";
  "SourceBuffer";
  "SourceBufferList";
  "SpeechSynthesisErrorEvent";
  "SpeechSynthesisEvent";
  "SpeechSynthesisUtterance";
  "StaticRange";
  "StereoPannerNode";
  "Storage";
  "StorageEvent";
  "String";
  "StylePropertyMap";
  "StylePropertyMapReadOnly";
  "StyleSheet";
  "StyleSheetList";
  "SubtleCrypto";
  "Symbol";
  "SyncManager";
  "SyntaxError";
  "TaskAttributionTiming";
  "Text";
  "TextDecoder";
  "TextDecoderStream";
  "TextEncoder";
  "TextEncoderStream";
  "TextEvent";
  "TextMetrics";
  "TextTrack";
  "TextTrackCue";
  "TextTrackCueList";
  "TextTrackList";
  "TimeRanges";
  "Touch";
  "TouchEvent";
  "TouchList";
  "TrackEvent";
  "TransformStream";
  "TransitionEvent";
  "TreeWalker";
  "TypeError";
  "UIEvent";
  "URIError";
  "URL";
  "URLSearchParams";
  "Uint16Array";
  "Uint32Array";
  "Uint8Array";
  "Uint8ClampedArray";
  "UserActivation";
  "VTTCue";
  "ValidityState";
  "VisualViewport";
  "WaveShaperNode";
  "WeakMap";
  "WeakSet";
  "WebAssembly";
  "WebGL2RenderingContext";
  "WebGLActiveInfo";
  "WebGLBuffer";
  "WebGLContextEvent";
  "WebGLFramebuffer";
  "WebGLProgram";
  "WebGLQuery";
  "WebGLRenderbuffer";
  "WebGLRenderingContext";
  "WebGLSampler";
  "WebGLShader";
  "WebGLShaderPrecisionFormat";
  "WebGLSync";
  "WebGLTexture";
  "WebGLTransformFeedback";
  "WebGLUniformLocation";
  "WebGLVertexArrayObject";
  "WebKitCSSMatrix";
  "WebKitMutationObserver";
  "WebSocket";
  "WheelEvent";
  "Window";
  "Worker";
  "WritableStream";
  "XDomainRequest";
  "XMLDocument";
  "XMLHttpRequest";
  "XMLHttpRequestEventTarget";
  "XMLHttpRequestUpload";
  "XMLSerializer";
  "XPathEvaluator";
  "XPathExpression";
  "XPathResult";
  "XSLTProcessor";
  "__dirname";
  "__esModule";
  "__filename";
  "abstract";
  "arguments";
  "await";
  "boolean";
  "break";
  "byte";
  "case";
  "catch";
  "char";
  "class";
  "clearImmediate";
  "clearInterval";
  "clearTimeout";
  "console";
  "const";
  "continue";
  "debugger";
  "decodeURI";
  "decodeURIComponent";
  "default";
  "delete";
  "do";
  "document";
  "double";
  "else";
  "encodeURI";
  "encodeURIComponent";
  "enum";
  "escape";
  "eval";
  "event";
  "export";
  "exports";
  "extends";
  "false";
  "fetch";
  "final";
  "finally";
  "float";
  "for";
  "function";
  "global";
  "goto";
  "if";
  "implements";
  "import";
  "in";
  "instanceof";
  "int";
  "interface";
  "isFinite";
  "isNaN";
  "let";
  "location";
  "long";
  "module";
  "native";
  "navigator";
  "new";
  "null";
  "package";
  "parseFloat";
  "parseInt";
  "private";
  "process";
  "protected";
  "public";
  "require";
  "return";
  "setImmediate";
  "setInterval";
  "setTimeout";
  "short";
  "static";
  "super";
  "switch";
  "synchronized";
  "this";
  "throw";
  "transient";
  "true";
  "try";
  "typeof";
  "undefined";
  "unescape";
  "var";
  "void";
  "volatile";
  "while";
  "window";
  "with";
  "yield";
  |]


type element = string 

let rec binarySearchAux (arr : element array) (lo : int) (hi : int) key : bool =   
    let mid = (lo + hi)/2 in 
    let midVal = Array.unsafe_get arr mid in 
    (* let c = cmp key midVal [@bs] in  *)
    if key = midVal then true 
    else if key < midVal then  (*  a[lo] =< key < a[mid] <= a[hi] *)
      if hi = mid then  
        (Array.unsafe_get arr lo) = key 
      else binarySearchAux arr lo mid key 
    else  (*  a[lo] =< a[mid] < key <= a[hi] *)
      if lo = mid then 
        (Array.unsafe_get arr hi) = key 
      else binarySearchAux arr mid hi key 

let binarySearch (sorted : element array) (key : element)  : bool =  
  let len = Array.length sorted in 
  if len = 0 then false
  else 
    let lo = Array.unsafe_get sorted 0 in 
    (* let c = cmp key lo [@bs] in  *)
    if key < lo then false
    else
    let hi = Array.unsafe_get sorted (len - 1) in 
    (* let c2 = cmp key hi [@bs]in  *)
    if key > hi then false
    else binarySearchAux sorted 0 (len - 1) key 

let is_reserved s = binarySearch sorted_keywords s     

end
module Ext_ident : sig 
#1 "ext_ident.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A wrapper around [Ident] module in compiler-libs*)

val is_js : Ident.t -> bool 

val is_js_object : Ident.t -> bool

(** create identifiers for predefined [js] global variables *)
val create_js : string -> Ident.t

val create : string -> Ident.t

val make_js_object : Ident.t -> unit 

val reset : unit -> unit

val create_tmp :  ?name:string -> unit -> Ident.t

val make_unused : unit -> Ident.t 



(**
   Invariant: if name is not converted, the reference should be equal
*)
val convert : string -> string



val is_js_or_global : Ident.t -> bool



val compare : Ident.t -> Ident.t -> int
val equal : Ident.t -> Ident.t -> bool 

end = struct
#1 "ext_ident.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 2017 - Hongbo Zhang, Authors of ReScript
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let js_flag = 0b1_000 (* check with ocaml compiler *)

(* let js_module_flag = 0b10_000 (\* javascript external modules *\) *)
(* TODO:
    check name conflicts with javascript conventions
   {[
     Ext_ident.convert "^";;
     - : string = "$caret"
   ]}
*)
let js_object_flag = 0b100_000 (* javascript object flags *)

let is_js (i : Ident.t) =
  i.flags land js_flag <> 0

let is_js_or_global (i : Ident.t) =
  i.flags land (8 lor 1) <> 0


let is_js_object (i : Ident.t) =
  i.flags land js_object_flag <> 0

let make_js_object (i : Ident.t) =
  i.flags <- i.flags lor js_object_flag

(* It's a js function hard coded by js api, so when printing,
   it should preserve the name
*)
let create_js (name : string) : Ident.t  =
  { name = name; flags = js_flag ; stamp = 0}

let create = Ident.create

(* FIXME: no need for `$' operator *)
let create_tmp ?(name=Literals.tmp) () = create name


let js_module_table : Ident.t Hash_string.t = Hash_string.create 31

(* This is for a js exeternal module, we can change it when printing
   for example
   {[
     var React$1 = require('react');
     React$1.render(..)
   ]}

   Given a name, if duplicated, they should  have the same id
*)
(* let create_js_module (name : string) : Ident.t =
   let name =
    String.concat "" @@ Ext_list.map
    (Ext_string.split name '-')  Ext_string.capitalize_ascii in
   (* TODO: if we do such transformation, we should avoid       collision for example:
      react-dom
      react--dom
      check collision later
  *)
   match Hash_string.find_exn js_module_table name  with
   | exception Not_found ->
    let ans = Ident.create name in
    (* let ans = { v with flags = js_module_flag} in  *)
    Hash_string.add js_module_table name ans;
    ans
   | v -> (* v *) Ident.rename v


*)

let [@inline] convert ?(op=false) (c : char) : string =
  (match c with
   | '*' ->   "$star"
   | '\'' ->   "$p"
   | '!' ->   "$bang"
   | '>' ->   "$great"
   | '<' ->   "$less"
   | '=' ->   "$eq"
   | '+' ->   "$plus"
   | '-' ->   if op then "$neg" else "$"
   | '@' ->   "$at"
   | '^' ->   "$caret"
   | '/' ->   "$slash"
   | '|' ->   "$pipe"
   | '.' ->   "$dot"
   | '%' ->   "$percent"
   | '~' ->   "$tilde"
   | '#' ->   "$hash"
   | ':' ->   "$colon"
   | '?' ->   "$question"
   | '&' ->   "$amp"
   | '(' ->   "$lpar"
   | ')' ->   "$rpar"
   | '{' ->   "$lbrace"
   | '}' ->   "$lbrace"
   | '[' ->   "$lbrack"
   | ']' ->   "$rbrack"

   | _ ->   "$unknown")  
let [@inline] no_escape (c : char) =  
  match c with   
  | 'a' .. 'z' | 'A' .. 'Z'
  | '0' .. '9' | '_' | '$' -> true 
  | _ -> false

exception Not_normal_letter of int
let name_mangle name =
  let len = String.length name  in
  try
    for i  = 0 to len - 1 do
      if not (no_escape (String.unsafe_get name i)) then
        raise_notrace (Not_normal_letter i)
    done;
    name (* Normal letter *)
  with
  | Not_normal_letter i ->
    let buffer = Ext_buffer.create len in
    for j = 0 to  len - 1 do
      let c = String.unsafe_get name j in
      if no_escape c then Ext_buffer.add_char buffer c 
      else 
        Ext_buffer.add_string buffer (convert ~op:(i=0) c)        
    done; Ext_buffer.contents buffer

(* TODO:
    check name conflicts with javascript conventions
   {[
     Ext_ident.convert "^";;
     - : string = "$caret"
   ]}
   [convert name] if [name] is a js keyword,add "$$"
   otherwise do the name mangling to make sure ocaml identifier it is
   a valid js identifier
*)
let convert (name : string) =
  if  Js_reserved_map.is_reserved name  then
    "$$" ^ name
  else name_mangle name

(** keyword could be used in property *)

(* It is currently made a persistent ident to avoid fresh ids
    which would result in different signature files
   - other solution: use lazy values
*)
let make_unused () = create "_"



let reset () =
  Hash_string.clear js_module_table


(* Has to be total order, [x < y]
   and [x > y] should be consistent
   flags are not relevant here
*)
let compare (x : Ident.t ) ( y : Ident.t) =
  let u = x.stamp - y.stamp in
  if u = 0 then
    Ext_string.compare x.name y.name
  else u

let equal ( x : Ident.t) ( y : Ident.t) =
  if x.stamp <> 0 then x.stamp = y.stamp
  else y.stamp = 0 && x.name = y.name

end
module Hash_set_ident_mask : sig 
#1 "hash_set_ident_mask.mli"


(** Based on [hash_set] specialized for mask operations  *)
type ident = Ident.t  


type t

val create: int ->  t


(* add one ident 
   ident is unmaksed by default
*)
val add_unmask :  t -> ident -> unit


(** [check_mask h key] if [key] exists mask it otherwise nothing
    return true if all keys are masked otherwise false
*)
val mask_and_check_all_hit : 
  t -> 
  ident ->  
  bool

(** [iter_and_unmask f h] iterating the collection and mask all idents,
    dont consul the collection in function [f]
    TODO: what happens if an exception raised in the callback,
    would the hashtbl still be in consistent state?
*)
val iter_and_unmask: 
  t -> 
  (ident -> bool ->  unit) -> 
  unit





end = struct
#1 "hash_set_ident_mask.ml"

(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** A speicalized datastructure for scc algorithm *)

type ident = Ident.t

type bucket =
  | Empty 
  | Cons of {
      ident : ident; 
      mutable mask : bool;
      rest : bucket
    }

type t = {
  mutable size : int ; 
  mutable data : bucket array;
  mutable mask_size : int (* mark how many idents are marked *)
}



let key_index_by_ident (h : t) (key : Ident.t) =    
  (Bs_hash_stubs.hash_string_int  key.name key.stamp) land (Array.length h.data - 1)




let create  initial_size =
  let s = Ext_util.power_2_above 8 initial_size in
  { size = 0; data = Array.make s Empty ; mask_size = 0}

let iter_and_unmask h f =
  let rec iter_bucket buckets = 
    match buckets with 
    | Empty ->
      ()
    | Cons k ->    
      let k_mask = k.mask in 
      f k.ident k_mask ;
      if k_mask then 
        begin 
          k.mask <- false ;
          (* we can set [h.mask_size] to zero,
             however, it would result inconsistent state
             once [f] throw
          *)
          h.mask_size <- h.mask_size - 1
        end; 
      iter_bucket k.rest 
  in
  let d = h.data in
  for i = 0 to Array.length d - 1 do
    iter_bucket (Array.unsafe_get d i)
  done


let rec small_bucket_mem key lst =
  match lst with 
  | Empty -> false 
  | Cons rst -> 
    Ext_ident.equal key   rst.ident ||
    match rst.rest with 
    | Empty -> false 
    | Cons rst -> 
      Ext_ident.equal key   rst.ident ||
      match rst.rest with 
      | Empty -> false 
      | Cons rst -> 
        Ext_ident.equal key   rst.ident ||
        small_bucket_mem key rst.rest 

let resize indexfun h =
  let odata = h.data in
  let osize = Array.length odata in
  let nsize = osize * 2 in
  if nsize < Sys.max_array_length then begin
    let ndata = Array.make nsize Empty in
    h.data <- ndata;          (* so that indexfun sees the new bucket count *)
    let rec insert_bucket = function
        Empty -> ()
      | Cons {ident = key;  mask; rest} ->
        let nidx = indexfun h key in
        Array.unsafe_set 
          ndata (nidx)  
          (Cons {ident = key; mask; rest = Array.unsafe_get ndata (nidx)});
        insert_bucket rest
    in
    for i = 0 to osize - 1 do
      insert_bucket (Array.unsafe_get odata i)
    done
  end

let add_unmask (h : t) (key : Ident.t) =
  let i = key_index_by_ident h key  in 
  let h_data = h.data in 
  let old_bucket = Array.unsafe_get h_data i in
  if not (small_bucket_mem key old_bucket) then 
    begin 
      Array.unsafe_set h_data i 
        (Cons {ident = key; mask = false; rest =  old_bucket});
      h.size <- h.size + 1 ;
      if h.size > Array.length h_data lsl 1 then resize key_index_by_ident h
    end




let rec small_bucket_mask  key lst =
  match lst with 
  | Empty -> false 
  | Cons rst -> 
    if Ext_ident.equal key   rst.ident  then 
      if rst.mask then false else (rst.mask <- true ; true) 
    else 
      match rst.rest with 
      | Empty -> false
      | Cons rst -> 
        if Ext_ident.equal key rst.ident  then 
          if rst.mask then false else (rst.mask <- true ; true)
        else 
          match rst.rest with 
          | Empty -> false
          | Cons rst -> 
            if Ext_ident.equal key rst.ident then 
              if rst.mask then false else (rst.mask <- true ; true)
            else 
              small_bucket_mask  key rst.rest 

let mask_and_check_all_hit (h : t) (key : Ident.t) =     
  if 
    small_bucket_mask key 
      (Array.unsafe_get h.data (key_index_by_ident h key )) then 
    begin 
      h.mask_size <- h.mask_size + 1 
    end;
  h.size = h.mask_size 




end
module Ounit_ident_mask_tests
= struct
#1 "ounit_ident_mask_tests.ml"
let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal
let suites = 
  __FILE__
  >:::
  [
    __LOC__ >:: begin fun _ -> 
      let set = Hash_set_ident_mask.create 0  in
      let a,b,_,_ = 
        Ident.create "a", 
        Ident.create "b", 
        Ident.create "c",
        Ident.create "d" in 
      Hash_set_ident_mask.add_unmask set a ;     
      Hash_set_ident_mask.add_unmask set a ;     
      Hash_set_ident_mask.add_unmask set b ;     
      OUnit.assert_bool __LOC__ (not @@ Hash_set_ident_mask.mask_and_check_all_hit set  a);
      OUnit.assert_bool __LOC__ (Hash_set_ident_mask.mask_and_check_all_hit set  b );
      Hash_set_ident_mask.iter_and_unmask set (fun id mask -> 
          if id.Ident.name = "a" then
            OUnit.assert_bool __LOC__ mask 
          else if id.Ident.name = "b" then 
            OUnit.assert_bool __LOC__ mask 
          else ()        
        ) ;
      OUnit.assert_bool __LOC__ (not @@ Hash_set_ident_mask.mask_and_check_all_hit set a );
      OUnit.assert_bool __LOC__ (Hash_set_ident_mask.mask_and_check_all_hit set  b );
    end;
    __LOC__ >:: begin fun _ -> 
        let len = 1000 in 
        let idents = Array.init len (fun i -> Ident.create (string_of_int i)) in 
        let set = Hash_set_ident_mask.create 0 in 
        Array.iter (fun i -> Hash_set_ident_mask.add_unmask set i) idents;
        for i = 0 to len - 2 do 
                OUnit.assert_bool __LOC__ (not @@ Hash_set_ident_mask.mask_and_check_all_hit set idents.(i));
        done ;
         for i = 0 to len - 2 do 
                OUnit.assert_bool __LOC__ (not @@ Hash_set_ident_mask.mask_and_check_all_hit set idents.(i) );
        done ; 
         OUnit.assert_bool __LOC__ (Hash_set_ident_mask.mask_and_check_all_hit  set idents.(len - 1)) ;
         Hash_set_ident_mask.iter_and_unmask set(fun _ _ -> ()) ;
        for i = 0 to len - 2 do 
                OUnit.assert_bool __LOC__ (not @@ Hash_set_ident_mask.mask_and_check_all_hit set idents.(i) );
        done ;
         for i = 0 to len - 2 do 
                OUnit.assert_bool __LOC__ (not @@ Hash_set_ident_mask.mask_and_check_all_hit set idents.(i));
        done ; 
         OUnit.assert_bool __LOC__ (Hash_set_ident_mask.mask_and_check_all_hit  set idents.(len - 1)) ;
         
    end
  ]
end
module Vec_gen
= struct
#1 "vec_gen.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

module type ResizeType = sig
  type t

  val null : t
  (* used to populate new allocated array checkout {!Obj.new_block} for more performance *)
end

module type S = sig
  type elt

  type t

  val length : t -> int

  val compact : t -> unit

  val singleton : elt -> t

  val empty : unit -> t

  val make : int -> t

  val init : int -> (int -> elt) -> t

  val is_empty : t -> bool

  val of_sub_array : elt array -> int -> int -> t

  val unsafe_internal_array : t -> elt array
  (** Exposed for some APIs which only take array as input, 
      when exposed   
  *)

  val reserve : t -> int -> unit

  val push : t -> elt -> unit

  val delete : t -> int -> unit

  val pop : t -> unit

  val get_last_and_pop : t -> elt

  val delete_range : t -> int -> int -> unit

  val get_and_delete_range : t -> int -> int -> t

  val clear : t -> unit

  val reset : t -> unit

  val to_list : t -> elt list

  val of_list : elt list -> t

  val to_array : t -> elt array

  val of_array : elt array -> t

  val copy : t -> t

  val reverse_in_place : t -> unit

  val iter : t -> (elt -> unit) -> unit

  val iteri : t -> (int -> elt -> unit) -> unit

  val iter_range : t -> from:int -> to_:int -> (elt -> unit) -> unit

  val iteri_range : t -> from:int -> to_:int -> (int -> elt -> unit) -> unit

  val map : (elt -> elt) -> t -> t

  val mapi : (int -> elt -> elt) -> t -> t

  val map_into_array : (elt -> 'f) -> t -> 'f array

  val map_into_list : (elt -> 'f) -> t -> 'f list

  val fold_left : ('f -> elt -> 'f) -> 'f -> t -> 'f

  val fold_right : (elt -> 'g -> 'g) -> t -> 'g -> 'g

  val filter : (elt -> bool) -> t -> t

  val inplace_filter : (elt -> bool) -> t -> unit

  val inplace_filter_with :
    (elt -> bool) -> cb_no:(elt -> 'a -> 'a) -> 'a -> t -> 'a

  val inplace_filter_from : int -> (elt -> bool) -> t -> unit

  val equal : (elt -> elt -> bool) -> t -> t -> bool

  val get : t -> int -> elt

  val unsafe_get : t -> int -> elt

  val last : t -> elt

  val capacity : t -> int

  val exists : (elt -> bool) -> t -> bool

  val sub : t -> int -> int -> t
end

end
module Vec_int : sig 
#1 "vec_int.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

include Vec_gen.S with type elt = int

end = struct
#1 "vec_int.ml"
# 1 "ext/vec.cppo.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


let [@inline] min (x :int) y = if x < y then x else y


# 38 "ext/vec.cppo.ml"
type elt = int 
let null = 0 (* can be optimized *)
let unsafe_blit = Bs_hash_stubs.int_unsafe_blit

# 45 "ext/vec.cppo.ml"
external unsafe_sub : 'a array -> int -> int -> 'a array = "caml_array_sub"

type  t = {
  mutable arr : elt array ;
  mutable len : int ;  
}

let length d = d.len

let compact d =
  let d_arr = d.arr in 
  if d.len <> Array.length d_arr then 
    begin
      let newarr = unsafe_sub d_arr 0 d.len in 
      d.arr <- newarr
    end
let singleton v = 
  {
    len = 1 ; 
    arr = [|v|]
  }

let empty () =
  {
    len = 0;
    arr = [||];
  }

let is_empty d =
  d.len = 0

let reset d = 
  d.len <- 0; 
  d.arr <- [||]


(* For [to_*] operations, we should be careful to call {!Array.*} function 
   in case we operate on the whole array
*)
let to_list d =
  let rec loop (d_arr : elt array) idx accum =
    if idx < 0 then accum else loop d_arr (idx - 1) (Array.unsafe_get d_arr idx :: accum)
  in
  loop d.arr (d.len - 1) []


let of_list lst =
  let arr = Array.of_list lst in 
  { arr ; len = Array.length arr}


let to_array d = 
  unsafe_sub d.arr 0 d.len

let of_array src =
  {
    len = Array.length src;
    arr = Array.copy src;
    (* okay to call {!Array.copy}*)
  }
let of_sub_array arr off len = 
  { 
    len = len ; 
    arr = Array.sub arr off len  
  }  
let unsafe_internal_array v = v.arr  
(* we can not call {!Array.copy} *)
let copy src =
  let len = src.len in
  {
    len ;
    arr = unsafe_sub src.arr 0 len ;
  }

(* FIXME *)
let reverse_in_place src = 
  Ext_array.reverse_range src.arr 0 src.len 




(* {!Array.sub} is not enough for error checking, it 
   may contain some garbage
 *)
let sub (src : t) start len =
  let src_len = src.len in 
  if len < 0 || start > src_len - len then invalid_arg "Vec.sub"
  else 
  { len ; 
    arr = unsafe_sub src.arr start len }

let iter d  f = 
  let arr = d.arr in 
  for i = 0 to d.len - 1 do
    f (Array.unsafe_get arr i)
  done

let iteri d f =
  let arr = d.arr in
  for i = 0 to d.len - 1 do
    f i (Array.unsafe_get arr i)
  done

let iter_range d ~from ~to_ f =
  if from < 0 || to_ >= d.len then invalid_arg "Vec.iter_range"
  else 
    let d_arr = d.arr in 
    for i = from to to_ do 
      f  (Array.unsafe_get d_arr i)
    done

let iteri_range d ~from ~to_ f =
  if from < 0 || to_ >= d.len then invalid_arg "Vec.iteri_range"
  else 
    let d_arr = d.arr in 
    for i = from to to_ do 
      f i (Array.unsafe_get d_arr i)
    done

let map_into_array f src =
  let src_len = src.len in 
  let src_arr = src.arr in 
  if src_len = 0 then [||]
  else 
    let first_one = f (Array.unsafe_get src_arr 0) in 
    let arr = Array.make  src_len  first_one in
    for i = 1 to src_len - 1 do
      Array.unsafe_set arr i (f (Array.unsafe_get src_arr i))
    done;
    arr 
let map_into_list f src = 
  let src_len = src.len in 
  let src_arr = src.arr in 
  if src_len = 0 then []
  else 
    let acc = ref [] in         
    for i =  src_len - 1 downto 0 do
      acc := f (Array.unsafe_get src_arr i) :: !acc
    done;
    !acc

let mapi f src =
  let len = src.len in 
  if len = 0 then { len ; arr = [| |] }
  else 
    let src_arr = src.arr in 
    let arr = Array.make len (Array.unsafe_get src_arr 0) in
    for i = 1 to len - 1 do
      Array.unsafe_set arr i (f i (Array.unsafe_get src_arr i))
    done;
    {
      len ;
      arr ;
    }

let fold_left f x a =
  let rec loop a_len (a_arr : elt array) idx x =
    if idx >= a_len then x else 
      loop a_len a_arr (idx + 1) (f x (Array.unsafe_get a_arr idx))
  in
  loop a.len a.arr 0 x

let fold_right f a x =
  let rec loop (a_arr : elt array) idx x =
    if idx < 0 then x
    else loop a_arr (idx - 1) (f (Array.unsafe_get a_arr idx) x)
  in
  loop a.arr (a.len - 1) x

(**  
   [filter] and [inplace_filter]
*)
let filter f d =
  let new_d = copy d in 
  let new_d_arr = new_d.arr in 
  let d_arr = d.arr in
  let p = ref 0 in
  for i = 0 to d.len  - 1 do
    let x = Array.unsafe_get d_arr i in
    (* TODO: can be optimized for segments blit *)
    if f x  then
      begin
        Array.unsafe_set new_d_arr !p x;
        incr p;
      end;
  done;
  new_d.len <- !p;
  new_d 

let equal eq x y : bool = 
  if x.len <> y.len then false 
  else 
    let rec aux x_arr y_arr i =
      if i < 0 then true else  
      if eq (Array.unsafe_get x_arr i) (Array.unsafe_get y_arr i) then 
        aux x_arr y_arr (i - 1)
      else false in 
    aux x.arr y.arr (x.len - 1)

let get d i = 
  if i < 0 || i >= d.len then invalid_arg "Vec.get"
  else Array.unsafe_get d.arr i
let unsafe_get d i = Array.unsafe_get d.arr i 
let last d = 
  if d.len <= 0 then invalid_arg   "Vec.last"
  else Array.unsafe_get d.arr (d.len - 1)

let capacity d = Array.length d.arr

(* Attention can not use {!Array.exists} since the bound is not the same *)  
let exists p d = 
  let a = d.arr in 
  let n = d.len in   
  let rec loop i =
    if i = n then false
    else if p (Array.unsafe_get a i) then true
    else loop (succ i) in
  loop 0

let map f src =
  let src_len = src.len in 
  if src_len = 0 then { len = 0 ; arr = [||]}
  (* TODO: we may share the empty array 
     but sharing mutable state is very challenging, 
     the tricky part is to avoid mutating the immutable array,
     here it looks fine -- 
     invariant: whenever [.arr] mutated, make sure  it is not an empty array
     Actually no: since starting from an empty array 
     {[
       push v (* the address of v should not be changed *)
     ]}
  *)
  else 
    let src_arr = src.arr in 
    let first = f (Array.unsafe_get src_arr 0 ) in 
    let arr = Array.make  src_len first in
    for i = 1 to src_len - 1 do
      Array.unsafe_set arr i (f (Array.unsafe_get src_arr i))
    done;
    {
      len = src_len;
      arr = arr;
    }

let init len f =
  if len < 0 then invalid_arg  "Vec.init"
  else if len = 0 then { len = 0 ; arr = [||] }
  else 
    let first = f 0 in 
    let arr = Array.make len first in
    for i = 1 to len - 1 do
      Array.unsafe_set arr i (f i)
    done;
    {

      len ;
      arr 
    }



  let make initsize : t =
    if initsize < 0 then invalid_arg  "Vec.make" ;
    {

      len = 0;
      arr = Array.make  initsize null ;
    }



  let reserve (d : t ) s = 
    let d_len = d.len in 
    let d_arr = d.arr in 
    if s < d_len || s < Array.length d_arr then ()
    else 
      let new_capacity = min Sys.max_array_length s in 
      let new_d_arr = Array.make new_capacity null in 
       unsafe_blit d_arr 0 new_d_arr 0 d_len;
      d.arr <- new_d_arr 

  let push (d : t) v  =
    let d_len = d.len in
    let d_arr = d.arr in 
    let d_arr_len = Array.length d_arr in
    if d_arr_len = 0 then
      begin 
        d.len <- 1 ;
        d.arr <- [| v |]
      end
    else  
      begin 
        if d_len = d_arr_len then 
          begin
            if d_len >= Sys.max_array_length then 
              failwith "exceeds max_array_length";
            let new_capacity = min Sys.max_array_length d_len * 2 
            (* [d_len] can not be zero, so [*2] will enlarge   *)
            in
            let new_d_arr = Array.make new_capacity null in 
            d.arr <- new_d_arr;
             unsafe_blit d_arr 0 new_d_arr 0 d_len ;
          end;
        d.len <- d_len + 1;
        Array.unsafe_set d.arr d_len v
      end

(** delete element at offset [idx], will raise exception when have invalid input *)
  let delete (d : t) idx =
    let d_len = d.len in 
    if idx < 0 || idx >= d_len then invalid_arg "Vec.delete" ;
    let arr = d.arr in 
     unsafe_blit arr (idx + 1) arr idx  (d_len - idx - 1);
    let idx = d_len - 1 in 
    d.len <- idx
    
# 366 "ext/vec.cppo.ml"
(** pop the last element, a specialized version of [delete] *)
  let pop (d : t) = 
    let idx  = d.len - 1  in
    if idx < 0 then invalid_arg "Vec.pop";
    d.len <- idx
  
# 377 "ext/vec.cppo.ml"
(** pop and return the last element *)  
  let get_last_and_pop (d : t) = 
    let idx  = d.len - 1  in
    if idx < 0 then invalid_arg "Vec.get_last_and_pop";
    let last = Array.unsafe_get d.arr idx in 
    d.len <- idx 
    
# 388 "ext/vec.cppo.ml"
    ;
    last 

(** delete elements start from [idx] with length [len] *)
  let delete_range (d : t) idx len =
    let d_len = d.len in 
    if len < 0 || idx < 0 || idx + len > d_len then invalid_arg  "Vec.delete_range"  ;
    let arr = d.arr in 
     unsafe_blit arr (idx + len) arr idx (d_len  - idx - len);
    d.len <- d_len - len

# 406 "ext/vec.cppo.ml"
(** delete elements from [idx] with length [len] return the deleted elements as a new vec*)
  let get_and_delete_range (d : t) idx len : t = 
    let d_len = d.len in 
    if len < 0 || idx < 0 || idx + len > d_len then invalid_arg  "Vec.get_and_delete_range"  ;
    let arr = d.arr in 
    let value =  unsafe_sub arr idx len in
     unsafe_blit arr (idx + len) arr idx (d_len  - idx - len);
    d.len <- d_len - len; 
    
# 420 "ext/vec.cppo.ml"
    {len = len ; arr = value}


  (** Below are simple wrapper around normal Array operations *)  

  let clear (d : t ) =
    
# 432 "ext/vec.cppo.ml"
    d.len <- 0



  let inplace_filter f (d : t) : unit = 
    let d_arr = d.arr in     
    let d_len = d.len in
    let p = ref 0 in
    for i = 0 to d_len - 1 do 
      let x = Array.unsafe_get d_arr i in 
      if f x then 
        begin 
          let curr_p = !p in 
          (if curr_p <> i then 
             Array.unsafe_set d_arr curr_p x) ;
          incr p
        end
    done ;
    let last = !p  in 
    
# 452 "ext/vec.cppo.ml"
    d.len <-  last 
    (* INT , there is not need to reset it, since it will cause GC behavior *)

  
# 458 "ext/vec.cppo.ml"
  let inplace_filter_from start f (d : t) : unit = 
    if start < 0 then invalid_arg "Vec.inplace_filter_from"; 
    let d_arr = d.arr in     
    let d_len = d.len in
    let p = ref start in    
    for i = start to d_len - 1 do 
      let x = Array.unsafe_get d_arr i in 
      if f x then 
        begin 
          let curr_p = !p in 
          (if curr_p <> i then 
             Array.unsafe_set d_arr curr_p x) ;
          incr p
        end
    done ;
    let last = !p  in 
    
# 475 "ext/vec.cppo.ml"
    d.len <-  last 


# 481 "ext/vec.cppo.ml"
(** inplace filter the elements and accumulate the non-filtered elements *)
  let inplace_filter_with  f ~cb_no acc (d : t)  = 
    let d_arr = d.arr in     
    let p = ref 0 in
    let d_len = d.len in
    let acc = ref acc in 
    for i = 0 to d_len - 1 do 
      let x = Array.unsafe_get d_arr i in 
      if f x then 
        begin 
          let curr_p = !p in 
          (if curr_p <> i then 
             Array.unsafe_set d_arr curr_p x) ;
          incr p
        end
      else 
        acc := cb_no  x  !acc
    done ;
    let last = !p  in 
    
# 501 "ext/vec.cppo.ml"
    d.len <-  last 
    (* INT , there is not need to reset it, since it will cause GC behavior *)
    
# 506 "ext/vec.cppo.ml"
    ; !acc 




end
module Int_vec_util : sig 
#1 "int_vec_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val mem : int -> Vec_int.t -> bool

end = struct
#1 "int_vec_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let rec unsafe_mem_aux arr i (key : int) bound =
  if i <= bound then
    if Array.unsafe_get arr i = (key : int) then true
    else unsafe_mem_aux arr (i + 1) key bound
  else false

let mem key (x : Vec_int.t) =
  let internal_array = Vec_int.unsafe_internal_array x in
  let len = Vec_int.length x in
  unsafe_mem_aux internal_array 0 key (len - 1)

end
module Ounit_int_vec_tests
= struct
#1 "ounit_int_vec_tests.ml"
let ((>::),
    (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal
let suites = 
    __FILE__
    >:::
    [
        __LOC__ >:: begin fun _ -> 
            OUnit.assert_bool __LOC__
             (Int_vec_util.mem 3 (Vec_int.of_list [1;2;3]))
             ;
            OUnit.assert_bool __LOC__ 
             (not @@ Int_vec_util.mem 0 (Vec_int.of_list [1;2]) ); 
            
            let v = Vec_int.make 100 in 
            OUnit.assert_bool __LOC__ 
                (not @@ Int_vec_util.mem 0 v) ;
            Vec_int.push v 0;
            OUnit.assert_bool __LOC__ 
                (Int_vec_util.mem 0 v )
        end;

        __LOC__ >:: begin fun _ -> 
            let u = Vec_int.make 100 in 
            Vec_int.push u 1;
            OUnit.assert_bool __LOC__
            (not @@ Int_vec_util.mem 0 u );
            Vec_int.push u 0; 
            OUnit.assert_bool __LOC__
            (Int_vec_util.mem 0 u)
        end
    ]
end
module Ext_utf8 : sig 
#1 "ext_utf8.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type byte = Single of int | Cont of int | Leading of int * int | Invalid

val classify : char -> byte

val follow : string -> int -> int -> int -> int * int

val next : string -> remaining:int -> int -> int
(** 
   return [-1] if failed 
*)

exception Invalid_utf8 of string

val decode_utf8_string : string -> int list

end = struct
#1 "ext_utf8.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type byte = Single of int | Cont of int | Leading of int * int | Invalid

(** [classify chr] returns the {!byte} corresponding to [chr] *)
let classify chr =
  let c = int_of_char chr in
  (* Classify byte according to leftmost 0 bit *)
  if c land 0b1000_0000 = 0 then Single c
  else if (* c 0b0____*)
          c land 0b0100_0000 = 0 then Cont (c land 0b0011_1111)
  else if (* c 0b10___*)
          c land 0b0010_0000 = 0 then Leading (1, c land 0b0001_1111)
  else if (* c 0b110__*)
          c land 0b0001_0000 = 0 then Leading (2, c land 0b0000_1111)
  else if (* c 0b1110_ *)
          c land 0b0000_1000 = 0 then Leading (3, c land 0b0000_0111)
  else if (* c 0b1111_0___*)
          c land 0b0000_0100 = 0 then Leading (4, c land 0b0000_0011)
  else if (* c 0b1111_10__*)
          c land 0b0000_0010 = 0 then Leading (5, c land 0b0000_0001)
    (* c 0b1111_110__ *)
  else Invalid

exception Invalid_utf8 of string

(* when the first char is [Leading],
   TODO: need more error checking
   when out of bond
*)
let rec follow s n (c : int) offset =
  if n = 0 then (c, offset)
  else
    match classify s.[offset + 1] with
    | Cont cc -> follow s (n - 1) ((c lsl 6) lor (cc land 0x3f)) (offset + 1)
    | _ -> raise (Invalid_utf8 "Continuation byte expected")

let rec next s ~remaining offset =
  if remaining = 0 then offset
  else
    match classify s.[offset + 1] with
    | Cont _cc -> next s ~remaining:(remaining - 1) (offset + 1)
    | _ -> -1
    | exception _ -> -1
(* it can happen when out of bound *)

let decode_utf8_string s =
  let lst = ref [] in
  let add elem = lst := elem :: !lst in
  let rec decode_utf8_cont s i s_len =
    if i = s_len then ()
    else
      match classify s.[i] with
      | Single c ->
          add c;
          decode_utf8_cont s (i + 1) s_len
      | Cont _ -> raise (Invalid_utf8 "Unexpected continuation byte")
      | Leading (n, c) ->
          let c', i' = follow s n c i in
          add c';
          decode_utf8_cont s (i' + 1) s_len
      | Invalid -> raise (Invalid_utf8 "Invalid byte")
  in
  decode_utf8_cont s 0 (String.length s);
  List.rev !lst

(** To decode {j||j} we need verify in the ast so that we have better error 
    location, then we do the decode later
*)

(* let verify s loc =
   assert false *)

end
module Ext_js_regex : sig 
#1 "ext_js_regex.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(* This is a module that checks if js regex is valid or not *)

val js_regex_checker : string -> bool

end = struct
#1 "ext_js_regex.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let check_from_end al =
  let rec aux l seen =
    match l with
    | [] -> false
    | e :: r ->
        if e < 0 || e > 255 then false
        else
          let c = Char.chr e in
          if c = '/' then true
          else if Ext_list.exists seen (fun x -> x = c) then false
            (* flag should not be repeated *)
          else if c = 'i' || c = 'g' || c = 'm' || c = 'y' || c = 'u' then
            aux r (c :: seen)
          else false
  in
  aux al []

let js_regex_checker s =
  match Ext_utf8.decode_utf8_string s with
  | [] -> false
  | 47 (* [Char.code '/' = 47 ]*) :: tail -> check_from_end (List.rev tail)
  | _ :: _ -> false
  | exception Ext_utf8.Invalid_utf8 _ -> false

end
module Ounit_js_regex_checker_tests
= struct
#1 "ounit_js_regex_checker_tests.ml"
let ((>::),
    (>:::)) = OUnit.((>::),(>:::))

open Ext_js_regex

let suites =
    __FILE__
    >:::
    [
        "test_empty_string" >:: begin fun _ ->
        let b = js_regex_checker "" in
        OUnit.assert_equal b false
        end;
        "test_normal_regex" >:: begin fun _ ->
        let b = js_regex_checker "/abc/" in
        OUnit.assert_equal b true
        end;
        "test_wrong_regex_last" >:: begin fun _ ->
        let b = js_regex_checker "/abc" in 
        OUnit.assert_equal b false
        end;
        "test_regex_with_flag" >:: begin fun _ ->
        let b = js_regex_checker "/ss/ig" in
        OUnit.assert_equal b true
        end;
        "test_regex_with_invalid_flag" >:: begin fun _ ->
        let b = js_regex_checker "/ss/j" in
        OUnit.assert_equal b false
        end;
        "test_regex_invalid_regex" >:: begin fun _ ->
        let b = js_regex_checker "abc/i" in 
        OUnit.assert_equal b false
        end;
        "test_regex_empty_pattern" >:: begin fun _  ->
        let b = js_regex_checker "//" in 
        OUnit.assert_equal b true
        end;
        "test_regex_with_utf8" >:: begin fun _ ->
        let b = js_regex_checker "/😃/" in
        OUnit.assert_equal b true
        end;
        "test_regex_repeated_flags" >:: begin fun _ ->
        let b = js_regex_checker "/abc/gg" in
        OUnit.assert_equal b false
        end;
    ]
end
module Ext_json_types
= struct
#1 "ext_json_types.ml"
(* Copyright (C) 2015-2017 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type loc = Lexing.position

type json_str = { str : string; loc : loc }

type json_flo = { flo : string; loc : loc }

type json_array = { content : t array; loc_start : loc; loc_end : loc }

and json_map = { map : t Map_string.t; loc : loc }

and t =
  | True of loc
  | False of loc
  | Null of loc
  | Flo of json_flo
  | Str of json_str
  | Arr of json_array
  | Obj of json_map

end
module Ext_position : sig 
#1 "ext_position.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Lexing.position = {
  pos_fname : string;
  pos_lnum : int;
  pos_bol : int;
  pos_cnum : int;
}

val offset : t -> t -> t
(** [offset pos newpos]
    return a new position
    here [newpos] is zero based, the use case is that
    at position [pos], we get a string and Lexing from that string,
    therefore, we get a [newpos] and we need rebase it on top of 
    [pos]
*)

val lexbuf_from_channel_with_fname : in_channel -> string -> Lexing.lexbuf

val print : Format.formatter -> t -> unit

end = struct
#1 "ext_position.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Lexing.position = {
  pos_fname : string;
  pos_lnum : int;
  pos_bol : int;
  pos_cnum : int;
}

let offset (x : t) (y : t) =
  {
    x with
    pos_lnum = x.pos_lnum + y.pos_lnum - 1;
    pos_cnum = x.pos_cnum + y.pos_cnum;
    pos_bol = (if y.pos_lnum = 1 then x.pos_bol else x.pos_cnum + y.pos_bol);
  }

let print fmt (pos : t) =
  Format.fprintf fmt "(line %d, column %d)" pos.pos_lnum
    (pos.pos_cnum - pos.pos_bol)

let lexbuf_from_channel_with_fname ic fname =
  let x = Lexing.from_function (fun buf n -> input ic buf 0 n) in
  let pos : t =
    {
      pos_fname = fname;
      pos_lnum = 1;
      pos_bol = 0;
      pos_cnum = 0 (* copied from zero_pos*);
    }
  in
  x.lex_start_p <- pos;
  x.lex_curr_p <- pos;
  x

end
module Ext_json : sig 
#1 "ext_json.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type path = string list

type status = No_path | Found of Ext_json_types.t | Wrong_type of path

type callback =
  [ `Str of string -> unit
  | `Str_loc of string -> Lexing.position -> unit
  | `Flo of string -> unit
  | `Flo_loc of string -> Lexing.position -> unit
  | `Bool of bool -> unit
  | `Obj of Ext_json_types.t Map_string.t -> unit
  | `Arr of Ext_json_types.t array -> unit
  | `Arr_loc of
    Ext_json_types.t array -> Lexing.position -> Lexing.position -> unit
  | `Null of unit -> unit
  | `Not_found of unit -> unit
  | `Id of Ext_json_types.t -> unit ]

val test :
  ?fail:(unit -> unit) ->
  string ->
  callback ->
  Ext_json_types.t Map_string.t ->
  Ext_json_types.t Map_string.t

val loc_of : Ext_json_types.t -> Ext_position.t

end = struct
#1 "ext_json.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type callback =
  [ `Str of string -> unit
  | `Str_loc of string -> Lexing.position -> unit
  | `Flo of string -> unit
  | `Flo_loc of string -> Lexing.position -> unit
  | `Bool of bool -> unit
  | `Obj of Ext_json_types.t Map_string.t -> unit
  | `Arr of Ext_json_types.t array -> unit
  | `Arr_loc of
    Ext_json_types.t array -> Lexing.position -> Lexing.position -> unit
  | `Null of unit -> unit
  | `Not_found of unit -> unit
  | `Id of Ext_json_types.t -> unit ]

type path = string list

type status = No_path | Found of Ext_json_types.t | Wrong_type of path

let test ?(fail = fun () -> ()) key (cb : callback)
    (m : Ext_json_types.t Map_string.t) =
  (match (Map_string.find_exn m key, cb) with
  | exception Not_found -> (
      match cb with `Not_found f -> f () | _ -> fail ())
  | True _, `Bool cb -> cb true
  | False _, `Bool cb -> cb false
  | Flo { flo = s }, `Flo cb -> cb s
  | Flo { flo = s; loc }, `Flo_loc cb -> cb s loc
  | Obj { map = b }, `Obj cb -> cb b
  | Arr { content }, `Arr cb -> cb content
  | Arr { content; loc_start; loc_end }, `Arr_loc cb ->
      cb content loc_start loc_end
  | Null _, `Null cb -> cb ()
  | Str { str = s }, `Str cb -> cb s
  | Str { str = s; loc }, `Str_loc cb -> cb s loc
  | any, `Id cb -> cb any
  | _, _ -> fail ());
  m

let loc_of (x : Ext_json_types.t) =
  match x with
  | True p | False p | Null p -> p
  | Str p -> p.loc
  | Arr p -> p.loc_start
  | Obj p -> p.loc
  | Flo p -> p.loc

end
module Ext_json_noloc : sig 
#1 "ext_json_noloc.mli"
(* Copyright (C) 2017- Authors of ReScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = private
  | True
  | False
  | Null
  | Flo of string
  | Str of string
  | Arr of t array
  | Obj of t Map_string.t

val true_ : t

val false_ : t

val null : t

val str : string -> t

val flo : string -> t

val arr : t array -> t

val obj : t Map_string.t -> t

val kvs : (string * t) list -> t

val to_string : t -> string

val to_channel : out_channel -> t -> unit

val to_file : string -> t -> unit

end = struct
#1 "ext_json_noloc.ml"
(* Copyright (C) 2017- Hongbo Zhang, Authors of ReScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(* This file is only used in bsb watcher searlization *)
type t =
  | True
  | False
  | Null
  | Flo of string
  | Str of string
  | Arr of t array
  | Obj of t Map_string.t

(** poor man's serialization *)
let naive_escaped (unmodified_input : string) : string =
  let n = ref 0 in
  let len = String.length unmodified_input in
  for i = 0 to len - 1 do
    n :=
      !n
      +
      match String.unsafe_get unmodified_input i with
      | '\"' | '\\' | '\n' | '\t' | '\r' | '\b' -> 2
      | _ -> 1
  done;
  if !n = len then unmodified_input
  else
    let result = Bytes.create !n in
    n := 0;
    for i = 0 to len - 1 do
      let open Bytes in
      (match String.unsafe_get unmodified_input i with
      | ('\"' | '\\') as c ->
          unsafe_set result !n '\\';
          incr n;
          unsafe_set result !n c
      | '\n' ->
          unsafe_set result !n '\\';
          incr n;
          unsafe_set result !n 'n'
      | '\t' ->
          unsafe_set result !n '\\';
          incr n;
          unsafe_set result !n 't'
      | '\r' ->
          unsafe_set result !n '\\';
          incr n;
          unsafe_set result !n 'r'
      | '\b' ->
          unsafe_set result !n '\\';
          incr n;
          unsafe_set result !n 'b'
      | c -> unsafe_set result !n c);
      incr n
    done;
    Bytes.unsafe_to_string result

let quot x = "\"" ^ naive_escaped x ^ "\""

let true_ = True

let false_ = False

let null = Null

let str s = Str s

let flo s = Flo s

let arr s = Arr s

let obj s = Obj s

let kvs s = Obj (Map_string.of_list s)

let rec encode_buf (x : t) (buf : Buffer.t) : unit =
  let a str = Buffer.add_string buf str in
  match x with
  | Null -> a "null"
  | Str s -> a (quot s)
  | Flo s ->
      a s
      (*
         since our parsing keep the original float representation, we just dump it as is, there is no cases like [nan] *)
  | Arr content -> (
      match content with
      | [||] -> a "[]"
      | _ ->
          a "[ ";
          encode_buf (Array.unsafe_get content 0) buf;
          for i = 1 to Array.length content - 1 do
            a " , ";
            encode_buf (Array.unsafe_get content i) buf
          done;
          a " ]")
  | True -> a "true"
  | False -> a "false"
  | Obj map ->
      if Map_string.is_empty map then a "{}"
      else (
        (*prerr_endline "WEIRD";
          prerr_endline (string_of_int @@ Map_string.cardinal map ); *)
        a "{ ";
        let (_ : int) =
          Map_string.fold map 0 (fun k v i ->
              if i <> 0 then a " , ";
              a (quot k);
              a " : ";
              encode_buf v buf;
              i + 1)
        in
        a " }")

let to_string x =
  let buf = Buffer.create 1024 in
  encode_buf x buf;
  Buffer.contents buf

let to_channel (oc : out_channel) x =
  let buf = Buffer.create 1024 in
  encode_buf x buf;
  Buffer.output_buffer oc buf

let to_file name v =
  let ochan = open_out_bin name in
  to_channel ochan v;
  close_out ochan

end
module Ext_json_parse : sig 
#1 "ext_json_parse.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type error

val report_error : Format.formatter -> error -> unit

exception Error of Lexing.position * Lexing.position * error

val parse_json_from_string : string -> Ext_json_types.t

val parse_json_from_chan : string -> in_channel -> Ext_json_types.t

val parse_json_from_file : string -> Ext_json_types.t

end = struct
#1 "ext_json_parse.ml"
# 1 "ext/ext_json_parse.mll"
 
type error =
  | Illegal_character of char
  | Unterminated_string
  | Unterminated_comment
  | Illegal_escape of string
  | Unexpected_token 
  | Expect_comma_or_rbracket
  | Expect_comma_or_rbrace
  | Expect_colon
  | Expect_string_or_rbrace 
  | Expect_eof 
  (* | Trailing_comma_in_obj *)
  (* | Trailing_comma_in_array *)


let fprintf  = Format.fprintf
let report_error ppf = function
  | Illegal_character c ->
      fprintf ppf "Illegal character (%s)" (Char.escaped c)
  | Illegal_escape s ->
      fprintf ppf "Illegal backslash escape in string or character (%s)" s
  | Unterminated_string -> 
      fprintf ppf "Unterminated_string"
  | Expect_comma_or_rbracket ->
    fprintf ppf "Expect_comma_or_rbracket"
  | Expect_comma_or_rbrace -> 
    fprintf ppf "Expect_comma_or_rbrace"
  | Expect_colon -> 
    fprintf ppf "Expect_colon"
  | Expect_string_or_rbrace  -> 
    fprintf ppf "Expect_string_or_rbrace"
  | Expect_eof  -> 
    fprintf ppf "Expect_eof"
  | Unexpected_token 
    ->
    fprintf ppf "Unexpected_token"
  (* | Trailing_comma_in_obj  *)
  (*   -> fprintf ppf "Trailing_comma_in_obj" *)
  (* | Trailing_comma_in_array  *)
  (*   -> fprintf ppf "Trailing_comma_in_array" *)
  | Unterminated_comment 
    -> fprintf ppf "Unterminated_comment"
         

exception Error of Lexing.position * Lexing.position * error


let () = 
  Printexc.register_printer
    (function x -> 
     match x with 
     | Error (loc_start,loc_end,error) -> 
       Some (Format.asprintf 
          "@[%a:@ %a@ -@ %a)@]" 
          report_error  error
          Ext_position.print loc_start
          Ext_position.print loc_end
       )

     | _ -> None
    )





type token = 
  | Comma
  | Eof
  | False
  | Lbrace
  | Lbracket
  | Null
  | Colon
  | Number of string
  | Rbrace
  | Rbracket
  | String of string
  | True   
  
let error  (lexbuf : Lexing.lexbuf) e = 
  raise (Error (lexbuf.lex_start_p, lexbuf.lex_curr_p, e))


let lexeme_len (x : Lexing.lexbuf) =
  x.lex_curr_pos - x.lex_start_pos

let update_loc (lexbuf : Lexing.lexbuf) diff =
  let lex_curr_p = lexbuf.lex_curr_p in 
  lexbuf.lex_curr_p <-
    {
      lex_curr_p with
      pos_lnum = lex_curr_p.pos_lnum + 1;
      pos_bol = lex_curr_p.pos_cnum - diff;
    }

let char_for_backslash = function
  | 'n' -> '\010'
  | 'r' -> '\013'
  | 'b' -> '\008'
  | 't' -> '\009'
  | c -> c

let dec_code c1 c2 c3 =
  100 * (Char.code c1 - 48) + 10 * (Char.code c2 - 48) + (Char.code c3 - 48)

let hex_code c1 c2 =
  let d1 = Char.code c1 in
  let val1 =
    if d1 >= 97 then d1 - 87
    else if d1 >= 65 then d1 - 55
    else d1 - 48 in
  let d2 = Char.code c2 in
  let val2 =
    if d2 >= 97 then d2 - 87
    else if d2 >= 65 then d2 - 55
    else d2 - 48 in
  val1 * 16 + val2

let lf = '\010'

# 125 "ext/ext_json_parse.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base =
   "\000\000\239\255\240\255\241\255\000\000\025\000\011\000\244\255\
    \245\255\246\255\247\255\248\255\249\255\000\000\000\000\000\000\
    \041\000\001\000\254\255\005\000\005\000\253\255\001\000\002\000\
    \252\255\000\000\000\000\003\000\251\255\001\000\003\000\250\255\
    \079\000\089\000\099\000\121\000\131\000\141\000\153\000\163\000\
    \001\000\253\255\254\255\023\000\255\255\006\000\246\255\189\000\
    \248\255\215\000\255\255\249\255\249\000\181\000\252\255\009\000\
    \063\000\075\000\234\000\251\255\032\001\250\255";
  Lexing.lex_backtrk =
   "\255\255\255\255\255\255\255\255\013\000\013\000\016\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\016\000\016\000\016\000\
    \016\000\016\000\255\255\000\000\012\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\013\000\255\255\013\000\255\255\013\000\255\255\
    \255\255\255\255\255\255\001\000\255\255\255\255\255\255\008\000\
    \255\255\255\255\255\255\255\255\006\000\006\000\255\255\006\000\
    \001\000\002\000\255\255\255\255\255\255\255\255";
  Lexing.lex_default =
   "\001\000\000\000\000\000\000\000\255\255\255\255\255\255\000\000\
    \000\000\000\000\000\000\000\000\000\000\255\255\255\255\255\255\
    \255\255\255\255\000\000\255\255\020\000\000\000\255\255\255\255\
    \000\000\255\255\255\255\255\255\000\000\255\255\255\255\000\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \042\000\000\000\000\000\255\255\000\000\047\000\000\000\047\000\
    \000\000\051\000\000\000\000\000\255\255\255\255\000\000\255\255\
    \255\255\255\255\255\255\000\000\255\255\000\000";
  Lexing.lex_trans =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\019\000\018\000\018\000\019\000\017\000\019\000\255\255\
    \048\000\019\000\255\255\057\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \019\000\000\000\003\000\000\000\000\000\019\000\000\000\000\000\
    \050\000\000\000\000\000\043\000\008\000\006\000\033\000\016\000\
    \004\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\007\000\004\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\032\000\044\000\033\000\
    \056\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\021\000\057\000\000\000\000\000\000\000\
    \020\000\000\000\000\000\012\000\000\000\011\000\032\000\056\000\
    \000\000\025\000\049\000\000\000\000\000\032\000\014\000\024\000\
    \028\000\000\000\000\000\057\000\026\000\030\000\013\000\031\000\
    \000\000\000\000\022\000\027\000\015\000\029\000\023\000\000\000\
    \000\000\000\000\039\000\010\000\039\000\009\000\032\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\037\000\000\000\037\000\000\000\
    \035\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\255\255\
    \035\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\000\000\000\000\255\255\
    \000\000\056\000\000\000\000\000\055\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\054\000\
    \000\000\054\000\000\000\000\000\000\000\000\000\054\000\000\000\
    \002\000\041\000\000\000\000\000\000\000\255\255\046\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\255\255\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\000\000\000\000\000\000\000\000\
    \000\000\060\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \060\000\060\000\060\000\054\000\000\000\000\000\000\000\000\000\
    \000\000\054\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \000\000\000\000\000\000\000\000\000\000\054\000\000\000\000\000\
    \000\000\054\000\000\000\054\000\000\000\000\000\000\000\052\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \000\000\061\000\061\000\061\000\061\000\061\000\061\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\061\000\061\000\061\000\061\000\061\000\061\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\255\255\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000";
  Lexing.lex_check =
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\017\000\000\000\000\000\019\000\020\000\
    \045\000\019\000\020\000\055\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\000\000\255\255\255\255\019\000\255\255\255\255\
    \045\000\255\255\255\255\040\000\000\000\000\000\004\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\004\000\043\000\005\000\
    \056\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\016\000\057\000\255\255\255\255\255\255\
    \016\000\255\255\255\255\000\000\255\255\000\000\005\000\056\000\
    \255\255\014\000\045\000\255\255\255\255\004\000\000\000\023\000\
    \027\000\255\255\255\255\057\000\025\000\029\000\000\000\030\000\
    \255\255\255\255\015\000\026\000\000\000\013\000\022\000\255\255\
    \255\255\255\255\032\000\000\000\032\000\000\000\005\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\035\000\255\255\035\000\255\255\
    \034\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\047\000\
    \034\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\039\000\039\000\039\000\039\000\039\000\
    \039\000\039\000\039\000\039\000\039\000\255\255\255\255\047\000\
    \255\255\049\000\255\255\255\255\049\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\049\000\
    \255\255\049\000\255\255\255\255\255\255\255\255\049\000\255\255\
    \000\000\040\000\255\255\255\255\255\255\020\000\045\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\047\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\255\255\255\255\255\255\255\255\
    \255\255\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\049\000\255\255\255\255\255\255\255\255\
    \255\255\049\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \255\255\255\255\255\255\255\255\255\255\049\000\255\255\255\255\
    \255\255\049\000\255\255\049\000\255\255\255\255\255\255\049\000\
    \060\000\060\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \060\000\060\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \255\255\060\000\060\000\060\000\060\000\060\000\060\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\060\000\060\000\060\000\060\000\060\000\060\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\047\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\049\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255";
  Lexing.lex_base_code =
   "";
  Lexing.lex_backtrk_code =
   "";
  Lexing.lex_default_code =
   "";
  Lexing.lex_trans_code =
   "";
  Lexing.lex_check_code =
   "";
  Lexing.lex_code =
   "";
}

let rec lex_json buf lexbuf =
   __ocaml_lex_lex_json_rec buf lexbuf 0
and __ocaml_lex_lex_json_rec buf lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 143 "ext/ext_json_parse.mll"
          ( lex_json buf lexbuf)
# 315 "ext/ext_json_parse.ml"

  | 1 ->
# 144 "ext/ext_json_parse.mll"
                   ( 
    update_loc lexbuf 0;
    lex_json buf  lexbuf
  )
# 323 "ext/ext_json_parse.ml"

  | 2 ->
# 148 "ext/ext_json_parse.mll"
                ( comment buf lexbuf)
# 328 "ext/ext_json_parse.ml"

  | 3 ->
# 149 "ext/ext_json_parse.mll"
         ( True)
# 333 "ext/ext_json_parse.ml"

  | 4 ->
# 150 "ext/ext_json_parse.mll"
          (False)
# 338 "ext/ext_json_parse.ml"

  | 5 ->
# 151 "ext/ext_json_parse.mll"
         (Null)
# 343 "ext/ext_json_parse.ml"

  | 6 ->
# 152 "ext/ext_json_parse.mll"
       (Lbracket)
# 348 "ext/ext_json_parse.ml"

  | 7 ->
# 153 "ext/ext_json_parse.mll"
       (Rbracket)
# 353 "ext/ext_json_parse.ml"

  | 8 ->
# 154 "ext/ext_json_parse.mll"
       (Lbrace)
# 358 "ext/ext_json_parse.ml"

  | 9 ->
# 155 "ext/ext_json_parse.mll"
       (Rbrace)
# 363 "ext/ext_json_parse.ml"

  | 10 ->
# 156 "ext/ext_json_parse.mll"
       (Comma)
# 368 "ext/ext_json_parse.ml"

  | 11 ->
# 157 "ext/ext_json_parse.mll"
        (Colon)
# 373 "ext/ext_json_parse.ml"

  | 12 ->
# 158 "ext/ext_json_parse.mll"
                      (lex_json buf lexbuf)
# 378 "ext/ext_json_parse.ml"

  | 13 ->
# 160 "ext/ext_json_parse.mll"
         ( Number (Lexing.lexeme lexbuf))
# 383 "ext/ext_json_parse.ml"

  | 14 ->
# 162 "ext/ext_json_parse.mll"
      (
  let pos = Lexing.lexeme_start_p lexbuf in
  scan_string buf pos lexbuf;
  let content = (Buffer.contents  buf) in 
  Buffer.clear buf ;
  String content 
)
# 394 "ext/ext_json_parse.ml"

  | 15 ->
# 169 "ext/ext_json_parse.mll"
       (Eof )
# 399 "ext/ext_json_parse.ml"

  | 16 ->
let
# 170 "ext/ext_json_parse.mll"
       c
# 405 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 170 "ext/ext_json_parse.mll"
          ( error lexbuf (Illegal_character c ))
# 409 "ext/ext_json_parse.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_lex_json_rec buf lexbuf __ocaml_lex_state

and comment buf lexbuf =
   __ocaml_lex_comment_rec buf lexbuf 40
and __ocaml_lex_comment_rec buf lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 172 "ext/ext_json_parse.mll"
              (lex_json buf lexbuf)
# 421 "ext/ext_json_parse.ml"

  | 1 ->
# 173 "ext/ext_json_parse.mll"
     (comment buf lexbuf)
# 426 "ext/ext_json_parse.ml"

  | 2 ->
# 174 "ext/ext_json_parse.mll"
       (error lexbuf Unterminated_comment)
# 431 "ext/ext_json_parse.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_comment_rec buf lexbuf __ocaml_lex_state

and scan_string buf start lexbuf =
   __ocaml_lex_scan_string_rec buf start lexbuf 45
and __ocaml_lex_scan_string_rec buf start lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 178 "ext/ext_json_parse.mll"
      ( () )
# 443 "ext/ext_json_parse.ml"

  | 1 ->
# 180 "ext/ext_json_parse.mll"
  (
        let len = lexeme_len lexbuf - 2 in
        update_loc lexbuf len;

        scan_string buf start lexbuf
      )
# 453 "ext/ext_json_parse.ml"

  | 2 ->
# 187 "ext/ext_json_parse.mll"
      (
        let len = lexeme_len lexbuf - 3 in
        update_loc lexbuf len;
        scan_string buf start lexbuf
      )
# 462 "ext/ext_json_parse.ml"

  | 3 ->
let
# 192 "ext/ext_json_parse.mll"
                                               c
# 468 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 1) in
# 193 "ext/ext_json_parse.mll"
      (
        Buffer.add_char buf (char_for_backslash c);
        scan_string buf start lexbuf
      )
# 475 "ext/ext_json_parse.ml"

  | 4 ->
let
# 197 "ext/ext_json_parse.mll"
                 c1
# 481 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 1)
and
# 197 "ext/ext_json_parse.mll"
                               c2
# 486 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 2)
and
# 197 "ext/ext_json_parse.mll"
                                             c3
# 491 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 3)
and
# 197 "ext/ext_json_parse.mll"
                                                    s
# 496 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos (lexbuf.Lexing.lex_start_pos + 4) in
# 198 "ext/ext_json_parse.mll"
      (
        let v = dec_code c1 c2 c3 in
        if v > 255 then
          error lexbuf (Illegal_escape s) ;
        Buffer.add_char buf (Char.chr v);

        scan_string buf start lexbuf
      )
# 507 "ext/ext_json_parse.ml"

  | 5 ->
let
# 206 "ext/ext_json_parse.mll"
                        c1
# 513 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 2)
and
# 206 "ext/ext_json_parse.mll"
                                         c2
# 518 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 3) in
# 207 "ext/ext_json_parse.mll"
      (
        let v = hex_code c1 c2 in
        Buffer.add_char buf (Char.chr v);

        scan_string buf start lexbuf
      )
# 527 "ext/ext_json_parse.ml"

  | 6 ->
let
# 213 "ext/ext_json_parse.mll"
             c
# 533 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 1) in
# 214 "ext/ext_json_parse.mll"
      (
        Buffer.add_char buf '\\';
        Buffer.add_char buf c;

        scan_string buf start lexbuf
      )
# 542 "ext/ext_json_parse.ml"

  | 7 ->
# 221 "ext/ext_json_parse.mll"
      (
        update_loc lexbuf 0;
        Buffer.add_char buf lf;

        scan_string buf start lexbuf
      )
# 552 "ext/ext_json_parse.ml"

  | 8 ->
# 228 "ext/ext_json_parse.mll"
      (
        let ofs = lexbuf.lex_start_pos in
        let len = lexbuf.lex_curr_pos - ofs in
        Buffer.add_subbytes buf lexbuf.lex_buffer ofs len;

        scan_string buf start lexbuf
      )
# 563 "ext/ext_json_parse.ml"

  | 9 ->
# 236 "ext/ext_json_parse.mll"
      (
        error lexbuf Unterminated_string
      )
# 570 "ext/ext_json_parse.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_scan_string_rec buf start lexbuf __ocaml_lex_state

;;

# 240 "ext/ext_json_parse.mll"
 






let  parse_json lexbuf =
  let buf = Buffer.create 64 in 
  let look_ahead = ref None in
  let token () : token = 
    match !look_ahead with 
    | None ->  
      lex_json buf lexbuf 
    | Some x -> 
      look_ahead := None ;
      x 
  in
  let push e = look_ahead := Some e in 
  let rec json (lexbuf : Lexing.lexbuf) : Ext_json_types.t = 
    match token () with 
    | True -> True lexbuf.lex_start_p
    | False -> False lexbuf.lex_start_p
    | Null -> Null lexbuf.lex_start_p
    | Number s ->  Flo {flo = s; loc = lexbuf.lex_start_p}  
    | String s -> Str { str = s; loc =    lexbuf.lex_start_p}
    | Lbracket -> parse_array  lexbuf.lex_start_p lexbuf.lex_curr_p [] lexbuf
    | Lbrace -> parse_map lexbuf.lex_start_p Map_string.empty lexbuf
    |  _ -> error lexbuf Unexpected_token

(* Note if we remove [trailing_comma] support 
    we should report errors (actually more work), for example 
    {[
    match token () with 
    | Rbracket ->
      if trailing_comma then
        error lexbuf Trailing_comma_in_array
      else
    ]} 
    {[
    match token () with 
    | Rbrace -> 
      if trailing_comma then
        error lexbuf Trailing_comma_in_obj
      else

    ]}   
 *)
  and parse_array   loc_start loc_finish acc lexbuf 
    : Ext_json_types.t =
    match token () with 
    | Rbracket ->
        Arr {loc_start ; content = Ext_array.reverse_of_list acc ; 
              loc_end = lexbuf.lex_curr_p }
    | x -> 
      push x ;
      let new_one = json lexbuf in 
      begin match token ()  with 
      | Comma -> 
          parse_array  loc_start loc_finish (new_one :: acc) lexbuf 
      | Rbracket 
        -> Arr {content = (Ext_array.reverse_of_list (new_one::acc));
                     loc_start ; 
                     loc_end = lexbuf.lex_curr_p }
      | _ -> 
        error lexbuf Expect_comma_or_rbracket
      end
  and parse_map loc_start  acc lexbuf : Ext_json_types.t = 
    match token () with 
    | Rbrace -> 
        Obj { map = acc ; loc = loc_start}
    | String key -> 
      begin match token () with 
      | Colon ->
        let value = json lexbuf in
        begin match token () with 
        | Rbrace -> Obj {map = Map_string.add acc key value  ; loc = loc_start}
        | Comma -> 
          parse_map loc_start  (Map_string.add acc key value ) lexbuf 
        | _ -> error lexbuf Expect_comma_or_rbrace
        end
      | _ -> error lexbuf Expect_colon
      end
    | _ -> error lexbuf Expect_string_or_rbrace
  in 
  let v = json lexbuf in 
  match token () with 
  | Eof -> v 
  | _ -> error lexbuf Expect_eof

let parse_json_from_string s = 
  parse_json (Lexing.from_string s )

let parse_json_from_chan fname in_chan = 
  let lexbuf = 
    Ext_position.lexbuf_from_channel_with_fname
    in_chan fname in 
  parse_json lexbuf 

let parse_json_from_file s = 
  let in_chan = open_in s in 
  let lexbuf = 
    Ext_position.lexbuf_from_channel_with_fname
    in_chan s in 
  match parse_json lexbuf with 
  | exception e -> close_in in_chan ; raise e
  | v  -> close_in in_chan;  v





# 690 "ext/ext_json_parse.ml"

end
module Ounit_json_tests
= struct
#1 "ounit_json_tests.ml"

let ((>::),
     (>:::)) = OUnit.((>::),(>:::))
type t = Ext_json_noloc.t     
let rec equal 
    (x : t)
    (y : t) = 
  match x with 
  | Null  -> (* [%p? Null _ ] *)
    begin match y with
      | Null  -> true
      | _ -> false end
  | Str str  -> 
    begin match y with 
      | Str str2 -> str = str2
      | _ -> false end
  | Flo flo 
    ->
    begin match y with
      |  Flo flo2 -> 
        flo = flo2 
      | _ -> false
    end
  | True  -> 
    begin match y with 
      | True  -> true 
      | _ -> false 
    end
  | False  -> 
    begin match y with 
      | False  -> true 
      | _ -> false 
    end     
  | Arr content 
    -> 
    begin match y with 
      | Arr content2
        ->
        Ext_array.for_all2_no_exn content content2 equal 
      | _ -> false 
    end

  | Obj map -> 
    begin match y with 
      | Obj map2 -> 
        let xs = Map_string.bindings map 
                 |> List.sort (fun (a,_) (b,_) -> compare a b) in 
        let ys = Map_string.bindings map2 
                 |> List.sort (fun (a,_) (b,_) -> compare a b) in 
        Ext_list.for_all2_no_exn xs ys (fun (k0,v0) (k1,v1) -> k0=k1 && equal v0 v1)
      | _ -> false 
    end 


open Ext_json_parse
let (|?)  m (key, cb) =
  m  |> Ext_json.test key cb 

let rec strip (x : Ext_json_types.t) : Ext_json_noloc.t = 
  let open Ext_json_noloc in 
  match x with 
  | True _ -> true_
  | False _ -> false_
  | Null _ -> null
  | Flo {flo = s} -> flo s 
  | Str {str = s} -> str s 
  | Arr {content } -> arr (Array.map strip content)
  | Obj {map} -> 
    obj (Map_string.map map strip)

let id_parsing_serializing x = 
  let normal_s = 
    Ext_json_noloc.to_string 
      @@ strip 
      @@ Ext_json_parse.parse_json_from_string x  
  in 
  let normal_ss = 
    Ext_json_noloc.to_string 
    @@ strip 
    @@ Ext_json_parse.parse_json_from_string normal_s
  in 
  if normal_s <> normal_ss then 
    begin 
      prerr_endline "ERROR";
      prerr_endline normal_s ;
      prerr_endline normal_ss ;
    end;
  OUnit.assert_equal ~cmp:(fun (x:string) y -> x = y) normal_s normal_ss

let id_parsing_x2 x = 
  let stru = Ext_json_parse.parse_json_from_string x |> strip in 
  let normal_s = Ext_json_noloc.to_string stru in 
  let normal_ss = strip (Ext_json_parse.parse_json_from_string normal_s) in 
  if equal stru normal_ss then 
    true
  else begin 
    prerr_endline "ERROR";
    prerr_endline normal_s;
    Format.fprintf Format.err_formatter 
    "%a@.%a@." Ext_obj.pp_any stru Ext_obj.pp_any normal_ss; 
    
    prerr_endline (Ext_json_noloc.to_string normal_ss);
    false
  end  

let test_data = 
  [{|
      {}
      |};
   {| [] |};
   {| [1,2,3]|};
   {| ["x", "y", 1,2,3 ]|};
   {| { "x" :  3, "y" : "x", "z" : [1,2,3, "x"] }|};
   {| {"x " : true , "y" : false , "z\"" : 1} |}
  ] 
exception Parse_error 
let suites = 
  __FILE__ 
  >:::
  [

    __LOC__ >:: begin fun _ -> 
      List.iter id_parsing_serializing test_data
    end;

    __LOC__ >:: begin fun _ -> 
      List.iteri (fun i x -> OUnit.assert_bool (__LOC__ ^ string_of_int i ) (id_parsing_x2 x)) test_data
    end;
    "empty_json" >:: begin fun _ -> 
      let v =parse_json_from_string "{}" in
      match v with 
      | Obj {map = v} -> OUnit.assert_equal (Map_string.is_empty v ) true
      | _ -> OUnit.assert_failure "should be empty"
    end
    ;
    "empty_arr" >:: begin fun _ -> 
      let v =parse_json_from_string "[]" in
      match v with 
      | Arr {content = [||]} -> ()
      | _ -> OUnit.assert_failure "should be empty"
    end
    ;
    "empty trails" >:: begin fun _ -> 
      (OUnit.assert_raises Parse_error @@ fun _ -> 
       try parse_json_from_string {| [,]|} with _ -> raise Parse_error);
      OUnit.assert_raises Parse_error @@ fun _ -> 
      try parse_json_from_string {| {,}|} with _ -> raise Parse_error
    end;
    "two trails" >:: begin fun _ -> 
      (OUnit.assert_raises Parse_error @@ fun _ -> 
       try parse_json_from_string {| [1,2,,]|} with _ -> raise Parse_error);
      (OUnit.assert_raises Parse_error @@ fun _ -> 
       try parse_json_from_string {| { "x": 3, ,}|} with _ -> raise Parse_error)
    end;

    "two trails fail" >:: begin fun _ -> 
      (OUnit.assert_raises Parse_error @@ fun _ -> 
       try parse_json_from_string {| { "x": 3, 2 ,}|} with _ -> raise Parse_error)
    end;

    "trail comma obj" >:: begin fun _ -> 
      let v =  parse_json_from_string {| { "x" : 3 , }|} in 
      let v1 =  parse_json_from_string {| { "x" : 3 , }|} in 
      let test (v : Ext_json_types.t)  = 
        match v with 
        | Obj {map = v} -> 
          v
          |? ("x" , `Flo (fun x -> OUnit.assert_equal x "3"))
          |> ignore 
        | _ -> OUnit.assert_failure "trail comma" in 
      test v ;
      test v1 
    end
    ;
    "trail comma arr" >:: begin fun _ -> 
      let v = parse_json_from_string {| [ 1, 3, ]|} in
      let v1 = parse_json_from_string {| [ 1, 3 ]|} in
      let test (v : Ext_json_types.t) = 
        match v with 
        | Arr { content = [| Flo {flo = "1"} ; Flo { flo = "3"} |] } -> ()
        | _ -> OUnit.assert_failure "trailing comma array" in 
      test v ;
      test v1
    end
  ]

end
module Ounit_list_test
= struct
#1 "ounit_list_test.ml"
let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal
let printer_int_list = fun xs -> Format.asprintf "%a" 
      (Format.pp_print_list  Format.pp_print_int
      ~pp_sep:Format.pp_print_space 
      ) xs 
let suites = 
  __FILE__
  >:::
  [
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_equal
        (Ext_list.flat_map [1;2] (fun x -> [x;x]) ) [1;1;2;2] 
    end;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_equal
        (Ext_list.flat_map_append 
           [1;2] [3;4] (fun x -> [x;x]) ) [1;1;2;2;3;4] 
    end;
    __LOC__ >:: begin fun _ -> 
    
     let (=~)  = OUnit.assert_equal ~printer:printer_int_list in 
     (Ext_list.flat_map  [] (fun x -> [succ x ])) =~ [];
     (Ext_list.flat_map [1] (fun x -> [x;succ x ]) ) =~ [1;2];
     (Ext_list.flat_map [1;2] (fun x -> [x;succ x ])) =~ [1;2;2;3];
     (Ext_list.flat_map [1;2;3] (fun x -> [x;succ x ]) ) =~ [1;2;2;3;3;4]
    end
    ;
    __LOC__ >:: begin fun _ ->
      OUnit.assert_equal 
      (Ext_list.stable_group 
        [1;2;3;4;3] (=)
      )
      ([[1];[2];[4];[3;3]])
    end
    ;
    __LOC__ >:: begin fun _ -> 
      let (=~)  = OUnit.assert_equal ~printer:printer_int_list in 
      let f b _v = if b then 1 else 0 in 
      Ext_list.map_last  []  f =~ [];
      Ext_list.map_last [0] f =~ [1];
      Ext_list.map_last [0;0] f =~ [0;1];
      Ext_list.map_last [0;0;0] f =~ [0;0;1];
      Ext_list.map_last [0;0;0;0] f =~ [0;0;0;1];
      Ext_list.map_last [0;0;0;0;0] f =~ [0;0;0;0;1];
      Ext_list.map_last [0;0;0;0;0;0] f =~ [0;0;0;0;0;1];
      Ext_list.map_last [0;0;0;0;0;0;0] f =~ [0;0;0;0;0;0;1];
    end
    ;
    __LOC__ >:: begin fun _ ->
      OUnit.assert_equal (
        Ext_list.flat_map_append           
          [1;2] [false;false] 
          (fun x -> if x mod 2 = 0 then [true] else [])
      )  [true;false;false]
    end;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_equal (
        Ext_list.map_append  
          [0;1;2] 
          ["1";"2";"3"]
          (fun x -> string_of_int x) 
      )
        ["0";"1";"2"; "1";"2";"3"]
    end;

    __LOC__ >:: begin fun _ -> 
      let (a,b) = Ext_list.split_at [1;2;3;4;5;6]  3 in 
      OUnit.assert_equal (a,b)
        ([1;2;3],[4;5;6]);
      OUnit.assert_equal (Ext_list.split_at  [1] 1)
        ([1],[])  ;
      OUnit.assert_equal (Ext_list.split_at [1;2;3]  2 )
        ([1;2],[3])  
    end;
    __LOC__ >:: begin fun _ -> 
      let printer = fun (a,b) -> 
        Format.asprintf "([%a],%d)"
          (Format.pp_print_list Format.pp_print_int ) a  
          b 
      in 
      let (=~) = OUnit.assert_equal ~printer in 
      (Ext_list.split_at_last [1;2;3])
      =~ ([1;2],3);
      (Ext_list.split_at_last [1;2;3;4;5;6;7;8])
      =~
      ([1;2;3;4;5;6;7],8);
      (Ext_list.split_at_last [1;2;3;4;5;6;7;])
      =~
      ([1;2;3;4;5;6],7)
    end;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_equal (Ext_list.assoc_by_int  [2,"x"; 3,"y"; 1, "z"] 1 None) "z"
    end;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_raise_any
        (fun _ -> Ext_list.assoc_by_int [2,"x"; 3,"y"; 1, "z"] 11 None )
    end ;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_equal
        (Ext_list.length_compare [0;0;0] 3) `Eq ;
      OUnit.assert_equal
        (Ext_list.length_compare [0;0;0] 1) `Gt ;   
      OUnit.assert_equal
        (Ext_list.length_compare [0;0;0] 4) `Lt ;   
      OUnit.assert_equal
        (Ext_list.length_compare [] (-1)) `Gt ;   
      OUnit.assert_equal
        (Ext_list.length_compare [] (0)) `Eq ;          
    end;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool __LOC__ 
        (Ext_list.length_larger_than_n [1;2] [1] 1 );
      OUnit.assert_bool __LOC__ 
        (Ext_list.length_larger_than_n [1;2] [1;2] 0);
      OUnit.assert_bool __LOC__ 
        (Ext_list.length_larger_than_n [1;2] [] 2)

    end;

    __LOC__ >:: begin fun _ ->
      OUnit.assert_bool __LOC__
        (Ext_list.length_ge [1;2;3] 3 );
      OUnit.assert_bool __LOC__
        (Ext_list.length_ge [] 0 );
      OUnit.assert_bool __LOC__
        (not (Ext_list.length_ge [] 1 ));

    end;

    __LOC__ >:: begin fun _ ->
      let (=~) = OUnit.assert_equal in 

      let f p x = Ext_list.exclude_with_val x p  in 
      f  (fun x -> x = 1) [1;2;3] =~ (Some [2;3]);
      f (fun x -> x = 4) [1;2;3] =~ (None);
      f (fun x -> x = 2) [1;2;3;2] =~ (Some [1;3]);
      f (fun x -> x = 2) [1;2;2;3;2] =~ (Some [1;3]);
      f (fun x -> x = 2) [2;2;2] =~ (Some []);
      f (fun x -> x = 3) [2;2;2] =~ (None)
    end ;

  ]
end
module Map_int : sig 
#1 "map_int.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

include Map_gen.S with type key = int

end = struct
#1 "map_int.ml"

# 2 "ext/map.cppo.ml"
(* we don't create [map_poly], since some operations require raise an exception which carries [key] *)

# 9 "ext/map.cppo.ml"
type key = int
let compare_key = Ext_int.compare
let [@inline] eq_key (x : key) y = x = y
    
# 19 "ext/map.cppo.ml"
    (* let [@inline] (=) (a : int) b = a = b *)
type + 'a t = (key,'a) Map_gen.t

let empty = Map_gen.empty 
let is_empty = Map_gen.is_empty
let iter = Map_gen.iter
let fold = Map_gen.fold
let for_all = Map_gen.for_all 
let exists = Map_gen.exists 
let singleton = Map_gen.singleton 
let cardinal = Map_gen.cardinal
let bindings = Map_gen.bindings
let to_sorted_array = Map_gen.to_sorted_array
let to_sorted_array_with_f = Map_gen.to_sorted_array_with_f
let keys = Map_gen.keys



let map = Map_gen.map 
let mapi = Map_gen.mapi
let bal = Map_gen.bal 
let height = Map_gen.height 


let rec add (tree : _ Map_gen.t as 'a) x data  : 'a = match tree with 
  | Empty ->
    singleton x data
  | Leaf {k;v} ->
    let c = compare_key x k in 
    if c = 0 then singleton x data else
    if c < 0 then 
      Map_gen.unsafe_two_elements x data k v 
    else 
      Map_gen.unsafe_two_elements k v x data  
  | Node {l; k ; v ; r; h} ->
    let c = compare_key x k in
    if c = 0 then
      Map_gen.unsafe_node x data l r h (* at least need update data *)
    else if c < 0 then
      bal (add l x data ) k v r
    else
      bal l k v (add r x data )


let rec adjust (tree : _ Map_gen.t as 'a) x replace  : 'a = 
  match tree with 
  | Empty ->
    singleton x (replace None)
  | Leaf {k ; v} -> 
    let c = compare_key x k in 
    if c = 0 then singleton x (replace (Some v)) else 
    if c < 0 then 
      Map_gen.unsafe_two_elements x (replace None) k v   
    else
      Map_gen.unsafe_two_elements k v x (replace None)   
  | Node ({l; k ; r} as tree) ->
    let c = compare_key x k in
    if c = 0 then
      Map_gen.unsafe_node x (replace  (Some tree.v)) l r tree.h
    else if c < 0 then
      bal (adjust l x  replace ) k tree.v r
    else
      bal l k tree.v (adjust r x  replace )


let rec find_exn (tree : _ Map_gen.t ) x = match tree with 
  | Empty ->
    raise Not_found
  | Leaf leaf -> 
    if eq_key x leaf.k then leaf.v else raise Not_found  
  | Node tree ->
    let c = compare_key x tree.k in
    if c = 0 then tree.v
    else find_exn (if c < 0 then tree.l else tree.r) x

let rec find_opt (tree : _ Map_gen.t ) x = match tree with 
  | Empty -> None 
  | Leaf leaf -> 
    if eq_key x leaf.k then Some leaf.v else None
  | Node tree ->
    let c = compare_key x tree.k in
    if c = 0 then Some tree.v
    else find_opt (if c < 0 then tree.l else tree.r) x

let rec find_default (tree : _ Map_gen.t ) x  default     = match tree with 
  | Empty -> default  
  | Leaf leaf -> 
    if eq_key x leaf.k then  leaf.v else default
  | Node tree ->
    let c = compare_key x tree.k in
    if c = 0 then tree.v
    else find_default (if c < 0 then tree.l else tree.r) x default

let rec mem (tree : _ Map_gen.t )  x= match tree with 
  | Empty ->
    false
  | Leaf leaf -> eq_key x leaf.k 
  | Node{l; k ;  r} ->
    let c = compare_key x k in
    c = 0 || mem (if c < 0 then l else r) x 

let rec remove (tree : _ Map_gen.t as 'a) x : 'a = match tree with 
  | Empty -> empty
  | Leaf leaf -> 
    if eq_key x leaf.k then empty 
    else tree
  | Node{l; k ; v; r} ->
    let c = compare_key x k in
    if c = 0 then
      Map_gen.merge l r
    else if c < 0 then
      bal (remove l x) k v r
    else
      bal l k v (remove r x )

type 'a split = 
  | Yes of {l : (key,'a) Map_gen.t; r : (key,'a)Map_gen.t ; v : 'a}
  | No of {l : (key,'a) Map_gen.t; r : (key,'a)Map_gen.t }


let rec split  (tree : (key,'a) Map_gen.t) x : 'a split  = 
  match tree with 
  | Empty ->
    No {l = empty; r = empty}
  | Leaf leaf -> 
    let c = compare_key x leaf.k in 
    if c = 0 then Yes {l = empty; v= leaf.v; r = empty} 
    else if c < 0 then No { l = empty; r = tree }
    else  No { l = tree; r = empty}
  | Node {l; k ; v ; r} ->
    let c = compare_key x k in
    if c = 0 then Yes {l; v; r}
    else if c < 0 then      
      match  split l x with 
      | Yes result -> Yes {result with r = Map_gen.join result.r k v r }
      | No result -> No {result with r = Map_gen.join result.r k v r } 
    else
      match split r x with 
      | Yes result -> 
        Yes {result with l = Map_gen.join l k v result.l}
      | No result -> 
        No {result with l = Map_gen.join l k v result.l}


let rec disjoint_merge_exn  
    (s1 : _ Map_gen.t) 
    (s2  : _ Map_gen.t) 
    fail : _ Map_gen.t =
  match s1 with
  | Empty -> s2  
  | Leaf ({k } as l1)  -> 
    begin match s2 with 
      | Empty -> s1 
      | Leaf l2 -> 
        let c = compare_key k l2.k in 
        if c = 0 then raise_notrace (fail k l1.v l2.v)
        else if c < 0 then Map_gen.unsafe_two_elements l1.k l1.v l2.k l2.v
        else Map_gen.unsafe_two_elements l2.k l2.v k l1.v
      | Node _ -> 
        adjust s2 k (fun data -> 
            match data with 
            |  None -> l1.v
            | Some s2v  -> raise_notrace (fail k l1.v s2v)
          )        
    end
  | Node ({k} as xs1) -> 
    if  xs1.h >= height s2 then
      begin match split s2 k with 
        | No {l; r} -> 
          Map_gen.join 
            (disjoint_merge_exn  xs1.l l fail)
            k 
            xs1.v 
            (disjoint_merge_exn xs1.r r fail)
        | Yes { v =  s2v} ->
          raise_notrace (fail k xs1.v s2v)
      end        
    else let [@warning "-8"] (Node ({k} as s2) : _ Map_gen.t)  = s2 in 
      begin match  split s1 k with 
        | No {l;  r} -> 
          Map_gen.join 
            (disjoint_merge_exn  l s2.l fail) k s2.v 
            (disjoint_merge_exn  r s2.r fail)
        | Yes { v = s1v} -> 
          raise_notrace (fail k s1v s2.v)
      end






let add_list (xs : _ list ) init = 
  Ext_list.fold_left xs init (fun  acc (k,v) -> add acc k v )

let of_list xs = add_list xs empty

let of_array xs = 
  Ext_array.fold_left xs empty (fun acc (k,v) -> add acc k v ) 

end
module Ounit_map_tests
= struct
#1 "ounit_map_tests.ml"
let ((>::),
    (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal 

let test_sorted_strict arr = 
  let v = Map_int.of_array arr |> Map_int.to_sorted_array in 
  let arr_copy = Array.copy arr in 
  Array.sort (fun ((a:int),_) (b,_) -> compare a b ) arr_copy;
  v =~ arr_copy 

let suites = 
  __MODULE__ >:::
  [
    __LOC__ >:: begin fun _ -> 
      [1,"1"; 2,"2"; 12,"12"; 3, "3"]
      |> Map_int.of_list 
      |> Map_int.keys 
      |> OUnit.assert_equal [1;2;3;12]
    end
    ;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_equal (Map_int.cardinal Map_int.empty) 0 ;
      OUnit.assert_equal ([1,"1"; 2,"2"; 12,"12"; 3, "3"]
      |> Map_int.of_list|>Map_int.cardinal )  4      
    end;
    __LOC__ >:: begin fun _ -> 
      let v = 
      [1,"1"; 2,"2"; 12,"12"; 3, "3"]
      |> Map_int.of_list 
      |> Map_int.to_sorted_array in 
      Array.length v =~ 4 ; 
      v =~ [|1,"1"; 2,"2"; 3, "3"; 12,"12"; |]
    end;
    __LOC__ >:: begin fun _ -> 
        test_sorted_strict [||];
        test_sorted_strict [|1,""|];
        test_sorted_strict [|2,""; 1,""|];
        test_sorted_strict [|2,""; 1,""; 3, ""|];
        test_sorted_strict [|2,""; 1,""; 3, ""; 4,""|]
    end;
    __LOC__ >:: begin fun _ ->
      Map_int.cardinal (Map_int.of_array (Array.init 1000 (fun i -> (i,i))))
      =~ 1000
    end;
    __LOC__ >:: begin fun _ -> 
      let count = 1000 in 
      let a = Array.init count (fun x -> x ) in 
      let v = Map_int.empty in
      let u = 
        begin 
          let v = Array.fold_left (fun acc key -> Map_int.adjust acc key (fun v ->  match v with None -> 1 | Some v -> succ v)  ) v a   in 
          Array.fold_left (fun acc key -> Map_int.adjust acc key (fun v -> match v with None ->  1 | Some v -> succ v)   ) v a  
          end
        in  
       Map_int.iter u (fun _ v -> v =~ 2 ) ;
       Map_int.cardinal u =~ count
    end
  ]

end
module Ext_fmt
= struct
#1 "ext_fmt.ml"
let with_file_as_pp filename f =
  Ext_pervasives.finally (open_out_bin filename) ~clean:close_out (fun chan ->
      let fmt = Format.formatter_of_out_channel chan in
      let v = f fmt in
      Format.pp_print_flush fmt ();
      v)

let failwithf ~loc fmt = Format.ksprintf (fun s -> failwith (loc ^ s)) fmt

let invalid_argf fmt = Format.ksprintf invalid_arg fmt

end
module Ext_sys : sig 
#1 "ext_sys.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val is_directory_no_exn : string -> bool

val is_windows_or_cygwin : bool

end = struct
#1 "ext_sys.pp.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** TODO: not exported yet, wait for Windows Fix*)

external is_directory_no_exn : string -> bool = "caml_sys_is_directory_no_exn"



let is_windows_or_cygwin = Sys.win32 || Sys.cygwin



end
module Ext_path : sig 
#1 "ext_path.mli"
(* Copyright (C) 2017 Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t

val simple_convert_node_path_to_os_path : string -> string
(** Js_output is node style, which means 
    separator is only '/'

    if the path contains 'node_modules', 
    [node_relative_path] will discard its prefix and 
    just treat it as a library instead
*)

val combine : string -> string -> string
(**
   [combine path1 path2]
   1. add some simplifications when concatenating
   2. when [path2] is absolute, return [path2]
*)

(**
   {[
     get_extension "a.txt" = ".txt"
       get_extension "a" = ""
   ]}
*)

val node_rebase_file : from:string -> to_:string -> string -> string

val rel_normalized_absolute_path : from:string -> string -> string
(** 
   TODO: could be highly optimized
   if [from] and [to] resolve to the same path, a zero-length string is returned 
   Given that two paths are directory

   A typical use case is 
   {[
     Filename.concat 
       (rel_normalized_absolute_path cwd (Filename.dirname a))
       (Filename.basename a)
   ]}
*)

val normalize_absolute_path : string -> string

val absolute_cwd_path : string -> string

val concat : string -> string -> string
(** [concat dirname filename]
    The same as {!Filename.concat} except a tiny optimization 
    for current directory simplification
*)

val check_suffix_case : string -> string -> bool

(* It is lazy so that it will not hit errors when in script mode *)
val package_dir : string Lazy.t

end = struct
#1 "ext_path.ml"
(* Copyright (C) 2017 Hongbo Zhang, Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(* [@@@warning "-37"] *)
type t = (* | File of string  *)
  | Dir of string [@@unboxed]

let simple_convert_node_path_to_os_path =
  if Sys.unix then fun x -> x
  else if Sys.win32 || Sys.cygwin then Ext_string.replace_slash_backward
  else failwith ("Unknown OS : " ^ Sys.os_type)

let cwd = lazy (Sys.getcwd ())

let split_by_sep_per_os : string -> string list =
  if Ext_sys.is_windows_or_cygwin then fun x ->
    (* on Windows, we can still accept -bs-package-output lib/js *)
    Ext_string.split_by
      (fun x -> match x with '/' | '\\' -> true | _ -> false)
      x
  else fun x -> Ext_string.split x '/'

(** example
    {[
      "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib/external/pervasives.cmj"
        "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib/ocaml_array.ml"
    ]}

    The other way
    {[

      "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib/ocaml_array.ml"
        "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib/external/pervasives.cmj"
    ]}
    {[
      "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib//ocaml_array.ml"
    ]}
    {[
      /a/b
      /c/d
    ]}
*)
let node_relative_path ~from:(file_or_dir_2 : t) (file_or_dir_1 : t) =
  let relevant_dir1 =
    match file_or_dir_1 with Dir x -> x
    (* | File file1 ->  Filename.dirname file1 *)
  in
  let relevant_dir2 =
    match file_or_dir_2 with Dir x -> x
    (* | File file2 -> Filename.dirname file2  *)
  in
  let dir1 = split_by_sep_per_os relevant_dir1 in
  let dir2 = split_by_sep_per_os relevant_dir2 in
  let rec go (dir1 : string list) (dir2 : string list) =
    match (dir1, dir2) with
    | "." :: xs, ys -> go xs ys
    | xs, "." :: ys -> go xs ys
    | x :: xs, y :: ys when x = y -> go xs ys
    | _, _ -> Ext_list.map_append dir2 dir1 (fun _ -> Literals.node_parent)
  in
  match go dir1 dir2 with
  | x :: _ as ys when x = Literals.node_parent ->
      String.concat Literals.node_sep ys
  | ys -> String.concat Literals.node_sep @@ (Literals.node_current :: ys)

let node_concat ~dir base = dir ^ Literals.node_sep ^ base

let node_rebase_file ~from ~to_ file =
  node_concat
    ~dir:
      (if from = to_ then Literals.node_current
      else node_relative_path ~from:(Dir from) (Dir to_))
    file

(***
   {[
     Filename.concat "." "";;
     "./"
   ]}
*)
let combine path1 path2 =
  if Filename.is_relative path2 then
    if Ext_string.is_empty path2 then path1
    else if path1 = Filename.current_dir_name then path2
    else if path2 = Filename.current_dir_name then path1
    else Filename.concat path1 path2
  else path2

let ( // ) x y =
  if x = Filename.current_dir_name then y
  else if y = Filename.current_dir_name then x
  else Filename.concat x y

(**
   {[
     split_aux "//ghosg//ghsogh/";;
     - : string * string list = ("/", ["ghosg"; "ghsogh"])
   ]}
   Note that 
   {[
     Filename.dirname "/a/" = "/"
       Filename.dirname "/a/b/" = Filename.dirname "/a/b" = "/a"
   ]}
   Special case:
   {[
     basename "//" = "/"
       basename "///"  = "/"
   ]}
   {[
     basename "" =  "."
       basename "" = "."
       dirname "" = "."
       dirname "" =  "."
   ]}  
*)
let split_aux p =
  let rec go p acc =
    let dir = Filename.dirname p in
    if dir = p then (dir, acc)
    else
      let new_path = Filename.basename p in
      if Ext_string.equal new_path Filename.dir_sep then go dir acc
        (* We could do more path simplification here
           leave to [rel_normalized_absolute_path]
        *)
      else go dir (new_path :: acc)
  in

  go p []

(** 
   TODO: optimization
   if [from] and [to] resolve to the same path, a zero-length string is returned 

   This function is useed in [es6-global] and 
   [amdjs-global] format and tailored for `rollup`
*)
let rel_normalized_absolute_path ~from to_ =
  let root1, paths1 = split_aux from in
  let root2, paths2 = split_aux to_ in
  if root1 <> root2 then root2
  else
    let rec go xss yss =
      match (xss, yss) with
      | x :: xs, y :: ys ->
          if Ext_string.equal x y then go xs ys
          else if x = Filename.current_dir_name then go xs yss
          else if y = Filename.current_dir_name then go xss ys
          else
            let start =
              Ext_list.fold_left xs Ext_string.parent_dir_lit (fun acc _ ->
                  acc // Ext_string.parent_dir_lit)
            in
            Ext_list.fold_left yss start (fun acc v -> acc // v)
      | [], [] -> Ext_string.empty
      | [], y :: ys -> Ext_list.fold_left ys y (fun acc x -> acc // x)
      | _ :: xs, [] ->
          Ext_list.fold_left xs Ext_string.parent_dir_lit (fun acc _ ->
              acc // Ext_string.parent_dir_lit)
    in
    let v = go paths1 paths2 in

    if Ext_string.is_empty v then Literals.node_current
    else if
      v = "." || v = ".."
      || Ext_string.starts_with v "./"
      || Ext_string.starts_with v "../"
    then v
    else "./" ^ v

(*TODO: could be hgighly optimized later
  {[
    normalize_absolute_path "/gsho/./..";;

    normalize_absolute_path "/a/b/../c../d/e/f";;

    normalize_absolute_path "/gsho/./..";;

    normalize_absolute_path "/gsho/./../..";;

    normalize_absolute_path "/a/b/c/d";;

    normalize_absolute_path "/a/b/c/d/";;

    normalize_absolute_path "/a/";;

    normalize_absolute_path "/a";;
  ]}
*)

(** See tests in {!Ounit_path_tests} *)
let normalize_absolute_path x =
  let drop_if_exist xs = match xs with [] -> [] | _ :: xs -> xs in
  let rec normalize_list acc paths =
    match paths with
    | [] -> acc
    | x :: xs ->
        if Ext_string.equal x Ext_string.current_dir_lit then
          normalize_list acc xs
        else if Ext_string.equal x Ext_string.parent_dir_lit then
          normalize_list (drop_if_exist acc) xs
        else normalize_list (x :: acc) xs
  in
  let root, paths = split_aux x in
  let rev_paths = normalize_list [] paths in
  let rec go acc rev_paths =
    match rev_paths with
    | [] -> Filename.concat root acc
    | last :: rest -> go (Filename.concat last acc) rest
  in
  match rev_paths with [] -> root | last :: rest -> go last rest

let absolute_path cwd s =
  let process s =
    let s = if Filename.is_relative s then Lazy.force cwd // s else s in
    (* Now simplify . and .. components *)
    let rec aux s =
      let base, dir = (Filename.basename s, Filename.dirname s) in
      if dir = s then dir
      else if base = Filename.current_dir_name then aux dir
      else if base = Filename.parent_dir_name then Filename.dirname (aux dir)
      else aux dir // base
    in
    aux s
  in
  process s

let absolute_cwd_path s = absolute_path cwd s

(* let absolute cwd s =
   match s with
   | File x -> File (absolute_path cwd x )
   | Dir x -> Dir (absolute_path cwd x) *)

let concat dirname filename =
  if filename = Filename.current_dir_name then dirname
  else if dirname = Filename.current_dir_name then filename
  else Filename.concat dirname filename

let check_suffix_case = Ext_string.ends_with

(* Input must be absolute directory *)
let rec find_root_filename ~cwd filename =
  if Sys.file_exists (Filename.concat cwd filename) then cwd
  else
    let cwd' = Filename.dirname cwd in
    if String.length cwd' < String.length cwd then
      find_root_filename ~cwd:cwd' filename
    else Ext_fmt.failwithf ~loc:__LOC__ "%s not found from %s" filename cwd

let find_package_json_dir cwd = find_root_filename ~cwd Literals.bsconfig_json

let package_dir = lazy (find_package_json_dir (Lazy.force cwd))

end
module Ounit_path_tests
= struct
#1 "ounit_path_tests.ml"
let ((>::),
     (>:::)) = OUnit.((>::),(>:::))


let normalize = Ext_path.normalize_absolute_path
let (=~) x y = 
  OUnit.assert_equal 
  ~printer:(fun x -> x)
  ~cmp:(fun x y ->   Ext_string.equal x y ) x y

let suites = 
  __FILE__ 
  >:::
  [
    "linux path tests" >:: begin fun _ -> 
      let norm = 
        Array.map normalize
          [|
            "/gsho/./..";
            "/a/b/../c../d/e/f";
            "/a/b/../c/../d/e/f";
            "/gsho/./../..";
            "/a/b/c/d";
            "/a/b/c/d/";
            "/a/";
            "/a";
            "/a.txt/";
            "/a.txt"
          |] in 
      OUnit.assert_equal norm 
        [|
          "/";
          "/a/c../d/e/f";
          "/a/d/e/f";
          "/";
          "/a/b/c/d" ;
          "/a/b/c/d";
          "/a";
          "/a";
          "/a.txt";
          "/a.txt"
        |]
    end;
    __LOC__ >:: begin fun _ ->
      normalize "/./a/.////////j/k//../////..///././b/./c/d/./." =~ "/a/b/c/d"
    end;
    __LOC__ >:: begin fun _ -> 
      normalize "/./a/.////////j/k//../////..///././b/./c/d/././../" =~ "/a/b/c"
    end;

    __LOC__ >:: begin fun _ -> 
      let aux a b result = 

        Ext_path.rel_normalized_absolute_path
          ~from:a b =~ result ; 

        Ext_path.rel_normalized_absolute_path
          ~from:(String.sub a 0 (String.length a - 1)) 
          b  =~ result ;

        Ext_path.rel_normalized_absolute_path
          ~from:a
          (String.sub b 0 (String.length b - 1))  =~ result
        ;


        Ext_path.rel_normalized_absolute_path
          ~from:(String.sub a 0 (String.length a - 1 ))
          (String.sub b 0 (String.length b - 1))
        =~ result  
      in   
      aux
        "/a/b/c/"
        "/a/b/c/d/"  "./d";
      aux
        "/a/b/c/"
        "/a/b/c/d/e/f/" "./d/e/f" ;
      aux
        "/a/b/c/d/"
        "/a/b/c/"  ".."  ;
      aux
        "/a/b/c/d/"
        "/a/b/"  "../.."  ;  
      aux
        "/a/b/c/d/"
        "/a/"  "../../.."  ;  
      aux
        "/a/b/c/d/"
        "//"  "../../../.."  ;  


    end;
    (* This is still correct just not optimal depends 
       on user's perspective *)
    __LOC__ >:: begin fun _ -> 
      Ext_path.rel_normalized_absolute_path 
        ~from:"/a/b/c/d"
        "/x/y" =~ "../../../../x/y"  

    end;

    (* used in module system: [es6-global] and [amdjs-global] *)    
    __LOC__ >:: begin fun _ -> 
      Ext_path.rel_normalized_absolute_path
        ~from:"/usr/local/lib/node_modules/"
        "//" =~ "../../../..";
      Ext_path.rel_normalized_absolute_path
        ~from:"/usr/local/lib/node_modules/"
        "/" =~ "../../../..";
      Ext_path.rel_normalized_absolute_path
        ~from:"./"
        "./node_modules/xx/./xx.js" =~ "./node_modules/xx/xx.js";
      Ext_path.rel_normalized_absolute_path
        ~from:"././"
        "./node_modules/xx/./xx.js" =~ "./node_modules/xx/xx.js"        
    end;

     __LOC__ >:: begin fun _ -> 
      Ext_path.node_rebase_file
        ~to_:( "lib/js/src/a")
        ~from:( "lib/js/src") "b" =~ "./a/b" ;
      Ext_path.node_rebase_file
        ~to_:( "lib/js/src/")
        ~from:( "lib/js/src") "b" =~ "./b" ;          
      Ext_path.node_rebase_file
        ~to_:( "lib/js/src")
        ~from:("lib/js/src/a") "b" =~ "../b";
      Ext_path.node_rebase_file
        ~to_:( "lib/js/src/a")
        ~from:("lib/js/") "b" =~ "./src/a/b" ;
      Ext_path.node_rebase_file
        ~to_:("lib/js/./src/a") 
        ~from:("lib/js/src/a/") "b"
        =~ "./b";

      Ext_path.node_rebase_file
        ~to_:"lib/js/src/a"
        ~from: "lib/js/src/a/" "b"
      =~ "./b";
      Ext_path.node_rebase_file
        ~to_:"lib/js/src/a/"
        ~from:"lib/js/src/a/" "b"
      =~ "./b"
    end     
  ]

end
module Vec : sig 
#1 "vec.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

module Make (Resize : Vec_gen.ResizeType) : Vec_gen.S with type elt = Resize.t

end = struct
#1 "vec.ml"
# 1 "ext/vec.cppo.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


let [@inline] min (x :int) y = if x < y then x else y

# 29 "ext/vec.cppo.ml"
external unsafe_blit : 
    'a array -> int -> 'a array -> int -> int -> unit = "caml_array_blit"
module Make ( Resize :  Vec_gen.ResizeType) = struct
  type elt = Resize.t 

  let null = Resize.null 
  

# 45 "ext/vec.cppo.ml"
external unsafe_sub : 'a array -> int -> int -> 'a array = "caml_array_sub"

type  t = {
  mutable arr : elt array ;
  mutable len : int ;  
}

let length d = d.len

let compact d =
  let d_arr = d.arr in 
  if d.len <> Array.length d_arr then 
    begin
      let newarr = unsafe_sub d_arr 0 d.len in 
      d.arr <- newarr
    end
let singleton v = 
  {
    len = 1 ; 
    arr = [|v|]
  }

let empty () =
  {
    len = 0;
    arr = [||];
  }

let is_empty d =
  d.len = 0

let reset d = 
  d.len <- 0; 
  d.arr <- [||]


(* For [to_*] operations, we should be careful to call {!Array.*} function 
   in case we operate on the whole array
*)
let to_list d =
  let rec loop (d_arr : elt array) idx accum =
    if idx < 0 then accum else loop d_arr (idx - 1) (Array.unsafe_get d_arr idx :: accum)
  in
  loop d.arr (d.len - 1) []


let of_list lst =
  let arr = Array.of_list lst in 
  { arr ; len = Array.length arr}


let to_array d = 
  unsafe_sub d.arr 0 d.len

let of_array src =
  {
    len = Array.length src;
    arr = Array.copy src;
    (* okay to call {!Array.copy}*)
  }
let of_sub_array arr off len = 
  { 
    len = len ; 
    arr = Array.sub arr off len  
  }  
let unsafe_internal_array v = v.arr  
(* we can not call {!Array.copy} *)
let copy src =
  let len = src.len in
  {
    len ;
    arr = unsafe_sub src.arr 0 len ;
  }

(* FIXME *)
let reverse_in_place src = 
  Ext_array.reverse_range src.arr 0 src.len 




(* {!Array.sub} is not enough for error checking, it 
   may contain some garbage
 *)
let sub (src : t) start len =
  let src_len = src.len in 
  if len < 0 || start > src_len - len then invalid_arg "Vec.sub"
  else 
  { len ; 
    arr = unsafe_sub src.arr start len }

let iter d  f = 
  let arr = d.arr in 
  for i = 0 to d.len - 1 do
    f (Array.unsafe_get arr i)
  done

let iteri d f =
  let arr = d.arr in
  for i = 0 to d.len - 1 do
    f i (Array.unsafe_get arr i)
  done

let iter_range d ~from ~to_ f =
  if from < 0 || to_ >= d.len then invalid_arg "Vec.iter_range"
  else 
    let d_arr = d.arr in 
    for i = from to to_ do 
      f  (Array.unsafe_get d_arr i)
    done

let iteri_range d ~from ~to_ f =
  if from < 0 || to_ >= d.len then invalid_arg "Vec.iteri_range"
  else 
    let d_arr = d.arr in 
    for i = from to to_ do 
      f i (Array.unsafe_get d_arr i)
    done

let map_into_array f src =
  let src_len = src.len in 
  let src_arr = src.arr in 
  if src_len = 0 then [||]
  else 
    let first_one = f (Array.unsafe_get src_arr 0) in 
    let arr = Array.make  src_len  first_one in
    for i = 1 to src_len - 1 do
      Array.unsafe_set arr i (f (Array.unsafe_get src_arr i))
    done;
    arr 
let map_into_list f src = 
  let src_len = src.len in 
  let src_arr = src.arr in 
  if src_len = 0 then []
  else 
    let acc = ref [] in         
    for i =  src_len - 1 downto 0 do
      acc := f (Array.unsafe_get src_arr i) :: !acc
    done;
    !acc

let mapi f src =
  let len = src.len in 
  if len = 0 then { len ; arr = [| |] }
  else 
    let src_arr = src.arr in 
    let arr = Array.make len (Array.unsafe_get src_arr 0) in
    for i = 1 to len - 1 do
      Array.unsafe_set arr i (f i (Array.unsafe_get src_arr i))
    done;
    {
      len ;
      arr ;
    }

let fold_left f x a =
  let rec loop a_len (a_arr : elt array) idx x =
    if idx >= a_len then x else 
      loop a_len a_arr (idx + 1) (f x (Array.unsafe_get a_arr idx))
  in
  loop a.len a.arr 0 x

let fold_right f a x =
  let rec loop (a_arr : elt array) idx x =
    if idx < 0 then x
    else loop a_arr (idx - 1) (f (Array.unsafe_get a_arr idx) x)
  in
  loop a.arr (a.len - 1) x

(**  
   [filter] and [inplace_filter]
*)
let filter f d =
  let new_d = copy d in 
  let new_d_arr = new_d.arr in 
  let d_arr = d.arr in
  let p = ref 0 in
  for i = 0 to d.len  - 1 do
    let x = Array.unsafe_get d_arr i in
    (* TODO: can be optimized for segments blit *)
    if f x  then
      begin
        Array.unsafe_set new_d_arr !p x;
        incr p;
      end;
  done;
  new_d.len <- !p;
  new_d 

let equal eq x y : bool = 
  if x.len <> y.len then false 
  else 
    let rec aux x_arr y_arr i =
      if i < 0 then true else  
      if eq (Array.unsafe_get x_arr i) (Array.unsafe_get y_arr i) then 
        aux x_arr y_arr (i - 1)
      else false in 
    aux x.arr y.arr (x.len - 1)

let get d i = 
  if i < 0 || i >= d.len then invalid_arg "Vec.get"
  else Array.unsafe_get d.arr i
let unsafe_get d i = Array.unsafe_get d.arr i 
let last d = 
  if d.len <= 0 then invalid_arg   "Vec.last"
  else Array.unsafe_get d.arr (d.len - 1)

let capacity d = Array.length d.arr

(* Attention can not use {!Array.exists} since the bound is not the same *)  
let exists p d = 
  let a = d.arr in 
  let n = d.len in   
  let rec loop i =
    if i = n then false
    else if p (Array.unsafe_get a i) then true
    else loop (succ i) in
  loop 0

let map f src =
  let src_len = src.len in 
  if src_len = 0 then { len = 0 ; arr = [||]}
  (* TODO: we may share the empty array 
     but sharing mutable state is very challenging, 
     the tricky part is to avoid mutating the immutable array,
     here it looks fine -- 
     invariant: whenever [.arr] mutated, make sure  it is not an empty array
     Actually no: since starting from an empty array 
     {[
       push v (* the address of v should not be changed *)
     ]}
  *)
  else 
    let src_arr = src.arr in 
    let first = f (Array.unsafe_get src_arr 0 ) in 
    let arr = Array.make  src_len first in
    for i = 1 to src_len - 1 do
      Array.unsafe_set arr i (f (Array.unsafe_get src_arr i))
    done;
    {
      len = src_len;
      arr = arr;
    }

let init len f =
  if len < 0 then invalid_arg  "Vec.init"
  else if len = 0 then { len = 0 ; arr = [||] }
  else 
    let first = f 0 in 
    let arr = Array.make len first in
    for i = 1 to len - 1 do
      Array.unsafe_set arr i (f i)
    done;
    {

      len ;
      arr 
    }



  let make initsize : t =
    if initsize < 0 then invalid_arg  "Vec.make" ;
    {

      len = 0;
      arr = Array.make  initsize null ;
    }



  let reserve (d : t ) s = 
    let d_len = d.len in 
    let d_arr = d.arr in 
    if s < d_len || s < Array.length d_arr then ()
    else 
      let new_capacity = min Sys.max_array_length s in 
      let new_d_arr = Array.make new_capacity null in 
       unsafe_blit d_arr 0 new_d_arr 0 d_len;
      d.arr <- new_d_arr 

  let push (d : t) v  =
    let d_len = d.len in
    let d_arr = d.arr in 
    let d_arr_len = Array.length d_arr in
    if d_arr_len = 0 then
      begin 
        d.len <- 1 ;
        d.arr <- [| v |]
      end
    else  
      begin 
        if d_len = d_arr_len then 
          begin
            if d_len >= Sys.max_array_length then 
              failwith "exceeds max_array_length";
            let new_capacity = min Sys.max_array_length d_len * 2 
            (* [d_len] can not be zero, so [*2] will enlarge   *)
            in
            let new_d_arr = Array.make new_capacity null in 
            d.arr <- new_d_arr;
             unsafe_blit d_arr 0 new_d_arr 0 d_len ;
          end;
        d.len <- d_len + 1;
        Array.unsafe_set d.arr d_len v
      end

(** delete element at offset [idx], will raise exception when have invalid input *)
  let delete (d : t) idx =
    let d_len = d.len in 
    if idx < 0 || idx >= d_len then invalid_arg "Vec.delete" ;
    let arr = d.arr in 
     unsafe_blit arr (idx + 1) arr idx  (d_len - idx - 1);
    let idx = d_len - 1 in 
    d.len <- idx
    
# 362 "ext/vec.cppo.ml"
    ;
    Array.unsafe_set arr idx  null
    
# 366 "ext/vec.cppo.ml"
(** pop the last element, a specialized version of [delete] *)
  let pop (d : t) = 
    let idx  = d.len - 1  in
    if idx < 0 then invalid_arg "Vec.pop";
    d.len <- idx
    
# 373 "ext/vec.cppo.ml"
    ;    
    Array.unsafe_set d.arr idx null
  
# 377 "ext/vec.cppo.ml"
(** pop and return the last element *)  
  let get_last_and_pop (d : t) = 
    let idx  = d.len - 1  in
    if idx < 0 then invalid_arg "Vec.get_last_and_pop";
    let last = Array.unsafe_get d.arr idx in 
    d.len <- idx 
    
# 385 "ext/vec.cppo.ml"
    ;
    Array.unsafe_set d.arr idx null
    
# 388 "ext/vec.cppo.ml"
    ;
    last 

(** delete elements start from [idx] with length [len] *)
  let delete_range (d : t) idx len =
    let d_len = d.len in 
    if len < 0 || idx < 0 || idx + len > d_len then invalid_arg  "Vec.delete_range"  ;
    let arr = d.arr in 
     unsafe_blit arr (idx + len) arr idx (d_len  - idx - len);
    d.len <- d_len - len
    
# 400 "ext/vec.cppo.ml"
    ;
    for i = d_len - len to d_len - 1 do
      Array.unsafe_set arr i null
    done

# 406 "ext/vec.cppo.ml"
(** delete elements from [idx] with length [len] return the deleted elements as a new vec*)
  let get_and_delete_range (d : t) idx len : t = 
    let d_len = d.len in 
    if len < 0 || idx < 0 || idx + len > d_len then invalid_arg  "Vec.get_and_delete_range"  ;
    let arr = d.arr in 
    let value =  unsafe_sub arr idx len in
     unsafe_blit arr (idx + len) arr idx (d_len  - idx - len);
    d.len <- d_len - len; 
    
# 416 "ext/vec.cppo.ml"
    for i = d_len - len to d_len - 1 do
      Array.unsafe_set arr i null
    done;
    
# 420 "ext/vec.cppo.ml"
    {len = len ; arr = value}


  (** Below are simple wrapper around normal Array operations *)  

  let clear (d : t ) =
    
# 428 "ext/vec.cppo.ml"
    for i = 0 to d.len - 1 do 
      Array.unsafe_set d.arr i null
    done;
    
# 432 "ext/vec.cppo.ml"
    d.len <- 0



  let inplace_filter f (d : t) : unit = 
    let d_arr = d.arr in     
    let d_len = d.len in
    let p = ref 0 in
    for i = 0 to d_len - 1 do 
      let x = Array.unsafe_get d_arr i in 
      if f x then 
        begin 
          let curr_p = !p in 
          (if curr_p <> i then 
             Array.unsafe_set d_arr curr_p x) ;
          incr p
        end
    done ;
    let last = !p  in 
    
# 455 "ext/vec.cppo.ml"
    delete_range d last  (d_len - last)

  
# 458 "ext/vec.cppo.ml"
  let inplace_filter_from start f (d : t) : unit = 
    if start < 0 then invalid_arg "Vec.inplace_filter_from"; 
    let d_arr = d.arr in     
    let d_len = d.len in
    let p = ref start in    
    for i = start to d_len - 1 do 
      let x = Array.unsafe_get d_arr i in 
      if f x then 
        begin 
          let curr_p = !p in 
          (if curr_p <> i then 
             Array.unsafe_set d_arr curr_p x) ;
          incr p
        end
    done ;
    let last = !p  in 
    
# 477 "ext/vec.cppo.ml"
    delete_range d last  (d_len - last)


# 481 "ext/vec.cppo.ml"
(** inplace filter the elements and accumulate the non-filtered elements *)
  let inplace_filter_with  f ~cb_no acc (d : t)  = 
    let d_arr = d.arr in     
    let p = ref 0 in
    let d_len = d.len in
    let acc = ref acc in 
    for i = 0 to d_len - 1 do 
      let x = Array.unsafe_get d_arr i in 
      if f x then 
        begin 
          let curr_p = !p in 
          (if curr_p <> i then 
             Array.unsafe_set d_arr curr_p x) ;
          incr p
        end
      else 
        acc := cb_no  x  !acc
    done ;
    let last = !p  in 
    
# 504 "ext/vec.cppo.ml"
    delete_range d last  (d_len - last)
    
# 506 "ext/vec.cppo.ml"
    ; !acc 



# 511 "ext/vec.cppo.ml"
end

end
module Int_vec_vec : sig 
#1 "int_vec_vec.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

include Vec_gen.S with type elt = Vec_int.t

end = struct
#1 "int_vec_vec.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

include Vec.Make (struct
  type t = Vec_int.t

  let null = Vec_int.empty ()
end)

end
module Ext_scc : sig 
#1 "ext_scc.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type node = Vec_int.t

val graph : Vec_int.t array -> Int_vec_vec.t
(** Assume input is int array with offset from 0 
    Typical input 
    {[
      [|
        [ 1 ; 2 ]; // 0 -> 1,  0 -> 2 
                     [ 1 ];   // 0 -> 1 
          [ 2 ]  // 0 -> 2 
      |]
    ]}
    Note that we can tell how many nodes by calculating 
    [Array.length] of the input 
*)

val graph_check : node array -> int * int list
(** Used for unit test *)

end = struct
#1 "ext_scc.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type node = Vec_int.t

(** 
   [int] as data for this algorithm
   Pros:
   1. Easy to eoncode algorithm (especially given that the capacity of node is known)
   2. Algorithms itself are much more efficient
   3. Node comparison semantics is clear
   4. Easy to print output
   Cons:
   1. post processing input data  
*)
let min_int (x : int) y = if x < y then x else y

let graph e =
  let index = ref 0 in
  let s = Vec_int.empty () in

  let output = Int_vec_vec.empty () in
  (* collect output *)
  let node_numes = Array.length e in

  let on_stack_array = Array.make node_numes false in
  let index_array = Array.make node_numes (-1) in
  let lowlink_array = Array.make node_numes (-1) in

  let rec scc v_data =
    let new_index = !index + 1 in
    index := new_index;
    Vec_int.push s v_data;

    index_array.(v_data) <- new_index;
    lowlink_array.(v_data) <- new_index;
    on_stack_array.(v_data) <- true;
    let v = e.(v_data) in
    Vec_int.iter v (fun w_data ->
        if Array.unsafe_get index_array w_data < 0 then (
          (* not processed *)
          scc w_data;
          Array.unsafe_set lowlink_array v_data
            (min_int
               (Array.unsafe_get lowlink_array v_data)
               (Array.unsafe_get lowlink_array w_data)))
        else if Array.unsafe_get on_stack_array w_data then
          (* successor is in stack and hence in current scc *)
          Array.unsafe_set lowlink_array v_data
            (min_int
               (Array.unsafe_get lowlink_array v_data)
               (Array.unsafe_get lowlink_array w_data)));

    if
      Array.unsafe_get lowlink_array v_data
      = Array.unsafe_get index_array v_data
    then (
      (* start a new scc *)
      let s_len = Vec_int.length s in
      let last_index = ref (s_len - 1) in
      let u = ref (Vec_int.unsafe_get s !last_index) in
      while !u <> v_data do
        Array.unsafe_set on_stack_array !u false;
        last_index := !last_index - 1;
        u := Vec_int.unsafe_get s !last_index
      done;
      on_stack_array.(v_data) <- false;
      (* necessary *)
      Int_vec_vec.push output
        (Vec_int.get_and_delete_range s !last_index (s_len - !last_index)))
  in
  for i = 0 to node_numes - 1 do
    if Array.unsafe_get index_array i < 0 then scc i
  done;
  output

let graph_check v =
  let v = graph v in
  ( Int_vec_vec.length v,
    Int_vec_vec.fold_left (fun acc x -> Vec_int.length x :: acc) [] v )

end
module Ounit_scc_tests
= struct
#1 "ounit_scc_tests.ml"
let ((>::),
    (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal

let tiny_test_cases = {|
13
22
 4  2
 2  3
 3  2
 6  0
 0  1
 2  0
11 12
12  9
 9 10
 9 11
 7  9
10 12
11  4
 4  3
 3  5
 6  8
 8  6
 5  4
 0  5
 6  4
 6  9
 7  6
|}     

let medium_test_cases = {|
50
147
 0  7
 0 34
 1 14
 1 45
 1 21
 1 22
 1 22
 1 49
 2 19
 2 25
 2 33
 3  4
 3 17
 3 27
 3 36
 3 42
 4 17
 4 17
 4 27
 5 43
 6 13
 6 13
 6 28
 6 28
 7 41
 7 44
 8 19
 8 48
 9  9
 9 11
 9 30
 9 46
10  0
10  7
10 28
10 28
10 28
10 29
10 29
10 34
10 41
11 21
11 30
12  9
12 11
12 21
12 21
12 26
13 22
13 23
13 47
14  8
14 21
14 48
15  8
15 34
15 49
16  9
17 20
17 24
17 38
18  6
18 28
18 32
18 42
19 15
19 40
20  3
20 35
20 38
20 46
22  6
23 11
23 21
23 22
24  4
24  5
24 38
24 43
25  2
25 34
26  9
26 12
26 16
27  5
27 24
27 32
27 31
27 42
28 22
28 29
28 39
28 44
29 22
29 49
30 23
30 37
31 18
31 32
32  5
32  6
32 13
32 37
32 47
33  2
33  8
33 19
34  2 
34 19
34 40
35  9
35 37
35 46
36 20
36 42
37  5
37  9
37 35
37 47
37 47
38 35
38 37
38 38
39 18
39 42
40 15
41 28
41 44
42 31
43 37
43 38
44 39
45  8
45 14
45 14
45 15
45 49
46 16
47 23
47 30
48 12
48 21
48 33
48 33
49 34
49 22
49 49
|}
(* 
reference output: 
http://algs4.cs.princeton.edu/42digraph/KosarajuSharirSCC.java.html 
*)

let handle_lines tiny_test_cases = 
  match Ext_string.split  tiny_test_cases '\n' with 
  | nodes :: _edges :: rest -> 
    let nodes_num = int_of_string nodes in 
    let node_array = 
      Array.init nodes_num
        (fun _ -> Vec_int.empty () )
    in 
    begin 
    Ext_list.iter rest (fun x ->
          match Ext_string.split x ' ' with 
          | [ a ; b] -> 
            let a , b = int_of_string a , int_of_string b in 
            Vec_int.push node_array.(a) b  
          | _ -> assert false 
        );
      node_array 
    end
  | _ -> assert false

let read_file file = 
  let in_chan = open_in_bin file in 
  let nodes_sum = int_of_string (input_line in_chan) in 
  let node_array = Array.init nodes_sum (fun _ -> Vec_int.empty () ) in 
  let rec aux () = 
    match input_line in_chan with 
    | exception End_of_file -> ()
    | x -> 
      begin match Ext_string.split x ' ' with 
      | [ a ; b] -> 
        let a , b = int_of_string a , int_of_string b in 
        Vec_int.push node_array.(a) b 
      | _ -> (* assert false  *) ()
      end; 
      aux () in 
  print_endline "read data into memory";
  aux ();
   (fst (Ext_scc.graph_check node_array)) (* 25 *)


let test  (input : (string * string list) list) = 
  (* string -> int mapping 
  *)
  let tbl = Hash_string.create 32 in
  let idx = ref 0 in 
  let add x =
    if not (Hash_string.mem tbl x ) then 
      begin 
        Hash_string.add  tbl x !idx ;
        incr idx 
      end in
  input |> List.iter 
    (fun (x,others) -> List.iter add (x::others));
  let nodes_num = Hash_string.length tbl in
  let node_array = 
      Array.init nodes_num
        (fun _ -> Vec_int.empty () ) in 
  input |> 
  List.iter (fun (x,others) -> 
      let idx = Hash_string.find_exn tbl  x  in 
      others |> 
      List.iter (fun y -> Vec_int.push node_array.(idx) (Hash_string.find_exn tbl y ) )
    ) ; 
  Ext_scc.graph_check node_array 

let test2  (input : (string * string list) list) = 
  (* string -> int mapping 
  *)
  let tbl = Hash_string.create 32 in
  let idx = ref 0 in 
  let add x =
    if not (Hash_string.mem tbl x ) then 
      begin 
        Hash_string.add  tbl x !idx ;
        incr idx 
      end in
  input |> List.iter 
    (fun (x,others) -> List.iter add (x::others));
  let nodes_num = Hash_string.length tbl in
  let other_mapping = Array.make nodes_num "" in 
  Hash_string.iter tbl (fun k v  -> other_mapping.(v) <- k ) ;
  
  let node_array = 
      Array.init nodes_num
        (fun _ -> Vec_int.empty () ) in 
  input |> 
  List.iter (fun (x,others) -> 
      let idx = Hash_string.find_exn tbl  x  in 
      others |> 
      List.iter (fun y -> Vec_int.push node_array.(idx) (Hash_string.find_exn tbl y ) )
    )  ;
  let output = Ext_scc.graph node_array in 
  output |> Int_vec_vec.map_into_array (fun int_vec -> Vec_int.map_into_array (fun i -> other_mapping.(i)) int_vec )


let suites = 
    __FILE__
    >::: [
      __LOC__ >:: begin fun _ -> 
        OUnit.assert_equal (fst @@ Ext_scc.graph_check (handle_lines tiny_test_cases))  5
      end       ;
      __LOC__ >:: begin fun _ -> 
        OUnit.assert_equal (fst @@ Ext_scc.graph_check (handle_lines medium_test_cases))  10
      end       ;
      __LOC__ >:: begin fun _ ->
        OUnit.assert_equal (test [
            "a", ["b" ; "c"];
            "b" , ["c" ; "d"];
            "c", [ "b"];
            "d", [];
          ]) (3 , [1;2;1])
      end ; 
      __LOC__ >:: begin fun _ ->
        OUnit.assert_equal (test [
            "a", ["b" ; "c"];
            "b" , ["c" ; "d"];
            "c", [ "b"];
            "d", [];
            "e", []
          ])  (4, [1;1;2;1])
          (*  {[
              a -> b
              a -> c 
              b -> c 
              b -> d 
              c -> b 
              d 
              e
              ]}
              {[
              [d ; e ; [b;c] [a] ]
              ]}  
          *)
      end ;
      __LOC__ >:: begin fun _ ->
        OUnit.assert_equal (test [
            "a", ["b" ; "c"];
            "b" , ["c" ; "d"];
            "c", [ "b"];
            "d", ["e"];
            "e", []
          ]) (4 , [1;2;1;1])
      end ; 
      __LOC__ >:: begin fun _ ->
        OUnit.assert_equal (test [
            "a", ["b" ; "c"];
            "b" , ["c" ; "d"];
            "c", [ "b"];
            "d", ["e"];
            "e", ["c"]
          ]) (2, [1;4])
      end ;
      __LOC__ >:: begin fun _ ->
        OUnit.assert_equal (test [
            "a", ["b" ; "c"];
            "b" , ["c" ; "d"];
            "c", [ "b"];
            "d", ["e"];
            "e", ["a"]
          ]) (1, [5])
      end ; 
      __LOC__ >:: begin fun _ ->
        OUnit.assert_equal (test [
            "a", ["b"];
            "b" , ["c" ];
            "c", [ ];
            "d", [];
            "e", []
          ]) (5, [1;1;1;1;1])
      end ; 
      __LOC__ >:: begin fun _ ->
        OUnit.assert_equal (test [
            "1", ["0"];
            "0" , ["2" ];
            "2", ["1" ];
            "0", ["3"];
            "3", [ "4"]
          ]) (3, [3;1;1])
      end ; 
      (* http://algs4.cs.princeton.edu/42digraph/largeDG.txt *)
      (* __LOC__ >:: begin fun _ -> *)
      (*   OUnit.assert_equal (read_file "largeDG.txt") 25 *)
      (* end *)
      (* ; *)
      __LOC__ >:: begin fun _ ->
        OUnit.assert_equal (test2 [
            "a", ["b" ; "c"];
            "b" , ["c" ; "d"];
            "c", [ "b"];
            "d", [];
          ]) [|[|"d"|]; [|"b"; "c"|]; [|"a"|]|]
      end ;

      __LOC__ >:: begin fun _ ->
        OUnit.assert_equal (test2 [
            "a", ["b"];
            "b" , ["c" ];
            "c", ["d" ];
            "d", ["e"];
            "e", []
          ]) [|[|"e"|]; [|"d"|]; [|"c"|]; [|"b"|]; [|"a"|]|] 
      end ;

    ]

end
module Ext_digest : sig 
#1 "ext_digest.mli"
(* Copyright (C) 2019- Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val length : int

val hex_length : int

end = struct
#1 "ext_digest.ml"
(* Copyright (C) 2019- Hongbo Zhang, Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let length = 16

let hex_length = 32

end
module Ext_filename : sig 
#1 "ext_filename.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(* TODO:
   Change the module name, this code is not really an extension of the standard
    library but rather specific to JS Module name convention.
*)

(** An extension module to calculate relative path follow node/npm style. 
    TODO : this short name will have to change upon renaming the file.
*)

val is_dir_sep : char -> bool

val maybe_quote : string -> string

val chop_extension_maybe : string -> string

(* return an empty string if no extension found *)
val get_extension_maybe : string -> string

val new_extension : string -> string -> string

val chop_all_extensions_maybe : string -> string

(* OCaml specific abstraction*)
val module_name : string -> string

type module_info = { module_name : string; case : bool }

val as_module : basename:string -> module_info option

end = struct
#1 "ext_filename.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let is_dir_sep_unix c = c = '/'

let is_dir_sep_win_cygwin c = c = '/' || c = '\\' || c = ':'

let is_dir_sep = if Sys.unix then is_dir_sep_unix else is_dir_sep_win_cygwin

(* reference ninja.cc IsKnownShellSafeCharacter *)
let maybe_quote (s : string) =
  let noneed_quote =
    Ext_string.for_all s (function
      | '0' .. '9' | 'a' .. 'z' | 'A' .. 'Z' | '_' | '+' | '-' | '.' | '/' | '@'
        ->
          true
      | _ -> false)
  in
  if noneed_quote then s else Filename.quote s

let chop_extension_maybe name =
  let rec search_dot i =
    if i < 0 || is_dir_sep (String.unsafe_get name i) then name
    else if String.unsafe_get name i = '.' then String.sub name 0 i
    else search_dot (i - 1)
  in
  search_dot (String.length name - 1)

let get_extension_maybe name =
  let name_len = String.length name in
  let rec search_dot name i name_len =
    if i < 0 || is_dir_sep (String.unsafe_get name i) then ""
    else if String.unsafe_get name i = '.' then String.sub name i (name_len - i)
    else search_dot name (i - 1) name_len
  in
  search_dot name (name_len - 1) name_len

let chop_all_extensions_maybe name =
  let rec search_dot i last =
    if i < 0 || is_dir_sep (String.unsafe_get name i) then
      match last with None -> name | Some i -> String.sub name 0 i
    else if String.unsafe_get name i = '.' then search_dot (i - 1) (Some i)
    else search_dot (i - 1) last
  in
  search_dot (String.length name - 1) None

let new_extension name (ext : string) =
  let rec search_dot name i ext =
    if i < 0 || is_dir_sep (String.unsafe_get name i) then name ^ ext
    else if String.unsafe_get name i = '.' then (
      let ext_len = String.length ext in
      let buf = Bytes.create (i + ext_len) in
      Bytes.blit_string name 0 buf 0 i;
      Bytes.blit_string ext 0 buf i ext_len;
      Bytes.unsafe_to_string buf)
    else search_dot name (i - 1) ext
  in
  search_dot name (String.length name - 1) ext

(** TODO: improve efficiency
    given a path, calcuate its module name 
    Note that `ocamlc.opt -c aa.xx.mli` gives `aa.xx.cmi`
    we can not strip all extensions, otherwise
    we can not tell the difference between "x.cpp.ml" 
    and "x.ml"
*)
let module_name name =
  let rec search_dot i name =
    if i < 0 then Ext_string.capitalize_ascii name
    else if String.unsafe_get name i = '.' then Ext_string.capitalize_sub name i
    else search_dot (i - 1) name
  in
  let name = Filename.basename name in
  let name_len = String.length name in
  search_dot (name_len - 1) name

type module_info = { module_name : string; case : bool }

let rec valid_module_name_aux name off len =
  if off >= len then true
  else
    let c = String.unsafe_get name off in
    match c with
    | 'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '\'' | '.' | '[' | ']' ->
        valid_module_name_aux name (off + 1) len
    | _ -> false

type state = Invalid | Upper | Lower

let valid_module_name name len =
  if len = 0 then Invalid
  else
    let c = String.unsafe_get name 0 in
    match c with
    | 'A' .. 'Z' -> if valid_module_name_aux name 1 len then Upper else Invalid
    | 'a' .. 'z' | '0' .. '9' | '_' | '[' | ']' ->
        if valid_module_name_aux name 1 len then Lower else Invalid
    | _ -> Invalid

let as_module ~basename =
  let rec search_dot i name name_len =
    if i < 0 then
      (* Input e.g, [a_b] *)
      match valid_module_name name name_len with
      | Invalid -> None
      | Upper -> Some { module_name = name; case = true }
      | Lower ->
          Some { module_name = Ext_string.capitalize_ascii name; case = false }
    else if String.unsafe_get name i = '.' then
      (*Input e.g, [A_b] *)
      match valid_module_name name i with
      | Invalid -> None
      | Upper ->
          Some { module_name = Ext_string.capitalize_sub name i; case = true }
      | Lower ->
          Some { module_name = Ext_string.capitalize_sub name i; case = false }
    else search_dot (i - 1) name name_len
  in
  let name_len = String.length basename in
  search_dot (name_len - 1) basename name_len

end
module Ext_modulename : sig 
#1 "ext_modulename.mli"
(* Copyright (C) 2017 Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val js_id_name_of_hint_name : string -> string
(** Given an JS bundle name, generate a meaningful
    bounded module name
*)

end = struct
#1 "ext_modulename.ml"
(* Copyright (C) 2017 Hongbo Zhang, Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let good_hint_name module_name offset =
  let len = String.length module_name in
  len > offset
  && (function 'a' .. 'z' | 'A' .. 'Z' -> true | _ -> false)
       (String.unsafe_get module_name offset)
  && Ext_string.for_all_from module_name (offset + 1) (function
       | 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' -> true
       | _ -> false)

let rec collect_start buf s off len =
  if off >= len then ()
  else
    let next = succ off in
    match String.unsafe_get s off with
    | 'a' .. 'z' as c ->
        Ext_buffer.add_char buf (Char.uppercase_ascii c);
        collect_next buf s next len
    | 'A' .. 'Z' as c ->
        Ext_buffer.add_char buf c;
        collect_next buf s next len
    | _ -> collect_start buf s next len

and collect_next buf s off len =
  if off >= len then ()
  else
    let next = off + 1 in
    match String.unsafe_get s off with
    | ('a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_') as c ->
        Ext_buffer.add_char buf c;
        collect_next buf s next len
    | '.' | '-' -> collect_start buf s next len
    | _ -> collect_next buf s next len

(** This is for a js exeternal module, we can change it when printing
    for example
    {[
      var React$1 = require('react');
      React$1.render(..)
    ]}
    Given a name, if duplicated, they should  have the same id
*)
let js_id_name_of_hint_name module_name =
  let i = Ext_string.rindex_neg module_name '/' in
  if i >= 0 then (
    let offset = succ i in
    if good_hint_name module_name offset then
      Ext_string.capitalize_ascii (Ext_string.tail_from module_name offset)
    else
      let str_len = String.length module_name in
      let buf = Ext_buffer.create str_len in
      collect_start buf module_name offset str_len;
      if Ext_buffer.is_empty buf then Ext_string.capitalize_ascii module_name
      else Ext_buffer.contents buf)
  else if good_hint_name module_name 0 then
    Ext_string.capitalize_ascii module_name
  else
    let str_len = String.length module_name in
    let buf = Ext_buffer.create str_len in
    collect_start buf module_name 0 str_len;
    if Ext_buffer.is_empty buf then module_name else Ext_buffer.contents buf

end
module Ext_js_suffix
= struct
#1 "ext_js_suffix.ml"
type t = Js | Bs_js | Mjs | Cjs | Unknown_extension

let to_string (x : t) =
  match x with
  | Js -> Literals.suffix_js
  | Bs_js -> Literals.suffix_bs_js
  | Mjs -> Literals.suffix_mjs
  | Cjs -> Literals.suffix_cjs
  | Unknown_extension -> assert false

let of_string (x : string) : t =
  match () with
  | () when x = Literals.suffix_js -> Js
  | () when x = Literals.suffix_bs_js -> Bs_js
  | () when x = Literals.suffix_mjs -> Mjs
  | () when x = Literals.suffix_cjs -> Cjs
  | _ -> Unknown_extension

end
module Ext_js_file_kind
= struct
#1 "ext_js_file_kind.ml"
(* Copyright (C) 2020- Hongbo Zhang, Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
type case = Upper | Little

type t = { case : case; suffix : Ext_js_suffix.t }

let any_runtime_kind = { case = Little; suffix = Ext_js_suffix.Js }

end
module Ext_namespace : sig 
#1 "ext_namespace.mli"
(* Copyright (C) 2017- Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val try_split_module_name : string -> (string * string) option

(* Note  we have to output uncapitalized file Name,
   or at least be consistent, since by reading cmi file on Case insensitive OS, we don't really know it is `list.cmi` or `List.cmi`, so that `require (./list.js)` or `require(./List.js)`
   relevant issues: #1609, #913

   #1933 when removing ns suffix, don't pass the bound
   of basename
*)
val change_ext_ns_suffix : string -> string -> string

val js_name_of_modulename :
  string -> Ext_js_file_kind.case -> Ext_js_suffix.t -> string
(** [js_name_of_modulename ~little A-Ns]
*)

(* TODO handle cases like
   '@angular/core'
   its directory structure is like
   {[
     @angular
     |-------- core
   ]}
*)
val is_valid_npm_package_name : string -> bool

val namespace_of_package_name : string -> string

end = struct
#1 "ext_namespace.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let rec rindex_rec s i =
  if i < 0 then i
  else
    let char = String.unsafe_get s i in
    if Ext_filename.is_dir_sep char then -1
    else if char = Literals.ns_sep_char then i
    else rindex_rec s (i - 1)

let change_ext_ns_suffix name ext =
  let i = rindex_rec name (String.length name - 1) in
  if i < 0 then name ^ ext else String.sub name 0 i ^ ext
(* FIXME: micro-optimizaiton*)

let try_split_module_name name =
  let len = String.length name in
  let i = rindex_rec name (len - 1) in
  if i < 0 then None
  else Some (String.sub name (i + 1) (len - i - 1), String.sub name 0 i)

let js_name_of_modulename s (case : Ext_js_file_kind.case) suffix : string =
  let s =
    match case with Little -> Ext_string.uncapitalize_ascii s | Upper -> s
  in
  change_ext_ns_suffix s (Ext_js_suffix.to_string suffix)

(* https://docs.npmjs.com/files/package.json
   Some rules:
   The name must be less than or equal to 214 characters. This includes the scope for scoped packages.
   The name can't start with a dot or an underscore.
   New packages must not have uppercase letters in the name.
   The name ends up being part of a URL, an argument on the command line, and a folder name. Therefore, the name can't contain any non-URL-safe characters.
*)
let is_valid_npm_package_name (s : string) =
  let len = String.length s in
  len <= 214 (* magic number forced by npm *)
  && len > 0
  &&
  match String.unsafe_get s 0 with
  | 'a' .. 'z' | '@' ->
      Ext_string.for_all_from s 1 (fun x ->
          match x with
          | 'a' .. 'z' | '0' .. '9' | '_' | '-' -> true
          | _ -> false)
  | _ -> false

let namespace_of_package_name (s : string) : string =
  let len = String.length s in
  let buf = Ext_buffer.create len in
  let add capital ch =
    Ext_buffer.add_char buf (if capital then Char.uppercase_ascii ch else ch)
  in
  let rec aux capital off len =
    if off >= len then ()
    else
      let ch = String.unsafe_get s off in
      match ch with
      | 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' ->
          add capital ch;
          aux false (off + 1) len
      | '/' | '-' -> aux true (off + 1) len
      | _ -> aux capital (off + 1) len
  in
  aux true 0 len;
  Ext_buffer.contents buf

end
module Ounit_data_random
= struct
#1 "ounit_data_random.ml"


let min_int x y = 
    if x < y then x else y

let random_string chars upper = 
    let len = Array.length chars in 
    let string_len = (Random.int (min_int upper len)) in
    String.init string_len (fun _i -> chars.(Random.int len ))
end
module Ounit_string_tests
= struct
#1 "ounit_string_tests.ml"
let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal  ~printer:Ext_obj.dump  

let printer_string = fun x -> x 

let string_eq = OUnit.assert_equal ~printer:(fun id -> id)

let suites = 
  __FILE__ >::: 
  [
    __LOC__ >:: begin fun _ ->
      OUnit.assert_bool "not found " (Ext_string.rindex_neg "hello" 'x' < 0 )
    end;

    __LOC__ >:: begin fun _ -> 
      Ext_string.rindex_neg "hello" 'h' =~ 0 ;
      Ext_string.rindex_neg "hello" 'e' =~ 1 ;
      Ext_string.rindex_neg "hello" 'l' =~ 3 ;
      Ext_string.rindex_neg "hello" 'l' =~ 3 ;
      Ext_string.rindex_neg "hello" 'o' =~ 4 ;
    end;
    (* __LOC__ >:: begin 
      fun _ -> 
      let nl cur s = Ext_string.extract_until s cur '\n' in 
      nl (ref 0) "hello\n" =~ "hello";
      nl (ref 0) "\nhell" =~ "";
      nl (ref 0) "hello" =~ "hello";
      let cur = ref 0 in 
      let b = "a\nb\nc\nd" in 
      nl cur b =~ "a";
      nl cur b =~ "b";
      nl cur b =~ "c";
      nl cur b =~ "d";
      nl cur b =~ "" ;
      nl cur b =~ "" ;
      cur := 0 ;
      let b = "a\nb\nc\nd\n" in 
      nl cur b =~ "a";
      nl cur b =~ "b";
      nl cur b =~ "c";
      nl cur b =~ "d";
      nl cur b =~ "" ;
      nl cur b =~ "" ;
    end ; *)
    __LOC__ >:: begin fun _ -> 
      let b = "a\nb\nc\nd\n" in
      let a = Ext_string.index_count in 
      a b 0 '\n' 1 =~ 1 ;
      a b 0 '\n' 2 =~ 3;
      a b 0 '\n' 3 =~ 5;
      a b 0 '\n' 4 =~ 7; 
      a b 0 '\n' 5 =~ -1; 
    end ;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool "empty string" (Ext_string.rindex_neg "" 'x' < 0 )
    end;

    __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool __LOC__
        (not (Ext_string.for_all_from "xABc"1
                (function 'A' .. 'Z' -> true | _ -> false)));
      OUnit.assert_bool __LOC__
        ( (Ext_string.for_all_from "xABC" 1
             (function 'A' .. 'Z' -> true | _ -> false)));
      OUnit.assert_bool __LOC__
        ( (Ext_string.for_all_from "xABC" 1_000
             (function 'A' .. 'Z' -> true | _ -> false)));             
    end; 

    (* __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool __LOC__ @@
      List.for_all (fun x -> Ext_string.is_valid_source_name x = Good)
        ["x.ml"; "x.mli"; "x.re"; "x.rei"; 
         "A_x.ml"; "ab.ml"; "a_.ml"; "a__.ml";
         "ax.ml"];
      OUnit.assert_bool __LOC__ @@ not @@
      List.exists (fun x -> Ext_string.is_valid_source_name x = Good)
        [".re"; ".rei";"..re"; "..rei"; "..ml"; ".mll~"; 
         "...ml"; "_.mli"; "_x.ml"; "__.ml"; "__.rei"; 
         ".#hello.ml"; ".#hello.rei"; "a-.ml"; "a-b.ml"; "-a-.ml"
        ; "-.ml"
        ]
    end; *)
    __LOC__ >:: begin fun _ -> 
      Ext_filename.module_name "a/hello.ml" =~ "Hello";
      Ext_filename.as_module ~basename:"a.ml" =~ Some {module_name = "A"; case = false};
      Ext_filename.as_module ~basename:"Aa.ml" =~ Some {module_name = "Aa"; case = true};
      (* Ext_filename.as_module ~basename:"_Aa.ml" =~ None; *)
      Ext_filename.as_module ~basename:"A_a" =~ Some {module_name = "A_a"; case = true};
      Ext_filename.as_module ~basename:"" =~ None;
      Ext_filename.as_module ~basename:"a/hello.ml" =~ 
        None

    end;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool __LOC__ @@
      List.for_all Ext_namespace.is_valid_npm_package_name
        ["x"; "@angualr"; "test"; "hi-x"; "hi-"]
      ;
      OUnit.assert_bool __LOC__ @@
      List.for_all 
        (fun x -> not (Ext_namespace.is_valid_npm_package_name x))
        ["x "; "x'"; "Test"; "hI"]
      ;
    end;
    __LOC__ >:: begin fun _ -> 
      Ext_string.find ~sub:"hello" "xx hello xx" =~ 3 ;
      Ext_string.rfind ~sub:"hello" "xx hello xx" =~ 3 ;
      Ext_string.find ~sub:"hello" "xx hello hello xx" =~ 3 ;
      Ext_string.rfind ~sub:"hello" "xx hello hello xx" =~ 9 ;
    end;
    __LOC__ >:: begin fun _ -> 
      Ext_string.non_overlap_count ~sub:"0" "1000,000" =~ 6;
      Ext_string.non_overlap_count ~sub:"0" "000000" =~ 6;
      Ext_string.non_overlap_count ~sub:"00" "000000" =~ 3;
      Ext_string.non_overlap_count ~sub:"00" "00000" =~ 2
    end;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool __LOC__ (Ext_string.contain_substring "abc" "abc");
      OUnit.assert_bool __LOC__ (Ext_string.contain_substring "abc" "a");
      OUnit.assert_bool __LOC__ (Ext_string.contain_substring "abc" "b");
      OUnit.assert_bool __LOC__ (Ext_string.contain_substring "abc" "c");
      OUnit.assert_bool __LOC__ (Ext_string.contain_substring "abc" "");
      OUnit.assert_bool __LOC__ (not @@ Ext_string.contain_substring "abc" "abcc");
    end;
    __LOC__ >:: begin fun _ -> 
      Ext_string.trim " \t\n" =~ "";
      Ext_string.trim " \t\nb" =~ "b";
      Ext_string.trim "b \t\n" =~ "b";
      Ext_string.trim "\t\n b \t\n" =~ "b";            
    end;
    __LOC__ >:: begin fun _ -> 
      Ext_string.starts_with "ab" "a" =~ true;
      Ext_string.starts_with "ab" "" =~ true;
      Ext_string.starts_with "abb" "abb" =~ true;
      Ext_string.starts_with "abb" "abbc" =~ false;
    end;
    __LOC__ >:: begin fun _ -> 
      let (=~) = OUnit.assert_equal ~printer:(fun x -> string_of_bool x ) in 
      let k = Ext_string.ends_with in 
      k "xx.ml" ".ml" =~ true;
      k "xx.bs.js" ".js" =~ true ;
      k "xx" ".x" =~false;
      k "xx" "" =~true
    end;  
    __LOC__ >:: begin fun _ -> 
      Ext_string.ends_with_then_chop "xx.ml"  ".ml" =~ Some "xx";
      Ext_string.ends_with_then_chop "xx.ml" ".mll" =~ None
    end;
    (* __LOC__ >:: begin fun _ -> 
       Ext_string.starts_with_and_number "js_fn_mk_01" ~offset:0 "js_fn_mk_" =~ 1 ;
       Ext_string.starts_with_and_number "js_fn_run_02" ~offset:0 "js_fn_mk_" =~ -1 ;
       Ext_string.starts_with_and_number "js_fn_mk_03" ~offset:6 "mk_" =~ 3 ;
       Ext_string.starts_with_and_number "js_fn_mk_04" ~offset:6 "run_" =~ -1;
       Ext_string.starts_with_and_number "js_fn_run_04" ~offset:6 "run_" =~ 4;
       Ext_string.(starts_with_and_number "js_fn_run_04" ~offset:6 "run_" = 3) =~ false 
       end; *)
    __LOC__ >:: begin fun _ -> 
      Ext_string.for_all "____" (function '_' -> true | _ -> false)
        =~ true;
      Ext_string.for_all "___-" (function '_' -> true | _ -> false)
        =~ false;
      Ext_string.for_all ""  (function '_' -> true | _ -> false)        
        =~ true
    end;
    __LOC__ >:: begin fun _ -> 
      Ext_string.tail_from "ghsogh" 1 =~ "hsogh";
      Ext_string.tail_from "ghsogh" 0 =~ "ghsogh"
    end;
    (* __LOC__ >:: begin fun _ -> 
       Ext_string.digits_of_str "11_js" ~offset:0 2 =~ 11 
       end; *)
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool __LOC__ 
        (Ext_string.replace_backward_slash "a:\\b\\d" = 
         "a:/b/d"
        ) ;
      OUnit.assert_bool __LOC__ 
        (Ext_string.replace_backward_slash "a:\\b\\d\\" = 
         "a:/b/d/"
        ) ;
      OUnit.assert_bool __LOC__ 
        (Ext_string.replace_slash_backward "a:/b/d/"= 
         "a:\\b\\d\\" 
        ) ;  
      OUnit.assert_bool __LOC__ 
        (let old = "a:bd" in 
         Ext_string.replace_backward_slash old == 
         old
        ) ;
      OUnit.assert_bool __LOC__ 
        (let old = "a:bd" in 
         Ext_string.replace_backward_slash old == 
         old
        ) ;

    end;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool __LOC__ 
        (Ext_string.no_slash "ahgoh" );
      OUnit.assert_bool __LOC__ 
        (Ext_string.no_slash "" );            
      OUnit.assert_bool __LOC__ 
        (not (Ext_string.no_slash "ahgoh/" ));
      OUnit.assert_bool __LOC__ 
        (not (Ext_string.no_slash "/ahgoh" ));
      OUnit.assert_bool __LOC__ 
        (not (Ext_string.no_slash "/ahgoh/" ));            
    end;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool __LOC__ (Ext_string.compare "" ""  = 0);
      OUnit.assert_bool __LOC__ (Ext_string.compare "0" "0"  = 0);
      OUnit.assert_bool __LOC__ (Ext_string.compare "" "acd" < 0);
      OUnit.assert_bool __LOC__ (Ext_string.compare  "acd" "" > 0);
      for i = 0 to 256 do 
        let a = String.init i (fun _ -> '0') in 
        let b = String.init i (fun _ -> '0') in 
        OUnit.assert_bool __LOC__ (Ext_string.compare  b a = 0);
        OUnit.assert_bool __LOC__ (Ext_string.compare a b = 0)
      done ;
      for i = 0 to 256 do 
        let a = String.init i (fun _ -> '0') in 
        let b = String.init i (fun _ -> '0') ^ "\000"in 
        OUnit.assert_bool __LOC__ (Ext_string.compare a b < 0);
        OUnit.assert_bool __LOC__ (Ext_string.compare  b a  > 0)
      done ;

    end;
    __LOC__ >:: begin fun _ -> 
      let slow_compare x y  = 
        let x_len = String.length x  in 
        let y_len = String.length y in 
        if x_len = y_len then 
          String.compare x y 
        else 
          Pervasives.compare x_len y_len  in 
      let same_sign x y =
        if x = 0 then y = 0 
        else if x < 0 then y < 0 
        else y > 0 in 
      for _ = 0 to 3000 do
        let chars = [|'a';'b';'c';'d'|] in 
        let x = Ounit_data_random.random_string chars 129 in 
        let y = Ounit_data_random.random_string chars 129 in 
        let a = Ext_string.compare  x y  in 
        let b = slow_compare x y in 
        if same_sign a b then OUnit.assert_bool __LOC__ true 
        else failwith ("incosistent " ^ x ^ " " ^ y ^ " " ^ string_of_int a ^ " " ^ string_of_int b)
      done 
    end ;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool __LOC__ 
        (Ext_string.equal
           (Ext_string.concat3 "a0" "a1" "a2") "a0a1a2"
        );
      OUnit.assert_bool __LOC__ 
        (Ext_string.equal
           (Ext_string.concat3 "a0" "a11" "") "a0a11"
        );

      OUnit.assert_bool __LOC__ 
        (Ext_string.equal
           (Ext_string.concat4 "a0" "a1" "a2" "a3") "a0a1a2a3"
        );
      OUnit.assert_bool __LOC__ 
        (Ext_string.equal
           (Ext_string.concat4 "a0" "a11" "" "a33") "a0a11a33"
        );   
    end;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool __LOC__ 
        (Ext_string.equal
           (Ext_string.inter2 "a0" "a1") "a0 a1"
        );
      OUnit.assert_bool __LOC__ 
        (Ext_string.equal
           (Ext_string.inter3 "a0" "a1" "a2") "a0 a1 a2"
        );
      OUnit.assert_bool __LOC__ 
        (Ext_string.equal
           (Ext_string.inter4 "a0" "a1" "a2" "a3") "a0 a1 a2 a3"
        );
    end;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool __LOC__ 
        (Ext_string.no_slash_idx "" < 0);
      OUnit.assert_bool __LOC__ 
        (Ext_string.no_slash_idx "xxx" < 0);
      OUnit.assert_bool __LOC__ 
        (Ext_string.no_slash_idx "xxx/" = 3);
      OUnit.assert_bool __LOC__ 
        (Ext_string.no_slash_idx "xxx/g/" = 3);
      OUnit.assert_bool __LOC__ 
        (Ext_string.no_slash_idx "/xxx/g/" = 0)
    end;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool __LOC__ 
        (Ext_string.no_slash_idx_from "xxx" 0 < 0);
      OUnit.assert_bool __LOC__ 
        (Ext_string.no_slash_idx_from "xxx/" 1 = 3);
      OUnit.assert_bool __LOC__ 
        (Ext_string.no_slash_idx_from "xxx/g/" 4 = 5);
      OUnit.assert_bool __LOC__ 
        (Ext_string.no_slash_idx_from "xxx/g/" 3 = 3);  
      OUnit.assert_bool __LOC__ 
        (Ext_string.no_slash_idx_from "/xxx/g/" 0 = 0)
    end;
    __LOC__ >:: begin fun _ -> 
      OUnit.assert_bool __LOC__
        (Ext_string.equal 
           (Ext_string.concat_array Ext_string.single_space [||])
           Ext_string.empty
        );
      OUnit.assert_bool __LOC__
        (Ext_string.equal 
           (Ext_string.concat_array Ext_string.single_space [|"a0"|])
           "a0"
        );
      OUnit.assert_bool __LOC__
        (Ext_string.equal 
           (Ext_string.concat_array Ext_string.single_space [|"a0";"a1"|])
           "a0 a1"
        );   
      OUnit.assert_bool __LOC__
        (Ext_string.equal 
           (Ext_string.concat_array Ext_string.single_space [|"a0";"a1"; "a2"|])
           "a0 a1 a2"
        );   
      OUnit.assert_bool __LOC__
        (Ext_string.equal 
           (Ext_string.concat_array Ext_string.single_space [|"a0";"a1"; "a2";"a3"|])
           "a0 a1 a2 a3"
        );    
      OUnit.assert_bool __LOC__
        (Ext_string.equal 
           (Ext_string.concat_array Ext_string.single_space [|"a0";"a1"; "a2";"a3";""; "a4"|])
           "a0 a1 a2 a3  a4"
        );      
      OUnit.assert_bool __LOC__
        (Ext_string.equal 
           (Ext_string.concat_array Ext_string.single_space [|"0";"a1"; "2";"a3";""; "a4"|])
           "0 a1 2 a3  a4"
        );        
      OUnit.assert_bool __LOC__
        (Ext_string.equal 
           (Ext_string.concat_array Ext_string.single_space [|"0";"a1"; "2";"3";"d"; ""; "e"|])
           "0 a1 2 3 d  e"
        );        

    end;

    __LOC__ >:: begin fun _ ->
      Ext_namespace.namespace_of_package_name "bs-json"
      =~ "BsJson"
    end;
    __LOC__ >:: begin fun _ -> 
      Ext_namespace.namespace_of_package_name "xx"
      =~ "Xx"
    end;
    __LOC__ >:: begin fun _ ->
      let (=~) = OUnit.assert_equal ~printer:(fun x -> x) in
      Ext_namespace.namespace_of_package_name
        "reason-react"
      =~ "ReasonReact";
      Ext_namespace.namespace_of_package_name
          "Foo_bar"
        =~ "Foo_bar";
      Ext_namespace.namespace_of_package_name
        "reason"
      =~ "Reason";
      Ext_namespace.namespace_of_package_name 
        "@aa/bb"
        =~"AaBb";
      Ext_namespace.namespace_of_package_name 
        "@A/bb"
        =~"ABb"        
    end;
    __LOC__ >:: begin fun _ -> 
      Ext_namespace.change_ext_ns_suffix  "a-b" Literals.suffix_js
      =~ "a.js";
      Ext_namespace.change_ext_ns_suffix  "a-" Literals.suffix_js
      =~ "a.js";
      Ext_namespace.change_ext_ns_suffix  "a--" Literals.suffix_js
      =~ "a-.js";
      Ext_namespace.change_ext_ns_suffix  "AA-b" Literals.suffix_js
      =~ "AA.js";
      Ext_namespace.js_name_of_modulename 
        "AA-b" Little  Js
      =~ "aA.js";
      Ext_namespace.js_name_of_modulename 
        "AA-b" Upper  Js
      =~ "AA.js";
      Ext_namespace.js_name_of_modulename 
        "AA-b" Upper Bs_js
      =~ "AA.bs.js";
    end;
    __LOC__ >:: begin   fun _ -> 
      let (=~) = OUnit.assert_equal ~printer:(fun x -> 
          match x with 
          | None -> ""
          | Some (a,b) -> a ^","^ b
        ) in  
      Ext_namespace.try_split_module_name "Js-X" =~ Some ("X","Js");
      Ext_namespace.try_split_module_name "Js_X" =~ None
    end;
    __LOC__ >:: begin fun _ ->
      let (=~) = OUnit.assert_equal ~printer:(fun x -> x) in  
      let f = Ext_string.capitalize_ascii in
      f "x" =~ "X";
      f "X" =~ "X";
      f "" =~ "";
      f "abc" =~ "Abc";
      f "_bc" =~ "_bc";
      let v = "bc" in
      f v =~ "Bc";
      v =~ "bc"
    end;
    __LOC__ >:: begin fun _ -> 
      let (=~) = OUnit.assert_equal ~printer:printer_string in 
      Ext_filename.chop_all_extensions_maybe "a.bs.js" =~ "a" ; 
      Ext_filename.chop_all_extensions_maybe "a.js" =~ "a";
      Ext_filename.chop_all_extensions_maybe "a" =~ "a";
      Ext_filename.chop_all_extensions_maybe "a.x.bs.js" =~ "a"
    end;
    (* let (=~) = OUnit.assert_equal ~printer:(fun x -> x) in  *)
    __LOC__ >:: begin fun _ ->
      let k = Ext_modulename.js_id_name_of_hint_name in 
      k "xx" =~ "Xx";
      k "react-dom" =~ "ReactDom";
      k "a/b/react-dom" =~ "ReactDom";
      k "a/b" =~ "B";
      k "a/" =~ "A/" ; (*TODO: warning?*)
      k "#moduleid" =~ "Moduleid";
      k "@bundle" =~ "Bundle";
      k "xx#bc" =~ "Xxbc";
      k "hi@myproj" =~ "Himyproj";
      k "ab/c/xx.b.js" =~ "XxBJs"; (* improve it in the future*)
      k "c/d/a--b"=~ "AB";
      k "c/d/ac--" =~ "Ac"
    end ;
    __LOC__ >:: begin fun _ -> 
      Ext_string.capitalize_sub "ab-Ns.cmi" 2 =~ "Ab";
      Ext_string.capitalize_sub "Ab-Ns.cmi" 2 =~ "Ab";
      Ext_string.capitalize_sub "Ab-Ns.cmi" 3 =~ "Ab-"
    end ;
    __LOC__ >:: begin fun _ ->
      OUnit.assert_equal 
        (String.length (Digest.string "")) 
         Ext_digest.length
    end;

    __LOC__ >:: begin fun _ -> 
      let bench = String.concat 
        ";" (Ext_list.init 11 (fun i -> string_of_int i)) in
      let buf = Ext_buffer.create 10 in 
      OUnit.assert_bool
        __LOC__ (Ext_buffer.not_equal buf bench); 
      for i = 0 to 9 do   
        Ext_buffer.add_string buf (string_of_int i);
        Ext_buffer.add_string buf ";"
      done ;
      OUnit.assert_bool
        __LOC__ (Ext_buffer.not_equal buf bench); 
      Ext_buffer.add_string buf "10"  ;
      (* print_endline (Ext_buffer.contents buf);
      print_endline bench; *)
      OUnit.assert_bool
      __LOC__ (not (Ext_buffer.not_equal buf bench))
    end ;

    __LOC__ >:: begin fun _ -> 
        string_eq (Ext_filename.new_extension "a.c" ".xx")  "a.xx";
        string_eq (Ext_filename.new_extension "abb.c" ".xx")  "abb.xx";
        string_eq (Ext_filename.new_extension ".c" ".xx")  ".xx";
        string_eq (Ext_filename.new_extension "a/b" ".xx")  "a/b.xx";
        string_eq (Ext_filename.new_extension "a/b." ".xx")  "a/b.xx";
        string_eq (Ext_filename.chop_all_extensions_maybe "a.b.x") "a";
        string_eq (Ext_filename.chop_all_extensions_maybe "a.b") "a";
        string_eq (Ext_filename.chop_all_extensions_maybe ".a.b.x") "";
        string_eq (Ext_filename.chop_all_extensions_maybe "abx") "abx";
    end;
    __LOC__ >:: begin fun _ ->
        string_eq 
          (Ext_filename.module_name "a/b/c.d")
          "C";
        string_eq 
          (Ext_filename.module_name "a/b/xc.re")
          "Xc";
        string_eq 
          (Ext_filename.module_name "a/b/xc.ml")
          "Xc"  ;
        string_eq 
          (Ext_filename.module_name "a/b/xc.mli")
          "Xc"  ;
        string_eq 
          (Ext_filename.module_name "a/b/xc.cppo.mli")
          "Xc.cppo";
        string_eq 
          (Ext_filename.module_name "a/b/xc.cppo.")
          "Xc.cppo"  ;
        string_eq 
          (Ext_filename.module_name "a/b/xc..")
          "Xc."  ;
        string_eq 
          (Ext_filename.module_name "a/b/Xc..")
          "Xc."  ;
        string_eq 
          (Ext_filename.module_name "a/b/.")
          ""  ;  
    end;
    __LOC__ >:: begin fun _ -> 
      Ext_string.split "" ':' =~ [];
      Ext_string.split "a:b:" ':' =~ ["a";"b"];
      Ext_string.split "a:b:" ':' ~keep_empty:true =~ ["a";"b";""]
    end;
    __LOC__ >:: begin fun _ ->    
        let cmp0 = Ext_string.compare in 
        let cmp1 = Map_string.compare_key in 
        let f a b = 
          cmp0 a b =~ cmp1 a b ;
          cmp0 b a =~ cmp1 b a
          in
        (* This is needed since deserialization/serialization
          needs to be synced up for .bsbuild decoding
         *)
        f "a" "A";
        f "bcdef" "abcdef";
        f "" "A";
        f "Abcdef" "abcdef";
    end
  ]


end
module Ext_topsort : sig 
#1 "ext_topsort.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type edges = { id : int; deps : Vec_int.t }

module Edge_vec : Vec_gen.S with type elt = edges

type t = Edge_vec.t

val layered_dfs : t -> Set_int.t Queue.t
(** the input will be modified ,
*)

end = struct
#1 "ext_topsort.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type edges = { id : int; deps : Vec_int.t }

module Edge_vec = Vec.Make (struct
  type t = edges

  let null = { id = 0; deps = Vec_int.empty () }
end)

type t = Edge_vec.t

(** 
    This graph is different the graph used in [scc] graph, since 
    we need dynamic shrink the graph, so for each vector the first node is it self ,
    it will also change the input.

    TODO: error handling (cycle handling) and defensive bad input (missing edges etc)
*)

let layered_dfs (g : t) =
  let queue = Queue.create () in
  let rec aux g =
    let new_entries =
      Edge_vec.inplace_filter_with
        (fun (x : edges) -> not (Vec_int.is_empty x.deps))
        ~cb_no:(fun x acc -> Set_int.add acc x.id)
        Set_int.empty g
    in
    if not (Set_int.is_empty new_entries) then (
      Queue.push new_entries queue;
      Edge_vec.iter g (fun edges ->
          Vec_int.inplace_filter
            (fun x -> not (Set_int.mem new_entries x))
            edges.deps);
      aux g)
  in
  aux g;
  queue

end
module Ounit_topsort_tests
= struct
#1 "ounit_topsort_tests.ml"
let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let handle graph = 
  let len = List.length graph in 
  let result = Ext_topsort.Edge_vec.make len in 
  List.iter (fun (id,deps) -> 
      Ext_topsort.Edge_vec.push result {id ; deps = Vec_int.of_list deps } 
    ) graph; 
  result 


let graph1 = 
  [ 
    0, [1;2];
    1, [2;3];
    2, [4];
    3, [];
    4, []
  ], [[0]; [1]; [2] ; [3;4]]


let graph2 = 
  [ 
    0, [1;2];
    1, [2;3];
    2, [4];
    3, [5];
    4, [5];
    5, []
  ],  
  [[0]; [1]; [2] ; [3;4]; [5]]

let graph3 = 
    [ 0,[1;2;3;4;5];
      1, [6;7;8] ;
      2, [6;7;8];
      3, [6;7;8];
      4, [6;7;8];
      5, [6;7;8];
      6, [];
      7, [] ;
      8, []
     ],
     [[0]; [1;2;3;4;5]; [6; 7; 8]]


let expect loc (graph1, v) = 
  let graph = handle graph1  in 
  let queue = Ext_topsort.layered_dfs graph  in 
  OUnit.assert_bool loc
    (Queue.fold (fun acc x -> Set_int.elements x::acc) [] queue =
     v)





let (=~) = OUnit.assert_equal
let suites = 
  __FILE__
  >:::
  [
    __LOC__ >:: begin fun _ -> 
      expect __LOC__ graph1;
      expect __LOC__ graph2 ;
      expect __LOC__ graph3
    end

  ]
end
module Ext_char : sig 
#1 "ext_char.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** Extension to Standard char module, avoid locale sensitivity *)

val valid_hex : char -> bool

val is_lower_case : char -> bool

end = struct
#1 "ext_char.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** {!Char.escaped} is locale sensitive in 4.02.3, fixed in the trunk,
    backport it here
*)

let valid_hex x =
  match x with '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' -> true | _ -> false

let is_lower_case c =
  (c >= 'a' && c <= 'z')
  || (c >= '\224' && c <= '\246')
  || (c >= '\248' && c <= '\254')

end
module Ast_utf8_string : sig 
#1 "ast_utf8_string.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type error

type exn += Error of int (* offset *) * error

val pp_error : Format.formatter -> error -> unit

(* module Interp : sig *)
(*   val check_and_transform : int -> string -> int -> cxt -> unit *)
(*   val transform_test : string -> segments *)
(* end *)
val transform_test : string -> string

val transform : Location.t -> string -> string

end = struct
#1 "ast_utf8_string.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type error =
  | Invalid_code_point
  | Unterminated_backslash
  | Invalid_hex_escape
  | Invalid_unicode_escape
  | Invalid_unicode_codepoint_escape

let pp_error fmt err =
  Format.pp_print_string fmt
  @@
  match err with
  | Invalid_code_point -> "Invalid code point"
  | Unterminated_backslash -> "\\ ended unexpectedly"
  | Invalid_hex_escape -> "Invalid \\x escape"
  | Invalid_unicode_escape -> "Invalid \\u escape"
  | Invalid_unicode_codepoint_escape ->
      "Invalid \\u{…} codepoint escape sequence"

type exn += Error of int (* offset *) * error

let error ~loc error = raise (Error (loc, error))

(** Note the [loc] really should be the utf8-offset, it has nothing to do with our 
    escaping mechanism
*)
(* we can not just print new line in ES5
   seems we don't need
   escape "\b" "\f"
   we need escape "\n" "\r" since
   ocaml multiple-line allows [\n]
   visual input while es5 string
   does not*)

let rec check_and_transform (loc : int) (buf : Buffer.t) (s : string)
    (byte_offset : int) (s_len : int) =
  if byte_offset = s_len then ()
  else
    let current_char = s.[byte_offset] in
    match Ext_utf8.classify current_char with
    | Single 92 (* '\\' *) ->
        escape_code (loc + 1) buf s (byte_offset + 1) s_len
    | Single 34 ->
        Buffer.add_string buf "\\\"";
        check_and_transform (loc + 1) buf s (byte_offset + 1) s_len
    | Single 10 ->
        Buffer.add_string buf "\\n";
        check_and_transform (loc + 1) buf s (byte_offset + 1) s_len
    | Single 13 ->
        Buffer.add_string buf "\\r";
        check_and_transform (loc + 1) buf s (byte_offset + 1) s_len
    | Single _ ->
        Buffer.add_char buf current_char;
        check_and_transform (loc + 1) buf s (byte_offset + 1) s_len
    | Invalid | Cont _ -> error ~loc Invalid_code_point
    | Leading (n, _) ->
        let i' = Ext_utf8.next s ~remaining:n byte_offset in
        if i' < 0 then error ~loc Invalid_code_point
        else (
          for k = byte_offset to i' do
            Buffer.add_char buf s.[k]
          done;
          check_and_transform (loc + 1) buf s (i' + 1) s_len)

(* we share the same escape sequence with js *)
and escape_code loc buf s offset s_len =
  if offset >= s_len then error ~loc Unterminated_backslash
  else Buffer.add_char buf '\\';
  let cur_char = s.[offset] in
  match cur_char with
  | '\\' | 'b' | 't' | 'n' | 'v' | 'f' | 'r' | '0' | '$' ->
      Buffer.add_char buf cur_char;
      check_and_transform (loc + 1) buf s (offset + 1) s_len
  | 'u' ->
      if offset + 1 >= s_len then error ~loc Invalid_unicode_escape
      else (
        Buffer.add_char buf cur_char;
        let next_char = s.[offset + 1] in
        match next_char with
        | '{' ->
            Buffer.add_char buf next_char;
            unicode_codepoint_escape (loc + 2) buf s (offset + 2) s_len
        | _ -> unicode (loc + 1) buf s (offset + 1) s_len)
  | 'x' ->
      Buffer.add_char buf cur_char;
      two_hex (loc + 1) buf s (offset + 1) s_len
  | _ ->
      (* Regular characters, like `a` in `\a`,
       * are valid escape sequences *)
      Buffer.add_char buf cur_char;
      check_and_transform (loc + 1) buf s (offset + 1) s_len

and two_hex loc buf s offset s_len =
  if offset + 1 >= s_len then error ~loc Invalid_hex_escape;
  (*Location.raise_errorf ~loc "\\x need at least two chars";*)
  let a, b = (s.[offset], s.[offset + 1]) in
  if Ext_char.valid_hex a && Ext_char.valid_hex b then (
    Buffer.add_char buf a;
    Buffer.add_char buf b;
    check_and_transform (loc + 2) buf s (offset + 2) s_len)
  else error ~loc Invalid_hex_escape
(*Location.raise_errorf ~loc "%c%c is not a valid hex code" a b*)

and unicode loc buf s offset s_len =
  if offset + 3 >= s_len then error ~loc Invalid_unicode_escape
    (*Location.raise_errorf ~loc "\\u need at least four chars"*);
  let a0, a1, a2, a3 =
    (s.[offset], s.[offset + 1], s.[offset + 2], s.[offset + 3])
  in
  if
    Ext_char.valid_hex a0 && Ext_char.valid_hex a1 && Ext_char.valid_hex a2
    && Ext_char.valid_hex a3
  then (
    Buffer.add_char buf a0;
    Buffer.add_char buf a1;
    Buffer.add_char buf a2;
    Buffer.add_char buf a3;
    check_and_transform (loc + 4) buf s (offset + 4) s_len)
  else error ~loc Invalid_unicode_escape

(*Location.raise_errorf ~loc "%c%c%c%c is not a valid unicode point"
  a0 a1 a2 a3 *)
(* http://www.2ality.com/2015/01/es6-strings.html
   console.log('\uD83D\uDE80'); (* ES6*)
   console.log('\u{1F680}');
*)

(* ES6 unicode codepoint escape sequences: \u{…}
   https://262.ecma-international.org/6.0/#sec-literals-string-literals *)
and unicode_codepoint_escape loc buf s offset s_len =
  if offset >= s_len then error ~loc Invalid_unicode_codepoint_escape
  else
    let cur_char = s.[offset] in
    match cur_char with
    | '}' ->
        Buffer.add_char buf cur_char;
        let x = ref 0 in
        for ix = loc to offset - 1 do
          let c = s.[ix] in
          let value =
            match c with
            | '0' .. '9' -> Char.code c - 48
            | 'a' .. 'f' -> Char.code c - Char.code 'a' + 10
            | 'A' .. 'F' -> Char.code c + 32 - Char.code 'a' + 10
            | _ -> 16
            (* larger than any legal value, unicode_codepoint_escape only makes progress if we have valid hex symbols *)
          in
          (* too long escape sequence will result in an overflow, perform an upperbound check *)
          if !x > 0x10FFFF then error ~loc Invalid_unicode_codepoint_escape
          else x := (!x * 16) + value
        done;
        if Uchar.is_valid !x then
          check_and_transform (offset + 1) buf s (offset + 1) s_len
        else error ~loc Invalid_unicode_codepoint_escape
    | _ ->
        if Ext_char.valid_hex cur_char then (
          Buffer.add_char buf cur_char;
          unicode_codepoint_escape loc buf s (offset + 1) s_len)
        else error ~loc Invalid_unicode_codepoint_escape

let transform_test s =
  let s_len = String.length s in
  let buf = Buffer.create (s_len * 2) in
  check_and_transform 0 buf s 0 s_len;
  Buffer.contents buf

let transform loc s =
  let s_len = String.length s in
  let buf = Buffer.create (s_len * 2) in
  try
    check_and_transform 0 buf s 0 s_len;
    Buffer.contents buf
  with Error (offset, error) ->
    Location.raise_errorf ~loc "Offset: %d, %a" offset pp_error error

end
module Ast_compatible : sig 
#1 "ast_compatible.mli"
(* Copyright (C) 2018 Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type loc = Location.t

type attrs = Parsetree.attribute list

open Parsetree

val const_exp_string :
  ?loc:Location.t -> ?attrs:attrs -> ?delimiter:string -> string -> expression

val const_exp_int : ?loc:Location.t -> ?attrs:attrs -> int -> expression

val const_exp_int_list_as_array : int list -> expression

val apply_simple :
  ?loc:Location.t -> ?attrs:attrs -> expression -> expression list -> expression

val app1 :
  ?loc:Location.t -> ?attrs:attrs -> expression -> expression -> expression

val app2 :
  ?loc:Location.t ->
  ?attrs:attrs ->
  expression ->
  expression ->
  expression ->
  expression

val app3 :
  ?loc:Location.t ->
  ?attrs:attrs ->
  expression ->
  expression ->
  expression ->
  expression ->
  expression

val apply_labels :
  ?loc:Location.t ->
  ?attrs:attrs ->
  expression ->
  (string * expression) list ->
  (* [(label,e)] [label] is strictly interpreted as label *)
  expression
(** Note this function would slightly 
    change its semantics depending on compiler versions
    for newer version: it means always label
    for older version: it could be optional (which we should avoid)
*)

val fun_ :
  ?loc:Location.t -> ?attrs:attrs -> pattern -> expression -> expression

(* val opt_label : string -> Asttypes.arg_label *)

(* val label_fun :
   ?loc:Location.t ->
   ?attrs:attrs ->
   label:Asttypes.arg_label ->
   pattern ->
   expression ->
   expression *)

val arrow :
  ?loc:Location.t -> ?attrs:attrs -> core_type -> core_type -> core_type

val label_arrow :
  ?loc:Location.t ->
  ?attrs:attrs ->
  string ->
  core_type ->
  core_type ->
  core_type

val opt_arrow :
  ?loc:Location.t ->
  ?attrs:attrs ->
  string ->
  core_type ->
  core_type ->
  core_type

(* val nonrec_type_str:
   ?loc:loc ->
   type_declaration list ->
   structure_item *)

val rec_type_str :
  ?loc:loc -> Asttypes.rec_flag -> type_declaration list -> structure_item

(* val nonrec_type_sig:
   ?loc:loc ->
   type_declaration list ->
   signature_item *)

val rec_type_sig :
  ?loc:loc -> Asttypes.rec_flag -> type_declaration list -> signature_item

type object_field = Parsetree.object_field

val object_field :
  Asttypes.label Asttypes.loc -> attributes -> core_type -> object_field

type args = (Asttypes.arg_label * Parsetree.expression) list

end = struct
#1 "ast_compatible.ml"
(* Copyright (C) 2018 Hongbo Zhang, Authors of ReScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type loc = Location.t

type attrs = Parsetree.attribute list

open Parsetree

let default_loc = Location.none

let arrow ?loc ?attrs a b = Ast_helper.Typ.arrow ?loc ?attrs Nolabel a b

let apply_simple ?(loc = default_loc) ?(attrs = []) (fn : expression)
    (args : expression list) : expression =
  {
    pexp_loc = loc;
    pexp_attributes = attrs;
    pexp_desc =
      Pexp_apply (fn, Ext_list.map args (fun x -> (Asttypes.Nolabel, x)));
  }

let app1 ?(loc = default_loc) ?(attrs = []) fn arg1 : expression =
  {
    pexp_loc = loc;
    pexp_attributes = attrs;
    pexp_desc = Pexp_apply (fn, [ (Nolabel, arg1) ]);
  }

let app2 ?(loc = default_loc) ?(attrs = []) fn arg1 arg2 : expression =
  {
    pexp_loc = loc;
    pexp_attributes = attrs;
    pexp_desc = Pexp_apply (fn, [ (Nolabel, arg1); (Nolabel, arg2) ]);
  }

let app3 ?(loc = default_loc) ?(attrs = []) fn arg1 arg2 arg3 : expression =
  {
    pexp_loc = loc;
    pexp_attributes = attrs;
    pexp_desc =
      Pexp_apply (fn, [ (Nolabel, arg1); (Nolabel, arg2); (Nolabel, arg3) ]);
  }

let fun_ ?(loc = default_loc) ?(attrs = []) pat exp =
  {
    pexp_loc = loc;
    pexp_attributes = attrs;
    pexp_desc = Pexp_fun (Nolabel, None, pat, exp);
  }

let const_exp_string ?(loc = default_loc) ?(attrs = []) ?delimiter (s : string)
    : expression =
  {
    pexp_loc = loc;
    pexp_attributes = attrs;
    pexp_desc = Pexp_constant (Pconst_string (s, delimiter));
  }

let const_exp_int ?(loc = default_loc) ?(attrs = []) (s : int) : expression =
  {
    pexp_loc = loc;
    pexp_attributes = attrs;
    pexp_desc = Pexp_constant (Pconst_integer (string_of_int s, None));
  }

let apply_labels ?(loc = default_loc) ?(attrs = []) fn
    (args : (string * expression) list) : expression =
  {
    pexp_loc = loc;
    pexp_attributes = attrs;
    pexp_desc =
      Pexp_apply (fn, Ext_list.map args (fun (l, a) -> (Asttypes.Labelled l, a)));
  }

let label_arrow ?(loc = default_loc) ?(attrs = []) s a b : core_type =
  {
    ptyp_desc = Ptyp_arrow (Asttypes.Labelled s, a, b);
    ptyp_loc = loc;
    ptyp_attributes = attrs;
  }

let opt_arrow ?(loc = default_loc) ?(attrs = []) s a b : core_type =
  {
    ptyp_desc = Ptyp_arrow (Asttypes.Optional s, a, b);
    ptyp_loc = loc;
    ptyp_attributes = attrs;
  }

let rec_type_str ?(loc = default_loc) rf tds : structure_item =
  { pstr_loc = loc; pstr_desc = Pstr_type (rf, tds) }

let rec_type_sig ?(loc = default_loc) rf tds : signature_item =
  { psig_loc = loc; psig_desc = Psig_type (rf, tds) }

(* FIXME: need address migration of `[@nonrec]` attributes in older ocaml *)
(* let nonrec_type_sig ?(loc=default_loc)  tds : signature_item =
   {
    psig_loc = loc;
    psig_desc = Psig_type (
      Nonrecursive,
      tds)
   } *)

let const_exp_int_list_as_array xs =
  Ast_helper.Exp.array (Ext_list.map xs (fun x -> const_exp_int x))

(* let const_exp_string_list_as_array xs =
   Ast_helper.Exp.array
   (Ext_list.map xs (fun x -> const_exp_string x ) ) *)



type object_field = Parsetree.object_field

let object_field l attrs ty = Parsetree.Otag (l, attrs, ty)

type args = (Asttypes.arg_label * Parsetree.expression) list

end
module Bs_loc : sig 
#1 "bs_loc.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Location.t = {
  loc_start : Lexing.position;
  loc_end : Lexing.position;
  loc_ghost : bool;
}

(* val is_ghost : t -> bool *)
val merge : t -> t -> t
(* val none : t  *)

end = struct
#1 "bs_loc.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Location.t = {
  loc_start : Lexing.position;
  loc_end : Lexing.position;
  loc_ghost : bool;
}

let is_ghost x = x.loc_ghost

let merge (l : t) (r : t) =
  if is_ghost l then r
  else if is_ghost r then l
  else
    match (l, r) with
    | { loc_start; _ }, { loc_end; _ } (* TODO: improve*) ->
        { loc_start; loc_end; loc_ghost = false }

(* let none = Location.none *)

end
module Ast_utf8_string_interp : sig 
#1 "ast_utf8_string_interp.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type kind = String | Var of int * int (* int records its border length *)

type error = private
  | Invalid_code_point
  | Unterminated_backslash
  | Invalid_escape_code of char
  | Invalid_hex_escape
  | Invalid_unicode_escape
  | Unterminated_variable
  | Unmatched_paren
  | Invalid_syntax_of_var of string

type pos = { lnum : int; offset : int; byte_bol : int }
(** Note the position is about code point *)

type segment = { start : pos; finish : pos; kind : kind; content : string }

type segments = segment list

type cxt = {
  mutable segment_start : pos;
  buf : Buffer.t;
  s_len : int;
  mutable segments : segments;
  mutable pos_bol : int;
  (* record the abs position of current beginning line *)
  mutable byte_bol : int;
  mutable pos_lnum : int; (* record the line number *)
}

type exn += Error of pos * pos * error

val empty_segment : segment -> bool

val transform_test : string -> segment list

val transform : Parsetree.expression -> string -> string -> Parsetree.expression

val is_unicode_string : string -> bool

val is_unescaped : string -> bool

end = struct
#1 "ast_utf8_string_interp.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type error =
  | Invalid_code_point
  | Unterminated_backslash
  | Invalid_escape_code of char
  | Invalid_hex_escape
  | Invalid_unicode_escape
  | Unterminated_variable
  | Unmatched_paren
  | Invalid_syntax_of_var of string

type kind = String | Var of int * int
(* [Var (loffset, roffset)]
   For parens it used to be (2,-1)
   for non-parens it used to be (1,0)
*)

type pos = {
  lnum : int;
  offset : int;
  byte_bol : int;
      (* Note it actually needs to be in sync with OCaml's lexing semantics *)
}
(** Note the position is about code point *)

type segment = { start : pos; finish : pos; kind : kind; content : string }

type segments = segment list

type cxt = {
  mutable segment_start : pos;
  buf : Buffer.t;
  s_len : int;
  mutable segments : segments;
  mutable pos_bol : int;
  (* record the abs position of current beginning line *)
  mutable byte_bol : int;
  mutable pos_lnum : int; (* record the line number *)
}

type exn += Error of pos * pos * error

let pp_error fmt err =
  Format.pp_print_string fmt
  @@
  match err with
  | Invalid_code_point -> "Invalid code point"
  | Unterminated_backslash -> "\\ ended unexpectedly"
  | Invalid_escape_code c -> "Invalid escape code: " ^ String.make 1 c
  | Invalid_hex_escape -> "Invalid \\x escape"
  | Invalid_unicode_escape -> "Invalid \\u escape"
  | Unterminated_variable -> "$ unterminated"
  | Unmatched_paren -> "Unmatched paren"
  | Invalid_syntax_of_var s ->
      "`" ^ s ^ "' is not a valid syntax of interpolated identifer"

let valid_lead_identifier_char x =
  match x with 'a' .. 'z' | '_' -> true | _ -> false

(** Invariant: [valid_lead_identifier] has to be [valid_identifier] *)
let valid_identifier_char x =
  match x with
  | 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '\'' -> true
  | _ -> false

let valid_identifier s =
  let s_len = String.length s in
  if s_len = 0 then false
  else
    valid_lead_identifier_char s.[0]
    && Ext_string.for_all_from s 1 valid_identifier_char

(* let is_space x =
   match x with
   | ' ' | '\n' | '\t' -> true
   | _ -> false *)

(**
   FIXME: multiple line offset
   if there is no line offset. Note {|{j||} border will never trigger a new line
*)
let update_position border ({ lnum; offset; byte_bol } : pos)
    (pos : Lexing.position) =
  if lnum = 0 then { pos with pos_cnum = pos.pos_cnum + border + offset }
    (* When no newline, the column number is [border + offset] *)
  else
    {
      pos with
      pos_lnum = pos.pos_lnum + lnum;
      pos_bol = pos.pos_cnum + border + byte_bol;
      pos_cnum =
        pos.pos_cnum + border + byte_bol + offset
        (* when newline, the column number is [offset] *);
    }

let update border (start : pos) (finish : pos) (loc : Location.t) : Location.t =
  let start_pos = loc.loc_start in
  {
    loc with
    loc_start = update_position border start start_pos;
    loc_end = update_position border finish start_pos;
  }

(** Note [Var] kind can not be mpty  *)
let empty_segment { content } = Ext_string.is_empty content

let update_newline ~byte_bol loc cxt =
  cxt.pos_lnum <- cxt.pos_lnum + 1;
  cxt.pos_bol <- loc;
  cxt.byte_bol <- byte_bol

let pos_error cxt ~loc error =
  raise
    (Error
       ( cxt.segment_start,
         {
           lnum = cxt.pos_lnum;
           offset = loc - cxt.pos_bol;
           byte_bol = cxt.byte_bol;
         },
         error ))

let add_var_segment cxt loc loffset roffset =
  let content = Buffer.contents cxt.buf in
  Buffer.clear cxt.buf;
  let next_loc =
    { lnum = cxt.pos_lnum; offset = loc - cxt.pos_bol; byte_bol = cxt.byte_bol }
  in
  if valid_identifier content then (
    cxt.segments <-
      {
        start = cxt.segment_start;
        finish = next_loc;
        kind = Var (loffset, roffset);
        content;
      }
      :: cxt.segments;
    cxt.segment_start <- next_loc)
  else pos_error cxt ~loc (Invalid_syntax_of_var content)

let add_str_segment cxt loc =
  let content = Buffer.contents cxt.buf in
  Buffer.clear cxt.buf;
  let next_loc =
    { lnum = cxt.pos_lnum; offset = loc - cxt.pos_bol; byte_bol = cxt.byte_bol }
  in
  cxt.segments <-
    { start = cxt.segment_start; finish = next_loc; kind = String; content }
    :: cxt.segments;
  cxt.segment_start <- next_loc

let rec check_and_transform (loc : int) s byte_offset
    ({ s_len; buf } as cxt : cxt) =
  if byte_offset = s_len then add_str_segment cxt loc
  else
    let current_char = s.[byte_offset] in
    match Ext_utf8.classify current_char with
    | Single 92 (* '\\' *) -> escape_code (loc + 1) s (byte_offset + 1) cxt
    | Single 34 ->
        Buffer.add_string buf "\\\"";
        check_and_transform (loc + 1) s (byte_offset + 1) cxt
    | Single 10 ->
        Buffer.add_string buf "\\n";
        let loc = loc + 1 in
        let byte_offset = byte_offset + 1 in
        update_newline ~byte_bol:byte_offset loc cxt;
        (* Note variable could not have new-line *)
        check_and_transform loc s byte_offset cxt
    | Single 13 ->
        Buffer.add_string buf "\\r";
        check_and_transform (loc + 1) s (byte_offset + 1) cxt
    | Single 36 ->
        (* $ *)
        add_str_segment cxt loc;
        let offset = byte_offset + 1 in
        if offset >= s_len then pos_error ~loc cxt Unterminated_variable
        else
          let cur_char = s.[offset] in
          if cur_char = '(' then expect_var_paren (loc + 2) s (offset + 1) cxt
          else expect_simple_var (loc + 1) s offset cxt
    | Single _ ->
        Buffer.add_char buf current_char;
        check_and_transform (loc + 1) s (byte_offset + 1) cxt
    | Invalid | Cont _ -> pos_error ~loc cxt Invalid_code_point
    | Leading (n, _) ->
        let i' = Ext_utf8.next s ~remaining:n byte_offset in
        if i' < 0 then pos_error cxt ~loc Invalid_code_point
        else (
          for k = byte_offset to i' do
            Buffer.add_char buf s.[k]
          done;
          check_and_transform (loc + 1) s (i' + 1) cxt)

(* Lets keep identifier simple, so that we could generating a function easier in the future
   for example
   let f = [%fn{| $x + $y = $x_add_y |}]
*)
and expect_simple_var loc s offset ({ buf; s_len } as cxt) =
  let v = ref offset in
  (* prerr_endline @@ Ext_pervasives.dump (s, has_paren, (is_space s.[!v]), !v); *)
  if not (offset < s_len && valid_lead_identifier_char s.[offset]) then
    pos_error cxt ~loc (Invalid_syntax_of_var Ext_string.empty)
  else (
    while !v < s_len && valid_identifier_char s.[!v] do
      (* TODO*)
      let cur_char = s.[!v] in
      Buffer.add_char buf cur_char;
      incr v
    done;
    let added_length = !v - offset in
    let loc = added_length + loc in
    add_var_segment cxt loc 1 0;
    check_and_transform loc s (added_length + offset) cxt)

and expect_var_paren loc s offset ({ buf; s_len } as cxt) =
  let v = ref offset in
  (* prerr_endline @@ Ext_pervasives.dump (s, has_paren, (is_space s.[!v]), !v); *)
  while !v < s_len && s.[!v] <> ')' do
    let cur_char = s.[!v] in
    Buffer.add_char buf cur_char;
    incr v
  done;
  let added_length = !v - offset in
  let loc = added_length + 1 + loc in
  if !v < s_len && s.[!v] = ')' then (
    add_var_segment cxt loc 2 (-1);
    check_and_transform loc s (added_length + 1 + offset) cxt)
  else pos_error cxt ~loc Unmatched_paren

(* we share the same escape sequence with js *)
and escape_code loc s offset ({ buf; s_len } as cxt) =
  if offset >= s_len then pos_error cxt ~loc Unterminated_backslash
  else Buffer.add_char buf '\\';
  let cur_char = s.[offset] in
  match cur_char with
  | '\\' | 'b' | 't' | 'n' | 'v' | 'f' | 'r' | '0' | '$' ->
      Buffer.add_char buf cur_char;
      check_and_transform (loc + 1) s (offset + 1) cxt
  | 'u' ->
      Buffer.add_char buf cur_char;
      unicode (loc + 1) s (offset + 1) cxt
  | 'x' ->
      Buffer.add_char buf cur_char;
      two_hex (loc + 1) s (offset + 1) cxt
  | _ -> pos_error cxt ~loc (Invalid_escape_code cur_char)

and two_hex loc s offset ({ buf; s_len } as cxt) =
  if offset + 1 >= s_len then pos_error cxt ~loc Invalid_hex_escape;
  let a, b = (s.[offset], s.[offset + 1]) in
  if Ext_char.valid_hex a && Ext_char.valid_hex b then (
    Buffer.add_char buf a;
    Buffer.add_char buf b;
    check_and_transform (loc + 2) s (offset + 2) cxt)
  else pos_error cxt ~loc Invalid_hex_escape

and unicode loc s offset ({ buf; s_len } as cxt) =
  if offset + 3 >= s_len then pos_error cxt ~loc Invalid_unicode_escape;
  let a0, a1, a2, a3 =
    (s.[offset], s.[offset + 1], s.[offset + 2], s.[offset + 3])
  in
  if
    Ext_char.valid_hex a0 && Ext_char.valid_hex a1 && Ext_char.valid_hex a2
    && Ext_char.valid_hex a3
  then (
    Buffer.add_char buf a0;
    Buffer.add_char buf a1;
    Buffer.add_char buf a2;
    Buffer.add_char buf a3;
    check_and_transform (loc + 4) s (offset + 4) cxt)
  else pos_error cxt ~loc Invalid_unicode_escape

let transform_test s =
  let s_len = String.length s in
  let buf = Buffer.create (s_len * 2) in
  let cxt =
    {
      segment_start = { lnum = 0; offset = 0; byte_bol = 0 };
      buf;
      s_len;
      segments = [];
      pos_lnum = 0;
      byte_bol = 0;
      pos_bol = 0;
    }
  in
  check_and_transform 0 s 0 cxt;
  List.rev cxt.segments

(** TODO: test empty var $() $ failure,
    Allow identifers x.A.y *)

open Ast_helper

(** Longident.parse "Pervasives.^" *)
let concat_ident : Longident.t = Ldot (Lident "Pervasives", "^")
(* FIXME: remove deps on `Pervasives` *)

(* JS string concatMany *)
(* Ldot (Ldot (Lident "Js", "String2"), "concat") *)

(* Longident.parse "Js.String.make"     *)
let to_string_ident : Longident.t = Ldot (Ldot (Lident "Js", "String2"), "make")

let escaped_j_delimiter = "*j" (* not user level syntax allowed *)

let unescaped_j_delimiter = "j"

let unescaped_js_delimiter = "js"

let escaped = Some escaped_j_delimiter

let border = String.length "{j|"

let aux loc (segment : segment) ~to_string_ident : Parsetree.expression =
  match segment with
  | { start; finish; kind; content } -> (
      match kind with
      | String ->
          let loc = update border start finish loc in
          Ast_compatible.const_exp_string content ?delimiter:escaped ~loc
      | Var (soffset, foffset) ->
          let loc =
            {
              loc with
              loc_start = update_position (soffset + border) start loc.loc_start;
              loc_end = update_position (foffset + border) finish loc.loc_start;
            }
          in
          Ast_compatible.apply_simple ~loc
            (Exp.ident ~loc { loc; txt = to_string_ident })
            [ Exp.ident ~loc { loc; txt = Lident content } ])

let concat_exp a_loc x ~(lhs : Parsetree.expression) : Parsetree.expression =
  let loc = Bs_loc.merge a_loc lhs.pexp_loc in
  Ast_compatible.apply_simple ~loc
    (Exp.ident { txt = concat_ident; loc })
    [ lhs; aux loc x ~to_string_ident:(Longident.Lident "__unsafe_cast") ]

(* Invariant: the [lhs] is always of type string *)
let rec handle_segments loc (rev_segments : segment list) =
  match rev_segments with
  | [] -> Ast_compatible.const_exp_string ~loc "" ?delimiter:escaped
  | [ segment ] -> aux loc segment ~to_string_ident (* string literal *)
  | { content = "" } :: rest -> handle_segments loc rest
  | a :: rest -> concat_exp loc a ~lhs:(handle_segments loc rest)

let transform_interp loc s =
  let s_len = String.length s in
  let buf = Buffer.create (s_len * 2) in
  try
    let cxt : cxt =
      {
        segment_start = { lnum = 0; offset = 0; byte_bol = 0 };
        buf;
        s_len;
        segments = [];
        pos_lnum = 0;
        byte_bol = 0;
        pos_bol = 0;
      }
    in

    check_and_transform 0 s 0 cxt;
    handle_segments loc cxt.segments
  with Error (start, pos, error) ->
    Location.raise_errorf ~loc:(update border start pos loc) "%a" pp_error error

let transform (e : Parsetree.expression) s delim : Parsetree.expression =
  if Ext_string.equal delim unescaped_js_delimiter then
    let js_str = Ast_utf8_string.transform e.pexp_loc s in
    { e with pexp_desc = Pexp_constant (Pconst_string (js_str, escaped)) }
  else if Ext_string.equal delim unescaped_j_delimiter then
    transform_interp e.pexp_loc s
  else e

let is_unicode_string opt = Ext_string.equal opt escaped_j_delimiter

let is_unescaped s =
  Ext_string.equal s unescaped_j_delimiter
  || Ext_string.equal s unescaped_js_delimiter

end
module Ounit_unicode_tests
= struct
#1 "ounit_unicode_tests.ml"
let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let (=~) a b = 
    OUnit.assert_equal ~cmp:Ext_string.equal a b 

(** Test for single line *)
let (==~) a b =
  OUnit.assert_equal
    (
     Ext_list.map (Ast_utf8_string_interp.transform_test a
     |> List.filter (fun x -> not @@ Ast_utf8_string_interp.empty_segment x))
     (fun 
      ({start = {offset = a}; finish = {offset = b}; kind ; content }
       : Ast_utf8_string_interp.segment) -> 
      a,b,kind,content
      )
    )
    b 

let (==*) a b =
  let segments =     
     Ext_list.map (
       Ast_utf8_string_interp.transform_test a
     |> List.filter (fun x -> not @@ Ast_utf8_string_interp.empty_segment x)
     )(fun 
      ({start = {lnum=la; offset = a}; finish = {lnum = lb; offset = b}; kind ; content } 
        : Ast_utf8_string_interp.segment) -> 
      la,a,lb,b,kind,content
      )
   in 
   OUnit.assert_equal segments b 

let varParen : Ast_utf8_string_interp.kind = Var (2,-1)   
let var : Ast_utf8_string_interp.kind = Var (1,0)
let suites = 
    __FILE__
    >:::
    [
        __LOC__ >:: begin fun _ ->
            Ast_utf8_string.transform_test {|x|} =~ {|x|}
        end;
        __LOC__ >:: begin fun _ ->
            Ast_utf8_string.transform_test "a\nb" =~ {|a\nb|}
        end;
        __LOC__ >:: begin fun _ ->
            Ast_utf8_string.transform_test
            "\\n" =~ "\\n"
        end;
        __LOC__ >:: begin fun _ ->
            Ast_utf8_string.transform_test {|\h\e\l\lo \"world\"!|} =~ {|\h\e\l\lo \"world\"!|}
        end;
        __LOC__ >:: begin fun _ ->
            Ast_utf8_string.transform_test "\\u{1d306}" =~ "\\u{1d306}"
        end;
        __LOC__ >:: begin fun _ ->
            Ast_utf8_string.transform_test "unicode escape: \\u{1d306}" =~ "unicode escape: \\u{1d306}"
        end;
        __LOC__ >:: begin fun _ ->
            Ast_utf8_string.transform_test "unicode escape: \\u{1d306} with suffix text" =~ "unicode escape: \\u{1d306} with suffix text"
        end;
        __LOC__ >:: begin fun _ ->
          Ast_utf8_string.transform_test
            "\\\\\\b\\t\\n\\v\\f\\r\\0\\$" =~
          "\\\\\\b\\t\\n\\v\\f\\r\\0\\$"
        end;

        __LOC__ >:: begin fun _ ->
           match Ast_utf8_string.transform_test
             {|\|} with
           | exception Ast_utf8_string.Error(offset,_) ->
            OUnit.assert_equal offset 1
           | _ -> OUnit.assert_failure __LOC__
        end ;
         __LOC__ >:: begin fun _ ->
           match Ast_utf8_string.transform_test
             {|你\|} with
           | exception Ast_utf8_string.Error(offset,_) ->
            OUnit.assert_equal offset 2
           | _ -> OUnit.assert_failure __LOC__
        end ;
         __LOC__ >:: begin fun _ ->
           match Ast_utf8_string.transform_test
             {|你BuckleScript,好啊\uffff\|} with
           | exception Ast_utf8_string.Error(offset,_) ->
            OUnit.assert_equal offset 23
           | _ -> OUnit.assert_failure __LOC__
        end ;
         __LOC__ >:: begin fun _ ->
           match Ast_utf8_string.transform_test
             {js|\u{110000}|js} with (* bigger than max valid unicode codepoint *)
           | exception Ast_utf8_string.Error(offset,_) ->
            OUnit.assert_equal offset 3
           | _ -> OUnit.assert_failure __LOC__
        end ;
        __LOC__ >:: begin fun _ ->
           match Ast_utf8_string.transform_test
             {js|\u{FFFFFFFFFFFFFFFFFFFFFFFFFFFFF}|js} with (* overflow *)
           | exception Ast_utf8_string.Error(offset,_) ->
            OUnit.assert_equal offset 3
           | _ -> OUnit.assert_failure __LOC__
        end ;

        __LOC__ >:: begin fun _ ->
          "hie $x hi 你好" ==~
            [
              0,4, String, "hie ";
              4,6, var, "x";
              6,12,String, " hi 你好"
            ]
        end;
        __LOC__ >:: begin fun _ ->
          "x" ==~
          [0,1, String, "x"]
        end;

        __LOC__ >:: begin fun _ ->
          "" ==~
          []
        end;
        __LOC__ >:: begin fun _ ->
          "你好" ==~
          [0,2,String, "你好"]
        end;
        __LOC__ >:: begin fun _ ->
          "你好$x" ==~
          [0,2,String, "你好";
           2,4,var, "x";

          ]
        end
        ;
        __LOC__ >:: begin fun _ ->
          "你好$this" ==~
          [
            0,2,String, "你好";
            2,7,var, "this";
          ]
        end
        ;
        __LOC__ >:: begin fun _ ->
          "你好$(this)" ==~
          [
            0,2,String, "你好";
            2,9,varParen, "this"
          ];

          "你好$this)" ==~
          [
             0,2,String, "你好";
             2,7,var, "this";
             7,8,String,")"
          ];
          {|\xff\xff你好 $x |} ==~
          [
            0,11,String, {|\xff\xff你好 |};
            11,13, var, "x";
            13,14, String, " "
          ];
          {|\xff\xff你好 $x 不吃亏了buckle $y $z = $sum|}
          ==~
          [(0, 11, String,{|\xff\xff你好 |} );
           (11, 13, var, "x");
           (13, 25, String,{| 不吃亏了buckle |} );
           (25, 27, var, "y");
           (27, 28, String, " ");
           (28, 30, var, "z");
           (30, 33, String, " = ");
           (33, 37, var, "sum");
           ]
        end
        ;
        __LOC__ >:: begin fun _ ->
          "你好 $(this_is_a_var)  x" ==~
          [
            0,3,String, "你好 ";
            3,19,varParen, "this_is_a_var";
            19,22, String, "  x"
          ]
        end
        ;

        __LOC__ >:: begin fun _ ->
        "hi\n$x\n" ==*
        [
          0,0,1,0,String, "hi\\n";
          1,0,1,2,var, "x" ;
          1,2,2,0,String,"\\n"
        ];
        "$x" ==*
        [0,0,0,2,var,"x"];
        

        "\n$x\n" ==*
        [
          0,0,1,0,String,"\\n";
          1,0,1,2,var,"x";
          1,2,2,0,String,"\\n"
        ]
        end;

        __LOC__ >:: begin fun _ -> 
        "\n$(x_this_is_cool) " ==*
        [
          0,0,1,0,String, "\\n";
          1,0,1,17,varParen, "x_this_is_cool";
          1,17,1,18,String, " "
        ]
        end;
        __LOC__ >:: begin fun _ -> 
        " $x + $y = $sum " ==*
        [
          0,0,0,1,String , " ";
          0,1,0,3,var, "x";
          0,3,0,6,String, " + ";
          0,6,0,8,var, "y";
          0,8,0,11,String, " = ";
          0,11,0,15,var, "sum";
          0,15,0,16,String, " "
        ]
        end;
        __LOC__ >:: begin fun _ -> 
        "中文 | $a " ==*
        [
          0,0,0,5,String, "中文 | ";
          0,5,0,7,var, "a";
          0,7,0,8,String, " "
        ]
        end
        ;
        __LOC__ >:: begin fun _ ->
          {|Hello \\$world|} ==*
          [
            0,0,0,8,String,"Hello \\\\";
            0,8,0,14,var, "world"
          ]
        end
        ;
        __LOC__ >:: begin fun _ -> 
          {|$x)|} ==*
          [
            0,0,0,2,var,"x";
            0,2,0,3,String,")"
          ]
        end;
        __LOC__ >:: begin fun _ ->
          match Ast_utf8_string_interp.transform_test {j| $( ()) |j}
          with 
          |exception Ast_utf8_string_interp.Error
              ({lnum = 0; offset = 1; byte_bol = 0},
               {lnum = 0; offset = 6; byte_bol = 0}, Invalid_syntax_of_var " (")
            -> OUnit.assert_bool __LOC__ true 
          | _ -> OUnit.assert_bool __LOC__ false 
        end
        ;
        __LOC__ >:: begin fun _ -> 
          match Ast_utf8_string_interp.transform_test {|$()|}
          with 
          | exception Ast_utf8_string_interp.Error ({lnum = 0; offset = 0; byte_bol = 0},
                             {lnum = 0; offset = 3; byte_bol = 0}, Invalid_syntax_of_var "")
            -> OUnit.assert_bool __LOC__ true 
          | _ -> OUnit.assert_bool __LOC__ false
        end
        ;
        __LOC__ >:: begin fun _ ->
          match Ast_utf8_string_interp.transform_test {|$ ()|}
          with 
          | exception Ast_utf8_string_interp.Error 
              ({lnum = 0; offset = 0; byte_bol = 0},
               {lnum = 0; offset = 1; byte_bol = 0}, Invalid_syntax_of_var "")
            -> OUnit.assert_bool __LOC__ true 
          | _ -> OUnit.assert_bool __LOC__ false
        end ;
        __LOC__ >:: begin fun _ -> 
          match Ast_utf8_string_interp.transform_test {|$()|} with 
          | exception Ast_utf8_string_interp.Error 
              ({lnum = 0; offset = 0; byte_bol = 0},
               {lnum = 0; offset = 3; byte_bol = 0}, Invalid_syntax_of_var "")
            -> OUnit.assert_bool __LOC__ true
          | _ -> OUnit.assert_bool __LOC__ false 
        end
        ;
        __LOC__ >:: begin fun _ -> 
          match Ast_utf8_string_interp.transform_test {|$(hello world)|} with 
          | exception Ast_utf8_string_interp.Error 
              ({lnum = 0; offset = 0; byte_bol = 0},
               {lnum = 0; offset = 14; byte_bol = 0}, Invalid_syntax_of_var "hello world")
            -> OUnit.assert_bool __LOC__ true
          | _ -> OUnit.assert_bool __LOC__ false 
        end


        ;
        __LOC__ >:: begin fun _ -> 
          match Ast_utf8_string_interp.transform_test {|$( hi*) |} with 
          | exception Ast_utf8_string_interp.Error 
              ({lnum = 0; offset = 0; byte_bol = 0},
               {lnum = 0; offset = 7; byte_bol = 0}, Invalid_syntax_of_var " hi*")
            -> 
            OUnit.assert_bool __LOC__ true
          | _ -> OUnit.assert_bool __LOC__ false 
        end;
        __LOC__ >:: begin fun _ -> 
          match Ast_utf8_string_interp.transform_test {|xx $|} with 
          | exception Ast_utf8_string_interp.Error 
              ({lnum = 0; offset = 3; byte_bol = 0},
               {lnum = 0; offset = 3; byte_bol = 0}, Unterminated_variable)
            -> 
            OUnit.assert_bool __LOC__ true 
          | _ -> OUnit.assert_bool __LOC__ false
        end ;

        __LOC__ >:: begin fun _ ->
          match Ast_utf8_string_interp.transform_test {|$(world |}; with 
          | exception Ast_utf8_string_interp.Error 
              ({lnum = 0; offset = 0; byte_bol = 0},
               {lnum = 0; offset = 9; byte_bol = 0}, Unmatched_paren)
            -> 
            OUnit.assert_bool __LOC__ true 
          | _ -> OUnit.assert_bool __LOC__ false
        end
    ]

end
module Union_find : sig 
#1 "union_find.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t

val init : int -> t

val find : t -> int -> int

val union : t -> int -> int -> unit

val count : t -> int

end = struct
#1 "union_find.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = { id : int array; sz : int array; mutable components : int }

let init n =
  let id = Array.make n 0 in
  for i = 0 to n - 1 do
    Array.unsafe_set id i i
  done;
  { id; sz = Array.make n 1; components = n }

let rec find_aux id_store p =
  let parent = Array.unsafe_get id_store p in
  if p <> parent then find_aux id_store parent else p

let find store p = find_aux store.id p

let union store p q =
  let id_store = store.id in
  let p_root = find_aux id_store p in
  let q_root = find_aux id_store q in
  if p_root <> q_root then
    let () = store.components <- store.components - 1 in
    let sz_store = store.sz in
    let sz_p_root = Array.unsafe_get sz_store p_root in
    let sz_q_root = Array.unsafe_get sz_store q_root in
    let bigger = sz_p_root + sz_q_root in
    (* Smaller root point to larger to make
       it more balanced
       it will introduce a cost for small root find,
       but major will not be impacted
    *)
    if sz_p_root < sz_q_root then (
      Array.unsafe_set id_store p q_root;
      Array.unsafe_set id_store p_root q_root;
      Array.unsafe_set sz_store q_root bigger (* little optimization *))
    else (
      Array.unsafe_set id_store q p_root;
      Array.unsafe_set id_store q_root p_root;
      Array.unsafe_set sz_store p_root bigger (* little optimization *))

let count store = store.components

end
module Ounit_union_find_tests
= struct
#1 "ounit_union_find_tests.ml"
let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal
let tinyUF = {|10
               4 3
               3 8
               6 5
               9 4
               2 1
               8 9
               5 0
               7 2
               6 1
               1 0
               6 7
             |}
let mediumUF = {|625
                 528 503
                 548 523
                 389 414
                 446 421
                 552 553
                 154 155
                 173 174
                 373 348
                 567 542
                 44 43
                 370 345
                 546 547
                 204 229
                 404 429
                 240 215
                 364 389
                 612 611
                 513 512
                 377 376
                 468 443
                 410 435
                 243 218
                 347 322
                 580 581
                 188 163
                 61 36
                 545 546
                 93 68
                 84 83
                 94 69
                 7 8
                 619 618
                 314 339
                 155 156
                 150 175
                 605 580
                 118 93
                 385 360
                 459 458
                 167 168
                 107 108
                 44 69
                 335 334
                 251 276
                 196 197
                 501 502
                 212 187
                 251 250
                 269 270
                 332 331
                 125 150
                 391 416
                 366 367
                 65 40
                 515 540
                 248 273
                 34 9
                 480 479
                 198 173
                 463 488
                 111 86
                 524 499
                 28 27
                 323 324
                 198 199
                 146 147
                 133 158
                 416 415
                 103 102
                 457 482
                 57 82
                 88 113
                 535 560
                 181 180
                 605 606
                 481 456
                 127 102
                 470 445
                 229 254
                 169 170
                 386 385
                 383 384
                 153 152
                 541 542
                 36 37
                 474 473
                 126 125
                 534 509
                 154 129
                 591 592
                 161 186
                 209 234
                 88 87
                 61 60
                 161 136
                 472 447
                 239 240
                 102 101
                 342 343
                 566 565
                 567 568
                 41 42
                 154 153
                 471 496
                 358 383
                 423 448
                 241 242
                 292 293
                 363 364
                 361 362
                 258 283
                 75 100
                 61 86
                 81 106
                 52 27
                 230 255
                 309 334
                 378 379
                 136 111
                 439 464
                 532 533
                 166 191
                 523 522
                 210 211
                 115 140
                 347 346
                 218 217
                 561 560
                 526 501
                 174 149
                 258 259
                 77 52
                 36 11
                 307 306
                 577 552
                 62 61
                 450 425
                 569 570
                 268 293
                 79 78
                 233 208
                 571 570
                 534 535
                 527 552
                 224 199
                 409 408
                 521 520
                 621 622
                 493 518
                 107 106
                 511 510
                 298 299
                 37 62
                 224 249
                 405 380
                 236 237
                 120 121
                 393 418
                 206 231
                 287 288
                 593 568
                 34 59
                 483 484
                 226 227
                 73 74
                 276 277
                 588 587
                 288 313
                 410 385
                 506 505
                 597 598
                 337 312
                 55 56
                 300 325
                 135 134
                 4 29
                 501 500
                 438 437
                 311 312
                 598 599
                 320 345
                 211 236
                 587 562
                 74 99
                 473 498
                 278 279
                 394 369
                 123 148
                 233 232
                 252 277
                 177 202
                 160 185
                 331 356
                 192 191
                 119 118
                 576 601
                 317 316
                 462 487
                 42 43
                 336 311
                 515 490
                 13 14
                 210 235
                 473 448
                 342 341
                 340 315
                 413 388
                 514 515
                 144 143
                 146 145
                 541 566
                 128 103
                 184 159
                 488 489
                 454 455
                 82 83
                 70 45
                 221 222
                 241 240
                 412 411
                 591 590
                 592 593
                 276 301
                 452 453
                 256 255
                 397 372
                 201 200
                 232 207
                 466 465
                 561 586
                 417 442
                 409 434
                 238 239
                 389 390
                 26 1
                 510 485
                 283 282
                 281 306
                 449 474
                 324 349
                 121 146
                 111 112
                 434 435
                 507 508
                 103 104
                 319 294
                 455 480
                 558 557
                 291 292
                 553 578
                 392 391
                 552 551
                 55 80
                 538 539
                 367 392
                 340 365
                 272 297
                 266 265
                 401 376
                 279 280
                 516 515
                 178 177
                 572 571
                 154 179
                 263 262
                 6 31
                 323 348
                 481 506
                 178 179
                 526 527
                 444 469
                 273 274
                 132 133
                 275 300
                 261 236
                 344 369
                 63 38
                 5 30
                 301 300
                 86 87
                 9 10
                 344 319
                 428 427
                 400 375
                 350 375
                 235 236
                 337 336
                 616 615
                 381 380
                 58 59
                 492 493
                 555 556
                 459 434
                 368 369
                 407 382
                 166 141
                 70 95
                 380 355
                 34 35
                 49 24
                 126 127
                 403 378
                 509 484
                 613 588
                 208 207
                 143 168
                 406 431
                 263 238
                 595 596
                 218 193
                 183 182
                 195 220
                 381 406
                 64 65
                 371 372
                 531 506
                 218 219
                 144 145
                 475 450
                 547 548
                 363 362
                 337 362
                 214 239
                 110 111
                 600 575
                 105 106
                 147 148
                 599 574
                 622 623
                 319 320
                 36 35
                 258 233
                 266 267
                 481 480
                 414 439
                 169 168
                 479 478
                 224 223
                 181 182
                 351 326
                 466 441
                 85 60
                 140 165
                 91 90
                 263 264
                 188 187
                 446 447
                 607 606
                 341 316
                 143 142
                 443 442
                 354 353
                 162 137
                 281 256
                 549 574
                 407 408
                 575 550
                 171 170
                 389 388
                 390 391
                 250 225
                 536 537
                 227 228
                 84 59
                 139 140
                 485 484
                 573 598
                 356 381
                 314 315
                 299 324
                 370 395
                 166 165
                 63 62
                 507 506
                 426 425
                 479 454
                 545 570
                 376 375
                 572 597
                 606 581
                 278 277
                 303 302
                 190 165
                 230 205
                 175 200
                 529 528
                 18 17
                 458 457
                 514 513
                 617 616
                 298 323
                 162 161
                 471 472
                 81 56
                 182 207
                 539 564
                 573 572
                 596 621
                 64 39
                 571 546
                 554 555
                 388 363
                 351 376
                 304 329
                 123 122
                 135 160
                 157 132
                 599 624
                 451 426
                 162 187
                 502 477
                 508 483
                 141 140
                 303 328
                 551 576
                 471 446
                 161 160
                 465 490
                 3 2
                 138 113
                 309 284
                 452 451
                 414 413
                 540 565
                 210 185
                 350 325
                 383 382
                 2 1
                 598 623
                 97 72
                 485 460
                 315 316
                 19 20
                 31 32
                 546 521
                 320 321
                 29 54
                 330 331
                 92 67
                 480 505
                 274 249
                 22 47
                 304 279
                 493 468
                 424 423
                 39 40
                 164 165
                 269 268
                 445 446
                 228 203
                 384 409
                 390 365
                 283 308
                 374 399
                 361 386
                 94 119
                 237 262
                 43 68
                 295 270
                 400 425
                 360 335
                 122 121
                 469 468
                 189 188
                 377 352
                 367 342
                 67 42
                 616 591
                 442 467
                 558 533
                 395 394
                 3 28
                 476 477
                 257 258
                 280 281
                 517 542
                 505 504
                 302 301
                 14 15
                 523 498
                 393 368
                 46 71
                 141 142
                 477 452
                 535 510
                 237 238
                 232 231
                 5 6
                 75 50
                 278 253
                 68 69
                 584 559
                 503 504
                 281 282
                 19 44
                 411 410
                 290 265
                 579 554
                 85 84
                 65 66
                 9 8
                 484 459
                 427 402
                 195 196
                 617 618
                 418 443
                 101 126
                 268 243
                 92 117
                 290 315
                 562 561
                 255 280
                 488 487
                 578 603
                 80 79
                 57 58
                 77 78
                 417 418
                 246 271
                 95 96
                 234 233
                 530 555
                 543 568
                 396 397
                 22 23
                 29 28
                 502 527
                 12 13
                 217 216
                 522 547
                 357 332
                 543 518
                 151 176
                 69 70
                 556 557
                 247 248
                 513 538
                 204 205
                 604 605
                 528 527
                 455 456
                 624 623
                 284 285
                 27 26
                 94 95
                 486 511
                 192 167
                 372 347
                 129 104
                 349 374
                 313 314
                 354 329
                 294 293
                 377 378
                 291 290
                 433 408
                 57 56
                 215 190
                 467 492
                 383 408
                 569 594
                 209 208
                 2 27
                 466 491
                 147 122
                 112 113
                 21 46
                 284 259
                 563 538
                 392 417
                 458 433
                 464 465
                 297 298
                 336 361
                 607 582
                 553 554
                 225 200
                 186 211
                 33 34
                 237 212
                 52 51
                 620 595
                 492 517
                 585 610
                 257 282
                 520 545
                 541 540
                 269 244
                 609 584
                 109 84
                 247 246
                 562 537
                 172 197
                 166 167
                 264 265
                 129 130
                 89 114
                 204 179
                 51 76
                 415 390
                 54 53
                 219 244
                 491 490
                 494 493
                 87 62
                 158 183
                 517 518
                 358 359
                 105 104
                 285 260
                 343 318
                 348 347
                 615 614
                 169 144
                 53 78
                 494 495
                 576 577
                 23 24
                 22 21
                 41 40
                 467 466
                 112 87
                 245 220
                 442 441
                 411 436
                 256 257
                 469 494
                 441 416
                 132 107
                 468 467
                 345 344
                 608 609
                 358 333
                 418 419
                 430 429
                 130 131
                 127 128
                 115 90
                 364 365
                 296 271
                 260 235
                 229 228
                 232 257
                 189 190
                 234 235
                 195 170
                 117 118
                 487 486
                 203 204
                 142 117
                 582 583
                 561 536
                 7 32
                 387 388
                 333 334
                 420 421
                 317 292
                 327 352
                 564 563
                 39 14
                 177 152
                 144 119
                 426 401
                 248 223
                 566 567
                 53 28
                 106 131
                 473 472
                 525 526
                 327 302
                 382 381
                 222 197
                 610 609
                 522 521
                 291 316
                 339 338
                 328 329
                 31 56
                 247 222
                 185 186
                 554 529
                 393 392
                 108 83
                 514 489
                 48 23
                 37 12
                 46 45
                 25 0
                 463 462
                 101 76
                 11 10
                 548 573
                 137 112
                 123 124
                 359 360
                 489 490
                 368 367
                 71 96
                 229 230
                 496 495
                 366 365
                 86 85
                 496 497
                 482 481
                 326 301
                 278 303
                 139 114
                 71 70
                 275 276
                 223 198
                 590 565
                 496 521
                 16 41
                 501 476
                 371 370
                 511 536
                 577 602
                 37 38
                 423 422
                 71 72
                 399 424
                 171 146
                 32 33
                 157 182
                 608 583
                 474 499
                 205 206
                 539 514
                 601 600
                 419 420
                 208 183
                 537 538
                 110 85
                 105 130
                 288 289
                 455 430
                 531 532
                 337 338
                 227 202
                 120 145
                 559 534
                 261 262
                 241 216
                 379 354
                 430 405
                 241 266
                 396 421
                 317 318
                 139 164
                 310 285
                 478 477
                 532 557
                 238 213
                 195 194
                 359 384
                 243 242
                 432 457
                 422 447
                 519 518
                 271 272
                 12 11
                 478 453
                 453 428
                 614 613
                 138 139
                 96 97
                 399 398
                 55 54
                 199 174
                 566 591
                 213 188
                 488 513
                 169 194
                 603 602
                 293 318
                 432 431
                 524 523
                 30 31
                 88 63
                 172 173
                 510 509
                 272 273
                 559 558
                 494 519
                 374 373
                 547 572
                 263 288
                 17 16
                 78 103
                 542 543
                 131 132
                 519 544
                 504 529
                 60 59
                 356 355
                 341 340
                 415 414
                 285 286
                 439 438
                 588 563
                 25 50
                 463 438
                 581 556
                 244 245
                 500 475
                 93 92
                 274 299
                 351 350
                 152 127
                 472 497
                 440 415
                 214 215
                 231 230
                 80 81
                 550 525
                 511 512
                 483 458
                 67 68
                 255 254
                 589 588
                 147 172
                 454 453
                 587 612
                 343 368
                 508 509
                 240 265
                 49 48
                 184 183
                 583 558
                 164 189
                 461 436
                 109 134
                 196 171
                 156 181
                 124 99
                 531 530
                 116 91
                 431 430
                 326 325
                 44 45
                 507 482
                 557 582
                 519 520
                 167 142
                 469 470
                 563 562
                 507 532
                 94 93
                 3 4
                 366 391
                 456 431
                 524 549
                 489 464
                 397 398
                 98 97
                 377 402
                 413 412
                 148 149
                 91 66
                 308 333
                 16 15
                 312 287
                 212 211
                 486 461
                 571 596
                 226 251
                 356 357
                 145 170
                 295 294
                 308 309
                 163 138
                 364 339
                 416 417
                 402 401
                 302 277
                 349 348
                 582 581
                 176 175
                 254 279
                 589 614
                 322 297
                 587 586
                 221 246
                 526 551
                 159 158
                 460 461
                 452 427
                 329 330
                 321 322
                 82 107
                 462 461
                 495 520
                 303 304
                 90 65
                 295 320
                 160 159
                 463 464
                 10 35
                 619 594
                 403 402
               |}


let process_str tinyUF = 
  match Ext_string.split tinyUF '\n' with 
  | number :: rest ->
    let n = int_of_string number in
    let store = Union_find.init n in
    List.iter (fun x ->
        match Ext_string.quick_split_by_ws x with 
        | [a;b] ->
          let a,b = int_of_string a , int_of_string b in 
          Union_find.union store a b 
        | _ -> ()) rest;
    Union_find.count store
  | _ -> assert false
;;        

let process_file file = 
  let ichan = open_in_bin file in
  let n = int_of_string (input_line ichan) in
  let store = Union_find.init n in
  let edges = Int_vec_vec.make n in   
  let rec aux i =  
    match input_line ichan with 
    | exception _ -> ()
    | v ->
      begin 
        (* if i = 0 then 
          print_endline "processing 100 nodes start";
    *)
        begin match Ext_string.quick_split_by_ws v with
          | [a;b] ->
            let a,b = int_of_string a , int_of_string b in
            Int_vec_vec.push  edges (Vec_int.of_array [|a;b|]); 
          | _ -> ()
        end;
        aux ((i+1) mod 10000);
      end
  in aux 0;
  (* indeed, [unsafe_internal_array] is necessary for real performnace *)
  let internal = Int_vec_vec.unsafe_internal_array edges in
  for i = 0 to Array.length internal - 1 do
     let i = Vec_int.unsafe_internal_array (Array.unsafe_get internal i) in 
     Union_find.union store (Array.unsafe_get i 0) (Array.unsafe_get i 1) 
  done;  
              (* Union_find.union store a b *)
  Union_find.count store 
;;                
let suites = 
  __FILE__
  >:::
  [
    __LOC__ >:: begin fun _ ->
      OUnit.assert_equal (process_str tinyUF) 2
    end;
    __LOC__ >:: begin fun _ ->
      OUnit.assert_equal (process_str mediumUF) 3
    end;
(*
   __LOC__ >:: begin fun _ ->
      OUnit.assert_equal (process_file "largeUF.txt") 6
    end;
  *)  

  ]
end
module Ounit_utf8_test
= struct
#1 "ounit_utf8_test.ml"


(* https://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt
*)

let ((>::),
    (>:::)) = OUnit.((>::),(>:::))

let (=~) = OUnit.assert_equal
let suites = 
    __FILE__
    >:::
    [
        __LOC__ >:: begin fun _ -> 
            Ext_utf8.decode_utf8_string
            "hello 你好，中华民族 hei" =~
            [104; 101; 108; 108; 111; 32; 20320; 22909; 65292; 20013; 21326; 27665; 26063; 32; 104; 101; 105]
        end ;
        __LOC__ >:: begin fun _ -> 
            Ext_utf8.decode_utf8_string
            "" =~ []
        end
    ]
end
module Ounit_util_tests
= struct
#1 "ounit_util_tests.ml"

let ((>::),
     (>:::)) = OUnit.((>::),(>:::))


let (=~) = 
  OUnit.assert_equal
  ~printer:Ext_obj.dump
let suites = 
  __FILE__ >:::
  [
    __LOC__ >:: begin fun _ -> 
      Ext_pervasives.nat_of_string_exn "003" =~ 3;
      (try Ext_pervasives.nat_of_string_exn "0a" |> ignore ; 2 with _ -> -1)  =~ -1;
    end;
    __LOC__ >:: begin fun _ -> 
      let cursor = ref 0 in 
      let v = Ext_pervasives.parse_nat_of_string "123a" cursor in 
      (v, !cursor) =~ (123,3);
      cursor := 0;
      let v = Ext_pervasives.parse_nat_of_string "a" cursor in 
      (v,!cursor) =~ (0,0)
    end;

    (* __LOC__ >:: begin fun _ -> 
      for i = 0 to 0xff do 
        let buf = Ext_buffer.create 0 in 
        Ext_buffer.add_int_1 buf i;
        let s = Ext_buffer.contents buf in 
        s =~ String.make 1 (Char.chr i);
        Ext_string.get_int_1 s 0 =~ i
      done 
    end; *)

    (* __LOC__ >:: begin fun _ -> 
      for i = 0x100 to 0xff_ff do 
        let buf = Ext_buffer.create 0 in 
        Ext_buffer.add_int_2 buf i;
        let s = Ext_buffer.contents buf in         
        Ext_string.get_int_2 s 0 =~ i
      done ;
      let buf = Ext_buffer.create 0 in 
      Ext_buffer.add_int_3 buf 0x1_ff_ff;
      Ext_string.get_int_3 (Ext_buffer.contents buf) 0 =~ 0x1_ff_ff
      ;
      let buf = Ext_buffer.create 0 in 
      Ext_buffer.add_int_4 buf 0x1_ff_ff_ff;
      Ext_string.get_int_4 (Ext_buffer.contents buf) 0 =~ 0x1_ff_ff_ff
    end; *)
    __LOC__ >:: begin fun _ -> 
        let buf = Ext_buffer.create 0 in 
        Ext_buffer.add_string_char buf "hello" 'v';
        Ext_buffer.contents buf =~ "hellov";
        Ext_buffer.length buf =~ 6
    end;
    __LOC__ >:: begin fun _ -> 
        let buf = Ext_buffer.create 0 in 
        Ext_buffer.add_char_string buf 'h' "ellov";
        Ext_buffer.contents buf =~ "hellov";
        Ext_buffer.length buf =~ 6
    end;
    __LOC__ >:: begin fun _ -> 
        String.length 
        (Digest.to_hex(Digest.string "")) =~ 32
    end

  ]
end
module Ounit_vec_test
= struct
#1 "ounit_vec_test.ml"
let ((>::),
     (>:::)) = OUnit.((>::),(>:::))

(* open Ext_json *)

let v = Vec_int.init 10 (fun i -> i);;
let (=~) x y = OUnit.assert_equal ~cmp:(Vec_int.equal  (fun (x: int) y -> x=y)) x y
let (=~~) x y 
  = 
  OUnit.assert_equal ~cmp:(Vec_int.equal  (fun (x: int) y -> x=y)) 
  x (Vec_int.of_array y) 

let suites = 
  __FILE__ 
  >:::
  [
    (* idea 
      [%loc "inplace filter" ] --> __LOC__ ^ "inplace filter" 
      or "inplace filter" [@bs.loc]
    *)
    "inplace_filter " ^ __LOC__ >:: begin fun _ -> 
      v =~~ [|0; 1; 2; 3; 4; 5; 6; 7; 8; 9|];
      
      ignore @@ Vec_int.push v 32;
      let capacity = Vec_int.capacity v  in 
      v =~~ [|0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 32|];
      Vec_int.inplace_filter (fun x -> x mod 2 = 0) v ;
      v =~~ [|0; 2; 4; 6; 8; 32|];
      Vec_int.inplace_filter (fun x -> x mod 3 = 0) v ;
      v =~~ [|0;6|];
      Vec_int.inplace_filter (fun x -> x mod 3 <> 0) v ;
      v =~~ [||];
      OUnit.assert_equal (Vec_int.capacity v ) capacity ;
      Vec_int.compact v ; 
      OUnit.assert_equal (Vec_int.capacity v ) 0 
    end
    ;
    "inplace_filter_from " ^ __LOC__ >:: begin fun _ -> 
      let v = Vec_int.of_array (Array.init 10 (fun i -> i)) in 
      v =~~ [|0; 1; 2; 3; 4; 5; 6; 7; 8; 9|]; 
      Vec_int.push v 96  ;      
      Vec_int.inplace_filter_from 2 (fun x -> x mod 2 = 0) v ;
      v =~~ [|0; 1; 2; 4; 6; 8; 96|];
      Vec_int.inplace_filter_from 2 (fun x -> x mod 3 = 0) v ;
      v =~~ [|0; 1; 6; 96|];
      Vec_int.inplace_filter (fun x -> x mod 3 <> 0) v ;
      v =~~ [|1|];      
      Vec_int.compact v ; 
      OUnit.assert_equal (Vec_int.capacity v ) 1
    end
    ;
    "map " ^ __LOC__ >:: begin fun _ -> 
      let v = Vec_int.of_array (Array.init 1000 (fun i -> i )) in 
      Vec_int.map succ v =~~ (Array.init 1000 succ) ;
      OUnit.assert_bool __LOC__ (Vec_int.exists (fun x -> x >= 999) v );
      OUnit.assert_bool __LOC__ (not (Vec_int.exists (fun x -> x > 1000) v ));
      OUnit.assert_equal (Vec_int.last v ) 999
    end ;  
    __LOC__ >:: begin fun _ -> 
      let count = 1000 in 
      let init_array = (Array.init count (fun i -> i)) in 
      let u = Vec_int.of_array  init_array in 
      let v = Vec_int.inplace_filter_with (fun x -> x mod 2 = 0) ~cb_no:(fun a b -> Set_int.add b a)Set_int.empty u  in
      let (even,odd) = init_array |> Array.to_list |> List.partition (fun x -> x mod 2 = 0) in 
      OUnit.assert_equal 
      (Set_int.elements v) odd ;
      u =~~ Array.of_list even 
    end ;
    "filter" ^ __LOC__ >:: begin fun _ -> 
      let v = Vec_int.of_array [|1;2;3;4;5;6|] in 
      v |> Vec_int.filter (fun x -> x mod 3 = 0) |> (fun x -> x =~~ [|3;6|]);
      v =~~ [|1;2;3;4;5;6|];
      Vec_int.pop v ; 
      v =~~ [|1;2;3;4;5|];
      let count = ref 0 in 
      let len = Vec_int.length v  in 
      while not (Vec_int.is_empty v ) do 
        Vec_int.pop v ;
        incr count
      done;
      OUnit.assert_equal len !count
    end
    ;
    __LOC__ >:: begin fun _ -> 
      let count = 100 in 
      let v = Vec_int.of_array (Array.init count (fun i -> i)) in 
      OUnit.assert_bool __LOC__ 
        (try Vec_int.delete v count; false with _ -> true );
      for i = count - 1 downto 10 do 
        Vec_int.delete v i ;
      done ;
      v =~~ [|0;1;2;3;4;5;6;7;8;9|] 
    end; 
    "sub" ^ __LOC__ >:: begin fun _ -> 
      let v = Vec_int.make 5 in 
      OUnit.assert_bool __LOC__
        (try ignore @@ Vec_int.sub v 0 2 ; false with Invalid_argument _  -> true);
      Vec_int.push v 1;
      OUnit.assert_bool __LOC__
        (try ignore @@ Vec_int.sub v 0 2 ; false with Invalid_argument _  -> true);
      Vec_int.push v 2;  
      ( Vec_int.sub v 0 2 =~~ [|1;2|])
    end;
    "reserve" ^ __LOC__ >:: begin fun _ -> 
      let v = Vec_int.empty () in 
      Vec_int.reserve v  1000 ;
      for i = 0 to 900 do
        Vec_int.push v i
      done ;
      OUnit.assert_equal (Vec_int.length v) 901 ;
      OUnit.assert_equal (Vec_int.capacity v) 1000
    end ; 
    "capacity"  ^ __LOC__ >:: begin fun _ -> 
      let v = Vec_int.of_array [|3|] in 
      Vec_int.reserve v 10 ;
      v =~~ [|3 |];
      Vec_int.push v 1 ;
      Vec_int.push v 2 ;
      Vec_int.push v 5;
      v=~~ [|3;1;2;5|];
      OUnit.assert_equal (Vec_int.capacity v  ) 10 ;
      for i = 0 to 5 do
        Vec_int.push v i
      done;
      v=~~ [|3;1;2;5;0;1;2;3;4;5|];
      Vec_int.push v 100;
      v=~~[|3;1;2;5;0;1;2;3;4;5;100|];
      OUnit.assert_equal (Vec_int.capacity v ) 20
    end
    ;
    __LOC__  >:: begin fun _ -> 
      let empty = Vec_int.empty () in 
      Vec_int.push empty 3;
      empty =~~ [|3|];

    end
    ;
    __LOC__ >:: begin fun _ ->
      let lst = [1;2;3;4] in 
      let v = Vec_int.of_list lst in 
      OUnit.assert_equal 
        (Vec_int.map_into_list (fun x -> x + 1) v)
        (Ext_list.map lst (fun x -> x + 1) )  
    end;
    __LOC__ >:: begin fun _ ->
      let v = Vec_int.make 4 in 
      Vec_int.push v  1 ;
      Vec_int.push v 2;
      Vec_int.reverse_in_place v;
      v =~~ [|2;1|]
    end
    ;
  ]

end
module Ounit_tests_main : sig 
#1 "ounit_tests_main.mli"

end = struct
#1 "ounit_tests_main.ml"
[@@@warning "-32"]

module Int_array = Vec.Make (struct
  type t = int

  let null = 0
end)

let v = Int_array.init 10 (fun i -> i)

let ( >:: ), ( >::: ) = OUnit.(( >:: ), ( >::: ))

let ( =~ ) x y =
  OUnit.assert_equal ~cmp:(Int_array.equal (fun (x : int) y -> x = y)) x y

let ( =~~ ) x y =
  OUnit.assert_equal
    ~cmp:(Int_array.equal (fun (x : int) y -> x = y))
    x (Int_array.of_array y)

let suites =
  __FILE__
  >::: [
         Ounit_vec_test.suites;
         Ounit_json_tests.suites;
         Ounit_path_tests.suites;
         Ounit_array_tests.suites;
         Ounit_scc_tests.suites;
         Ounit_list_test.suites;
         Ounit_hash_set_tests.suites;
         Ounit_union_find_tests.suites;
         Ounit_bal_tree_tests.suites;
         Ounit_hash_stubs_test.suites;
         Ounit_map_tests.suites;
         Ounit_hashtbl_tests.suites;
         Ounit_string_tests.suites;
         Ounit_topsort_tests.suites;
         (* Ounit_sexp_tests.suites; *)
         Ounit_int_vec_tests.suites;
         Ounit_ident_mask_tests.suites;
         Ounit_cmd_tests.suites;
         Ounit_ffi_error_debug_test.suites;
         Ounit_js_regex_checker_tests.suites;
         Ounit_utf8_test.suites;
         Ounit_unicode_tests.suites;
         Ounit_bsb_regex_tests.suites;
         Ounit_bsb_pkg_tests.suites;
         Ounit_depends_format_test.suites;
         Ounit_util_tests.suites;
       ]

let _ = OUnit.run_test_tt_main suites

end
